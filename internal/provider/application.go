package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/objects/application"

	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &ApplicationDataSource{}
	_ datasource.DataSourceWithConfigure = &ApplicationDataSource{}
)

func NewApplicationDataSource() datasource.DataSource {
	return &ApplicationDataSource{}
}

type ApplicationDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*application.Entry, application.Location, *application.Service]
}

type ApplicationDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type ApplicationDataSourceModel struct {
	Location               ApplicationLocation                 `tfsdk:"location"`
	Name                   types.String                        `tfsdk:"name"`
	AbleToTransferFile     types.Bool                          `tfsdk:"able_to_transfer_file"`
	ParentApp              types.String                        `tfsdk:"parent_app"`
	TcpTimeout             types.Int64                         `tfsdk:"tcp_timeout"`
	UdpTimeout             types.Int64                         `tfsdk:"udp_timeout"`
	Risk                   types.Int64                         `tfsdk:"risk"`
	TcpTimeWaitTimeout     types.Int64                         `tfsdk:"tcp_time_wait_timeout"`
	AlgDisableCapability   types.String                        `tfsdk:"alg_disable_capability"`
	NoAppidCaching         types.Bool                          `tfsdk:"no_appid_caching"`
	Signature              types.List                          `tfsdk:"signature"`
	TunnelOtherApplication types.Bool                          `tfsdk:"tunnel_other_application"`
	ProneToMisuse          types.Bool                          `tfsdk:"prone_to_misuse"`
	UsedByMalware          types.Bool                          `tfsdk:"used_by_malware"`
	DataIdent              types.Bool                          `tfsdk:"data_ident"`
	Default                *ApplicationDataSourceDefaultObject `tfsdk:"default"`
	DisableOverride        types.String                        `tfsdk:"disable_override"`
	EvasiveBehavior        types.Bool                          `tfsdk:"evasive_behavior"`
	Timeout                types.Int64                         `tfsdk:"timeout"`
	TunnelApplications     types.Bool                          `tfsdk:"tunnel_applications"`
	FileTypeIdent          types.Bool                          `tfsdk:"file_type_ident"`
	HasKnownVulnerability  types.Bool                          `tfsdk:"has_known_vulnerability"`
	Subcategory            types.String                        `tfsdk:"subcategory"`
	Technology             types.String                        `tfsdk:"technology"`
	Category               types.String                        `tfsdk:"category"`
	ConsumeBigBandwidth    types.Bool                          `tfsdk:"consume_big_bandwidth"`
	Description            types.String                        `tfsdk:"description"`
	PervasiveUse           types.Bool                          `tfsdk:"pervasive_use"`
	TcpHalfClosedTimeout   types.Int64                         `tfsdk:"tcp_half_closed_timeout"`
	VirusIdent             types.Bool                          `tfsdk:"virus_ident"`
}
type ApplicationDataSourceSignatureObject struct {
	Name         types.String `tfsdk:"name"`
	Comment      types.String `tfsdk:"comment"`
	Scope        types.String `tfsdk:"scope"`
	OrderFree    types.Bool   `tfsdk:"order_free"`
	AndCondition types.List   `tfsdk:"and_condition"`
}
type ApplicationDataSourceSignatureAndConditionObject struct {
	Name        types.String `tfsdk:"name"`
	OrCondition types.List   `tfsdk:"or_condition"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionObject struct {
	Name     types.String                                                         `tfsdk:"name"`
	Operator *ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject `tfsdk:"operator"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject struct {
	LessThan     *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject     `tfsdk:"less_than"`
	EqualTo      *ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject      `tfsdk:"equal_to"`
	PatternMatch *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject `tfsdk:"pattern_match"`
	GreaterThan  *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject  `tfsdk:"greater_than"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject struct {
	Context  types.String `tfsdk:"context"`
	Position types.String `tfsdk:"position"`
	Mask     types.String `tfsdk:"mask"`
	Value    types.String `tfsdk:"value"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject struct {
	Pattern   types.String `tfsdk:"pattern"`
	Qualifier types.List   `tfsdk:"qualifier"`
	Context   types.String `tfsdk:"context"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject struct {
	Value     types.Int64  `tfsdk:"value"`
	Qualifier types.List   `tfsdk:"qualifier"`
	Context   types.String `tfsdk:"context"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject struct {
	Qualifier types.List   `tfsdk:"qualifier"`
	Context   types.String `tfsdk:"context"`
	Value     types.Int64  `tfsdk:"value"`
}
type ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type ApplicationDataSourceDefaultObject struct {
	IdentByIcmpType   *ApplicationDataSourceDefaultIdentByIcmpTypeObject  `tfsdk:"ident_by_icmp_type"`
	IdentByIcmp6Type  *ApplicationDataSourceDefaultIdentByIcmp6TypeObject `tfsdk:"ident_by_icmp6_type"`
	IdentByIpProtocol types.String                                        `tfsdk:"ident_by_ip_protocol"`
	Port              types.List                                          `tfsdk:"port"`
}
type ApplicationDataSourceDefaultIdentByIcmp6TypeObject struct {
	Code types.String `tfsdk:"code"`
	Type types.String `tfsdk:"type"`
}
type ApplicationDataSourceDefaultIdentByIcmpTypeObject struct {
	Code types.String `tfsdk:"code"`
	Type types.String `tfsdk:"type"`
}

func (o *ApplicationDataSourceModel) CopyToPango(ctx context.Context, obj **application.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var default_entry *application.Default
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(application.Default)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	evasiveBehavior_value := o.EvasiveBehavior.ValueBoolPointer()
	timeout_value := o.Timeout.ValueInt64Pointer()
	tunnelApplications_value := o.TunnelApplications.ValueBoolPointer()
	fileTypeIdent_value := o.FileTypeIdent.ValueBoolPointer()
	hasKnownVulnerability_value := o.HasKnownVulnerability.ValueBoolPointer()
	subcategory_value := o.Subcategory.ValueStringPointer()
	technology_value := o.Technology.ValueStringPointer()
	category_value := o.Category.ValueStringPointer()
	consumeBigBandwidth_value := o.ConsumeBigBandwidth.ValueBoolPointer()
	description_value := o.Description.ValueStringPointer()
	pervasiveUse_value := o.PervasiveUse.ValueBoolPointer()
	tcpHalfClosedTimeout_value := o.TcpHalfClosedTimeout.ValueInt64Pointer()
	virusIdent_value := o.VirusIdent.ValueBoolPointer()
	ableToTransferFile_value := o.AbleToTransferFile.ValueBoolPointer()
	parentApp_value := o.ParentApp.ValueStringPointer()
	tcpTimeout_value := o.TcpTimeout.ValueInt64Pointer()
	udpTimeout_value := o.UdpTimeout.ValueInt64Pointer()
	risk_value := o.Risk.ValueInt64Pointer()
	tcpTimeWaitTimeout_value := o.TcpTimeWaitTimeout.ValueInt64Pointer()
	algDisableCapability_value := o.AlgDisableCapability.ValueStringPointer()
	noAppidCaching_value := o.NoAppidCaching.ValueBoolPointer()
	var signature_tf_entries []ApplicationDataSourceSignatureObject
	var signature_pango_entries []application.Signature
	{
		d := o.Signature.ElementsAs(ctx, &signature_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range signature_tf_entries {
			var entry *application.Signature
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			signature_pango_entries = append(signature_pango_entries, *entry)
		}
	}
	tunnelOtherApplication_value := o.TunnelOtherApplication.ValueBoolPointer()
	proneToMisuse_value := o.ProneToMisuse.ValueBoolPointer()
	usedByMalware_value := o.UsedByMalware.ValueBoolPointer()
	dataIdent_value := o.DataIdent.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(application.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Default = default_entry
	(*obj).DisableOverride = disableOverride_value
	(*obj).EvasiveBehavior = evasiveBehavior_value
	(*obj).Timeout = timeout_value
	(*obj).TunnelApplications = tunnelApplications_value
	(*obj).FileTypeIdent = fileTypeIdent_value
	(*obj).HasKnownVulnerability = hasKnownVulnerability_value
	(*obj).Subcategory = subcategory_value
	(*obj).Technology = technology_value
	(*obj).Category = category_value
	(*obj).ConsumeBigBandwidth = consumeBigBandwidth_value
	(*obj).Description = description_value
	(*obj).PervasiveUse = pervasiveUse_value
	(*obj).TcpHalfClosedTimeout = tcpHalfClosedTimeout_value
	(*obj).VirusIdent = virusIdent_value
	(*obj).AbleToTransferFile = ableToTransferFile_value
	(*obj).ParentApp = parentApp_value
	(*obj).TcpTimeout = tcpTimeout_value
	(*obj).UdpTimeout = udpTimeout_value
	(*obj).Risk = risk_value
	(*obj).TcpTimeWaitTimeout = tcpTimeWaitTimeout_value
	(*obj).AlgDisableCapability = algDisableCapability_value
	(*obj).NoAppidCaching = noAppidCaching_value
	(*obj).Signature = signature_pango_entries
	(*obj).TunnelOtherApplication = tunnelOtherApplication_value
	(*obj).ProneToMisuse = proneToMisuse_value
	(*obj).UsedByMalware = usedByMalware_value
	(*obj).DataIdent = dataIdent_value

	return diags
}
func (o *ApplicationDataSourceDefaultObject) CopyToPango(ctx context.Context, obj **application.Default, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var identByIcmpType_entry *application.DefaultIdentByIcmpType
	if o.IdentByIcmpType != nil {
		if *obj != nil && (*obj).IdentByIcmpType != nil {
			identByIcmpType_entry = (*obj).IdentByIcmpType
		} else {
			identByIcmpType_entry = new(application.DefaultIdentByIcmpType)
		}

		diags.Append(o.IdentByIcmpType.CopyToPango(ctx, &identByIcmpType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var identByIcmp6Type_entry *application.DefaultIdentByIcmp6Type
	if o.IdentByIcmp6Type != nil {
		if *obj != nil && (*obj).IdentByIcmp6Type != nil {
			identByIcmp6Type_entry = (*obj).IdentByIcmp6Type
		} else {
			identByIcmp6Type_entry = new(application.DefaultIdentByIcmp6Type)
		}

		diags.Append(o.IdentByIcmp6Type.CopyToPango(ctx, &identByIcmp6Type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	identByIpProtocol_value := o.IdentByIpProtocol.ValueStringPointer()
	port_pango_entries := make([]string, 0)
	diags.Append(o.Port.ElementsAs(ctx, &port_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(application.Default)
	}
	(*obj).IdentByIcmpType = identByIcmpType_entry
	(*obj).IdentByIcmp6Type = identByIcmp6Type_entry
	(*obj).IdentByIpProtocol = identByIpProtocol_value
	(*obj).Port = port_pango_entries

	return diags
}
func (o *ApplicationDataSourceDefaultIdentByIcmpTypeObject) CopyToPango(ctx context.Context, obj **application.DefaultIdentByIcmpType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.DefaultIdentByIcmpType)
	}
	(*obj).Code = code_value
	(*obj).Type = type_value

	return diags
}
func (o *ApplicationDataSourceDefaultIdentByIcmp6TypeObject) CopyToPango(ctx context.Context, obj **application.DefaultIdentByIcmp6Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.DefaultIdentByIcmp6Type)
	}
	(*obj).Code = code_value
	(*obj).Type = type_value

	return diags
}
func (o *ApplicationDataSourceSignatureObject) CopyToPango(ctx context.Context, obj **application.Signature, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	scope_value := o.Scope.ValueStringPointer()
	orderFree_value := o.OrderFree.ValueBoolPointer()
	var andCondition_tf_entries []ApplicationDataSourceSignatureAndConditionObject
	var andCondition_pango_entries []application.SignatureAndCondition
	{
		d := o.AndCondition.ElementsAs(ctx, &andCondition_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range andCondition_tf_entries {
			var entry *application.SignatureAndCondition
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			andCondition_pango_entries = append(andCondition_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.Signature)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).Scope = scope_value
	(*obj).OrderFree = orderFree_value
	(*obj).AndCondition = andCondition_pango_entries

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionObject) CopyToPango(ctx context.Context, obj **application.SignatureAndCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var orCondition_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionObject
	var orCondition_pango_entries []application.SignatureAndConditionOrCondition
	{
		d := o.OrCondition.ElementsAs(ctx, &orCondition_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range orCondition_tf_entries {
			var entry *application.SignatureAndConditionOrCondition
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			orCondition_pango_entries = append(orCondition_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndCondition)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).OrCondition = orCondition_pango_entries

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var operator_entry *application.SignatureAndConditionOrConditionOperator
	if o.Operator != nil {
		if *obj != nil && (*obj).Operator != nil {
			operator_entry = (*obj).Operator
		} else {
			operator_entry = new(application.SignatureAndConditionOrConditionOperator)
		}

		diags.Append(o.Operator.CopyToPango(ctx, &operator_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrCondition)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Operator = operator_entry

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperator, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var patternMatch_entry *application.SignatureAndConditionOrConditionOperatorPatternMatch
	if o.PatternMatch != nil {
		if *obj != nil && (*obj).PatternMatch != nil {
			patternMatch_entry = (*obj).PatternMatch
		} else {
			patternMatch_entry = new(application.SignatureAndConditionOrConditionOperatorPatternMatch)
		}

		diags.Append(o.PatternMatch.CopyToPango(ctx, &patternMatch_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var greaterThan_entry *application.SignatureAndConditionOrConditionOperatorGreaterThan
	if o.GreaterThan != nil {
		if *obj != nil && (*obj).GreaterThan != nil {
			greaterThan_entry = (*obj).GreaterThan
		} else {
			greaterThan_entry = new(application.SignatureAndConditionOrConditionOperatorGreaterThan)
		}

		diags.Append(o.GreaterThan.CopyToPango(ctx, &greaterThan_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lessThan_entry *application.SignatureAndConditionOrConditionOperatorLessThan
	if o.LessThan != nil {
		if *obj != nil && (*obj).LessThan != nil {
			lessThan_entry = (*obj).LessThan
		} else {
			lessThan_entry = new(application.SignatureAndConditionOrConditionOperatorLessThan)
		}

		diags.Append(o.LessThan.CopyToPango(ctx, &lessThan_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var equalTo_entry *application.SignatureAndConditionOrConditionOperatorEqualTo
	if o.EqualTo != nil {
		if *obj != nil && (*obj).EqualTo != nil {
			equalTo_entry = (*obj).EqualTo
		} else {
			equalTo_entry = new(application.SignatureAndConditionOrConditionOperatorEqualTo)
		}

		diags.Append(o.EqualTo.CopyToPango(ctx, &equalTo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperator)
	}
	(*obj).PatternMatch = patternMatch_entry
	(*obj).GreaterThan = greaterThan_entry
	(*obj).LessThan = lessThan_entry
	(*obj).EqualTo = equalTo_entry

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorPatternMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	pattern_value := o.Pattern.ValueStringPointer()
	var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}
	context_value := o.Context.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorPatternMatch)
	}
	(*obj).Pattern = pattern_value
	(*obj).Qualifier = qualifier_pango_entries
	(*obj).Context = context_value

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorGreaterThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	context_value := o.Context.ValueStringPointer()
	value_value := o.Value.ValueInt64Pointer()
	var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorGreaterThan)
	}
	(*obj).Context = context_value
	(*obj).Value = value_value
	(*obj).Qualifier = qualifier_pango_entries

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorLessThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorLessThanQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorLessThanQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}
	context_value := o.Context.ValueStringPointer()
	value_value := o.Value.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorLessThan)
	}
	(*obj).Qualifier = qualifier_pango_entries
	(*obj).Context = context_value
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorLessThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorLessThanQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorEqualTo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	context_value := o.Context.ValueStringPointer()
	position_value := o.Position.ValueStringPointer()
	mask_value := o.Mask.ValueStringPointer()
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorEqualTo)
	}
	(*obj).Context = context_value
	(*obj).Position = position_value
	(*obj).Mask = mask_value
	(*obj).Value = value_value

	return diags
}

func (o *ApplicationDataSourceModel) CopyFromPango(ctx context.Context, obj *application.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var signature_list types.List
	{
		var signature_tf_entries []ApplicationDataSourceSignatureObject
		for _, elt := range obj.Signature {
			var entry ApplicationDataSourceSignatureObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			signature_tf_entries = append(signature_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("signature")
		signature_list, list_diags = types.ListValueFrom(ctx, schemaType, signature_tf_entries)
		diags.Append(list_diags...)
	}
	var default_object *ApplicationDataSourceDefaultObject
	if obj.Default != nil {
		default_object = new(ApplicationDataSourceDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dataIdent_value types.Bool
	if obj.DataIdent != nil {
		dataIdent_value = types.BoolValue(*obj.DataIdent)
	}
	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	var evasiveBehavior_value types.Bool
	if obj.EvasiveBehavior != nil {
		evasiveBehavior_value = types.BoolValue(*obj.EvasiveBehavior)
	}
	var timeout_value types.Int64
	if obj.Timeout != nil {
		timeout_value = types.Int64Value(*obj.Timeout)
	}
	var tunnelApplications_value types.Bool
	if obj.TunnelApplications != nil {
		tunnelApplications_value = types.BoolValue(*obj.TunnelApplications)
	}
	var fileTypeIdent_value types.Bool
	if obj.FileTypeIdent != nil {
		fileTypeIdent_value = types.BoolValue(*obj.FileTypeIdent)
	}
	var hasKnownVulnerability_value types.Bool
	if obj.HasKnownVulnerability != nil {
		hasKnownVulnerability_value = types.BoolValue(*obj.HasKnownVulnerability)
	}
	var subcategory_value types.String
	if obj.Subcategory != nil {
		subcategory_value = types.StringValue(*obj.Subcategory)
	}
	var technology_value types.String
	if obj.Technology != nil {
		technology_value = types.StringValue(*obj.Technology)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var consumeBigBandwidth_value types.Bool
	if obj.ConsumeBigBandwidth != nil {
		consumeBigBandwidth_value = types.BoolValue(*obj.ConsumeBigBandwidth)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var pervasiveUse_value types.Bool
	if obj.PervasiveUse != nil {
		pervasiveUse_value = types.BoolValue(*obj.PervasiveUse)
	}
	var tcpHalfClosedTimeout_value types.Int64
	if obj.TcpHalfClosedTimeout != nil {
		tcpHalfClosedTimeout_value = types.Int64Value(*obj.TcpHalfClosedTimeout)
	}
	var virusIdent_value types.Bool
	if obj.VirusIdent != nil {
		virusIdent_value = types.BoolValue(*obj.VirusIdent)
	}
	var ableToTransferFile_value types.Bool
	if obj.AbleToTransferFile != nil {
		ableToTransferFile_value = types.BoolValue(*obj.AbleToTransferFile)
	}
	var parentApp_value types.String
	if obj.ParentApp != nil {
		parentApp_value = types.StringValue(*obj.ParentApp)
	}
	var tcpTimeout_value types.Int64
	if obj.TcpTimeout != nil {
		tcpTimeout_value = types.Int64Value(*obj.TcpTimeout)
	}
	var udpTimeout_value types.Int64
	if obj.UdpTimeout != nil {
		udpTimeout_value = types.Int64Value(*obj.UdpTimeout)
	}
	var risk_value types.Int64
	if obj.Risk != nil {
		risk_value = types.Int64Value(*obj.Risk)
	}
	var tcpTimeWaitTimeout_value types.Int64
	if obj.TcpTimeWaitTimeout != nil {
		tcpTimeWaitTimeout_value = types.Int64Value(*obj.TcpTimeWaitTimeout)
	}
	var algDisableCapability_value types.String
	if obj.AlgDisableCapability != nil {
		algDisableCapability_value = types.StringValue(*obj.AlgDisableCapability)
	}
	var noAppidCaching_value types.Bool
	if obj.NoAppidCaching != nil {
		noAppidCaching_value = types.BoolValue(*obj.NoAppidCaching)
	}
	var tunnelOtherApplication_value types.Bool
	if obj.TunnelOtherApplication != nil {
		tunnelOtherApplication_value = types.BoolValue(*obj.TunnelOtherApplication)
	}
	var proneToMisuse_value types.Bool
	if obj.ProneToMisuse != nil {
		proneToMisuse_value = types.BoolValue(*obj.ProneToMisuse)
	}
	var usedByMalware_value types.Bool
	if obj.UsedByMalware != nil {
		usedByMalware_value = types.BoolValue(*obj.UsedByMalware)
	}
	o.Name = types.StringValue(obj.Name)
	o.DataIdent = dataIdent_value
	o.Default = default_object
	o.DisableOverride = disableOverride_value
	o.EvasiveBehavior = evasiveBehavior_value
	o.Timeout = timeout_value
	o.TunnelApplications = tunnelApplications_value
	o.FileTypeIdent = fileTypeIdent_value
	o.HasKnownVulnerability = hasKnownVulnerability_value
	o.Subcategory = subcategory_value
	o.Technology = technology_value
	o.Category = category_value
	o.ConsumeBigBandwidth = consumeBigBandwidth_value
	o.Description = description_value
	o.PervasiveUse = pervasiveUse_value
	o.TcpHalfClosedTimeout = tcpHalfClosedTimeout_value
	o.VirusIdent = virusIdent_value
	o.AbleToTransferFile = ableToTransferFile_value
	o.ParentApp = parentApp_value
	o.TcpTimeout = tcpTimeout_value
	o.UdpTimeout = udpTimeout_value
	o.Risk = risk_value
	o.TcpTimeWaitTimeout = tcpTimeWaitTimeout_value
	o.AlgDisableCapability = algDisableCapability_value
	o.NoAppidCaching = noAppidCaching_value
	o.Signature = signature_list
	o.TunnelOtherApplication = tunnelOtherApplication_value
	o.ProneToMisuse = proneToMisuse_value
	o.UsedByMalware = usedByMalware_value

	return diags
}

func (o *ApplicationDataSourceDefaultObject) CopyFromPango(ctx context.Context, obj *application.Default, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var port_list types.List
	{
		var list_diags diag.Diagnostics
		port_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Port)
		diags.Append(list_diags...)
	}
	var identByIcmpType_object *ApplicationDataSourceDefaultIdentByIcmpTypeObject
	if obj.IdentByIcmpType != nil {
		identByIcmpType_object = new(ApplicationDataSourceDefaultIdentByIcmpTypeObject)

		diags.Append(identByIcmpType_object.CopyFromPango(ctx, obj.IdentByIcmpType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var identByIcmp6Type_object *ApplicationDataSourceDefaultIdentByIcmp6TypeObject
	if obj.IdentByIcmp6Type != nil {
		identByIcmp6Type_object = new(ApplicationDataSourceDefaultIdentByIcmp6TypeObject)

		diags.Append(identByIcmp6Type_object.CopyFromPango(ctx, obj.IdentByIcmp6Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var identByIpProtocol_value types.String
	if obj.IdentByIpProtocol != nil {
		identByIpProtocol_value = types.StringValue(*obj.IdentByIpProtocol)
	}
	o.IdentByIcmpType = identByIcmpType_object
	o.IdentByIcmp6Type = identByIcmp6Type_object
	o.IdentByIpProtocol = identByIpProtocol_value
	o.Port = port_list

	return diags
}

func (o *ApplicationDataSourceDefaultIdentByIcmpTypeObject) CopyFromPango(ctx context.Context, obj *application.DefaultIdentByIcmpType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var code_value types.String
	if obj.Code != nil {
		code_value = types.StringValue(*obj.Code)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Code = code_value
	o.Type = type_value

	return diags
}

func (o *ApplicationDataSourceDefaultIdentByIcmp6TypeObject) CopyFromPango(ctx context.Context, obj *application.DefaultIdentByIcmp6Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	var code_value types.String
	if obj.Code != nil {
		code_value = types.StringValue(*obj.Code)
	}
	o.Type = type_value
	o.Code = code_value

	return diags
}

func (o *ApplicationDataSourceSignatureObject) CopyFromPango(ctx context.Context, obj *application.Signature, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var andCondition_list types.List
	{
		var andCondition_tf_entries []ApplicationDataSourceSignatureAndConditionObject
		for _, elt := range obj.AndCondition {
			var entry ApplicationDataSourceSignatureAndConditionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			andCondition_tf_entries = append(andCondition_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("and_condition")
		andCondition_list, list_diags = types.ListValueFrom(ctx, schemaType, andCondition_tf_entries)
		diags.Append(list_diags...)
	}

	var scope_value types.String
	if obj.Scope != nil {
		scope_value = types.StringValue(*obj.Scope)
	}
	var orderFree_value types.Bool
	if obj.OrderFree != nil {
		orderFree_value = types.BoolValue(*obj.OrderFree)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	o.Name = types.StringValue(obj.Name)
	o.Scope = scope_value
	o.OrderFree = orderFree_value
	o.AndCondition = andCondition_list
	o.Comment = comment_value

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var orCondition_list types.List
	{
		var orCondition_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionObject
		for _, elt := range obj.OrCondition {
			var entry ApplicationDataSourceSignatureAndConditionOrConditionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			orCondition_tf_entries = append(orCondition_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("or_condition")
		orCondition_list, list_diags = types.ListValueFrom(ctx, schemaType, orCondition_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.OrCondition = orCondition_list

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var operator_object *ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject
	if obj.Operator != nil {
		operator_object = new(ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject)

		diags.Append(operator_object.CopyFromPango(ctx, obj.Operator, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Operator = operator_object

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperator, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var patternMatch_object *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject
	if obj.PatternMatch != nil {
		patternMatch_object = new(ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject)

		diags.Append(patternMatch_object.CopyFromPango(ctx, obj.PatternMatch, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var greaterThan_object *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject
	if obj.GreaterThan != nil {
		greaterThan_object = new(ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject)

		diags.Append(greaterThan_object.CopyFromPango(ctx, obj.GreaterThan, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lessThan_object *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject
	if obj.LessThan != nil {
		lessThan_object = new(ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject)

		diags.Append(lessThan_object.CopyFromPango(ctx, obj.LessThan, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var equalTo_object *ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject
	if obj.EqualTo != nil {
		equalTo_object = new(ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject)

		diags.Append(equalTo_object.CopyFromPango(ctx, obj.EqualTo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.PatternMatch = patternMatch_object
	o.GreaterThan = greaterThan_object
	o.LessThan = lessThan_object
	o.EqualTo = equalTo_object

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorPatternMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var pattern_value types.String
	if obj.Pattern != nil {
		pattern_value = types.StringValue(*obj.Pattern)
	}
	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	o.Pattern = pattern_value
	o.Qualifier = qualifier_list
	o.Context = context_value

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorGreaterThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	o.Context = context_value
	o.Value = value_value
	o.Qualifier = qualifier_list

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorLessThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	o.Context = context_value
	o.Value = value_value
	o.Qualifier = qualifier_list

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorLessThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorEqualTo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var position_value types.String
	if obj.Position != nil {
		position_value = types.StringValue(*obj.Position)
	}
	var mask_value types.String
	if obj.Mask != nil {
		mask_value = types.StringValue(*obj.Mask)
	}
	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Context = context_value
	o.Position = position_value
	o.Mask = mask_value
	o.Value = value_value

	return diags
}

func ApplicationDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": ApplicationDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"file_type_ident": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"has_known_vulnerability": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"subcategory": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"technology": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"category": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"consume_big_bandwidth": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pervasive_use": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_half_closed_timeout": dsschema.Int64Attribute{
				Description: "timeout for half-close session in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"virus_ident": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"able_to_transfer_file": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"parent_app": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_timeout": dsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"udp_timeout": dsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"risk": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_time_wait_timeout": dsschema.Int64Attribute{
				Description: "timeout for session in time_wait state in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"alg_disable_capability": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"no_appid_caching": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"signature": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureSchema(),
			},

			"tunnel_other_application": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prone_to_misuse": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by_malware": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"data_ident": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default": ApplicationDataSourceDefaultSchema(),

			"disable_override": dsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"evasive_behavior": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timeout": dsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_applications": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceModel) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"scope": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"order_free": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"and_condition": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureAndConditionSchema(),
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"or_condition": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureAndConditionOrConditionSchema(),
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"operator": ApplicationDataSourceSignatureAndConditionOrConditionOperatorSchema(),
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"less_than": ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanSchema(),

			"equal_to": ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToSchema(),

			"pattern_match": ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchSchema(),

			"greater_than": ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanSchema(),
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"context": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"position": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mask": dsschema.StringAttribute{
				Description: "4-byte hex value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorEqualToSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"context": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pattern": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema(),
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"value": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema(),
			},

			"context": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"context": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"value": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema(),
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceDefaultSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ident_by_icmp_type": ApplicationDataSourceDefaultIdentByIcmpTypeSchema(),

			"ident_by_icmp6_type": ApplicationDataSourceDefaultIdentByIcmp6TypeSchema(),

			"ident_by_ip_protocol": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"port": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *ApplicationDataSourceDefaultObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceDefaultIdentByIcmpTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ident_by_icmp_type"),
				path.MatchRelative().AtParent().AtName("ident_by_icmp6_type"),
				path.MatchRelative().AtParent().AtName("ident_by_ip_protocol"),
				path.MatchRelative().AtParent().AtName("port"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"code": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceDefaultIdentByIcmpTypeObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceDefaultIdentByIcmpTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceDefaultIdentByIcmp6TypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ident_by_icmp_type"),
				path.MatchRelative().AtParent().AtName("ident_by_icmp6_type"),
				path.MatchRelative().AtParent().AtName("ident_by_ip_protocol"),
				path.MatchRelative().AtParent().AtName("port"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"code": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationDataSourceDefaultIdentByIcmp6TypeObject) getTypeFor(name string) attr.Type {
	schema := ApplicationDataSourceDefaultIdentByIcmp6TypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationDataSourceLocationSchema() rsschema.Attribute {
	return ApplicationLocationSchema()
}

// Metadata returns the data source type name.
func (d *ApplicationDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_application"
}

// Schema defines the schema for this data source.
func (d *ApplicationDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = ApplicationDataSourceSchema()
}

// Configure prepares the struct.
func (d *ApplicationDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := application.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, application.NewService(d.client), specifier, application.SpecMatches)
}
func (o *ApplicationDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state ApplicationDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location application.Location

	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if savestate.Location.Vsys != nil {
		location.Vsys = &application.VsysLocation{

			NgfwDevice: savestate.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       savestate.Location.Vsys.Name.ValueString(),
		}
	}
	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &application.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_application_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &ApplicationResource{}
	_ resource.ResourceWithConfigure   = &ApplicationResource{}
	_ resource.ResourceWithImportState = &ApplicationResource{}
)

func NewApplicationResource() resource.Resource {
	if _, found := resourceFuncMap["panos_application"]; !found {
		resourceFuncMap["panos_application"] = resourceFuncs{
			CreateImportId: ApplicationImportStateCreator,
		}
	}
	return &ApplicationResource{}
}

type ApplicationResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*application.Entry, application.Location, *application.Service]
}

func ApplicationResourceLocationSchema() rsschema.Attribute {
	return ApplicationLocationSchema()
}

type ApplicationResourceModel struct {
	Location               ApplicationLocation               `tfsdk:"location"`
	Name                   types.String                      `tfsdk:"name"`
	ProneToMisuse          types.Bool                        `tfsdk:"prone_to_misuse"`
	UsedByMalware          types.Bool                        `tfsdk:"used_by_malware"`
	DataIdent              types.Bool                        `tfsdk:"data_ident"`
	TunnelApplications     types.Bool                        `tfsdk:"tunnel_applications"`
	Default                *ApplicationResourceDefaultObject `tfsdk:"default"`
	DisableOverride        types.String                      `tfsdk:"disable_override"`
	EvasiveBehavior        types.Bool                        `tfsdk:"evasive_behavior"`
	Timeout                types.Int64                       `tfsdk:"timeout"`
	FileTypeIdent          types.Bool                        `tfsdk:"file_type_ident"`
	HasKnownVulnerability  types.Bool                        `tfsdk:"has_known_vulnerability"`
	Subcategory            types.String                      `tfsdk:"subcategory"`
	Technology             types.String                      `tfsdk:"technology"`
	TcpHalfClosedTimeout   types.Int64                       `tfsdk:"tcp_half_closed_timeout"`
	VirusIdent             types.Bool                        `tfsdk:"virus_ident"`
	Category               types.String                      `tfsdk:"category"`
	ConsumeBigBandwidth    types.Bool                        `tfsdk:"consume_big_bandwidth"`
	Description            types.String                      `tfsdk:"description"`
	PervasiveUse           types.Bool                        `tfsdk:"pervasive_use"`
	UdpTimeout             types.Int64                       `tfsdk:"udp_timeout"`
	AbleToTransferFile     types.Bool                        `tfsdk:"able_to_transfer_file"`
	ParentApp              types.String                      `tfsdk:"parent_app"`
	TcpTimeout             types.Int64                       `tfsdk:"tcp_timeout"`
	Risk                   types.Int64                       `tfsdk:"risk"`
	TcpTimeWaitTimeout     types.Int64                       `tfsdk:"tcp_time_wait_timeout"`
	AlgDisableCapability   types.String                      `tfsdk:"alg_disable_capability"`
	NoAppidCaching         types.Bool                        `tfsdk:"no_appid_caching"`
	Signature              types.List                        `tfsdk:"signature"`
	TunnelOtherApplication types.Bool                        `tfsdk:"tunnel_other_application"`
}
type ApplicationResourceDefaultObject struct {
	IdentByIcmpType   *ApplicationResourceDefaultIdentByIcmpTypeObject  `tfsdk:"ident_by_icmp_type"`
	IdentByIcmp6Type  *ApplicationResourceDefaultIdentByIcmp6TypeObject `tfsdk:"ident_by_icmp6_type"`
	IdentByIpProtocol types.String                                      `tfsdk:"ident_by_ip_protocol"`
	Port              types.List                                        `tfsdk:"port"`
}
type ApplicationResourceDefaultIdentByIcmpTypeObject struct {
	Code types.String `tfsdk:"code"`
	Type types.String `tfsdk:"type"`
}
type ApplicationResourceDefaultIdentByIcmp6TypeObject struct {
	Code types.String `tfsdk:"code"`
	Type types.String `tfsdk:"type"`
}
type ApplicationResourceSignatureObject struct {
	Name         types.String `tfsdk:"name"`
	Comment      types.String `tfsdk:"comment"`
	Scope        types.String `tfsdk:"scope"`
	OrderFree    types.Bool   `tfsdk:"order_free"`
	AndCondition types.List   `tfsdk:"and_condition"`
}
type ApplicationResourceSignatureAndConditionObject struct {
	Name        types.String `tfsdk:"name"`
	OrCondition types.List   `tfsdk:"or_condition"`
}
type ApplicationResourceSignatureAndConditionOrConditionObject struct {
	Name     types.String                                                       `tfsdk:"name"`
	Operator *ApplicationResourceSignatureAndConditionOrConditionOperatorObject `tfsdk:"operator"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorObject struct {
	LessThan     *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject     `tfsdk:"less_than"`
	EqualTo      *ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject      `tfsdk:"equal_to"`
	PatternMatch *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject `tfsdk:"pattern_match"`
	GreaterThan  *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject  `tfsdk:"greater_than"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject struct {
	Context  types.String `tfsdk:"context"`
	Position types.String `tfsdk:"position"`
	Mask     types.String `tfsdk:"mask"`
	Value    types.String `tfsdk:"value"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject struct {
	Context   types.String `tfsdk:"context"`
	Pattern   types.String `tfsdk:"pattern"`
	Qualifier types.List   `tfsdk:"qualifier"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject struct {
	Qualifier types.List   `tfsdk:"qualifier"`
	Context   types.String `tfsdk:"context"`
	Value     types.Int64  `tfsdk:"value"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject struct {
	Context   types.String `tfsdk:"context"`
	Value     types.Int64  `tfsdk:"value"`
	Qualifier types.List   `tfsdk:"qualifier"`
}
type ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

func (r *ApplicationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func ApplicationResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": ApplicationResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"risk": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_time_wait_timeout": rsschema.Int64Attribute{
				Description: "timeout for session in time_wait state in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"signature": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureSchema(),
			},

			"tunnel_other_application": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"alg_disable_capability": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"no_appid_caching": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prone_to_misuse": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by_malware": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"data_ident": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"evasive_behavior": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timeout": rsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_applications": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default": ApplicationResourceDefaultSchema(),

			"disable_override": rsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"no",
						"yes",
					}...),
				},
			},

			"subcategory": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"technology": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"file_type_ident": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"has_known_vulnerability": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pervasive_use": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_half_closed_timeout": rsschema.Int64Attribute{
				Description: "timeout for half-close session in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"virus_ident": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"category": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"consume_big_bandwidth": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"parent_app": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tcp_timeout": rsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"udp_timeout": rsschema.Int64Attribute{
				Description: "timeout in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"able_to_transfer_file": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceModel) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"scope": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("protocol-data-unit"),
			},

			"order_free": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"and_condition": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureAndConditionSchema(),
			},
		},
	}
}

func (o *ApplicationResourceSignatureObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"or_condition": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureAndConditionOrConditionSchema(),
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"operator": ApplicationResourceSignatureAndConditionOrConditionOperatorSchema(),
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"pattern_match": ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchSchema(),

			"greater_than": ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanSchema(),

			"less_than": ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanSchema(),

			"equal_to": ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToSchema(),
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"context": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"value": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema(),
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"context": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"value": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema(),
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"context": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"position": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mask": rsschema.StringAttribute{
				Description: "4-byte hex value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("pattern_match"),
				path.MatchRelative().AtParent().AtName("greater_than"),
				path.MatchRelative().AtParent().AtName("less_than"),
				path.MatchRelative().AtParent().AtName("equal_to"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"context": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pattern": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"qualifier": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema(),
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceDefaultSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ident_by_ip_protocol": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ident_by_icmp_type"),
						path.MatchRelative().AtParent().AtName("ident_by_icmp6_type"),
						path.MatchRelative().AtParent().AtName("ident_by_ip_protocol"),
						path.MatchRelative().AtParent().AtName("port"),
					}...),
				},
			},

			"port": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ident_by_icmp_type": ApplicationResourceDefaultIdentByIcmpTypeSchema(),

			"ident_by_icmp6_type": ApplicationResourceDefaultIdentByIcmp6TypeSchema(),
		},
	}
}

func (o *ApplicationResourceDefaultObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceDefaultSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceDefaultIdentByIcmp6TypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ident_by_icmp_type"),
				path.MatchRelative().AtParent().AtName("ident_by_icmp6_type"),
				path.MatchRelative().AtParent().AtName("ident_by_ip_protocol"),
				path.MatchRelative().AtParent().AtName("port"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"code": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceDefaultIdentByIcmp6TypeObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceDefaultIdentByIcmp6TypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ApplicationResourceDefaultIdentByIcmpTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ident_by_icmp_type"),
				path.MatchRelative().AtParent().AtName("ident_by_icmp6_type"),
				path.MatchRelative().AtParent().AtName("ident_by_ip_protocol"),
				path.MatchRelative().AtParent().AtName("port"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"code": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ApplicationResourceDefaultIdentByIcmpTypeObject) getTypeFor(name string) attr.Type {
	schema := ApplicationResourceDefaultIdentByIcmpTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *ApplicationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_application"
}

func (r *ApplicationResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = ApplicationResourceSchema()
}

// </ResourceSchema>

func (r *ApplicationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := application.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, application.NewService(r.client), specifier, application.SpecMatches)
}

func (o *ApplicationResourceModel) CopyToPango(ctx context.Context, obj **application.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	proneToMisuse_value := o.ProneToMisuse.ValueBoolPointer()
	usedByMalware_value := o.UsedByMalware.ValueBoolPointer()
	dataIdent_value := o.DataIdent.ValueBoolPointer()
	evasiveBehavior_value := o.EvasiveBehavior.ValueBoolPointer()
	timeout_value := o.Timeout.ValueInt64Pointer()
	tunnelApplications_value := o.TunnelApplications.ValueBoolPointer()
	var default_entry *application.Default
	if o.Default != nil {
		if *obj != nil && (*obj).Default != nil {
			default_entry = (*obj).Default
		} else {
			default_entry = new(application.Default)
		}

		diags.Append(o.Default.CopyToPango(ctx, &default_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	subcategory_value := o.Subcategory.ValueStringPointer()
	technology_value := o.Technology.ValueStringPointer()
	fileTypeIdent_value := o.FileTypeIdent.ValueBoolPointer()
	hasKnownVulnerability_value := o.HasKnownVulnerability.ValueBoolPointer()
	description_value := o.Description.ValueStringPointer()
	pervasiveUse_value := o.PervasiveUse.ValueBoolPointer()
	tcpHalfClosedTimeout_value := o.TcpHalfClosedTimeout.ValueInt64Pointer()
	virusIdent_value := o.VirusIdent.ValueBoolPointer()
	category_value := o.Category.ValueStringPointer()
	consumeBigBandwidth_value := o.ConsumeBigBandwidth.ValueBoolPointer()
	parentApp_value := o.ParentApp.ValueStringPointer()
	tcpTimeout_value := o.TcpTimeout.ValueInt64Pointer()
	udpTimeout_value := o.UdpTimeout.ValueInt64Pointer()
	ableToTransferFile_value := o.AbleToTransferFile.ValueBoolPointer()
	risk_value := o.Risk.ValueInt64Pointer()
	tcpTimeWaitTimeout_value := o.TcpTimeWaitTimeout.ValueInt64Pointer()
	var signature_tf_entries []ApplicationResourceSignatureObject
	var signature_pango_entries []application.Signature
	{
		d := o.Signature.ElementsAs(ctx, &signature_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range signature_tf_entries {
			var entry *application.Signature
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			signature_pango_entries = append(signature_pango_entries, *entry)
		}
	}
	tunnelOtherApplication_value := o.TunnelOtherApplication.ValueBoolPointer()
	algDisableCapability_value := o.AlgDisableCapability.ValueStringPointer()
	noAppidCaching_value := o.NoAppidCaching.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(application.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ProneToMisuse = proneToMisuse_value
	(*obj).UsedByMalware = usedByMalware_value
	(*obj).DataIdent = dataIdent_value
	(*obj).EvasiveBehavior = evasiveBehavior_value
	(*obj).Timeout = timeout_value
	(*obj).TunnelApplications = tunnelApplications_value
	(*obj).Default = default_entry
	(*obj).DisableOverride = disableOverride_value
	(*obj).Subcategory = subcategory_value
	(*obj).Technology = technology_value
	(*obj).FileTypeIdent = fileTypeIdent_value
	(*obj).HasKnownVulnerability = hasKnownVulnerability_value
	(*obj).Description = description_value
	(*obj).PervasiveUse = pervasiveUse_value
	(*obj).TcpHalfClosedTimeout = tcpHalfClosedTimeout_value
	(*obj).VirusIdent = virusIdent_value
	(*obj).Category = category_value
	(*obj).ConsumeBigBandwidth = consumeBigBandwidth_value
	(*obj).ParentApp = parentApp_value
	(*obj).TcpTimeout = tcpTimeout_value
	(*obj).UdpTimeout = udpTimeout_value
	(*obj).AbleToTransferFile = ableToTransferFile_value
	(*obj).Risk = risk_value
	(*obj).TcpTimeWaitTimeout = tcpTimeWaitTimeout_value
	(*obj).Signature = signature_pango_entries
	(*obj).TunnelOtherApplication = tunnelOtherApplication_value
	(*obj).AlgDisableCapability = algDisableCapability_value
	(*obj).NoAppidCaching = noAppidCaching_value

	return diags
}
func (o *ApplicationResourceSignatureObject) CopyToPango(ctx context.Context, obj **application.Signature, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	orderFree_value := o.OrderFree.ValueBoolPointer()
	var andCondition_tf_entries []ApplicationResourceSignatureAndConditionObject
	var andCondition_pango_entries []application.SignatureAndCondition
	{
		d := o.AndCondition.ElementsAs(ctx, &andCondition_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range andCondition_tf_entries {
			var entry *application.SignatureAndCondition
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			andCondition_pango_entries = append(andCondition_pango_entries, *entry)
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	scope_value := o.Scope.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.Signature)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).OrderFree = orderFree_value
	(*obj).AndCondition = andCondition_pango_entries
	(*obj).Comment = comment_value
	(*obj).Scope = scope_value

	return diags
}
func (o *ApplicationResourceSignatureAndConditionObject) CopyToPango(ctx context.Context, obj **application.SignatureAndCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var orCondition_tf_entries []ApplicationResourceSignatureAndConditionOrConditionObject
	var orCondition_pango_entries []application.SignatureAndConditionOrCondition
	{
		d := o.OrCondition.ElementsAs(ctx, &orCondition_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range orCondition_tf_entries {
			var entry *application.SignatureAndConditionOrCondition
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			orCondition_pango_entries = append(orCondition_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndCondition)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).OrCondition = orCondition_pango_entries

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var operator_entry *application.SignatureAndConditionOrConditionOperator
	if o.Operator != nil {
		if *obj != nil && (*obj).Operator != nil {
			operator_entry = (*obj).Operator
		} else {
			operator_entry = new(application.SignatureAndConditionOrConditionOperator)
		}

		diags.Append(o.Operator.CopyToPango(ctx, &operator_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrCondition)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Operator = operator_entry

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperator, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var patternMatch_entry *application.SignatureAndConditionOrConditionOperatorPatternMatch
	if o.PatternMatch != nil {
		if *obj != nil && (*obj).PatternMatch != nil {
			patternMatch_entry = (*obj).PatternMatch
		} else {
			patternMatch_entry = new(application.SignatureAndConditionOrConditionOperatorPatternMatch)
		}

		diags.Append(o.PatternMatch.CopyToPango(ctx, &patternMatch_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var greaterThan_entry *application.SignatureAndConditionOrConditionOperatorGreaterThan
	if o.GreaterThan != nil {
		if *obj != nil && (*obj).GreaterThan != nil {
			greaterThan_entry = (*obj).GreaterThan
		} else {
			greaterThan_entry = new(application.SignatureAndConditionOrConditionOperatorGreaterThan)
		}

		diags.Append(o.GreaterThan.CopyToPango(ctx, &greaterThan_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lessThan_entry *application.SignatureAndConditionOrConditionOperatorLessThan
	if o.LessThan != nil {
		if *obj != nil && (*obj).LessThan != nil {
			lessThan_entry = (*obj).LessThan
		} else {
			lessThan_entry = new(application.SignatureAndConditionOrConditionOperatorLessThan)
		}

		diags.Append(o.LessThan.CopyToPango(ctx, &lessThan_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var equalTo_entry *application.SignatureAndConditionOrConditionOperatorEqualTo
	if o.EqualTo != nil {
		if *obj != nil && (*obj).EqualTo != nil {
			equalTo_entry = (*obj).EqualTo
		} else {
			equalTo_entry = new(application.SignatureAndConditionOrConditionOperatorEqualTo)
		}

		diags.Append(o.EqualTo.CopyToPango(ctx, &equalTo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperator)
	}
	(*obj).PatternMatch = patternMatch_entry
	(*obj).GreaterThan = greaterThan_entry
	(*obj).LessThan = lessThan_entry
	(*obj).EqualTo = equalTo_entry

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorLessThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	context_value := o.Context.ValueStringPointer()
	value_value := o.Value.ValueInt64Pointer()
	var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorLessThanQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorLessThanQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorLessThan)
	}
	(*obj).Context = context_value
	(*obj).Value = value_value
	(*obj).Qualifier = qualifier_pango_entries

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorLessThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorLessThanQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorEqualTo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	context_value := o.Context.ValueStringPointer()
	position_value := o.Position.ValueStringPointer()
	mask_value := o.Mask.ValueStringPointer()
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorEqualTo)
	}
	(*obj).Context = context_value
	(*obj).Position = position_value
	(*obj).Mask = mask_value
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorPatternMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}
	context_value := o.Context.ValueStringPointer()
	pattern_value := o.Pattern.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorPatternMatch)
	}
	(*obj).Qualifier = qualifier_pango_entries
	(*obj).Context = context_value
	(*obj).Pattern = pattern_value

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorGreaterThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	context_value := o.Context.ValueStringPointer()
	value_value := o.Value.ValueInt64Pointer()
	var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
	var qualifier_pango_entries []application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier
	{
		d := o.Qualifier.ElementsAs(ctx, &qualifier_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range qualifier_tf_entries {
			var entry *application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			qualifier_pango_entries = append(qualifier_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorGreaterThan)
	}
	(*obj).Context = context_value
	(*obj).Value = value_value
	(*obj).Qualifier = qualifier_pango_entries

	return diags
}
func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) CopyToPango(ctx context.Context, obj **application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *ApplicationResourceDefaultObject) CopyToPango(ctx context.Context, obj **application.Default, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var identByIcmpType_entry *application.DefaultIdentByIcmpType
	if o.IdentByIcmpType != nil {
		if *obj != nil && (*obj).IdentByIcmpType != nil {
			identByIcmpType_entry = (*obj).IdentByIcmpType
		} else {
			identByIcmpType_entry = new(application.DefaultIdentByIcmpType)
		}

		diags.Append(o.IdentByIcmpType.CopyToPango(ctx, &identByIcmpType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var identByIcmp6Type_entry *application.DefaultIdentByIcmp6Type
	if o.IdentByIcmp6Type != nil {
		if *obj != nil && (*obj).IdentByIcmp6Type != nil {
			identByIcmp6Type_entry = (*obj).IdentByIcmp6Type
		} else {
			identByIcmp6Type_entry = new(application.DefaultIdentByIcmp6Type)
		}

		diags.Append(o.IdentByIcmp6Type.CopyToPango(ctx, &identByIcmp6Type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	identByIpProtocol_value := o.IdentByIpProtocol.ValueStringPointer()
	port_pango_entries := make([]string, 0)
	diags.Append(o.Port.ElementsAs(ctx, &port_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(application.Default)
	}
	(*obj).IdentByIcmpType = identByIcmpType_entry
	(*obj).IdentByIcmp6Type = identByIcmp6Type_entry
	(*obj).IdentByIpProtocol = identByIpProtocol_value
	(*obj).Port = port_pango_entries

	return diags
}
func (o *ApplicationResourceDefaultIdentByIcmpTypeObject) CopyToPango(ctx context.Context, obj **application.DefaultIdentByIcmpType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.DefaultIdentByIcmpType)
	}
	(*obj).Code = code_value
	(*obj).Type = type_value

	return diags
}
func (o *ApplicationResourceDefaultIdentByIcmp6TypeObject) CopyToPango(ctx context.Context, obj **application.DefaultIdentByIcmp6Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	code_value := o.Code.ValueStringPointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(application.DefaultIdentByIcmp6Type)
	}
	(*obj).Code = code_value
	(*obj).Type = type_value

	return diags
}

func (o *ApplicationResourceModel) CopyFromPango(ctx context.Context, obj *application.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var signature_list types.List
	{
		var signature_tf_entries []ApplicationResourceSignatureObject
		for _, elt := range obj.Signature {
			var entry ApplicationResourceSignatureObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			signature_tf_entries = append(signature_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("signature")
		signature_list, list_diags = types.ListValueFrom(ctx, schemaType, signature_tf_entries)
		diags.Append(list_diags...)
	}
	var default_object *ApplicationResourceDefaultObject
	if obj.Default != nil {
		default_object = new(ApplicationResourceDefaultObject)

		diags.Append(default_object.CopyFromPango(ctx, obj.Default, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	var evasiveBehavior_value types.Bool
	if obj.EvasiveBehavior != nil {
		evasiveBehavior_value = types.BoolValue(*obj.EvasiveBehavior)
	}
	var timeout_value types.Int64
	if obj.Timeout != nil {
		timeout_value = types.Int64Value(*obj.Timeout)
	}
	var tunnelApplications_value types.Bool
	if obj.TunnelApplications != nil {
		tunnelApplications_value = types.BoolValue(*obj.TunnelApplications)
	}
	var fileTypeIdent_value types.Bool
	if obj.FileTypeIdent != nil {
		fileTypeIdent_value = types.BoolValue(*obj.FileTypeIdent)
	}
	var hasKnownVulnerability_value types.Bool
	if obj.HasKnownVulnerability != nil {
		hasKnownVulnerability_value = types.BoolValue(*obj.HasKnownVulnerability)
	}
	var subcategory_value types.String
	if obj.Subcategory != nil {
		subcategory_value = types.StringValue(*obj.Subcategory)
	}
	var technology_value types.String
	if obj.Technology != nil {
		technology_value = types.StringValue(*obj.Technology)
	}
	var category_value types.String
	if obj.Category != nil {
		category_value = types.StringValue(*obj.Category)
	}
	var consumeBigBandwidth_value types.Bool
	if obj.ConsumeBigBandwidth != nil {
		consumeBigBandwidth_value = types.BoolValue(*obj.ConsumeBigBandwidth)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var pervasiveUse_value types.Bool
	if obj.PervasiveUse != nil {
		pervasiveUse_value = types.BoolValue(*obj.PervasiveUse)
	}
	var tcpHalfClosedTimeout_value types.Int64
	if obj.TcpHalfClosedTimeout != nil {
		tcpHalfClosedTimeout_value = types.Int64Value(*obj.TcpHalfClosedTimeout)
	}
	var virusIdent_value types.Bool
	if obj.VirusIdent != nil {
		virusIdent_value = types.BoolValue(*obj.VirusIdent)
	}
	var ableToTransferFile_value types.Bool
	if obj.AbleToTransferFile != nil {
		ableToTransferFile_value = types.BoolValue(*obj.AbleToTransferFile)
	}
	var parentApp_value types.String
	if obj.ParentApp != nil {
		parentApp_value = types.StringValue(*obj.ParentApp)
	}
	var tcpTimeout_value types.Int64
	if obj.TcpTimeout != nil {
		tcpTimeout_value = types.Int64Value(*obj.TcpTimeout)
	}
	var udpTimeout_value types.Int64
	if obj.UdpTimeout != nil {
		udpTimeout_value = types.Int64Value(*obj.UdpTimeout)
	}
	var risk_value types.Int64
	if obj.Risk != nil {
		risk_value = types.Int64Value(*obj.Risk)
	}
	var tcpTimeWaitTimeout_value types.Int64
	if obj.TcpTimeWaitTimeout != nil {
		tcpTimeWaitTimeout_value = types.Int64Value(*obj.TcpTimeWaitTimeout)
	}
	var algDisableCapability_value types.String
	if obj.AlgDisableCapability != nil {
		algDisableCapability_value = types.StringValue(*obj.AlgDisableCapability)
	}
	var noAppidCaching_value types.Bool
	if obj.NoAppidCaching != nil {
		noAppidCaching_value = types.BoolValue(*obj.NoAppidCaching)
	}
	var tunnelOtherApplication_value types.Bool
	if obj.TunnelOtherApplication != nil {
		tunnelOtherApplication_value = types.BoolValue(*obj.TunnelOtherApplication)
	}
	var proneToMisuse_value types.Bool
	if obj.ProneToMisuse != nil {
		proneToMisuse_value = types.BoolValue(*obj.ProneToMisuse)
	}
	var usedByMalware_value types.Bool
	if obj.UsedByMalware != nil {
		usedByMalware_value = types.BoolValue(*obj.UsedByMalware)
	}
	var dataIdent_value types.Bool
	if obj.DataIdent != nil {
		dataIdent_value = types.BoolValue(*obj.DataIdent)
	}
	o.Name = types.StringValue(obj.Name)
	o.Default = default_object
	o.DisableOverride = disableOverride_value
	o.EvasiveBehavior = evasiveBehavior_value
	o.Timeout = timeout_value
	o.TunnelApplications = tunnelApplications_value
	o.FileTypeIdent = fileTypeIdent_value
	o.HasKnownVulnerability = hasKnownVulnerability_value
	o.Subcategory = subcategory_value
	o.Technology = technology_value
	o.Category = category_value
	o.ConsumeBigBandwidth = consumeBigBandwidth_value
	o.Description = description_value
	o.PervasiveUse = pervasiveUse_value
	o.TcpHalfClosedTimeout = tcpHalfClosedTimeout_value
	o.VirusIdent = virusIdent_value
	o.AbleToTransferFile = ableToTransferFile_value
	o.ParentApp = parentApp_value
	o.TcpTimeout = tcpTimeout_value
	o.UdpTimeout = udpTimeout_value
	o.Risk = risk_value
	o.TcpTimeWaitTimeout = tcpTimeWaitTimeout_value
	o.AlgDisableCapability = algDisableCapability_value
	o.NoAppidCaching = noAppidCaching_value
	o.Signature = signature_list
	o.TunnelOtherApplication = tunnelOtherApplication_value
	o.ProneToMisuse = proneToMisuse_value
	o.UsedByMalware = usedByMalware_value
	o.DataIdent = dataIdent_value

	return diags
}

func (o *ApplicationResourceSignatureObject) CopyFromPango(ctx context.Context, obj *application.Signature, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var andCondition_list types.List
	{
		var andCondition_tf_entries []ApplicationResourceSignatureAndConditionObject
		for _, elt := range obj.AndCondition {
			var entry ApplicationResourceSignatureAndConditionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			andCondition_tf_entries = append(andCondition_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("and_condition")
		andCondition_list, list_diags = types.ListValueFrom(ctx, schemaType, andCondition_tf_entries)
		diags.Append(list_diags...)
	}

	var orderFree_value types.Bool
	if obj.OrderFree != nil {
		orderFree_value = types.BoolValue(*obj.OrderFree)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var scope_value types.String
	if obj.Scope != nil {
		scope_value = types.StringValue(*obj.Scope)
	}
	o.Name = types.StringValue(obj.Name)
	o.OrderFree = orderFree_value
	o.AndCondition = andCondition_list
	o.Comment = comment_value
	o.Scope = scope_value

	return diags
}

func (o *ApplicationResourceSignatureAndConditionObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var orCondition_list types.List
	{
		var orCondition_tf_entries []ApplicationResourceSignatureAndConditionOrConditionObject
		for _, elt := range obj.OrCondition {
			var entry ApplicationResourceSignatureAndConditionOrConditionObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			orCondition_tf_entries = append(orCondition_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("or_condition")
		orCondition_list, list_diags = types.ListValueFrom(ctx, schemaType, orCondition_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.OrCondition = orCondition_list

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrCondition, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var operator_object *ApplicationResourceSignatureAndConditionOrConditionOperatorObject
	if obj.Operator != nil {
		operator_object = new(ApplicationResourceSignatureAndConditionOrConditionOperatorObject)

		diags.Append(operator_object.CopyFromPango(ctx, obj.Operator, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Operator = operator_object

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperator, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var patternMatch_object *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject
	if obj.PatternMatch != nil {
		patternMatch_object = new(ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject)

		diags.Append(patternMatch_object.CopyFromPango(ctx, obj.PatternMatch, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var greaterThan_object *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject
	if obj.GreaterThan != nil {
		greaterThan_object = new(ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject)

		diags.Append(greaterThan_object.CopyFromPango(ctx, obj.GreaterThan, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var lessThan_object *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject
	if obj.LessThan != nil {
		lessThan_object = new(ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject)

		diags.Append(lessThan_object.CopyFromPango(ctx, obj.LessThan, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var equalTo_object *ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject
	if obj.EqualTo != nil {
		equalTo_object = new(ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject)

		diags.Append(equalTo_object.CopyFromPango(ctx, obj.EqualTo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.PatternMatch = patternMatch_object
	o.GreaterThan = greaterThan_object
	o.LessThan = lessThan_object
	o.EqualTo = equalTo_object

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorLessThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	o.Context = context_value
	o.Value = value_value
	o.Qualifier = qualifier_list

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorLessThanQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorLessThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorEqualToObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorEqualTo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var position_value types.String
	if obj.Position != nil {
		position_value = types.StringValue(*obj.Position)
	}
	var mask_value types.String
	if obj.Mask != nil {
		mask_value = types.StringValue(*obj.Mask)
	}
	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	o.Position = position_value
	o.Mask = mask_value
	o.Value = value_value
	o.Context = context_value

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorPatternMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var pattern_value types.String
	if obj.Pattern != nil {
		pattern_value = types.StringValue(*obj.Pattern)
	}
	o.Context = context_value
	o.Pattern = pattern_value
	o.Qualifier = qualifier_list

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorPatternMatchQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorPatternMatchQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorGreaterThan, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var qualifier_list types.List
	{
		var qualifier_tf_entries []ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
		for _, elt := range obj.Qualifier {
			var entry ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			qualifier_tf_entries = append(qualifier_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("qualifier")
		qualifier_list, list_diags = types.ListValueFrom(ctx, schemaType, qualifier_tf_entries)
		diags.Append(list_diags...)
	}

	var context_value types.String
	if obj.Context != nil {
		context_value = types.StringValue(*obj.Context)
	}
	var value_value types.Int64
	if obj.Value != nil {
		value_value = types.Int64Value(*obj.Value)
	}
	o.Context = context_value
	o.Value = value_value
	o.Qualifier = qualifier_list

	return diags
}

func (o *ApplicationResourceSignatureAndConditionOrConditionOperatorGreaterThanQualifierObject) CopyFromPango(ctx context.Context, obj *application.SignatureAndConditionOrConditionOperatorGreaterThanQualifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *ApplicationResourceDefaultObject) CopyFromPango(ctx context.Context, obj *application.Default, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var port_list types.List
	{
		var list_diags diag.Diagnostics
		port_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Port)
		diags.Append(list_diags...)
	}
	var identByIcmpType_object *ApplicationResourceDefaultIdentByIcmpTypeObject
	if obj.IdentByIcmpType != nil {
		identByIcmpType_object = new(ApplicationResourceDefaultIdentByIcmpTypeObject)

		diags.Append(identByIcmpType_object.CopyFromPango(ctx, obj.IdentByIcmpType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var identByIcmp6Type_object *ApplicationResourceDefaultIdentByIcmp6TypeObject
	if obj.IdentByIcmp6Type != nil {
		identByIcmp6Type_object = new(ApplicationResourceDefaultIdentByIcmp6TypeObject)

		diags.Append(identByIcmp6Type_object.CopyFromPango(ctx, obj.IdentByIcmp6Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var identByIpProtocol_value types.String
	if obj.IdentByIpProtocol != nil {
		identByIpProtocol_value = types.StringValue(*obj.IdentByIpProtocol)
	}
	o.IdentByIcmpType = identByIcmpType_object
	o.IdentByIcmp6Type = identByIcmp6Type_object
	o.IdentByIpProtocol = identByIpProtocol_value
	o.Port = port_list

	return diags
}

func (o *ApplicationResourceDefaultIdentByIcmpTypeObject) CopyFromPango(ctx context.Context, obj *application.DefaultIdentByIcmpType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	var code_value types.String
	if obj.Code != nil {
		code_value = types.StringValue(*obj.Code)
	}
	o.Type = type_value
	o.Code = code_value

	return diags
}

func (o *ApplicationResourceDefaultIdentByIcmp6TypeObject) CopyFromPango(ctx context.Context, obj *application.DefaultIdentByIcmp6Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var code_value types.String
	if obj.Code != nil {
		code_value = types.StringValue(*obj.Code)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Code = code_value
	o.Type = type_value

	return diags
}

func (r *ApplicationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state ApplicationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_application_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location application.Location

	if state.Location.Vsys != nil {
		location.Vsys = &application.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &application.DeviceGroupLocation{

			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *application.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *ApplicationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state ApplicationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location application.Location

	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if savestate.Location.Vsys != nil {
		location.Vsys = &application.VsysLocation{

			NgfwDevice: savestate.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       savestate.Location.Vsys.Name.ValueString(),
		}
	}
	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &application.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_application_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *ApplicationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state ApplicationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location application.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.Vsys != nil {
		location.Vsys = &application.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &application.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_application_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *ApplicationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state ApplicationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_application_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location application.Location

	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &application.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}
	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.Vsys != nil {
		location.Vsys = &application.VsysLocation{

			NgfwDevice: state.Location.Vsys.NgfwDevice.ValueString(),
			Vsys:       state.Location.Vsys.Name.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type ApplicationImportState struct {
	Location ApplicationLocation `json:"location"`
	Name     string              `json:"name"`
}

func ApplicationImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location ApplicationLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := ApplicationImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *ApplicationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj ApplicationImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type ApplicationVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type ApplicationDeviceGroupLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
}
type ApplicationLocation struct {
	Shared      types.Bool                      `tfsdk:"shared"`
	Vsys        *ApplicationVsysLocation        `tfsdk:"vsys"`
	DeviceGroup *ApplicationDeviceGroupLocation `tfsdk:"device_group"`
}

func ApplicationLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.BoolAttribute{
				Description: "Location in Shared Panorama",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Bool{
					boolvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("device_group"),
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("vsys"),
					}...),
				},
			},
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Virtual System",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The Virtual System name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Device Group",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Panorama device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Device Group name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o ApplicationVsysLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
		Name       *string `json:"name"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *ApplicationVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
		Name       *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o ApplicationDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *ApplicationDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o ApplicationLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Shared      *bool                           `json:"shared"`
		Vsys        *ApplicationVsysLocation        `json:"vsys"`
		DeviceGroup *ApplicationDeviceGroupLocation `json:"device_group"`
	}{
		Shared:      o.Shared.ValueBoolPointer(),
		Vsys:        o.Vsys,
		DeviceGroup: o.DeviceGroup,
	}

	return json.Marshal(obj)
}

func (o *ApplicationLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *bool                           `json:"shared"`
		Vsys        *ApplicationVsysLocation        `json:"vsys"`
		DeviceGroup *ApplicationDeviceGroupLocation `json:"device_group"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Shared = types.BoolPointerValue(shadow.Shared)
	o.Vsys = shadow.Vsys
	o.DeviceGroup = shadow.DeviceGroup

	return nil
}
