package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/tunnel/ipsec"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &IpsecTunnelDataSource{}
	_ datasource.DataSourceWithConfigure = &IpsecTunnelDataSource{}
)

func NewIpsecTunnelDataSource() datasource.DataSource {
	return &IpsecTunnelDataSource{}
}

type IpsecTunnelDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service]
}

type IpsecTunnelDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type IpsecTunnelDataSourceModel struct {
	Location               types.Object `tfsdk:"location"`
	Name                   types.String `tfsdk:"name"`
	AntiReplay             types.Bool   `tfsdk:"anti_replay"`
	AntiReplayWindow       types.String `tfsdk:"anti_replay_window"`
	Comment                types.String `tfsdk:"comment"`
	CopyFlowLabel          types.Bool   `tfsdk:"copy_flow_label"`
	CopyTos                types.Bool   `tfsdk:"copy_tos"`
	Disabled               types.Bool   `tfsdk:"disabled"`
	EnableGreEncapsulation types.Bool   `tfsdk:"enable_gre_encapsulation"`
	IpsecMode              types.String `tfsdk:"ipsec_mode"`
	Ipv6                   types.Bool   `tfsdk:"ipv6"`
	TunnelInterface        types.String `tfsdk:"tunnel_interface"`
	TunnelMonitor          types.Object `tfsdk:"tunnel_monitor"`
	AutoKey                types.Object `tfsdk:"auto_key"`
	GlobalProtectSatellite types.Object `tfsdk:"global_protect_satellite"`
	ManualKey              types.Object `tfsdk:"manual_key"`
}
type IpsecTunnelDataSourceTunnelMonitorObject struct {
	DestinationIp        types.String `tfsdk:"destination_ip"`
	Enable               types.Bool   `tfsdk:"enable"`
	ProxyId              types.String `tfsdk:"proxy_id"`
	TunnelMonitorProfile types.String `tfsdk:"tunnel_monitor_profile"`
}
type IpsecTunnelDataSourceAutoKeyObject struct {
	IkeGateway         types.List   `tfsdk:"ike_gateway"`
	IpsecCryptoProfile types.String `tfsdk:"ipsec_crypto_profile"`
	ProxyId            types.List   `tfsdk:"proxy_id"`
	ProxyIdV6          types.List   `tfsdk:"proxy_id_v6"`
}
type IpsecTunnelDataSourceAutoKeyIkeGatewayObject struct {
	Name types.String `tfsdk:"name"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdObject struct {
	Name     types.String `tfsdk:"name"`
	Local    types.String `tfsdk:"local"`
	Remote   types.String `tfsdk:"remote"`
	Protocol types.Object `tfsdk:"protocol"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject struct {
	Number types.Int64  `tfsdk:"number"`
	Any    types.Object `tfsdk:"any"`
	Tcp    types.Object `tfsdk:"tcp"`
	Udp    types.Object `tfsdk:"udp"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject struct {
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6Object struct {
	Name     types.String `tfsdk:"name"`
	Local    types.String `tfsdk:"local"`
	Remote   types.String `tfsdk:"remote"`
	Protocol types.Object `tfsdk:"protocol"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject struct {
	Number types.Int64  `tfsdk:"number"`
	Any    types.Object `tfsdk:"any"`
	Tcp    types.Object `tfsdk:"tcp"`
	Udp    types.Object `tfsdk:"udp"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject struct {
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteObject struct {
	ExternalCa             types.Object `tfsdk:"external_ca"`
	Ipv6Preferred          types.Bool   `tfsdk:"ipv6_preferred"`
	LocalAddress           types.Object `tfsdk:"local_address"`
	PortalAddress          types.String `tfsdk:"portal_address"`
	PublishConnectedRoutes types.Object `tfsdk:"publish_connected_routes"`
	PublishRoutes          types.List   `tfsdk:"publish_routes"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	LocalCertificate   types.String `tfsdk:"local_certificate"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.Object `tfsdk:"floating_ip"`
	Ip         types.Object `tfsdk:"ip"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IpsecTunnelDataSourceManualKeyObject struct {
	LocalAddress types.Object `tfsdk:"local_address"`
	LocalSpi     types.String `tfsdk:"local_spi"`
	PeerAddress  types.Object `tfsdk:"peer_address"`
	RemoteSpi    types.String `tfsdk:"remote_spi"`
	Ah           types.Object `tfsdk:"ah"`
	Esp          types.Object `tfsdk:"esp"`
}
type IpsecTunnelDataSourceManualKeyLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IpsecTunnelDataSourceManualKeyPeerAddressObject struct {
	Ip types.String `tfsdk:"ip"`
}
type IpsecTunnelDataSourceManualKeyAhObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type IpsecTunnelDataSourceManualKeyAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspObject struct {
	Authentication types.Object `tfsdk:"authentication"`
	Encryption     types.Object `tfsdk:"encryption"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationObject struct {
	Md5    types.Object `tfsdk:"md5"`
	None   types.Object `tfsdk:"none"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject struct {
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}

func (o *IpsecTunnelDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj IpsecTunnelLocation

	var tunnelMonitorObj *IpsecTunnelDataSourceTunnelMonitorObject

	var autoKeyObj *IpsecTunnelDataSourceAutoKeyObject

	var globalProtectSatelliteObj *IpsecTunnelDataSourceGlobalProtectSatelliteObject

	var manualKeyObj *IpsecTunnelDataSourceManualKeyObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                     types.StringType,
		"anti_replay":              types.BoolType,
		"anti_replay_window":       types.StringType,
		"comment":                  types.StringType,
		"copy_flow_label":          types.BoolType,
		"copy_tos":                 types.BoolType,
		"disabled":                 types.BoolType,
		"enable_gre_encapsulation": types.BoolType,
		"ipsec_mode":               types.StringType,
		"ipv6":                     types.BoolType,
		"tunnel_interface":         types.StringType,
		"tunnel_monitor": types.ObjectType{
			AttrTypes: tunnelMonitorObj.AttributeTypes(),
		},
		"auto_key": types.ObjectType{
			AttrTypes: autoKeyObj.AttributeTypes(),
		},
		"global_protect_satellite": types.ObjectType{
			AttrTypes: globalProtectSatelliteObj.AttributeTypes(),
		},
		"manual_key": types.ObjectType{
			AttrTypes: manualKeyObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceModel) AncestorName() string {
	return ""
}

func (o IpsecTunnelDataSourceModel) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceTunnelMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"destination_ip":         types.StringType,
		"enable":                 types.BoolType,
		"proxy_id":               types.StringType,
		"tunnel_monitor_profile": types.StringType,
	}
}

func (o IpsecTunnelDataSourceTunnelMonitorObject) AncestorName() string {
	return "tunnel-monitor"
}

func (o IpsecTunnelDataSourceTunnelMonitorObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyObject) AttributeTypes() map[string]attr.Type {

	var ikeGatewayObj *IpsecTunnelDataSourceAutoKeyIkeGatewayObject

	var proxyIdObj *IpsecTunnelDataSourceAutoKeyProxyIdObject

	var proxyIdV6Obj *IpsecTunnelDataSourceAutoKeyProxyIdV6Object
	return map[string]attr.Type{
		"ike_gateway": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ikeGatewayObj.AttributeTypes(),
			},
		},
		"ipsec_crypto_profile": types.StringType,
		"proxy_id": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyIdObj.AttributeTypes(),
			},
		},
		"proxy_id_v6": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyIdV6Obj.AttributeTypes(),
			},
		},
	}
}

func (o IpsecTunnelDataSourceAutoKeyObject) AncestorName() string {
	return "auto-key"
}

func (o IpsecTunnelDataSourceAutoKeyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o IpsecTunnelDataSourceAutoKeyIkeGatewayObject) AncestorName() string {
	return "ike-gateway"
}

func (o IpsecTunnelDataSourceAutoKeyIkeGatewayObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) AttributeTypes() map[string]attr.Type {

	var protocolObj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"local":  types.StringType,
		"remote": types.StringType,
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdObject) AncestorName() string {
	return "proxy-id"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) AttributeTypes() map[string]attr.Type {

	var anyObj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject

	var tcpObj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject

	var udpObj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject
	return map[string]attr.Type{
		"number": types.Int64Type,
		"any": types.ObjectType{
			AttrTypes: anyObj.AttributeTypes(),
		},
		"tcp": types.ObjectType{
			AttrTypes: tcpObj.AttributeTypes(),
		},
		"udp": types.ObjectType{
			AttrTypes: udpObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) AncestorName() string {
	return "any"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) AncestorName() string {
	return "tcp"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) AncestorName() string {
	return "udp"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) AttributeTypes() map[string]attr.Type {

	var protocolObj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"local":  types.StringType,
		"remote": types.StringType,
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6Object) AncestorName() string {
	return "proxy-id-v6"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) AttributeTypes() map[string]attr.Type {

	var anyObj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject

	var tcpObj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject

	var udpObj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject
	return map[string]attr.Type{
		"number": types.Int64Type,
		"any": types.ObjectType{
			AttrTypes: anyObj.AttributeTypes(),
		},
		"tcp": types.ObjectType{
			AttrTypes: tcpObj.AttributeTypes(),
		},
		"udp": types.ObjectType{
			AttrTypes: udpObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) AncestorName() string {
	return "any"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) AncestorName() string {
	return "tcp"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) AncestorName() string {
	return "udp"
}

func (o IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) AttributeTypes() map[string]attr.Type {

	var externalCaObj *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject

	var localAddressObj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject

	var publishConnectedRoutesObj *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject

	return map[string]attr.Type{
		"external_ca": types.ObjectType{
			AttrTypes: externalCaObj.AttributeTypes(),
		},
		"ipv6_preferred": types.BoolType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"portal_address": types.StringType,
		"publish_connected_routes": types.ObjectType{
			AttrTypes: publishConnectedRoutesObj.AttributeTypes(),
		},
		"publish_routes": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteObject) AncestorName() string {
	return "global-protect-satellite"
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"local_certificate":   types.StringType,
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) AncestorName() string {
	return "external-ca"
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject

	var ipObj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) AncestorName() string {
	return "publish-connected-routes"
}

func (o IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *IpsecTunnelDataSourceManualKeyLocalAddressObject

	var peerAddressObj *IpsecTunnelDataSourceManualKeyPeerAddressObject

	var ahObj *IpsecTunnelDataSourceManualKeyAhObject

	var espObj *IpsecTunnelDataSourceManualKeyEspObject
	return map[string]attr.Type{
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"local_spi": types.StringType,
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"remote_spi": types.StringType,
		"ah": types.ObjectType{
			AttrTypes: ahObj.AttributeTypes(),
		},
		"esp": types.ObjectType{
			AttrTypes: espObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceManualKeyObject) AncestorName() string {
	return "manual-key"
}

func (o IpsecTunnelDataSourceManualKeyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IpsecTunnelDataSourceManualKeyLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o IpsecTunnelDataSourceManualKeyPeerAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *IpsecTunnelDataSourceManualKeyAhMd5Object

	var sha1Obj *IpsecTunnelDataSourceManualKeyAhSha1Object

	var sha256Obj *IpsecTunnelDataSourceManualKeyAhSha256Object

	var sha384Obj *IpsecTunnelDataSourceManualKeyAhSha384Object

	var sha512Obj *IpsecTunnelDataSourceManualKeyAhSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceManualKeyAhObject) AncestorName() string {
	return "ah"
}

func (o IpsecTunnelDataSourceManualKeyAhObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyAhMd5Object) AncestorName() string {
	return "md5"
}

func (o IpsecTunnelDataSourceManualKeyAhMd5Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyAhSha1Object) AncestorName() string {
	return "sha1"
}

func (o IpsecTunnelDataSourceManualKeyAhSha1Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyAhSha256Object) AncestorName() string {
	return "sha256"
}

func (o IpsecTunnelDataSourceManualKeyAhSha256Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyAhSha384Object) AncestorName() string {
	return "sha384"
}

func (o IpsecTunnelDataSourceManualKeyAhSha384Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyAhSha512Object) AncestorName() string {
	return "sha512"
}

func (o IpsecTunnelDataSourceManualKeyAhSha512Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspObject) AttributeTypes() map[string]attr.Type {

	var authenticationObj *IpsecTunnelDataSourceManualKeyEspAuthenticationObject

	var encryptionObj *IpsecTunnelDataSourceManualKeyEspEncryptionObject
	return map[string]attr.Type{
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"encryption": types.ObjectType{
			AttrTypes: encryptionObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceManualKeyEspObject) AncestorName() string {
	return "esp"
}

func (o IpsecTunnelDataSourceManualKeyEspObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object

	var noneObj *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject

	var sha1Obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object

	var sha256Obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object

	var sha384Obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object

	var sha512Obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) AncestorName() string {
	return "md5"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) AncestorName() string {
	return "none"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) AncestorName() string {
	return "sha1"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) AncestorName() string {
	return "sha256"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) AncestorName() string {
	return "sha384"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) AncestorName() string {
	return "sha512"
}

func (o IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"algorithm": types.StringType,
		"key":       types.StringType,
	}
}

func (o IpsecTunnelDataSourceManualKeyEspEncryptionObject) AncestorName() string {
	return "encryption"
}

func (o IpsecTunnelDataSourceManualKeyEspEncryptionObject) EntryName() *string {
	return nil
}

func (o *IpsecTunnelDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	antiReplay_value := o.AntiReplay.ValueBoolPointer()
	antiReplayWindow_value := o.AntiReplayWindow.ValueStringPointer()
	comment_value := o.Comment.ValueStringPointer()
	copyFlowLabel_value := o.CopyFlowLabel.ValueBoolPointer()
	copyTos_value := o.CopyTos.ValueBoolPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	enableGreEncapsulation_value := o.EnableGreEncapsulation.ValueBoolPointer()
	ipsecMode_value := o.IpsecMode.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	tunnelInterface_value := o.TunnelInterface.ValueStringPointer()
	var tunnelMonitor_entry *ipsec.TunnelMonitor
	if !o.TunnelMonitor.IsUnknown() && !o.TunnelMonitor.IsNull() {
		if *obj != nil && (*obj).TunnelMonitor != nil {
			tunnelMonitor_entry = (*obj).TunnelMonitor
		} else {
			tunnelMonitor_entry = new(ipsec.TunnelMonitor)
		}
		var object *IpsecTunnelDataSourceTunnelMonitorObject
		diags.Append(o.TunnelMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &tunnelMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_entry *ipsec.AutoKey
	if !o.AutoKey.IsUnknown() && !o.AutoKey.IsNull() {
		if *obj != nil && (*obj).AutoKey != nil {
			autoKey_entry = (*obj).AutoKey
		} else {
			autoKey_entry = new(ipsec.AutoKey)
		}
		var object *IpsecTunnelDataSourceAutoKeyObject
		diags.Append(o.AutoKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &autoKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectSatellite_entry *ipsec.GlobalProtectSatellite
	if !o.GlobalProtectSatellite.IsUnknown() && !o.GlobalProtectSatellite.IsNull() {
		if *obj != nil && (*obj).GlobalProtectSatellite != nil {
			globalProtectSatellite_entry = (*obj).GlobalProtectSatellite
		} else {
			globalProtectSatellite_entry = new(ipsec.GlobalProtectSatellite)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatelliteObject
		diags.Append(o.GlobalProtectSatellite.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &globalProtectSatellite_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_entry *ipsec.ManualKey
	if !o.ManualKey.IsUnknown() && !o.ManualKey.IsNull() {
		if *obj != nil && (*obj).ManualKey != nil {
			manualKey_entry = (*obj).ManualKey
		} else {
			manualKey_entry = new(ipsec.ManualKey)
		}
		var object *IpsecTunnelDataSourceManualKeyObject
		diags.Append(o.ManualKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &manualKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AntiReplay = antiReplay_value
	(*obj).AntiReplayWindow = antiReplayWindow_value
	(*obj).Comment = comment_value
	(*obj).CopyFlowLabel = copyFlowLabel_value
	(*obj).CopyTos = copyTos_value
	(*obj).Disabled = disabled_value
	(*obj).EnableGreEncapsulation = enableGreEncapsulation_value
	(*obj).IpsecMode = ipsecMode_value
	(*obj).Ipv6 = ipv6_value
	(*obj).TunnelInterface = tunnelInterface_value
	(*obj).TunnelMonitor = tunnelMonitor_entry
	(*obj).AutoKey = autoKey_entry
	(*obj).GlobalProtectSatellite = globalProtectSatellite_entry
	(*obj).ManualKey = manualKey_entry

	return diags
}
func (o *IpsecTunnelDataSourceTunnelMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.TunnelMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destinationIp_value := o.DestinationIp.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	proxyId_value := o.ProxyId.ValueStringPointer()
	tunnelMonitorProfile_value := o.TunnelMonitorProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.TunnelMonitor)
	}
	(*obj).DestinationIp = destinationIp_value
	(*obj).Enable = enable_value
	(*obj).ProxyId = proxyId_value
	(*obj).TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_tf_entries []IpsecTunnelDataSourceAutoKeyIkeGatewayObject
	var ikeGateway_pango_entries []ipsec.AutoKeyIkeGateway
	{
		d := o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ikeGateway_tf_entries {
			var entry *ipsec.AutoKeyIkeGateway
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ikeGateway_pango_entries = append(ikeGateway_pango_entries, *entry)
		}
	}
	ipsecCryptoProfile_value := o.IpsecCryptoProfile.ValueStringPointer()
	var proxyId_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdObject
	var proxyId_pango_entries []ipsec.AutoKeyProxyId
	{
		d := o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyId_tf_entries {
			var entry *ipsec.AutoKeyProxyId
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyId_pango_entries = append(proxyId_pango_entries, *entry)
		}
	}
	var proxyIdV6_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdV6Object
	var proxyIdV6_pango_entries []ipsec.AutoKeyProxyIdV6
	{
		d := o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyIdV6_tf_entries {
			var entry *ipsec.AutoKeyProxyIdV6
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyIdV6_pango_entries = append(proxyIdV6_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKey)
	}
	(*obj).IkeGateway = ikeGateway_pango_entries
	(*obj).IpsecCryptoProfile = ipsecCryptoProfile_value
	(*obj).ProxyId = proxyId_pango_entries
	(*obj).ProxyIdV6 = proxyIdV6_pango_entries

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyIkeGateway, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyIkeGateway)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdProtocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdProtocol)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyId)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdProtocolAny
	if !o.Any.IsUnknown() && !o.Any.IsNull() {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdProtocolAny)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject
		diags.Append(o.Any.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &any_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_entry *ipsec.AutoKeyProxyIdProtocolTcp
	if !o.Tcp.IsUnknown() && !o.Tcp.IsNull() {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdProtocolTcp)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject
		diags.Append(o.Tcp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &tcp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdProtocolUdp
	if !o.Udp.IsUnknown() && !o.Udp.IsNull() {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdProtocolUdp)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject
		diags.Append(o.Udp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &udp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocol)
	}
	(*obj).Number = number_value
	(*obj).Any = any_entry
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdV6Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdV6Protocol)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdV6ProtocolAny
	if !o.Any.IsUnknown() && !o.Any.IsNull() {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject
		diags.Append(o.Any.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &any_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_entry *ipsec.AutoKeyProxyIdV6ProtocolTcp
	if !o.Tcp.IsUnknown() && !o.Tcp.IsNull() {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject
		diags.Append(o.Tcp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &tcp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdV6ProtocolUdp
	if !o.Udp.IsUnknown() && !o.Udp.IsNull() {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
		}
		var object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject
		diags.Append(o.Udp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &udp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6Protocol)
	}
	(*obj).Number = number_value
	(*obj).Any = any_entry
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatellite, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalCa_entry *ipsec.GlobalProtectSatelliteExternalCa
	if !o.ExternalCa.IsUnknown() && !o.ExternalCa.IsNull() {
		if *obj != nil && (*obj).ExternalCa != nil {
			externalCa_entry = (*obj).ExternalCa
		} else {
			externalCa_entry = new(ipsec.GlobalProtectSatelliteExternalCa)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject
		diags.Append(o.ExternalCa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &externalCa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()
	var localAddress_entry *ipsec.GlobalProtectSatelliteLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.GlobalProtectSatelliteLocalAddress)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	portalAddress_value := o.PortalAddress.ValueStringPointer()
	var publishConnectedRoutes_entry *ipsec.GlobalProtectSatellitePublishConnectedRoutes
	if !o.PublishConnectedRoutes.IsUnknown() && !o.PublishConnectedRoutes.IsNull() {
		if *obj != nil && (*obj).PublishConnectedRoutes != nil {
			publishConnectedRoutes_entry = (*obj).PublishConnectedRoutes
		} else {
			publishConnectedRoutes_entry = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject
		diags.Append(o.PublishConnectedRoutes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &publishConnectedRoutes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var publishRoutes_pango_entries []string
	if !o.PublishRoutes.IsUnknown() && !o.PublishRoutes.IsNull() {
		object_entries := make([]types.String, 0, len(o.PublishRoutes.Elements()))
		diags.Append(o.PublishRoutes.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			publishRoutes_pango_entries = append(publishRoutes_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellite)
	}
	(*obj).ExternalCa = externalCa_entry
	(*obj).Ipv6Preferred = ipv6Preferred_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PortalAddress = portalAddress_value
	(*obj).PublishConnectedRoutes = publishConnectedRoutes_entry
	(*obj).PublishRoutes = publishRoutes_pango_entries

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteExternalCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	localCertificate_value := o.LocalCertificate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteExternalCa)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	var floatingIp_entry *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *ipsec.GlobalProtectSatelliteLocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
		}
		var object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatellitePublishConnectedRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_entry *ipsec.ManualKeyLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.ManualKeyLocalAddress)
		}
		var object *IpsecTunnelDataSourceManualKeyLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	localSpi_value := o.LocalSpi.ValueStringPointer()
	var peerAddress_entry *ipsec.ManualKeyPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(ipsec.ManualKeyPeerAddress)
		}
		var object *IpsecTunnelDataSourceManualKeyPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	remoteSpi_value := o.RemoteSpi.ValueStringPointer()
	var ah_entry *ipsec.ManualKeyAh
	if !o.Ah.IsUnknown() && !o.Ah.IsNull() {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(ipsec.ManualKeyAh)
		}
		var object *IpsecTunnelDataSourceManualKeyAhObject
		diags.Append(o.Ah.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ah_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_entry *ipsec.ManualKeyEsp
	if !o.Esp.IsUnknown() && !o.Esp.IsNull() {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(ipsec.ManualKeyEsp)
		}
		var object *IpsecTunnelDataSourceManualKeyEspObject
		diags.Append(o.Esp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &esp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKey)
	}
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalSpi = localSpi_value
	(*obj).PeerAddress = peerAddress_entry
	(*obj).RemoteSpi = remoteSpi_value
	(*obj).Ah = ah_entry
	(*obj).Esp = esp_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyPeerAddress)
	}
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyAhMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyAhMd5)
		}
		var object *IpsecTunnelDataSourceManualKeyAhMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyAhSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyAhSha1)
		}
		var object *IpsecTunnelDataSourceManualKeyAhSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyAhSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyAhSha256)
		}
		var object *IpsecTunnelDataSourceManualKeyAhSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyAhSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyAhSha384)
		}
		var object *IpsecTunnelDataSourceManualKeyAhSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyAhSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyAhSha512)
		}
		var object *IpsecTunnelDataSourceManualKeyAhSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *ipsec.ManualKeyEspAuthentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(ipsec.ManualKeyEspAuthentication)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *ipsec.ManualKeyEspEncryption
	if !o.Encryption.IsUnknown() && !o.Encryption.IsNull() {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(ipsec.ManualKeyEspEncryption)
		}
		var object *IpsecTunnelDataSourceManualKeyEspEncryptionObject
		diags.Append(o.Encryption.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &encryption_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyEspAuthenticationMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyEspAuthenticationMd5)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *ipsec.ManualKeyEspAuthenticationNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(ipsec.ManualKeyEspAuthenticationNone)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyEspAuthenticationSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyEspAuthenticationSha1)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyEspAuthenticationSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyEspAuthenticationSha256)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyEspAuthenticationSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyEspAuthenticationSha384)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyEspAuthenticationSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyEspAuthenticationSha512)
		}
		var object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).None = none_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationNone)
	}

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var tunnelMonitor_obj *IpsecTunnelDataSourceTunnelMonitorObject
	if o.TunnelMonitor.IsNull() {
		tunnelMonitor_obj = new(IpsecTunnelDataSourceTunnelMonitorObject)
	} else {
		diags.Append(o.TunnelMonitor.As(ctx, &tunnelMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tunnelMonitor_object := types.ObjectNull(tunnelMonitor_obj.AttributeTypes())
	if obj.TunnelMonitor != nil {
		diags.Append(tunnelMonitor_obj.CopyFromPango(ctx, client, ancestors, obj.TunnelMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tunnelMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, tunnelMonitor_obj.AttributeTypes(), tunnelMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var autoKey_obj *IpsecTunnelDataSourceAutoKeyObject
	if o.AutoKey.IsNull() {
		autoKey_obj = new(IpsecTunnelDataSourceAutoKeyObject)
	} else {
		diags.Append(o.AutoKey.As(ctx, &autoKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	autoKey_object := types.ObjectNull(autoKey_obj.AttributeTypes())
	if obj.AutoKey != nil {
		diags.Append(autoKey_obj.CopyFromPango(ctx, client, ancestors, obj.AutoKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		autoKey_object, diags_tmp = types.ObjectValueFrom(ctx, autoKey_obj.AttributeTypes(), autoKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectSatellite_obj *IpsecTunnelDataSourceGlobalProtectSatelliteObject
	if o.GlobalProtectSatellite.IsNull() {
		globalProtectSatellite_obj = new(IpsecTunnelDataSourceGlobalProtectSatelliteObject)
	} else {
		diags.Append(o.GlobalProtectSatellite.As(ctx, &globalProtectSatellite_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectSatellite_object := types.ObjectNull(globalProtectSatellite_obj.AttributeTypes())
	if obj.GlobalProtectSatellite != nil {
		diags.Append(globalProtectSatellite_obj.CopyFromPango(ctx, client, ancestors, obj.GlobalProtectSatellite, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectSatellite_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectSatellite_obj.AttributeTypes(), globalProtectSatellite_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manualKey_obj *IpsecTunnelDataSourceManualKeyObject
	if o.ManualKey.IsNull() {
		manualKey_obj = new(IpsecTunnelDataSourceManualKeyObject)
	} else {
		diags.Append(o.ManualKey.As(ctx, &manualKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manualKey_object := types.ObjectNull(manualKey_obj.AttributeTypes())
	if obj.ManualKey != nil {
		diags.Append(manualKey_obj.CopyFromPango(ctx, client, ancestors, obj.ManualKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manualKey_object, diags_tmp = types.ObjectValueFrom(ctx, manualKey_obj.AttributeTypes(), manualKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var antiReplay_value types.Bool
	if obj.AntiReplay != nil {
		antiReplay_value = types.BoolValue(*obj.AntiReplay)
	}
	var antiReplayWindow_value types.String
	if obj.AntiReplayWindow != nil {
		antiReplayWindow_value = types.StringValue(*obj.AntiReplayWindow)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var copyFlowLabel_value types.Bool
	if obj.CopyFlowLabel != nil {
		copyFlowLabel_value = types.BoolValue(*obj.CopyFlowLabel)
	}
	var copyTos_value types.Bool
	if obj.CopyTos != nil {
		copyTos_value = types.BoolValue(*obj.CopyTos)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var enableGreEncapsulation_value types.Bool
	if obj.EnableGreEncapsulation != nil {
		enableGreEncapsulation_value = types.BoolValue(*obj.EnableGreEncapsulation)
	}
	var ipsecMode_value types.String
	if obj.IpsecMode != nil {
		ipsecMode_value = types.StringValue(*obj.IpsecMode)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	var tunnelInterface_value types.String
	if obj.TunnelInterface != nil {
		tunnelInterface_value = types.StringValue(*obj.TunnelInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.AntiReplay = antiReplay_value
	o.AntiReplayWindow = antiReplayWindow_value
	o.Comment = comment_value
	o.CopyFlowLabel = copyFlowLabel_value
	o.CopyTos = copyTos_value
	o.Disabled = disabled_value
	o.EnableGreEncapsulation = enableGreEncapsulation_value
	o.IpsecMode = ipsecMode_value
	o.Ipv6 = ipv6_value
	o.TunnelInterface = tunnelInterface_value
	o.TunnelMonitor = tunnelMonitor_object
	o.AutoKey = autoKey_object
	o.GlobalProtectSatellite = globalProtectSatellite_object
	o.ManualKey = manualKey_object

	return diags
}

func (o *IpsecTunnelDataSourceTunnelMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.TunnelMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var destinationIp_value types.String
	if obj.DestinationIp != nil {
		destinationIp_value = types.StringValue(*obj.DestinationIp)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var proxyId_value types.String
	if obj.ProxyId != nil {
		proxyId_value = types.StringValue(*obj.ProxyId)
	}
	var tunnelMonitorProfile_value types.String
	if obj.TunnelMonitorProfile != nil {
		tunnelMonitorProfile_value = types.StringValue(*obj.TunnelMonitorProfile)
	}
	o.DestinationIp = destinationIp_value
	o.Enable = enable_value
	o.ProxyId = proxyId_value
	o.TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_list types.List
	{
		var ikeGateway_tf_entries []IpsecTunnelDataSourceAutoKeyIkeGatewayObject
		if !o.IkeGateway.IsNull() {
			diags.Append(o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.IkeGateway {
			entry := IpsecTunnelDataSourceAutoKeyIkeGatewayObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ikeGateway_tf_entries) {
				entry = ikeGateway_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ikeGateway_tf_entries) {
				ikeGateway_tf_entries[idx] = entry
			} else {
				ikeGateway_tf_entries = append(ikeGateway_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ike_gateway")
		ikeGateway_list, list_diags = types.ListValueFrom(ctx, schemaType, ikeGateway_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyId_list types.List
	{
		var proxyId_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdObject
		if !o.ProxyId.IsNull() {
			diags.Append(o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyId {
			entry := IpsecTunnelDataSourceAutoKeyProxyIdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyId_tf_entries) {
				entry = proxyId_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyId_tf_entries) {
				proxyId_tf_entries[idx] = entry
			} else {
				proxyId_tf_entries = append(proxyId_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id")
		proxyId_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyId_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyIdV6_list types.List
	{
		var proxyIdV6_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdV6Object
		if !o.ProxyIdV6.IsNull() {
			diags.Append(o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyIdV6 {
			entry := IpsecTunnelDataSourceAutoKeyProxyIdV6Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyIdV6_tf_entries) {
				entry = proxyIdV6_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyIdV6_tf_entries) {
				proxyIdV6_tf_entries[idx] = entry
			} else {
				proxyIdV6_tf_entries = append(proxyIdV6_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id_v6")
		proxyIdV6_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyIdV6_tf_entries)
		diags.Append(list_diags...)
	}

	var ipsecCryptoProfile_value types.String
	if obj.IpsecCryptoProfile != nil {
		ipsecCryptoProfile_value = types.StringValue(*obj.IpsecCryptoProfile)
	}
	o.IkeGateway = ikeGateway_list
	o.IpsecCryptoProfile = ipsecCryptoProfile_value
	o.ProxyId = proxyId_list
	o.ProxyIdV6 = proxyIdV6_list

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyIkeGateway, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var protocol_obj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Local = local_value
	o.Remote = remote_value
	o.Protocol = protocol_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var any_obj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject
	if o.Any.IsNull() {
		any_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject)
	} else {
		diags.Append(o.Any.As(ctx, &any_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	any_object := types.ObjectNull(any_obj.AttributeTypes())
	if obj.Any != nil {
		diags.Append(any_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Any, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		any_object, diags_tmp = types.ObjectValueFrom(ctx, any_obj.AttributeTypes(), any_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tcp_obj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject
	if o.Tcp.IsNull() {
		tcp_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject)
	} else {
		diags.Append(o.Tcp.As(ctx, &tcp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tcp_object := types.ObjectNull(tcp_obj.AttributeTypes())
	if obj.Tcp != nil {
		diags.Append(tcp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Tcp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tcp_object, diags_tmp = types.ObjectValueFrom(ctx, tcp_obj.AttributeTypes(), tcp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var udp_obj *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject
	if o.Udp.IsNull() {
		udp_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject)
	} else {
		diags.Append(o.Udp.As(ctx, &udp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	udp_object := types.ObjectNull(udp_obj.AttributeTypes())
	if obj.Udp != nil {
		diags.Append(udp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Udp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		udp_object, diags_tmp = types.ObjectValueFrom(ctx, udp_obj.AttributeTypes(), udp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var protocol_obj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Local = local_value
	o.Remote = remote_value
	o.Protocol = protocol_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var any_obj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject
	if o.Any.IsNull() {
		any_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject)
	} else {
		diags.Append(o.Any.As(ctx, &any_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	any_object := types.ObjectNull(any_obj.AttributeTypes())
	if obj.Any != nil {
		diags.Append(any_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Any, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		any_object, diags_tmp = types.ObjectValueFrom(ctx, any_obj.AttributeTypes(), any_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tcp_obj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject
	if o.Tcp.IsNull() {
		tcp_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject)
	} else {
		diags.Append(o.Tcp.As(ctx, &tcp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tcp_object := types.ObjectNull(tcp_obj.AttributeTypes())
	if obj.Tcp != nil {
		diags.Append(tcp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Tcp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tcp_object, diags_tmp = types.ObjectValueFrom(ctx, tcp_obj.AttributeTypes(), tcp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var udp_obj *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject
	if o.Udp.IsNull() {
		udp_obj = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject)
	} else {
		diags.Append(o.Udp.As(ctx, &udp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	udp_object := types.ObjectNull(udp_obj.AttributeTypes())
	if obj.Udp != nil {
		diags.Append(udp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Udp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		udp_object, diags_tmp = types.ObjectValueFrom(ctx, udp_obj.AttributeTypes(), udp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatellite, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var publishRoutes_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PublishRoutes.IsNull() || len(obj.PublishRoutes) > 0 {
			entries = obj.PublishRoutes
		}

		publishRoutes_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var externalCa_obj *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject
	if o.ExternalCa.IsNull() {
		externalCa_obj = new(IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject)
	} else {
		diags.Append(o.ExternalCa.As(ctx, &externalCa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	externalCa_object := types.ObjectNull(externalCa_obj.AttributeTypes())
	if obj.ExternalCa != nil {
		diags.Append(externalCa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExternalCa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		externalCa_object, diags_tmp = types.ObjectValueFrom(ctx, externalCa_obj.AttributeTypes(), externalCa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var publishConnectedRoutes_obj *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject
	if o.PublishConnectedRoutes.IsNull() {
		publishConnectedRoutes_obj = new(IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject)
	} else {
		diags.Append(o.PublishConnectedRoutes.As(ctx, &publishConnectedRoutes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	publishConnectedRoutes_object := types.ObjectNull(publishConnectedRoutes_obj.AttributeTypes())
	if obj.PublishConnectedRoutes != nil {
		diags.Append(publishConnectedRoutes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PublishConnectedRoutes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		publishConnectedRoutes_object, diags_tmp = types.ObjectValueFrom(ctx, publishConnectedRoutes_obj.AttributeTypes(), publishConnectedRoutes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	var portalAddress_value types.String
	if obj.PortalAddress != nil {
		portalAddress_value = types.StringValue(*obj.PortalAddress)
	}
	o.ExternalCa = externalCa_object
	o.Ipv6Preferred = ipv6Preferred_value
	o.LocalAddress = localAddress_object
	o.PortalAddress = portalAddress_value
	o.PublishConnectedRoutes = publishConnectedRoutes_object
	o.PublishRoutes = publishRoutes_list

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteExternalCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var localCertificate_value types.String
	if obj.LocalCertificate != nil {
		localCertificate_value = types.StringValue(*obj.LocalCertificate)
	}
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatellitePublishConnectedRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localAddress_obj *IpsecTunnelDataSourceManualKeyLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IpsecTunnelDataSourceManualKeyLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *IpsecTunnelDataSourceManualKeyPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(IpsecTunnelDataSourceManualKeyPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ah_obj *IpsecTunnelDataSourceManualKeyAhObject
	if o.Ah.IsNull() {
		ah_obj = new(IpsecTunnelDataSourceManualKeyAhObject)
	} else {
		diags.Append(o.Ah.As(ctx, &ah_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ah_object := types.ObjectNull(ah_obj.AttributeTypes())
	if obj.Ah != nil {
		diags.Append(ah_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ah, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ah_object, diags_tmp = types.ObjectValueFrom(ctx, ah_obj.AttributeTypes(), ah_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var esp_obj *IpsecTunnelDataSourceManualKeyEspObject
	if o.Esp.IsNull() {
		esp_obj = new(IpsecTunnelDataSourceManualKeyEspObject)
	} else {
		diags.Append(o.Esp.As(ctx, &esp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	esp_object := types.ObjectNull(esp_obj.AttributeTypes())
	if obj.Esp != nil {
		diags.Append(esp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Esp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		esp_object, diags_tmp = types.ObjectValueFrom(ctx, esp_obj.AttributeTypes(), esp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localSpi_value types.String
	if obj.LocalSpi != nil {
		localSpi_value = types.StringValue(*obj.LocalSpi)
	}
	var remoteSpi_value types.String
	if obj.RemoteSpi != nil {
		remoteSpi_value = types.StringValue(*obj.RemoteSpi)
	}
	o.LocalAddress = localAddress_object
	o.LocalSpi = localSpi_value
	o.PeerAddress = peerAddress_object
	o.RemoteSpi = remoteSpi_value
	o.Ah = ah_object
	o.Esp = esp_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *IpsecTunnelDataSourceManualKeyAhMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(IpsecTunnelDataSourceManualKeyAhMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *IpsecTunnelDataSourceManualKeyAhSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(IpsecTunnelDataSourceManualKeyAhSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *IpsecTunnelDataSourceManualKeyAhSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(IpsecTunnelDataSourceManualKeyAhSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *IpsecTunnelDataSourceManualKeyAhSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(IpsecTunnelDataSourceManualKeyAhSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *IpsecTunnelDataSourceManualKeyAhSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(IpsecTunnelDataSourceManualKeyAhSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var encryption_obj *IpsecTunnelDataSourceManualKeyEspEncryptionObject
	if o.Encryption.IsNull() {
		encryption_obj = new(IpsecTunnelDataSourceManualKeyEspEncryptionObject)
	} else {
		diags.Append(o.Encryption.As(ctx, &encryption_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	encryption_object := types.ObjectNull(encryption_obj.AttributeTypes())
	if obj.Encryption != nil {
		diags.Append(encryption_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Encryption, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		encryption_object, diags_tmp = types.ObjectValueFrom(ctx, encryption_obj.AttributeTypes(), encryption_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject
	if o.None.IsNull() {
		none_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.None = none_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func IpsecTunnelDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": IpsecTunnelDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"anti_replay": dsschema.BoolAttribute{
				Description: "Enable Anti-Replay check on this tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anti_replay_window": dsschema.StringAttribute{
				Description: "64,128,256,512,1024,2048,4096",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_flow_label": dsschema.BoolAttribute{
				Description: "Copy IPv6 flow label for 6in6 tunnel from inner packet to IPSec packet (not recommended)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_tos": dsschema.BoolAttribute{
				Description: "Copy IP TOS bits from inner packet to IPSec packet (not recommended)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the IPSec tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_gre_encapsulation": dsschema.BoolAttribute{
				Description: "allow GRE over IPSec",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipsec_mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.BoolAttribute{
				Description: "use IPv6 for the IPSec tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_interface": dsschema.StringAttribute{
				Description: "to apply IPSec VPN tunnels to tunnel interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor": IpsecTunnelDataSourceTunnelMonitorSchema(),

			"auto_key": IpsecTunnelDataSourceAutoKeySchema(),

			"global_protect_satellite": IpsecTunnelDataSourceGlobalProtectSatelliteSchema(),

			"manual_key": IpsecTunnelDataSourceManualKeySchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceModel) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceTunnelMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"destination_ip": dsschema.StringAttribute{
				Description: "Destination IP to send ICMP probe",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable tunnel monitoring on this tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": dsschema.StringAttribute{
				Description: "Which proxy-id (or proxy-id-v6) the monitoring traffic will use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor_profile": dsschema.StringAttribute{
				Description: "monitoring action",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceTunnelMonitorObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceTunnelMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ike_gateway": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyIkeGatewaySchema(),
			},

			"ipsec_crypto_profile": dsschema.StringAttribute{
				Description: "IPSec crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyProxyIdSchema(),
			},

			"proxy_id_v6": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyProxyIdV6Schema(),
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyIkeGatewaySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyIkeGatewaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"number": dsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"any": IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema(),

			"tcp": IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema(),

			"udp": IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"number": dsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"any": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema(),

			"tcp": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema(),

			"udp": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"external_ca": IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema(),

			"ipv6_preferred": dsschema.BoolAttribute{
				Description: "Prefer to register to portal in ipv6. Only applicable to fqdn portal-address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema(),

			"portal_address": dsschema.StringAttribute{
				Description: "GlobalProtect portal address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"publish_connected_routes": IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema(),

			"publish_routes": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating GlobalProtect gateway certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": dsschema.StringAttribute{
				Description: "GlobalProtect satellite certificate file name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface to communicate with Portal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema(),

			"ip": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Floating IPv6 address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "specify exact local IPv6 address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable publishing of connected and static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_address": IpsecTunnelDataSourceManualKeyLocalAddressSchema(),

			"local_spi": dsschema.StringAttribute{
				Description: "Outbound SPI, hex format xxxxxxxx. range 00001000 to 1FFFFFFF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_address": IpsecTunnelDataSourceManualKeyPeerAddressSchema(),

			"remote_spi": dsschema.StringAttribute{
				Description: "Inbound SPI, hex format xxxxxxxx.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ah": IpsecTunnelDataSourceManualKeyAhSchema(),

			"esp": IpsecTunnelDataSourceManualKeyEspSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface to termate tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "Tunnel peer IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"md5": IpsecTunnelDataSourceManualKeyAhMd5Schema(),

			"sha1": IpsecTunnelDataSourceManualKeyAhSha1Schema(),

			"sha256": IpsecTunnelDataSourceManualKeyAhSha256Schema(),

			"sha384": IpsecTunnelDataSourceManualKeyAhSha384Schema(),

			"sha512": IpsecTunnelDataSourceManualKeyAhSha512Schema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"authentication": IpsecTunnelDataSourceManualKeyEspAuthenticationSchema(),

			"encryption": IpsecTunnelDataSourceManualKeyEspEncryptionSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"md5": IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema(),

			"none": IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema(),

			"sha1": IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema(),

			"sha256": IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema(),

			"sha384": IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema(),

			"sha512": IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspEncryptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: des: 2, 3des: 6, aes-128-cbc: 4, aes-192-cbc: 6, aes-256-cbc: 8",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceLocationSchema() rsschema.Attribute {
	return IpsecTunnelLocationSchema()
}

// Metadata returns the data source type name.
func (d *IpsecTunnelDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ipsec_tunnel"
}

// Schema defines the schema for this data source.
func (d *IpsecTunnelDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = IpsecTunnelDataSourceSchema()
}

// Configure prepares the struct.
func (d *IpsecTunnelDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := ipsec.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service](d.client, ipsec.NewService(d.client), batchSize, specifier, ipsec.SpecMatches)
}
func (o *IpsecTunnelDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state IpsecTunnelDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ipsec.Location

	{
		var terraformLocation IpsecTunnelLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ipsec.TemplateLocation{}
			var innerLocation IpsecTunnelTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ipsec.TemplateStackLocation{}
			var innerLocation IpsecTunnelTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &IpsecTunnelResource{}
	_ resource.ResourceWithConfigure   = &IpsecTunnelResource{}
	_ resource.ResourceWithImportState = &IpsecTunnelResource{}
)

func NewIpsecTunnelResource() resource.Resource {
	if _, found := resourceFuncMap["panos_ipsec_tunnel"]; !found {
		resourceFuncMap["panos_ipsec_tunnel"] = resourceFuncs{
			CreateImportId: IpsecTunnelImportStateCreator,
		}
	}
	return &IpsecTunnelResource{}
}

type IpsecTunnelResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service]
}

func IpsecTunnelResourceLocationSchema() rsschema.Attribute {
	return IpsecTunnelLocationSchema()
}

type IpsecTunnelResourceModel struct {
	Location               types.Object `tfsdk:"location"`
	Name                   types.String `tfsdk:"name"`
	AntiReplay             types.Bool   `tfsdk:"anti_replay"`
	AntiReplayWindow       types.String `tfsdk:"anti_replay_window"`
	Comment                types.String `tfsdk:"comment"`
	CopyFlowLabel          types.Bool   `tfsdk:"copy_flow_label"`
	CopyTos                types.Bool   `tfsdk:"copy_tos"`
	Disabled               types.Bool   `tfsdk:"disabled"`
	EnableGreEncapsulation types.Bool   `tfsdk:"enable_gre_encapsulation"`
	IpsecMode              types.String `tfsdk:"ipsec_mode"`
	Ipv6                   types.Bool   `tfsdk:"ipv6"`
	TunnelInterface        types.String `tfsdk:"tunnel_interface"`
	TunnelMonitor          types.Object `tfsdk:"tunnel_monitor"`
	AutoKey                types.Object `tfsdk:"auto_key"`
	GlobalProtectSatellite types.Object `tfsdk:"global_protect_satellite"`
	ManualKey              types.Object `tfsdk:"manual_key"`
}
type IpsecTunnelResourceTunnelMonitorObject struct {
	DestinationIp        types.String `tfsdk:"destination_ip"`
	Enable               types.Bool   `tfsdk:"enable"`
	ProxyId              types.String `tfsdk:"proxy_id"`
	TunnelMonitorProfile types.String `tfsdk:"tunnel_monitor_profile"`
}
type IpsecTunnelResourceAutoKeyObject struct {
	IkeGateway         types.List   `tfsdk:"ike_gateway"`
	IpsecCryptoProfile types.String `tfsdk:"ipsec_crypto_profile"`
	ProxyId            types.List   `tfsdk:"proxy_id"`
	ProxyIdV6          types.List   `tfsdk:"proxy_id_v6"`
}
type IpsecTunnelResourceAutoKeyIkeGatewayObject struct {
	Name types.String `tfsdk:"name"`
}
type IpsecTunnelResourceAutoKeyProxyIdObject struct {
	Name     types.String `tfsdk:"name"`
	Local    types.String `tfsdk:"local"`
	Remote   types.String `tfsdk:"remote"`
	Protocol types.Object `tfsdk:"protocol"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolObject struct {
	Number types.Int64  `tfsdk:"number"`
	Any    types.Object `tfsdk:"any"`
	Tcp    types.Object `tfsdk:"tcp"`
	Udp    types.Object `tfsdk:"udp"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject struct {
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6Object struct {
	Name     types.String `tfsdk:"name"`
	Local    types.String `tfsdk:"local"`
	Remote   types.String `tfsdk:"remote"`
	Protocol types.Object `tfsdk:"protocol"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject struct {
	Number types.Int64  `tfsdk:"number"`
	Any    types.Object `tfsdk:"any"`
	Tcp    types.Object `tfsdk:"tcp"`
	Udp    types.Object `tfsdk:"udp"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject struct {
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceGlobalProtectSatelliteObject struct {
	ExternalCa             types.Object `tfsdk:"external_ca"`
	Ipv6Preferred          types.Bool   `tfsdk:"ipv6_preferred"`
	LocalAddress           types.Object `tfsdk:"local_address"`
	PortalAddress          types.String `tfsdk:"portal_address"`
	PublishConnectedRoutes types.Object `tfsdk:"publish_connected_routes"`
	PublishRoutes          types.List   `tfsdk:"publish_routes"`
}
type IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	LocalCertificate   types.String `tfsdk:"local_certificate"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.Object `tfsdk:"floating_ip"`
	Ip         types.Object `tfsdk:"ip"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IpsecTunnelResourceManualKeyObject struct {
	LocalAddress types.Object `tfsdk:"local_address"`
	LocalSpi     types.String `tfsdk:"local_spi"`
	PeerAddress  types.Object `tfsdk:"peer_address"`
	RemoteSpi    types.String `tfsdk:"remote_spi"`
	Ah           types.Object `tfsdk:"ah"`
	Esp          types.Object `tfsdk:"esp"`
}
type IpsecTunnelResourceManualKeyLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IpsecTunnelResourceManualKeyPeerAddressObject struct {
	Ip types.String `tfsdk:"ip"`
}
type IpsecTunnelResourceManualKeyAhObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type IpsecTunnelResourceManualKeyAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspObject struct {
	Authentication types.Object `tfsdk:"authentication"`
	Encryption     types.Object `tfsdk:"encryption"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationObject struct {
	Md5    types.Object `tfsdk:"md5"`
	None   types.Object `tfsdk:"none"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationNoneObject struct {
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}

func (o *IpsecTunnelResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func IpsecTunnelResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": IpsecTunnelResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"anti_replay": rsschema.BoolAttribute{
				Description: "Enable Anti-Replay check on this tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anti_replay_window": rsschema.StringAttribute{
				Description: "64,128,256,512,1024,2048,4096",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("1024"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"64",
						"128",
						"256",
						"512",
						"1024",
						"2048",
						"4096",
					}...),
				},
			},

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_flow_label": rsschema.BoolAttribute{
				Description: "Copy IPv6 flow label for 6in6 tunnel from inner packet to IPSec packet (not recommended)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_tos": rsschema.BoolAttribute{
				Description: "Copy IP TOS bits from inner packet to IPSec packet (not recommended)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the IPSec tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_gre_encapsulation": rsschema.BoolAttribute{
				Description: "allow GRE over IPSec",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipsec_mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("tunnel"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"tunnel",
						"transport",
					}...),
				},
			},

			"ipv6": rsschema.BoolAttribute{
				Description: "use IPv6 for the IPSec tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_interface": rsschema.StringAttribute{
				Description: "to apply IPSec VPN tunnels to tunnel interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor": IpsecTunnelResourceTunnelMonitorSchema(),

			"auto_key": IpsecTunnelResourceAutoKeySchema(),

			"global_protect_satellite": IpsecTunnelResourceGlobalProtectSatelliteSchema(),

			"manual_key": IpsecTunnelResourceManualKeySchema(),
		},
	}
}

func (o *IpsecTunnelResourceModel) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceTunnelMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"destination_ip": rsschema.StringAttribute{
				Description: "Destination IP to send ICMP probe",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable tunnel monitoring on this tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": rsschema.StringAttribute{
				Description: "Which proxy-id (or proxy-id-v6) the monitoring traffic will use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor_profile": rsschema.StringAttribute{
				Description: "monitoring action",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceTunnelMonitorObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceTunnelMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("auto_key"),
				path.MatchRelative().AtParent().AtName("global_protect_satellite"),
				path.MatchRelative().AtParent().AtName("manual_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ike_gateway": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyIkeGatewaySchema(),
			},

			"ipsec_crypto_profile": rsschema.StringAttribute{
				Description: "IPSec crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},

			"proxy_id": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyProxyIdSchema(),
			},

			"proxy_id_v6": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyProxyIdV6Schema(),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyIkeGatewaySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyIkeGatewaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelResourceAutoKeyProxyIdProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"number": rsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("number"),
						path.MatchRelative().AtParent().AtName("any"),
						path.MatchRelative().AtParent().AtName("tcp"),
						path.MatchRelative().AtParent().AtName("udp"),
					}...),
				},
			},

			"any": IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema(),

			"tcp": IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema(),

			"udp": IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"number": rsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("number"),
						path.MatchRelative().AtParent().AtName("any"),
						path.MatchRelative().AtParent().AtName("tcp"),
						path.MatchRelative().AtParent().AtName("udp"),
					}...),
				},
			},

			"any": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema(),

			"tcp": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema(),

			"udp": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"external_ca": IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema(),

			"ipv6_preferred": rsschema.BoolAttribute{
				Description: "Prefer to register to portal in ipv6. Only applicable to fqdn portal-address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema(),

			"portal_address": rsschema.StringAttribute{
				Description: "GlobalProtect portal address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"publish_connected_routes": IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema(),

			"publish_routes": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating GlobalProtect gateway certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": rsschema.StringAttribute{
				Description: "GlobalProtect satellite certificate file name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface to communicate with Portal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema(),

			"ip": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema(),
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Floating IPv6 address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "specify exact local IPv6 address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable publishing of connected and static routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_address": IpsecTunnelResourceManualKeyLocalAddressSchema(),

			"local_spi": rsschema.StringAttribute{
				Description: "Outbound SPI, hex format xxxxxxxx. range 00001000 to 1FFFFFFF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_address": IpsecTunnelResourceManualKeyPeerAddressSchema(),

			"remote_spi": rsschema.StringAttribute{
				Description: "Inbound SPI, hex format xxxxxxxx.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ah": IpsecTunnelResourceManualKeyAhSchema(),

			"esp": IpsecTunnelResourceManualKeyEspSchema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface to termate tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "Tunnel peer IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"md5": IpsecTunnelResourceManualKeyAhMd5Schema(),

			"sha1": IpsecTunnelResourceManualKeyAhSha1Schema(),

			"sha256": IpsecTunnelResourceManualKeyAhSha256Schema(),

			"sha384": IpsecTunnelResourceManualKeyAhSha384Schema(),

			"sha512": IpsecTunnelResourceManualKeyAhSha512Schema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"authentication": IpsecTunnelResourceManualKeyEspAuthenticationSchema(),

			"encryption": IpsecTunnelResourceManualKeyEspEncryptionSchema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"md5": IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema(),

			"none": IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema(),

			"sha1": IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema(),

			"sha256": IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema(),

			"sha384": IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema(),

			"sha512": IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspEncryptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("aes-128-cbc"),
			},

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: des: 2, 3des: 6, aes-128-cbc: 4, aes-192-cbc: 6, aes-256-cbc: 8",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *IpsecTunnelResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ipsec_tunnel"
}

func (o *IpsecTunnelResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = IpsecTunnelResourceSchema()
}

// </ResourceSchema>

func (o *IpsecTunnelResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := ipsec.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service](o.client, ipsec.NewService(o.client), batchSize, specifier, ipsec.SpecMatches)
}

func (o *IpsecTunnelResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj IpsecTunnelLocation

	var tunnelMonitorObj *IpsecTunnelResourceTunnelMonitorObject

	var autoKeyObj *IpsecTunnelResourceAutoKeyObject

	var globalProtectSatelliteObj *IpsecTunnelResourceGlobalProtectSatelliteObject

	var manualKeyObj *IpsecTunnelResourceManualKeyObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":                     types.StringType,
		"anti_replay":              types.BoolType,
		"anti_replay_window":       types.StringType,
		"comment":                  types.StringType,
		"copy_flow_label":          types.BoolType,
		"copy_tos":                 types.BoolType,
		"disabled":                 types.BoolType,
		"enable_gre_encapsulation": types.BoolType,
		"ipsec_mode":               types.StringType,
		"ipv6":                     types.BoolType,
		"tunnel_interface":         types.StringType,
		"tunnel_monitor": types.ObjectType{
			AttrTypes: tunnelMonitorObj.AttributeTypes(),
		},
		"auto_key": types.ObjectType{
			AttrTypes: autoKeyObj.AttributeTypes(),
		},
		"global_protect_satellite": types.ObjectType{
			AttrTypes: globalProtectSatelliteObj.AttributeTypes(),
		},
		"manual_key": types.ObjectType{
			AttrTypes: manualKeyObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceModel) AncestorName() string {
	return ""
}

func (o IpsecTunnelResourceModel) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceTunnelMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"destination_ip":         types.StringType,
		"enable":                 types.BoolType,
		"proxy_id":               types.StringType,
		"tunnel_monitor_profile": types.StringType,
	}
}

func (o IpsecTunnelResourceTunnelMonitorObject) AncestorName() string {
	return "tunnel-monitor"
}

func (o IpsecTunnelResourceTunnelMonitorObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyObject) AttributeTypes() map[string]attr.Type {

	var ikeGatewayObj *IpsecTunnelResourceAutoKeyIkeGatewayObject

	var proxyIdObj *IpsecTunnelResourceAutoKeyProxyIdObject

	var proxyIdV6Obj *IpsecTunnelResourceAutoKeyProxyIdV6Object
	return map[string]attr.Type{
		"ike_gateway": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ikeGatewayObj.AttributeTypes(),
			},
		},
		"ipsec_crypto_profile": types.StringType,
		"proxy_id": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyIdObj.AttributeTypes(),
			},
		},
		"proxy_id_v6": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: proxyIdV6Obj.AttributeTypes(),
			},
		},
	}
}

func (o IpsecTunnelResourceAutoKeyObject) AncestorName() string {
	return "auto-key"
}

func (o IpsecTunnelResourceAutoKeyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o IpsecTunnelResourceAutoKeyIkeGatewayObject) AncestorName() string {
	return "ike-gateway"
}

func (o IpsecTunnelResourceAutoKeyIkeGatewayObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelResourceAutoKeyProxyIdObject) AttributeTypes() map[string]attr.Type {

	var protocolObj *IpsecTunnelResourceAutoKeyProxyIdProtocolObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"local":  types.StringType,
		"remote": types.StringType,
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdObject) AncestorName() string {
	return "proxy-id"
}

func (o IpsecTunnelResourceAutoKeyProxyIdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) AttributeTypes() map[string]attr.Type {

	var anyObj *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject

	var tcpObj *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject

	var udpObj *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject
	return map[string]attr.Type{
		"number": types.Int64Type,
		"any": types.ObjectType{
			AttrTypes: anyObj.AttributeTypes(),
		},
		"tcp": types.ObjectType{
			AttrTypes: tcpObj.AttributeTypes(),
		},
		"udp": types.ObjectType{
			AttrTypes: udpObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) AncestorName() string {
	return "any"
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) AncestorName() string {
	return "tcp"
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) AncestorName() string {
	return "udp"
}

func (o IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) AttributeTypes() map[string]attr.Type {

	var protocolObj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"local":  types.StringType,
		"remote": types.StringType,
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6Object) AncestorName() string {
	return "proxy-id-v6"
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) AttributeTypes() map[string]attr.Type {

	var anyObj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject

	var tcpObj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject

	var udpObj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject
	return map[string]attr.Type{
		"number": types.Int64Type,
		"any": types.ObjectType{
			AttrTypes: anyObj.AttributeTypes(),
		},
		"tcp": types.ObjectType{
			AttrTypes: tcpObj.AttributeTypes(),
		},
		"udp": types.ObjectType{
			AttrTypes: udpObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) AncestorName() string {
	return "protocol"
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) AncestorName() string {
	return "any"
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) AncestorName() string {
	return "tcp"
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port":  types.Int64Type,
		"remote_port": types.Int64Type,
	}
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) AncestorName() string {
	return "udp"
}

func (o IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) AttributeTypes() map[string]attr.Type {

	var externalCaObj *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject

	var localAddressObj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject

	var publishConnectedRoutesObj *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject

	return map[string]attr.Type{
		"external_ca": types.ObjectType{
			AttrTypes: externalCaObj.AttributeTypes(),
		},
		"ipv6_preferred": types.BoolType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"portal_address": types.StringType,
		"publish_connected_routes": types.ObjectType{
			AttrTypes: publishConnectedRoutesObj.AttributeTypes(),
		},
		"publish_routes": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o IpsecTunnelResourceGlobalProtectSatelliteObject) AncestorName() string {
	return "global-protect-satellite"
}

func (o IpsecTunnelResourceGlobalProtectSatelliteObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"certificate_profile": types.StringType,
		"local_certificate":   types.StringType,
	}
}

func (o IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) AncestorName() string {
	return "external-ca"
}

func (o IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) AttributeTypes() map[string]attr.Type {

	var floatingIpObj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject

	var ipObj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject
	return map[string]attr.Type{
		"interface": types.StringType,
		"floating_ip": types.ObjectType{
			AttrTypes: floatingIpObj.AttributeTypes(),
		},
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) AncestorName() string {
	return "floating-ip"
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) AncestorName() string {
	return "ip"
}

func (o IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) AncestorName() string {
	return "publish-connected-routes"
}

func (o IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *IpsecTunnelResourceManualKeyLocalAddressObject

	var peerAddressObj *IpsecTunnelResourceManualKeyPeerAddressObject

	var ahObj *IpsecTunnelResourceManualKeyAhObject

	var espObj *IpsecTunnelResourceManualKeyEspObject
	return map[string]attr.Type{
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"local_spi": types.StringType,
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"remote_spi": types.StringType,
		"ah": types.ObjectType{
			AttrTypes: ahObj.AttributeTypes(),
		},
		"esp": types.ObjectType{
			AttrTypes: espObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceManualKeyObject) AncestorName() string {
	return "manual-key"
}

func (o IpsecTunnelResourceManualKeyObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":   types.StringType,
		"floating_ip": types.StringType,
		"ip":          types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o IpsecTunnelResourceManualKeyLocalAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o IpsecTunnelResourceManualKeyPeerAddressObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *IpsecTunnelResourceManualKeyAhMd5Object

	var sha1Obj *IpsecTunnelResourceManualKeyAhSha1Object

	var sha256Obj *IpsecTunnelResourceManualKeyAhSha256Object

	var sha384Obj *IpsecTunnelResourceManualKeyAhSha384Object

	var sha512Obj *IpsecTunnelResourceManualKeyAhSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceManualKeyAhObject) AncestorName() string {
	return "ah"
}

func (o IpsecTunnelResourceManualKeyAhObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyAhMd5Object) AncestorName() string {
	return "md5"
}

func (o IpsecTunnelResourceManualKeyAhMd5Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyAhSha1Object) AncestorName() string {
	return "sha1"
}

func (o IpsecTunnelResourceManualKeyAhSha1Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyAhSha256Object) AncestorName() string {
	return "sha256"
}

func (o IpsecTunnelResourceManualKeyAhSha256Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyAhSha384Object) AncestorName() string {
	return "sha384"
}

func (o IpsecTunnelResourceManualKeyAhSha384Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyAhSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyAhSha512Object) AncestorName() string {
	return "sha512"
}

func (o IpsecTunnelResourceManualKeyAhSha512Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspObject) AttributeTypes() map[string]attr.Type {

	var authenticationObj *IpsecTunnelResourceManualKeyEspAuthenticationObject

	var encryptionObj *IpsecTunnelResourceManualKeyEspEncryptionObject
	return map[string]attr.Type{
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"encryption": types.ObjectType{
			AttrTypes: encryptionObj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceManualKeyEspObject) AncestorName() string {
	return "esp"
}

func (o IpsecTunnelResourceManualKeyEspObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object

	var noneObj *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject

	var sha1Obj *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object

	var sha256Obj *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object

	var sha384Obj *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object

	var sha512Obj *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) AncestorName() string {
	return "md5"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) AncestorName() string {
	return "none"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) AncestorName() string {
	return "sha1"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) AncestorName() string {
	return "sha256"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) AncestorName() string {
	return "sha384"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) AncestorName() string {
	return "sha512"
}

func (o IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) EntryName() *string {
	return nil
}
func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"algorithm": types.StringType,
		"key":       types.StringType,
	}
}

func (o IpsecTunnelResourceManualKeyEspEncryptionObject) AncestorName() string {
	return "encryption"
}

func (o IpsecTunnelResourceManualKeyEspEncryptionObject) EntryName() *string {
	return nil
}

func (o *IpsecTunnelResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	antiReplay_value := o.AntiReplay.ValueBoolPointer()
	antiReplayWindow_value := o.AntiReplayWindow.ValueStringPointer()
	comment_value := o.Comment.ValueStringPointer()
	copyFlowLabel_value := o.CopyFlowLabel.ValueBoolPointer()
	copyTos_value := o.CopyTos.ValueBoolPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	enableGreEncapsulation_value := o.EnableGreEncapsulation.ValueBoolPointer()
	ipsecMode_value := o.IpsecMode.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	tunnelInterface_value := o.TunnelInterface.ValueStringPointer()
	var tunnelMonitor_entry *ipsec.TunnelMonitor
	if !o.TunnelMonitor.IsUnknown() && !o.TunnelMonitor.IsNull() {
		if *obj != nil && (*obj).TunnelMonitor != nil {
			tunnelMonitor_entry = (*obj).TunnelMonitor
		} else {
			tunnelMonitor_entry = new(ipsec.TunnelMonitor)
		}
		var object *IpsecTunnelResourceTunnelMonitorObject
		diags.Append(o.TunnelMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &tunnelMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_entry *ipsec.AutoKey
	if !o.AutoKey.IsUnknown() && !o.AutoKey.IsNull() {
		if *obj != nil && (*obj).AutoKey != nil {
			autoKey_entry = (*obj).AutoKey
		} else {
			autoKey_entry = new(ipsec.AutoKey)
		}
		var object *IpsecTunnelResourceAutoKeyObject
		diags.Append(o.AutoKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &autoKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectSatellite_entry *ipsec.GlobalProtectSatellite
	if !o.GlobalProtectSatellite.IsUnknown() && !o.GlobalProtectSatellite.IsNull() {
		if *obj != nil && (*obj).GlobalProtectSatellite != nil {
			globalProtectSatellite_entry = (*obj).GlobalProtectSatellite
		} else {
			globalProtectSatellite_entry = new(ipsec.GlobalProtectSatellite)
		}
		var object *IpsecTunnelResourceGlobalProtectSatelliteObject
		diags.Append(o.GlobalProtectSatellite.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &globalProtectSatellite_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_entry *ipsec.ManualKey
	if !o.ManualKey.IsUnknown() && !o.ManualKey.IsNull() {
		if *obj != nil && (*obj).ManualKey != nil {
			manualKey_entry = (*obj).ManualKey
		} else {
			manualKey_entry = new(ipsec.ManualKey)
		}
		var object *IpsecTunnelResourceManualKeyObject
		diags.Append(o.ManualKey.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &manualKey_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AntiReplay = antiReplay_value
	(*obj).AntiReplayWindow = antiReplayWindow_value
	(*obj).Comment = comment_value
	(*obj).CopyFlowLabel = copyFlowLabel_value
	(*obj).CopyTos = copyTos_value
	(*obj).Disabled = disabled_value
	(*obj).EnableGreEncapsulation = enableGreEncapsulation_value
	(*obj).IpsecMode = ipsecMode_value
	(*obj).Ipv6 = ipv6_value
	(*obj).TunnelInterface = tunnelInterface_value
	(*obj).TunnelMonitor = tunnelMonitor_entry
	(*obj).AutoKey = autoKey_entry
	(*obj).GlobalProtectSatellite = globalProtectSatellite_entry
	(*obj).ManualKey = manualKey_entry

	return diags
}
func (o *IpsecTunnelResourceTunnelMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.TunnelMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destinationIp_value := o.DestinationIp.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	proxyId_value := o.ProxyId.ValueStringPointer()
	tunnelMonitorProfile_value := o.TunnelMonitorProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.TunnelMonitor)
	}
	(*obj).DestinationIp = destinationIp_value
	(*obj).Enable = enable_value
	(*obj).ProxyId = proxyId_value
	(*obj).TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_tf_entries []IpsecTunnelResourceAutoKeyIkeGatewayObject
	var ikeGateway_pango_entries []ipsec.AutoKeyIkeGateway
	{
		d := o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ikeGateway_tf_entries {
			var entry *ipsec.AutoKeyIkeGateway
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ikeGateway_pango_entries = append(ikeGateway_pango_entries, *entry)
		}
	}
	ipsecCryptoProfile_value := o.IpsecCryptoProfile.ValueStringPointer()
	var proxyId_tf_entries []IpsecTunnelResourceAutoKeyProxyIdObject
	var proxyId_pango_entries []ipsec.AutoKeyProxyId
	{
		d := o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyId_tf_entries {
			var entry *ipsec.AutoKeyProxyId
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyId_pango_entries = append(proxyId_pango_entries, *entry)
		}
	}
	var proxyIdV6_tf_entries []IpsecTunnelResourceAutoKeyProxyIdV6Object
	var proxyIdV6_pango_entries []ipsec.AutoKeyProxyIdV6
	{
		d := o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyIdV6_tf_entries {
			var entry *ipsec.AutoKeyProxyIdV6
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			proxyIdV6_pango_entries = append(proxyIdV6_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKey)
	}
	(*obj).IkeGateway = ikeGateway_pango_entries
	(*obj).IpsecCryptoProfile = ipsecCryptoProfile_value
	(*obj).ProxyId = proxyId_pango_entries
	(*obj).ProxyIdV6 = proxyIdV6_pango_entries

	return diags
}
func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyIkeGateway, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyIkeGateway)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdProtocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdProtocol)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyId)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdProtocolAny
	if !o.Any.IsUnknown() && !o.Any.IsNull() {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdProtocolAny)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject
		diags.Append(o.Any.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &any_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_entry *ipsec.AutoKeyProxyIdProtocolTcp
	if !o.Tcp.IsUnknown() && !o.Tcp.IsNull() {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdProtocolTcp)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject
		diags.Append(o.Tcp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &tcp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdProtocolUdp
	if !o.Udp.IsUnknown() && !o.Udp.IsNull() {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdProtocolUdp)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject
		diags.Append(o.Udp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &udp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocol)
	}
	(*obj).Number = number_value
	(*obj).Any = any_entry
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdV6Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdV6Protocol)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdV6ProtocolAny
	if !o.Any.IsUnknown() && !o.Any.IsNull() {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject
		diags.Append(o.Any.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &any_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_entry *ipsec.AutoKeyProxyIdV6ProtocolTcp
	if !o.Tcp.IsUnknown() && !o.Tcp.IsNull() {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject
		diags.Append(o.Tcp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &tcp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdV6ProtocolUdp
	if !o.Udp.IsUnknown() && !o.Udp.IsNull() {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
		}
		var object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject
		diags.Append(o.Udp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &udp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6Protocol)
	}
	(*obj).Number = number_value
	(*obj).Any = any_entry
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.AutoKeyProxyIdV6ProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatellite, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalCa_entry *ipsec.GlobalProtectSatelliteExternalCa
	if !o.ExternalCa.IsUnknown() && !o.ExternalCa.IsNull() {
		if *obj != nil && (*obj).ExternalCa != nil {
			externalCa_entry = (*obj).ExternalCa
		} else {
			externalCa_entry = new(ipsec.GlobalProtectSatelliteExternalCa)
		}
		var object *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject
		diags.Append(o.ExternalCa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &externalCa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()
	var localAddress_entry *ipsec.GlobalProtectSatelliteLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.GlobalProtectSatelliteLocalAddress)
		}
		var object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	portalAddress_value := o.PortalAddress.ValueStringPointer()
	var publishConnectedRoutes_entry *ipsec.GlobalProtectSatellitePublishConnectedRoutes
	if !o.PublishConnectedRoutes.IsUnknown() && !o.PublishConnectedRoutes.IsNull() {
		if *obj != nil && (*obj).PublishConnectedRoutes != nil {
			publishConnectedRoutes_entry = (*obj).PublishConnectedRoutes
		} else {
			publishConnectedRoutes_entry = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
		}
		var object *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject
		diags.Append(o.PublishConnectedRoutes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &publishConnectedRoutes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var publishRoutes_pango_entries []string
	if !o.PublishRoutes.IsUnknown() && !o.PublishRoutes.IsNull() {
		object_entries := make([]types.String, 0, len(o.PublishRoutes.Elements()))
		diags.Append(o.PublishRoutes.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			publishRoutes_pango_entries = append(publishRoutes_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellite)
	}
	(*obj).ExternalCa = externalCa_entry
	(*obj).Ipv6Preferred = ipv6Preferred_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PortalAddress = portalAddress_value
	(*obj).PublishConnectedRoutes = publishConnectedRoutes_entry
	(*obj).PublishRoutes = publishRoutes_pango_entries

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteExternalCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	localCertificate_value := o.LocalCertificate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteExternalCa)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	var floatingIp_entry *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp
	if !o.FloatingIp.IsUnknown() && !o.FloatingIp.IsNull() {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
		}
		var object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject
		diags.Append(o.FloatingIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &floatingIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *ipsec.GlobalProtectSatelliteLocalAddressIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
		}
		var object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatelliteLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.GlobalProtectSatellitePublishConnectedRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_entry *ipsec.ManualKeyLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.ManualKeyLocalAddress)
		}
		var object *IpsecTunnelResourceManualKeyLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	localSpi_value := o.LocalSpi.ValueStringPointer()
	var peerAddress_entry *ipsec.ManualKeyPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(ipsec.ManualKeyPeerAddress)
		}
		var object *IpsecTunnelResourceManualKeyPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	remoteSpi_value := o.RemoteSpi.ValueStringPointer()
	var ah_entry *ipsec.ManualKeyAh
	if !o.Ah.IsUnknown() && !o.Ah.IsNull() {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(ipsec.ManualKeyAh)
		}
		var object *IpsecTunnelResourceManualKeyAhObject
		diags.Append(o.Ah.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ah_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_entry *ipsec.ManualKeyEsp
	if !o.Esp.IsUnknown() && !o.Esp.IsNull() {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(ipsec.ManualKeyEsp)
		}
		var object *IpsecTunnelResourceManualKeyEspObject
		diags.Append(o.Esp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &esp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKey)
	}
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalSpi = localSpi_value
	(*obj).PeerAddress = peerAddress_entry
	(*obj).RemoteSpi = remoteSpi_value
	(*obj).Ah = ah_entry
	(*obj).Esp = esp_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyPeerAddress)
	}
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyAhMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyAhMd5)
		}
		var object *IpsecTunnelResourceManualKeyAhMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyAhSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyAhSha1)
		}
		var object *IpsecTunnelResourceManualKeyAhSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyAhSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyAhSha256)
		}
		var object *IpsecTunnelResourceManualKeyAhSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyAhSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyAhSha384)
		}
		var object *IpsecTunnelResourceManualKeyAhSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyAhSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyAhSha512)
		}
		var object *IpsecTunnelResourceManualKeyAhSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *ipsec.ManualKeyEspAuthentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(ipsec.ManualKeyEspAuthentication)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *ipsec.ManualKeyEspEncryption
	if !o.Encryption.IsUnknown() && !o.Encryption.IsNull() {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(ipsec.ManualKeyEspEncryption)
		}
		var object *IpsecTunnelResourceManualKeyEspEncryptionObject
		diags.Append(o.Encryption.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &encryption_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyEspAuthenticationMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyEspAuthenticationMd5)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *ipsec.ManualKeyEspAuthenticationNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(ipsec.ManualKeyEspAuthenticationNone)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyEspAuthenticationSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyEspAuthenticationSha1)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyEspAuthenticationSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyEspAuthenticationSha256)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyEspAuthenticationSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyEspAuthenticationSha384)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyEspAuthenticationSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyEspAuthenticationSha512)
		}
		var object *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).None = none_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationNone)
	}

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ipsec.ManualKeyEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}

func (o *IpsecTunnelResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var tunnelMonitor_obj *IpsecTunnelResourceTunnelMonitorObject
	if o.TunnelMonitor.IsNull() {
		tunnelMonitor_obj = new(IpsecTunnelResourceTunnelMonitorObject)
	} else {
		diags.Append(o.TunnelMonitor.As(ctx, &tunnelMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tunnelMonitor_object := types.ObjectNull(tunnelMonitor_obj.AttributeTypes())
	if obj.TunnelMonitor != nil {
		diags.Append(tunnelMonitor_obj.CopyFromPango(ctx, client, ancestors, obj.TunnelMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tunnelMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, tunnelMonitor_obj.AttributeTypes(), tunnelMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var autoKey_obj *IpsecTunnelResourceAutoKeyObject
	if o.AutoKey.IsNull() {
		autoKey_obj = new(IpsecTunnelResourceAutoKeyObject)
	} else {
		diags.Append(o.AutoKey.As(ctx, &autoKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	autoKey_object := types.ObjectNull(autoKey_obj.AttributeTypes())
	if obj.AutoKey != nil {
		diags.Append(autoKey_obj.CopyFromPango(ctx, client, ancestors, obj.AutoKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		autoKey_object, diags_tmp = types.ObjectValueFrom(ctx, autoKey_obj.AttributeTypes(), autoKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalProtectSatellite_obj *IpsecTunnelResourceGlobalProtectSatelliteObject
	if o.GlobalProtectSatellite.IsNull() {
		globalProtectSatellite_obj = new(IpsecTunnelResourceGlobalProtectSatelliteObject)
	} else {
		diags.Append(o.GlobalProtectSatellite.As(ctx, &globalProtectSatellite_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalProtectSatellite_object := types.ObjectNull(globalProtectSatellite_obj.AttributeTypes())
	if obj.GlobalProtectSatellite != nil {
		diags.Append(globalProtectSatellite_obj.CopyFromPango(ctx, client, ancestors, obj.GlobalProtectSatellite, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalProtectSatellite_object, diags_tmp = types.ObjectValueFrom(ctx, globalProtectSatellite_obj.AttributeTypes(), globalProtectSatellite_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manualKey_obj *IpsecTunnelResourceManualKeyObject
	if o.ManualKey.IsNull() {
		manualKey_obj = new(IpsecTunnelResourceManualKeyObject)
	} else {
		diags.Append(o.ManualKey.As(ctx, &manualKey_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manualKey_object := types.ObjectNull(manualKey_obj.AttributeTypes())
	if obj.ManualKey != nil {
		diags.Append(manualKey_obj.CopyFromPango(ctx, client, ancestors, obj.ManualKey, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manualKey_object, diags_tmp = types.ObjectValueFrom(ctx, manualKey_obj.AttributeTypes(), manualKey_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var antiReplay_value types.Bool
	if obj.AntiReplay != nil {
		antiReplay_value = types.BoolValue(*obj.AntiReplay)
	}
	var antiReplayWindow_value types.String
	if obj.AntiReplayWindow != nil {
		antiReplayWindow_value = types.StringValue(*obj.AntiReplayWindow)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var copyFlowLabel_value types.Bool
	if obj.CopyFlowLabel != nil {
		copyFlowLabel_value = types.BoolValue(*obj.CopyFlowLabel)
	}
	var copyTos_value types.Bool
	if obj.CopyTos != nil {
		copyTos_value = types.BoolValue(*obj.CopyTos)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var enableGreEncapsulation_value types.Bool
	if obj.EnableGreEncapsulation != nil {
		enableGreEncapsulation_value = types.BoolValue(*obj.EnableGreEncapsulation)
	}
	var ipsecMode_value types.String
	if obj.IpsecMode != nil {
		ipsecMode_value = types.StringValue(*obj.IpsecMode)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	var tunnelInterface_value types.String
	if obj.TunnelInterface != nil {
		tunnelInterface_value = types.StringValue(*obj.TunnelInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.AntiReplay = antiReplay_value
	o.AntiReplayWindow = antiReplayWindow_value
	o.Comment = comment_value
	o.CopyFlowLabel = copyFlowLabel_value
	o.CopyTos = copyTos_value
	o.Disabled = disabled_value
	o.EnableGreEncapsulation = enableGreEncapsulation_value
	o.IpsecMode = ipsecMode_value
	o.Ipv6 = ipv6_value
	o.TunnelInterface = tunnelInterface_value
	o.TunnelMonitor = tunnelMonitor_object
	o.AutoKey = autoKey_object
	o.GlobalProtectSatellite = globalProtectSatellite_object
	o.ManualKey = manualKey_object

	return diags
}

func (o *IpsecTunnelResourceTunnelMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.TunnelMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var destinationIp_value types.String
	if obj.DestinationIp != nil {
		destinationIp_value = types.StringValue(*obj.DestinationIp)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var proxyId_value types.String
	if obj.ProxyId != nil {
		proxyId_value = types.StringValue(*obj.ProxyId)
	}
	var tunnelMonitorProfile_value types.String
	if obj.TunnelMonitorProfile != nil {
		tunnelMonitorProfile_value = types.StringValue(*obj.TunnelMonitorProfile)
	}
	o.DestinationIp = destinationIp_value
	o.Enable = enable_value
	o.ProxyId = proxyId_value
	o.TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_list types.List
	{
		var ikeGateway_tf_entries []IpsecTunnelResourceAutoKeyIkeGatewayObject
		if !o.IkeGateway.IsNull() {
			diags.Append(o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.IkeGateway {
			entry := IpsecTunnelResourceAutoKeyIkeGatewayObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ikeGateway_tf_entries) {
				entry = ikeGateway_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ikeGateway_tf_entries) {
				ikeGateway_tf_entries[idx] = entry
			} else {
				ikeGateway_tf_entries = append(ikeGateway_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ike_gateway")
		ikeGateway_list, list_diags = types.ListValueFrom(ctx, schemaType, ikeGateway_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyId_list types.List
	{
		var proxyId_tf_entries []IpsecTunnelResourceAutoKeyProxyIdObject
		if !o.ProxyId.IsNull() {
			diags.Append(o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyId {
			entry := IpsecTunnelResourceAutoKeyProxyIdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyId_tf_entries) {
				entry = proxyId_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyId_tf_entries) {
				proxyId_tf_entries[idx] = entry
			} else {
				proxyId_tf_entries = append(proxyId_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id")
		proxyId_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyId_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyIdV6_list types.List
	{
		var proxyIdV6_tf_entries []IpsecTunnelResourceAutoKeyProxyIdV6Object
		if !o.ProxyIdV6.IsNull() {
			diags.Append(o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ProxyIdV6 {
			entry := IpsecTunnelResourceAutoKeyProxyIdV6Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(proxyIdV6_tf_entries) {
				entry = proxyIdV6_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(proxyIdV6_tf_entries) {
				proxyIdV6_tf_entries[idx] = entry
			} else {
				proxyIdV6_tf_entries = append(proxyIdV6_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id_v6")
		proxyIdV6_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyIdV6_tf_entries)
		diags.Append(list_diags...)
	}

	var ipsecCryptoProfile_value types.String
	if obj.IpsecCryptoProfile != nil {
		ipsecCryptoProfile_value = types.StringValue(*obj.IpsecCryptoProfile)
	}
	o.IkeGateway = ikeGateway_list
	o.IpsecCryptoProfile = ipsecCryptoProfile_value
	o.ProxyId = proxyId_list
	o.ProxyIdV6 = proxyIdV6_list

	return diags
}

func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyIkeGateway, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var protocol_obj *IpsecTunnelResourceAutoKeyProxyIdProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IpsecTunnelResourceAutoKeyProxyIdProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Local = local_value
	o.Remote = remote_value
	o.Protocol = protocol_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var any_obj *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject
	if o.Any.IsNull() {
		any_obj = new(IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject)
	} else {
		diags.Append(o.Any.As(ctx, &any_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	any_object := types.ObjectNull(any_obj.AttributeTypes())
	if obj.Any != nil {
		diags.Append(any_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Any, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		any_object, diags_tmp = types.ObjectValueFrom(ctx, any_obj.AttributeTypes(), any_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tcp_obj *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject
	if o.Tcp.IsNull() {
		tcp_obj = new(IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject)
	} else {
		diags.Append(o.Tcp.As(ctx, &tcp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tcp_object := types.ObjectNull(tcp_obj.AttributeTypes())
	if obj.Tcp != nil {
		diags.Append(tcp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Tcp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tcp_object, diags_tmp = types.ObjectValueFrom(ctx, tcp_obj.AttributeTypes(), tcp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var udp_obj *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject
	if o.Udp.IsNull() {
		udp_obj = new(IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject)
	} else {
		diags.Append(o.Udp.As(ctx, &udp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	udp_object := types.ObjectNull(udp_obj.AttributeTypes())
	if obj.Udp != nil {
		diags.Append(udp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Udp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		udp_object, diags_tmp = types.ObjectValueFrom(ctx, udp_obj.AttributeTypes(), udp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var protocol_obj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Local = local_value
	o.Remote = remote_value
	o.Protocol = protocol_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var any_obj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject
	if o.Any.IsNull() {
		any_obj = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject)
	} else {
		diags.Append(o.Any.As(ctx, &any_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	any_object := types.ObjectNull(any_obj.AttributeTypes())
	if obj.Any != nil {
		diags.Append(any_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Any, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		any_object, diags_tmp = types.ObjectValueFrom(ctx, any_obj.AttributeTypes(), any_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tcp_obj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject
	if o.Tcp.IsNull() {
		tcp_obj = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject)
	} else {
		diags.Append(o.Tcp.As(ctx, &tcp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tcp_object := types.ObjectNull(tcp_obj.AttributeTypes())
	if obj.Tcp != nil {
		diags.Append(tcp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Tcp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tcp_object, diags_tmp = types.ObjectValueFrom(ctx, tcp_obj.AttributeTypes(), tcp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var udp_obj *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject
	if o.Udp.IsNull() {
		udp_obj = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject)
	} else {
		diags.Append(o.Udp.As(ctx, &udp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	udp_object := types.ObjectNull(udp_obj.AttributeTypes())
	if obj.Udp != nil {
		diags.Append(udp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Udp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		udp_object, diags_tmp = types.ObjectValueFrom(ctx, udp_obj.AttributeTypes(), udp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolAny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolTcp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.AutoKeyProxyIdV6ProtocolUdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatellite, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var publishRoutes_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PublishRoutes.IsNull() || len(obj.PublishRoutes) > 0 {
			entries = obj.PublishRoutes
		}

		publishRoutes_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var externalCa_obj *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject
	if o.ExternalCa.IsNull() {
		externalCa_obj = new(IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject)
	} else {
		diags.Append(o.ExternalCa.As(ctx, &externalCa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	externalCa_object := types.ObjectNull(externalCa_obj.AttributeTypes())
	if obj.ExternalCa != nil {
		diags.Append(externalCa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExternalCa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		externalCa_object, diags_tmp = types.ObjectValueFrom(ctx, externalCa_obj.AttributeTypes(), externalCa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var publishConnectedRoutes_obj *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject
	if o.PublishConnectedRoutes.IsNull() {
		publishConnectedRoutes_obj = new(IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject)
	} else {
		diags.Append(o.PublishConnectedRoutes.As(ctx, &publishConnectedRoutes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	publishConnectedRoutes_object := types.ObjectNull(publishConnectedRoutes_obj.AttributeTypes())
	if obj.PublishConnectedRoutes != nil {
		diags.Append(publishConnectedRoutes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PublishConnectedRoutes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		publishConnectedRoutes_object, diags_tmp = types.ObjectValueFrom(ctx, publishConnectedRoutes_obj.AttributeTypes(), publishConnectedRoutes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	var portalAddress_value types.String
	if obj.PortalAddress != nil {
		portalAddress_value = types.StringValue(*obj.PortalAddress)
	}
	o.ExternalCa = externalCa_object
	o.Ipv6Preferred = ipv6Preferred_value
	o.LocalAddress = localAddress_object
	o.PortalAddress = portalAddress_value
	o.PublishConnectedRoutes = publishConnectedRoutes_object
	o.PublishRoutes = publishRoutes_list

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteExternalCa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var localCertificate_value types.String
	if obj.LocalCertificate != nil {
		localCertificate_value = types.StringValue(*obj.LocalCertificate)
	}
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var floatingIp_obj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject
	if o.FloatingIp.IsNull() {
		floatingIp_obj = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject)
	} else {
		diags.Append(o.FloatingIp.As(ctx, &floatingIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	floatingIp_object := types.ObjectNull(floatingIp_obj.AttributeTypes())
	if obj.FloatingIp != nil {
		diags.Append(floatingIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FloatingIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		floatingIp_object, diags_tmp = types.ObjectValueFrom(ctx, floatingIp_obj.AttributeTypes(), floatingIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ip_obj *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject
	if o.Ip.IsNull() {
		ip_obj = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatelliteLocalAddressIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.GlobalProtectSatellitePublishConnectedRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKey, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localAddress_obj *IpsecTunnelResourceManualKeyLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(IpsecTunnelResourceManualKeyLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *IpsecTunnelResourceManualKeyPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(IpsecTunnelResourceManualKeyPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ah_obj *IpsecTunnelResourceManualKeyAhObject
	if o.Ah.IsNull() {
		ah_obj = new(IpsecTunnelResourceManualKeyAhObject)
	} else {
		diags.Append(o.Ah.As(ctx, &ah_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ah_object := types.ObjectNull(ah_obj.AttributeTypes())
	if obj.Ah != nil {
		diags.Append(ah_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ah, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ah_object, diags_tmp = types.ObjectValueFrom(ctx, ah_obj.AttributeTypes(), ah_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var esp_obj *IpsecTunnelResourceManualKeyEspObject
	if o.Esp.IsNull() {
		esp_obj = new(IpsecTunnelResourceManualKeyEspObject)
	} else {
		diags.Append(o.Esp.As(ctx, &esp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	esp_object := types.ObjectNull(esp_obj.AttributeTypes())
	if obj.Esp != nil {
		diags.Append(esp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Esp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		esp_object, diags_tmp = types.ObjectValueFrom(ctx, esp_obj.AttributeTypes(), esp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localSpi_value types.String
	if obj.LocalSpi != nil {
		localSpi_value = types.StringValue(*obj.LocalSpi)
	}
	var remoteSpi_value types.String
	if obj.RemoteSpi != nil {
		remoteSpi_value = types.StringValue(*obj.RemoteSpi)
	}
	o.LocalAddress = localAddress_object
	o.LocalSpi = localSpi_value
	o.PeerAddress = peerAddress_object
	o.RemoteSpi = remoteSpi_value
	o.Ah = ah_object
	o.Esp = esp_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *IpsecTunnelResourceManualKeyAhMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(IpsecTunnelResourceManualKeyAhMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *IpsecTunnelResourceManualKeyAhSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(IpsecTunnelResourceManualKeyAhSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *IpsecTunnelResourceManualKeyAhSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(IpsecTunnelResourceManualKeyAhSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *IpsecTunnelResourceManualKeyAhSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(IpsecTunnelResourceManualKeyAhSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *IpsecTunnelResourceManualKeyAhSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(IpsecTunnelResourceManualKeyAhSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *IpsecTunnelResourceManualKeyEspAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var encryption_obj *IpsecTunnelResourceManualKeyEspEncryptionObject
	if o.Encryption.IsNull() {
		encryption_obj = new(IpsecTunnelResourceManualKeyEspEncryptionObject)
	} else {
		diags.Append(o.Encryption.As(ctx, &encryption_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	encryption_object := types.ObjectNull(encryption_obj.AttributeTypes())
	if obj.Encryption != nil {
		diags.Append(encryption_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Encryption, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		encryption_object, diags_tmp = types.ObjectValueFrom(ctx, encryption_obj.AttributeTypes(), encryption_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject
	if o.None.IsNull() {
		none_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(IpsecTunnelResourceManualKeyEspAuthenticationSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.None = none_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ipsec.ManualKeyEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *IpsecTunnelResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location ipsec.Location

	{
		var terraformLocation IpsecTunnelLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ipsec.TemplateLocation{}
			var innerLocation IpsecTunnelTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ipsec.TemplateStackLocation{}
			var innerLocation IpsecTunnelTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *ipsec.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *IpsecTunnelResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ipsec.Location

	{
		var terraformLocation IpsecTunnelLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ipsec.TemplateLocation{}
			var innerLocation IpsecTunnelTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ipsec.TemplateStackLocation{}
			var innerLocation IpsecTunnelTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *IpsecTunnelResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ipsec.Location

	{
		var terraformLocation IpsecTunnelLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ipsec.TemplateLocation{}
			var innerLocation IpsecTunnelTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ipsec.TemplateStackLocation{}
			var innerLocation IpsecTunnelTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := o.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := o.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *IpsecTunnelResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location ipsec.Location

	{
		var terraformLocation IpsecTunnelLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ipsec.TemplateLocation{}
			var innerLocation IpsecTunnelTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ipsec.TemplateStackLocation{}
			var innerLocation IpsecTunnelTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type IpsecTunnelImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o IpsecTunnelImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *IpsecTunnelLocation `json:"location"`
		Name     *string              `json:"name"`
	}
	var location_object *IpsecTunnelLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *IpsecTunnelLocation `json:"location"`
		Name     *string              `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func IpsecTunnelImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := IpsecTunnelImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *IpsecTunnelResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj IpsecTunnelImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type IpsecTunnelTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IpsecTunnelTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IpsecTunnelLocation struct {
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func IpsecTunnelLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o IpsecTunnelTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IpsecTunnelTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IpsecTunnelLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Template      *IpsecTunnelTemplateLocation      `json:"template,omitempty"`
		TemplateStack *IpsecTunnelTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var template_object *IpsecTunnelTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *IpsecTunnelTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template      *IpsecTunnelTemplateLocation      `json:"template,omitempty"`
		TemplateStack *IpsecTunnelTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *IpsecTunnelTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *IpsecTunnelTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *IpsecTunnelLocation) AttributeTypes() map[string]attr.Type {
	var templateObj IpsecTunnelTemplateLocation
	var templateStackObj IpsecTunnelTemplateStackLocation
	return map[string]attr.Type{
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
