package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/tunnel/ipsec"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &IpsecTunnelDataSource{}
	_ datasource.DataSourceWithConfigure = &IpsecTunnelDataSource{}
)

func NewIpsecTunnelDataSource() datasource.DataSource {
	return &IpsecTunnelDataSource{}
}

type IpsecTunnelDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service]
}

type IpsecTunnelDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type IpsecTunnelDataSourceModel struct {
	Location               IpsecTunnelLocation                                `tfsdk:"location"`
	Name                   types.String                                       `tfsdk:"name"`
	AntiReplay             types.Bool                                         `tfsdk:"anti_replay"`
	AntiReplayWindow       types.String                                       `tfsdk:"anti_replay_window"`
	Disabled               types.Bool                                         `tfsdk:"disabled"`
	EnableGreEncapsulation types.Bool                                         `tfsdk:"enable_gre_encapsulation"`
	TunnelInterface        types.String                                       `tfsdk:"tunnel_interface"`
	IpsecMode              types.String                                       `tfsdk:"ipsec_mode"`
	Comment                types.String                                       `tfsdk:"comment"`
	CopyFlowLabel          types.Bool                                         `tfsdk:"copy_flow_label"`
	CopyTos                types.Bool                                         `tfsdk:"copy_tos"`
	Ipv6                   types.Bool                                         `tfsdk:"ipv6"`
	TunnelMonitor          *IpsecTunnelDataSourceTunnelMonitorObject          `tfsdk:"tunnel_monitor"`
	GlobalProtectSatellite *IpsecTunnelDataSourceGlobalProtectSatelliteObject `tfsdk:"global_protect_satellite"`
	ManualKey              *IpsecTunnelDataSourceManualKeyObject              `tfsdk:"manual_key"`
	AutoKey                *IpsecTunnelDataSourceAutoKeyObject                `tfsdk:"auto_key"`
}
type IpsecTunnelDataSourceTunnelMonitorObject struct {
	DestinationIp        types.String `tfsdk:"destination_ip"`
	Enable               types.Bool   `tfsdk:"enable"`
	ProxyId              types.String `tfsdk:"proxy_id"`
	TunnelMonitorProfile types.String `tfsdk:"tunnel_monitor_profile"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteObject struct {
	ExternalCa             *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject             `tfsdk:"external_ca"`
	Ipv6Preferred          types.Bool                                                               `tfsdk:"ipv6_preferred"`
	LocalAddress           *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject           `tfsdk:"local_address"`
	PortalAddress          types.String                                                             `tfsdk:"portal_address"`
	PublishConnectedRoutes *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject `tfsdk:"publish_connected_routes"`
	PublishRoutes          types.List                                                               `tfsdk:"publish_routes"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	LocalCertificate   types.String `tfsdk:"local_certificate"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject struct {
	Interface  types.String                                                             `tfsdk:"interface"`
	FloatingIp *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject `tfsdk:"floating_ip"`
	Ip         *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject         `tfsdk:"ip"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IpsecTunnelDataSourceManualKeyObject struct {
	LocalAddress *IpsecTunnelDataSourceManualKeyLocalAddressObject `tfsdk:"local_address"`
	LocalSpi     types.String                                      `tfsdk:"local_spi"`
	PeerAddress  *IpsecTunnelDataSourceManualKeyPeerAddressObject  `tfsdk:"peer_address"`
	RemoteSpi    types.String                                      `tfsdk:"remote_spi"`
	Ah           *IpsecTunnelDataSourceManualKeyAhObject           `tfsdk:"ah"`
	Esp          *IpsecTunnelDataSourceManualKeyEspObject          `tfsdk:"esp"`
}
type IpsecTunnelDataSourceManualKeyLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IpsecTunnelDataSourceManualKeyPeerAddressObject struct {
	Ip types.String `tfsdk:"ip"`
}
type IpsecTunnelDataSourceManualKeyAhObject struct {
	Md5    *IpsecTunnelDataSourceManualKeyAhMd5Object    `tfsdk:"md5"`
	Sha1   *IpsecTunnelDataSourceManualKeyAhSha1Object   `tfsdk:"sha1"`
	Sha256 *IpsecTunnelDataSourceManualKeyAhSha256Object `tfsdk:"sha256"`
	Sha384 *IpsecTunnelDataSourceManualKeyAhSha384Object `tfsdk:"sha384"`
	Sha512 *IpsecTunnelDataSourceManualKeyAhSha512Object `tfsdk:"sha512"`
}
type IpsecTunnelDataSourceManualKeyAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspObject struct {
	Authentication *IpsecTunnelDataSourceManualKeyEspAuthenticationObject `tfsdk:"authentication"`
	Encryption     *IpsecTunnelDataSourceManualKeyEspEncryptionObject     `tfsdk:"encryption"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationObject struct {
	Sha384 *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object `tfsdk:"sha384"`
	Sha512 *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object `tfsdk:"sha512"`
	Md5    *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object    `tfsdk:"md5"`
	None   *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject   `tfsdk:"none"`
	Sha1   *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object   `tfsdk:"sha1"`
	Sha256 *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object `tfsdk:"sha256"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject struct {
}
type IpsecTunnelDataSourceManualKeyEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}
type IpsecTunnelDataSourceAutoKeyObject struct {
	ProxyIdV6          types.List   `tfsdk:"proxy_id_v6"`
	IkeGateway         types.List   `tfsdk:"ike_gateway"`
	IpsecCryptoProfile types.String `tfsdk:"ipsec_crypto_profile"`
	ProxyId            types.List   `tfsdk:"proxy_id"`
}
type IpsecTunnelDataSourceAutoKeyIkeGatewayObject struct {
	Name types.String `tfsdk:"name"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdObject struct {
	Name     types.String                                       `tfsdk:"name"`
	Local    types.String                                       `tfsdk:"local"`
	Remote   types.String                                       `tfsdk:"remote"`
	Protocol *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject `tfsdk:"protocol"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject struct {
	Number types.Int64                                           `tfsdk:"number"`
	Any    *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject `tfsdk:"any"`
	Tcp    *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject `tfsdk:"tcp"`
	Udp    *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject `tfsdk:"udp"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject struct {
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject struct {
	RemotePort types.Int64 `tfsdk:"remote_port"`
	LocalPort  types.Int64 `tfsdk:"local_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6Object struct {
	Name     types.String                                         `tfsdk:"name"`
	Remote   types.String                                         `tfsdk:"remote"`
	Protocol *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject `tfsdk:"protocol"`
	Local    types.String                                         `tfsdk:"local"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject struct {
	Tcp    *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject `tfsdk:"tcp"`
	Udp    *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject `tfsdk:"udp"`
	Number types.Int64                                             `tfsdk:"number"`
	Any    *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject `tfsdk:"any"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject struct {
}

func (o *IpsecTunnelDataSourceModel) CopyToPango(ctx context.Context, obj **ipsec.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	copyFlowLabel_value := o.CopyFlowLabel.ValueBoolPointer()
	copyTos_value := o.CopyTos.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	var tunnelMonitor_entry *ipsec.TunnelMonitor
	if o.TunnelMonitor != nil {
		if *obj != nil && (*obj).TunnelMonitor != nil {
			tunnelMonitor_entry = (*obj).TunnelMonitor
		} else {
			tunnelMonitor_entry = new(ipsec.TunnelMonitor)
		}

		diags.Append(o.TunnelMonitor.CopyToPango(ctx, &tunnelMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	antiReplayWindow_value := o.AntiReplayWindow.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	enableGreEncapsulation_value := o.EnableGreEncapsulation.ValueBoolPointer()
	tunnelInterface_value := o.TunnelInterface.ValueStringPointer()
	ipsecMode_value := o.IpsecMode.ValueStringPointer()
	antiReplay_value := o.AntiReplay.ValueBoolPointer()
	var globalProtectSatellite_entry *ipsec.GlobalProtectSatellite
	if o.GlobalProtectSatellite != nil {
		if *obj != nil && (*obj).GlobalProtectSatellite != nil {
			globalProtectSatellite_entry = (*obj).GlobalProtectSatellite
		} else {
			globalProtectSatellite_entry = new(ipsec.GlobalProtectSatellite)
		}

		diags.Append(o.GlobalProtectSatellite.CopyToPango(ctx, &globalProtectSatellite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_entry *ipsec.ManualKey
	if o.ManualKey != nil {
		if *obj != nil && (*obj).ManualKey != nil {
			manualKey_entry = (*obj).ManualKey
		} else {
			manualKey_entry = new(ipsec.ManualKey)
		}

		diags.Append(o.ManualKey.CopyToPango(ctx, &manualKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_entry *ipsec.AutoKey
	if o.AutoKey != nil {
		if *obj != nil && (*obj).AutoKey != nil {
			autoKey_entry = (*obj).AutoKey
		} else {
			autoKey_entry = new(ipsec.AutoKey)
		}

		diags.Append(o.AutoKey.CopyToPango(ctx, &autoKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).CopyFlowLabel = copyFlowLabel_value
	(*obj).CopyTos = copyTos_value
	(*obj).Ipv6 = ipv6_value
	(*obj).TunnelMonitor = tunnelMonitor_entry
	(*obj).Comment = comment_value
	(*obj).AntiReplayWindow = antiReplayWindow_value
	(*obj).Disabled = disabled_value
	(*obj).EnableGreEncapsulation = enableGreEncapsulation_value
	(*obj).TunnelInterface = tunnelInterface_value
	(*obj).IpsecMode = ipsecMode_value
	(*obj).AntiReplay = antiReplay_value
	(*obj).GlobalProtectSatellite = globalProtectSatellite_entry
	(*obj).ManualKey = manualKey_entry
	(*obj).AutoKey = autoKey_entry

	return diags
}
func (o *IpsecTunnelDataSourceTunnelMonitorObject) CopyToPango(ctx context.Context, obj **ipsec.TunnelMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	destinationIp_value := o.DestinationIp.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	proxyId_value := o.ProxyId.ValueStringPointer()
	tunnelMonitorProfile_value := o.TunnelMonitorProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.TunnelMonitor)
	}
	(*obj).DestinationIp = destinationIp_value
	(*obj).Enable = enable_value
	(*obj).ProxyId = proxyId_value
	(*obj).TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipsecCryptoProfile_value := o.IpsecCryptoProfile.ValueStringPointer()
	var proxyId_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdObject
	var proxyId_pango_entries []ipsec.AutoKeyProxyId
	{
		d := o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyId_tf_entries {
			var entry *ipsec.AutoKeyProxyId
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			proxyId_pango_entries = append(proxyId_pango_entries, *entry)
		}
	}
	var proxyIdV6_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdV6Object
	var proxyIdV6_pango_entries []ipsec.AutoKeyProxyIdV6
	{
		d := o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyIdV6_tf_entries {
			var entry *ipsec.AutoKeyProxyIdV6
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			proxyIdV6_pango_entries = append(proxyIdV6_pango_entries, *entry)
		}
	}
	var ikeGateway_tf_entries []IpsecTunnelDataSourceAutoKeyIkeGatewayObject
	var ikeGateway_pango_entries []ipsec.AutoKeyIkeGateway
	{
		d := o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ikeGateway_tf_entries {
			var entry *ipsec.AutoKeyIkeGateway
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ikeGateway_pango_entries = append(ikeGateway_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKey)
	}
	(*obj).IpsecCryptoProfile = ipsecCryptoProfile_value
	(*obj).ProxyId = proxyId_pango_entries
	(*obj).ProxyIdV6 = proxyIdV6_pango_entries
	(*obj).IkeGateway = ikeGateway_pango_entries

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyIkeGateway, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyIkeGateway)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdProtocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdProtocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyId)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tcp_entry *ipsec.AutoKeyProxyIdProtocolTcp
	if o.Tcp != nil {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdProtocolTcp)
		}

		diags.Append(o.Tcp.CopyToPango(ctx, &tcp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdProtocolUdp
	if o.Udp != nil {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdProtocolUdp)
		}

		diags.Append(o.Udp.CopyToPango(ctx, &udp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdProtocolAny
	if o.Any != nil {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdProtocolAny)
		}

		diags.Append(o.Any.CopyToPango(ctx, &any_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocol)
	}
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry
	(*obj).Number = number_value
	(*obj).Any = any_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	localPort_value := o.LocalPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolUdp)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).LocalPort = localPort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdV6Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdV6Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var any_entry *ipsec.AutoKeyProxyIdV6ProtocolAny
	if o.Any != nil {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
		}

		diags.Append(o.Any.CopyToPango(ctx, &any_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_entry *ipsec.AutoKeyProxyIdV6ProtocolTcp
	if o.Tcp != nil {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
		}

		diags.Append(o.Tcp.CopyToPango(ctx, &tcp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdV6ProtocolUdp
	if o.Udp != nil {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
		}

		diags.Append(o.Udp.CopyToPango(ctx, &udp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	number_value := o.Number.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6Protocol)
	}
	(*obj).Any = any_entry
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry
	(*obj).Number = number_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatellite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_entry *ipsec.GlobalProtectSatelliteLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.GlobalProtectSatelliteLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	portalAddress_value := o.PortalAddress.ValueStringPointer()
	var publishConnectedRoutes_entry *ipsec.GlobalProtectSatellitePublishConnectedRoutes
	if o.PublishConnectedRoutes != nil {
		if *obj != nil && (*obj).PublishConnectedRoutes != nil {
			publishConnectedRoutes_entry = (*obj).PublishConnectedRoutes
		} else {
			publishConnectedRoutes_entry = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
		}

		diags.Append(o.PublishConnectedRoutes.CopyToPango(ctx, &publishConnectedRoutes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	publishRoutes_pango_entries := make([]string, 0)
	diags.Append(o.PublishRoutes.ElementsAs(ctx, &publishRoutes_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var externalCa_entry *ipsec.GlobalProtectSatelliteExternalCa
	if o.ExternalCa != nil {
		if *obj != nil && (*obj).ExternalCa != nil {
			externalCa_entry = (*obj).ExternalCa
		} else {
			externalCa_entry = new(ipsec.GlobalProtectSatelliteExternalCa)
		}

		diags.Append(o.ExternalCa.CopyToPango(ctx, &externalCa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellite)
	}
	(*obj).LocalAddress = localAddress_entry
	(*obj).PortalAddress = portalAddress_value
	(*obj).PublishConnectedRoutes = publishConnectedRoutes_entry
	(*obj).PublishRoutes = publishRoutes_pango_entries
	(*obj).ExternalCa = externalCa_entry
	(*obj).Ipv6Preferred = ipv6Preferred_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteExternalCa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	localCertificate_value := o.LocalCertificate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteExternalCa)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	var ip_entry *ipsec.GlobalProtectSatelliteLocalAddressIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var floatingIp_entry *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp
	if o.FloatingIp != nil {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
		}

		diags.Append(o.FloatingIp.CopyToPango(ctx, &floatingIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_entry
	(*obj).FloatingIp = floatingIp_entry

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddressIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv6_value := o.Ipv6.ValueStringPointer()
	ipv4_value := o.Ipv4.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
	}
	(*obj).Ipv6 = ipv6_value
	(*obj).Ipv4 = ipv4_value

	return diags
}
func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatellitePublishConnectedRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerAddress_entry *ipsec.ManualKeyPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(ipsec.ManualKeyPeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	remoteSpi_value := o.RemoteSpi.ValueStringPointer()
	var localAddress_entry *ipsec.ManualKeyLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.ManualKeyLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localSpi_value := o.LocalSpi.ValueStringPointer()
	var ah_entry *ipsec.ManualKeyAh
	if o.Ah != nil {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(ipsec.ManualKeyAh)
		}

		diags.Append(o.Ah.CopyToPango(ctx, &ah_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_entry *ipsec.ManualKeyEsp
	if o.Esp != nil {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(ipsec.ManualKeyEsp)
		}

		diags.Append(o.Esp.CopyToPango(ctx, &esp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKey)
	}
	(*obj).PeerAddress = peerAddress_entry
	(*obj).RemoteSpi = remoteSpi_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalSpi = localSpi_value
	(*obj).Ah = ah_entry
	(*obj).Esp = esp_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyPeerAddress)
	}
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha1_entry *ipsec.ManualKeyAhSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyAhSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyAhSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyAhSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyAhSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyAhSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyAhSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyAhSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_entry *ipsec.ManualKeyAhMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyAhMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAh)
	}
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).Md5 = md5_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *ipsec.ManualKeyEspAuthentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(ipsec.ManualKeyEspAuthentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *ipsec.ManualKeyEspEncryption
	if o.Encryption != nil {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(ipsec.ManualKeyEspEncryption)
		}

		diags.Append(o.Encryption.CopyToPango(ctx, &encryption_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyEspAuthenticationMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyEspAuthenticationMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *ipsec.ManualKeyEspAuthenticationNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(ipsec.ManualKeyEspAuthenticationNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyEspAuthenticationSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyEspAuthenticationSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyEspAuthenticationSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyEspAuthenticationSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyEspAuthenticationSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyEspAuthenticationSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyEspAuthenticationSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyEspAuthenticationSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).None = none_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationNone)
	}

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	algorithm_value := o.Algorithm.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspEncryption)
	}
	(*obj).Key = key_value
	(*obj).Algorithm = algorithm_value

	return diags
}

func (o *IpsecTunnelDataSourceModel) CopyFromPango(ctx context.Context, obj *ipsec.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tunnelMonitor_object *IpsecTunnelDataSourceTunnelMonitorObject
	if obj.TunnelMonitor != nil {
		tunnelMonitor_object = new(IpsecTunnelDataSourceTunnelMonitorObject)

		diags.Append(tunnelMonitor_object.CopyFromPango(ctx, obj.TunnelMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_object *IpsecTunnelDataSourceAutoKeyObject
	if obj.AutoKey != nil {
		autoKey_object = new(IpsecTunnelDataSourceAutoKeyObject)

		diags.Append(autoKey_object.CopyFromPango(ctx, obj.AutoKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectSatellite_object *IpsecTunnelDataSourceGlobalProtectSatelliteObject
	if obj.GlobalProtectSatellite != nil {
		globalProtectSatellite_object = new(IpsecTunnelDataSourceGlobalProtectSatelliteObject)

		diags.Append(globalProtectSatellite_object.CopyFromPango(ctx, obj.GlobalProtectSatellite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_object *IpsecTunnelDataSourceManualKeyObject
	if obj.ManualKey != nil {
		manualKey_object = new(IpsecTunnelDataSourceManualKeyObject)

		diags.Append(manualKey_object.CopyFromPango(ctx, obj.ManualKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var copyFlowLabel_value types.Bool
	if obj.CopyFlowLabel != nil {
		copyFlowLabel_value = types.BoolValue(*obj.CopyFlowLabel)
	}
	var copyTos_value types.Bool
	if obj.CopyTos != nil {
		copyTos_value = types.BoolValue(*obj.CopyTos)
	}
	var enableGreEncapsulation_value types.Bool
	if obj.EnableGreEncapsulation != nil {
		enableGreEncapsulation_value = types.BoolValue(*obj.EnableGreEncapsulation)
	}
	var tunnelInterface_value types.String
	if obj.TunnelInterface != nil {
		tunnelInterface_value = types.StringValue(*obj.TunnelInterface)
	}
	var ipsecMode_value types.String
	if obj.IpsecMode != nil {
		ipsecMode_value = types.StringValue(*obj.IpsecMode)
	}
	var antiReplay_value types.Bool
	if obj.AntiReplay != nil {
		antiReplay_value = types.BoolValue(*obj.AntiReplay)
	}
	var antiReplayWindow_value types.String
	if obj.AntiReplayWindow != nil {
		antiReplayWindow_value = types.StringValue(*obj.AntiReplayWindow)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	o.Name = types.StringValue(obj.Name)
	o.Ipv6 = ipv6_value
	o.TunnelMonitor = tunnelMonitor_object
	o.Comment = comment_value
	o.CopyFlowLabel = copyFlowLabel_value
	o.CopyTos = copyTos_value
	o.EnableGreEncapsulation = enableGreEncapsulation_value
	o.TunnelInterface = tunnelInterface_value
	o.IpsecMode = ipsecMode_value
	o.AntiReplay = antiReplay_value
	o.AntiReplayWindow = antiReplayWindow_value
	o.Disabled = disabled_value
	o.AutoKey = autoKey_object
	o.GlobalProtectSatellite = globalProtectSatellite_object
	o.ManualKey = manualKey_object

	return diags
}

func (o *IpsecTunnelDataSourceTunnelMonitorObject) CopyFromPango(ctx context.Context, obj *ipsec.TunnelMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var proxyId_value types.String
	if obj.ProxyId != nil {
		proxyId_value = types.StringValue(*obj.ProxyId)
	}
	var tunnelMonitorProfile_value types.String
	if obj.TunnelMonitorProfile != nil {
		tunnelMonitorProfile_value = types.StringValue(*obj.TunnelMonitorProfile)
	}
	var destinationIp_value types.String
	if obj.DestinationIp != nil {
		destinationIp_value = types.StringValue(*obj.DestinationIp)
	}
	o.Enable = enable_value
	o.ProxyId = proxyId_value
	o.TunnelMonitorProfile = tunnelMonitorProfile_value
	o.DestinationIp = destinationIp_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatellite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var publishRoutes_list types.List
	{
		var list_diags diag.Diagnostics
		publishRoutes_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PublishRoutes)
		diags.Append(list_diags...)
	}
	var externalCa_object *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject
	if obj.ExternalCa != nil {
		externalCa_object = new(IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject)

		diags.Append(externalCa_object.CopyFromPango(ctx, obj.ExternalCa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var publishConnectedRoutes_object *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject
	if obj.PublishConnectedRoutes != nil {
		publishConnectedRoutes_object = new(IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject)

		diags.Append(publishConnectedRoutes_object.CopyFromPango(ctx, obj.PublishConnectedRoutes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	var portalAddress_value types.String
	if obj.PortalAddress != nil {
		portalAddress_value = types.StringValue(*obj.PortalAddress)
	}
	o.ExternalCa = externalCa_object
	o.Ipv6Preferred = ipv6Preferred_value
	o.LocalAddress = localAddress_object
	o.PortalAddress = portalAddress_value
	o.PublishConnectedRoutes = publishConnectedRoutes_object
	o.PublishRoutes = publishRoutes_list

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var floatingIp_object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject
	if obj.FloatingIp != nil {
		floatingIp_object = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject)

		diags.Append(floatingIp_object.CopyFromPango(ctx, obj.FloatingIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_object *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject
	if obj.Ip != nil {
		ip_object = new(IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddressIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	o.Ipv6 = ipv6_value
	o.Ipv4 = ipv4_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatellitePublishConnectedRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteExternalCa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var localCertificate_value types.String
	if obj.LocalCertificate != nil {
		localCertificate_value = types.StringValue(*obj.LocalCertificate)
	}
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerAddress_object *IpsecTunnelDataSourceManualKeyPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(IpsecTunnelDataSourceManualKeyPeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *IpsecTunnelDataSourceManualKeyLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IpsecTunnelDataSourceManualKeyLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_object *IpsecTunnelDataSourceManualKeyAhObject
	if obj.Ah != nil {
		ah_object = new(IpsecTunnelDataSourceManualKeyAhObject)

		diags.Append(ah_object.CopyFromPango(ctx, obj.Ah, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_object *IpsecTunnelDataSourceManualKeyEspObject
	if obj.Esp != nil {
		esp_object = new(IpsecTunnelDataSourceManualKeyEspObject)

		diags.Append(esp_object.CopyFromPango(ctx, obj.Esp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var remoteSpi_value types.String
	if obj.RemoteSpi != nil {
		remoteSpi_value = types.StringValue(*obj.RemoteSpi)
	}
	var localSpi_value types.String
	if obj.LocalSpi != nil {
		localSpi_value = types.StringValue(*obj.LocalSpi)
	}
	o.PeerAddress = peerAddress_object
	o.RemoteSpi = remoteSpi_value
	o.LocalAddress = localAddress_object
	o.LocalSpi = localSpi_value
	o.Ah = ah_object
	o.Esp = esp_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_value
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha384_object *IpsecTunnelDataSourceManualKeyAhSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(IpsecTunnelDataSourceManualKeyAhSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *IpsecTunnelDataSourceManualKeyAhSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(IpsecTunnelDataSourceManualKeyAhSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_object *IpsecTunnelDataSourceManualKeyAhMd5Object
	if obj.Md5 != nil {
		md5_object = new(IpsecTunnelDataSourceManualKeyAhMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *IpsecTunnelDataSourceManualKeyAhSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(IpsecTunnelDataSourceManualKeyAhSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *IpsecTunnelDataSourceManualKeyAhSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(IpsecTunnelDataSourceManualKeyAhSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_object *IpsecTunnelDataSourceManualKeyEspAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_object *IpsecTunnelDataSourceManualKeyEspEncryptionObject
	if obj.Encryption != nil {
		encryption_object = new(IpsecTunnelDataSourceManualKeyEspEncryptionObject)

		diags.Append(encryption_object.CopyFromPango(ctx, obj.Encryption, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha1_object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_object *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object
	if obj.Md5 != nil {
		md5_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject
	if obj.None != nil {
		none_object = new(IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.Md5 = md5_object
	o.None = none_object

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var proxyIdV6_list types.List
	{
		var proxyIdV6_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdV6Object
		for _, elt := range obj.ProxyIdV6 {
			var entry IpsecTunnelDataSourceAutoKeyProxyIdV6Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			proxyIdV6_tf_entries = append(proxyIdV6_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id_v6")
		proxyIdV6_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyIdV6_tf_entries)
		diags.Append(list_diags...)
	}
	var ikeGateway_list types.List
	{
		var ikeGateway_tf_entries []IpsecTunnelDataSourceAutoKeyIkeGatewayObject
		for _, elt := range obj.IkeGateway {
			var entry IpsecTunnelDataSourceAutoKeyIkeGatewayObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ikeGateway_tf_entries = append(ikeGateway_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ike_gateway")
		ikeGateway_list, list_diags = types.ListValueFrom(ctx, schemaType, ikeGateway_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyId_list types.List
	{
		var proxyId_tf_entries []IpsecTunnelDataSourceAutoKeyProxyIdObject
		for _, elt := range obj.ProxyId {
			var entry IpsecTunnelDataSourceAutoKeyProxyIdObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			proxyId_tf_entries = append(proxyId_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id")
		proxyId_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyId_tf_entries)
		diags.Append(list_diags...)
	}

	var ipsecCryptoProfile_value types.String
	if obj.IpsecCryptoProfile != nil {
		ipsecCryptoProfile_value = types.StringValue(*obj.IpsecCryptoProfile)
	}
	o.ProxyIdV6 = proxyIdV6_list
	o.IkeGateway = ikeGateway_list
	o.IpsecCryptoProfile = ipsecCryptoProfile_value
	o.ProxyId = proxyId_list

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyIkeGateway, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var protocol_object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Local = local_value
	o.Remote = remote_value
	o.Protocol = protocol_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tcp_object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject
	if obj.Tcp != nil {
		tcp_object = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject)

		diags.Append(tcp_object.CopyFromPango(ctx, obj.Tcp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject
	if obj.Udp != nil {
		udp_object = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject)

		diags.Append(udp_object.CopyFromPango(ctx, obj.Udp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var any_object *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject
	if obj.Any != nil {
		any_object = new(IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject)

		diags.Append(any_object.CopyFromPango(ctx, obj.Any, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Tcp = tcp_object
	o.Udp = udp_object
	o.Number = number_value
	o.Any = any_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	o.RemotePort = remotePort_value
	o.LocalPort = localPort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var protocol_object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	o.Name = types.StringValue(obj.Name)
	o.Remote = remote_value
	o.Protocol = protocol_object
	o.Local = local_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var any_object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject
	if obj.Any != nil {
		any_object = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject)

		diags.Append(any_object.CopyFromPango(ctx, obj.Any, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject
	if obj.Tcp != nil {
		tcp_object = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject)

		diags.Append(tcp_object.CopyFromPango(ctx, obj.Tcp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_object *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject
	if obj.Udp != nil {
		udp_object = new(IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject)

		diags.Append(udp_object.CopyFromPango(ctx, obj.Udp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func IpsecTunnelDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": IpsecTunnelDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_flow_label": dsschema.BoolAttribute{
				Description: "Copy IPv6 flow label for 6in6 tunnel from inner packet to IPSec packet (not recommended)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_tos": dsschema.BoolAttribute{
				Description: "Copy IP TOS bits from inner packet to IPSec packet (not recommended)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.BoolAttribute{
				Description: "use IPv6 for the IPSec tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor": IpsecTunnelDataSourceTunnelMonitorSchema(),

			"anti_replay": dsschema.BoolAttribute{
				Description: "Enable Anti-Replay check on this tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anti_replay_window": dsschema.StringAttribute{
				Description: "64,128,256,512,1024,2048,4096",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disabled": dsschema.BoolAttribute{
				Description: "Disable the IPSec tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_gre_encapsulation": dsschema.BoolAttribute{
				Description: "allow GRE over IPSec",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_interface": dsschema.StringAttribute{
				Description: "to apply IPSec VPN tunnels to tunnel interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipsec_mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_key": IpsecTunnelDataSourceAutoKeySchema(),

			"global_protect_satellite": IpsecTunnelDataSourceGlobalProtectSatelliteSchema(),

			"manual_key": IpsecTunnelDataSourceManualKeySchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceModel) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceTunnelMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"destination_ip": dsschema.StringAttribute{
				Description: "Destination IP to send ICMP probe",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable tunnel monitoring on this tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": dsschema.StringAttribute{
				Description: "Which proxy-id (or proxy-id-v6) the monitoring traffic will use",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor_profile": dsschema.StringAttribute{
				Description: "monitoring action",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceTunnelMonitorObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceTunnelMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"proxy_id_v6": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyProxyIdV6Schema(),
			},

			"ike_gateway": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyIkeGatewaySchema(),
			},

			"ipsec_crypto_profile": dsschema.StringAttribute{
				Description: "IPSec crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: IpsecTunnelDataSourceAutoKeyProxyIdSchema(),
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyIkeGatewaySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyIkeGatewayObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyIkeGatewaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"number": dsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"any": IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema(),

			"tcp": IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema(),

			"udp": IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("udp"),
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("udp"),
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("udp"),
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema(),

			"local": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": dsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"number": dsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"any": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema(),

			"tcp": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema(),

			"udp": IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceAutoKeyProxyIdV6ProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"external_ca": IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema(),

			"ipv6_preferred": dsschema.BoolAttribute{
				Description: "Prefer to register to portal in ipv6. Only applicable to fqdn portal-address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema(),

			"portal_address": dsschema.StringAttribute{
				Description: "GlobalProtect portal address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"publish_connected_routes": IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema(),

			"publish_routes": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating GlobalProtect gateway certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": dsschema.StringAttribute{
				Description: "GlobalProtect satellite certificate file name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteExternalCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface to communicate with Portal",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema(),

			"ip": IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Floating IPv6 address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("floating_ip"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "specify exact local IPv6 address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatelliteLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable publishing of connected and static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceGlobalProtectSatellitePublishConnectedRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_address": IpsecTunnelDataSourceManualKeyLocalAddressSchema(),

			"local_spi": dsschema.StringAttribute{
				Description: "Outbound SPI, hex format xxxxxxxx. range 00001000 to 1FFFFFFF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_address": IpsecTunnelDataSourceManualKeyPeerAddressSchema(),

			"remote_spi": dsschema.StringAttribute{
				Description: "Inbound SPI, hex format xxxxxxxx.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ah": IpsecTunnelDataSourceManualKeyAhSchema(),

			"esp": IpsecTunnelDataSourceManualKeyEspSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "Tunnel peer IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "Interface to termate tunnel",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": dsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"sha384": IpsecTunnelDataSourceManualKeyAhSha384Schema(),

			"sha512": IpsecTunnelDataSourceManualKeyAhSha512Schema(),

			"md5": IpsecTunnelDataSourceManualKeyAhMd5Schema(),

			"sha1": IpsecTunnelDataSourceManualKeyAhSha1Schema(),

			"sha256": IpsecTunnelDataSourceManualKeyAhSha256Schema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyAhSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyAhSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"authentication": IpsecTunnelDataSourceManualKeyEspAuthenticationSchema(),

			"encryption": IpsecTunnelDataSourceManualKeyEspEncryptionSchema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sha512": IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema(),

			"md5": IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema(),

			"none": IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema(),

			"sha1": IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema(),

			"sha256": IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema(),

			"sha384": IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema(),
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceManualKeyEspEncryptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: des: 2, 3des: 6, aes-128-cbc: 4, aes-192-cbc: 6, aes-256-cbc: 8",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelDataSourceManualKeyEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelDataSourceManualKeyEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelDataSourceLocationSchema() rsschema.Attribute {
	return IpsecTunnelLocationSchema()
}

// Metadata returns the data source type name.
func (d *IpsecTunnelDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ipsec_tunnel"
}

// Schema defines the schema for this data source.
func (d *IpsecTunnelDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = IpsecTunnelDataSourceSchema()
}

// Configure prepares the struct.
func (d *IpsecTunnelDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ipsec.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, ipsec.NewService(d.client), specifier, ipsec.SpecMatches)
}

func (o *IpsecTunnelDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state IpsecTunnelDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ipsec.Location

	if savestate.Location.Template != nil {
		location.Template = &ipsec.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &ipsec.TemplateStackLocation{

			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &IpsecTunnelResource{}
	_ resource.ResourceWithConfigure   = &IpsecTunnelResource{}
	_ resource.ResourceWithImportState = &IpsecTunnelResource{}
)

func NewIpsecTunnelResource() resource.Resource {
	if _, found := resourceFuncMap["panos_ipsec_tunnel"]; !found {
		resourceFuncMap["panos_ipsec_tunnel"] = resourceFuncs{
			CreateImportId: IpsecTunnelImportStateCreator,
		}
	}
	return &IpsecTunnelResource{}
}

type IpsecTunnelResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*ipsec.Entry, ipsec.Location, *ipsec.Service]
}

func IpsecTunnelResourceLocationSchema() rsschema.Attribute {
	return IpsecTunnelLocationSchema()
}

type IpsecTunnelResourceModel struct {
	Location               IpsecTunnelLocation                              `tfsdk:"location"`
	Name                   types.String                                     `tfsdk:"name"`
	AntiReplay             types.Bool                                       `tfsdk:"anti_replay"`
	AntiReplayWindow       types.String                                     `tfsdk:"anti_replay_window"`
	Disabled               types.Bool                                       `tfsdk:"disabled"`
	EnableGreEncapsulation types.Bool                                       `tfsdk:"enable_gre_encapsulation"`
	TunnelInterface        types.String                                     `tfsdk:"tunnel_interface"`
	IpsecMode              types.String                                     `tfsdk:"ipsec_mode"`
	Comment                types.String                                     `tfsdk:"comment"`
	CopyFlowLabel          types.Bool                                       `tfsdk:"copy_flow_label"`
	CopyTos                types.Bool                                       `tfsdk:"copy_tos"`
	Ipv6                   types.Bool                                       `tfsdk:"ipv6"`
	TunnelMonitor          *IpsecTunnelResourceTunnelMonitorObject          `tfsdk:"tunnel_monitor"`
	AutoKey                *IpsecTunnelResourceAutoKeyObject                `tfsdk:"auto_key"`
	GlobalProtectSatellite *IpsecTunnelResourceGlobalProtectSatelliteObject `tfsdk:"global_protect_satellite"`
	ManualKey              *IpsecTunnelResourceManualKeyObject              `tfsdk:"manual_key"`
}
type IpsecTunnelResourceTunnelMonitorObject struct {
	ProxyId              types.String `tfsdk:"proxy_id"`
	TunnelMonitorProfile types.String `tfsdk:"tunnel_monitor_profile"`
	DestinationIp        types.String `tfsdk:"destination_ip"`
	Enable               types.Bool   `tfsdk:"enable"`
}
type IpsecTunnelResourceAutoKeyObject struct {
	IkeGateway         types.List   `tfsdk:"ike_gateway"`
	IpsecCryptoProfile types.String `tfsdk:"ipsec_crypto_profile"`
	ProxyId            types.List   `tfsdk:"proxy_id"`
	ProxyIdV6          types.List   `tfsdk:"proxy_id_v6"`
}
type IpsecTunnelResourceAutoKeyIkeGatewayObject struct {
	Name types.String `tfsdk:"name"`
}
type IpsecTunnelResourceAutoKeyProxyIdObject struct {
	Name     types.String                                     `tfsdk:"name"`
	Local    types.String                                     `tfsdk:"local"`
	Remote   types.String                                     `tfsdk:"remote"`
	Protocol *IpsecTunnelResourceAutoKeyProxyIdProtocolObject `tfsdk:"protocol"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolObject struct {
	Number types.Int64                                         `tfsdk:"number"`
	Any    *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject `tfsdk:"any"`
	Tcp    *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject `tfsdk:"tcp"`
	Udp    *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject `tfsdk:"udp"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject struct {
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6Object struct {
	Name     types.String                                       `tfsdk:"name"`
	Protocol *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject `tfsdk:"protocol"`
	Local    types.String                                       `tfsdk:"local"`
	Remote   types.String                                       `tfsdk:"remote"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject struct {
	Any    *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject `tfsdk:"any"`
	Tcp    *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject `tfsdk:"tcp"`
	Udp    *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject `tfsdk:"udp"`
	Number types.Int64                                           `tfsdk:"number"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject struct {
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject struct {
	LocalPort  types.Int64 `tfsdk:"local_port"`
	RemotePort types.Int64 `tfsdk:"remote_port"`
}
type IpsecTunnelResourceGlobalProtectSatelliteObject struct {
	Ipv6Preferred          types.Bool                                                             `tfsdk:"ipv6_preferred"`
	LocalAddress           *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject           `tfsdk:"local_address"`
	PortalAddress          types.String                                                           `tfsdk:"portal_address"`
	PublishConnectedRoutes *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject `tfsdk:"publish_connected_routes"`
	PublishRoutes          types.List                                                             `tfsdk:"publish_routes"`
	ExternalCa             *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject             `tfsdk:"external_ca"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject struct {
	Interface  types.String                                                           `tfsdk:"interface"`
	FloatingIp *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject `tfsdk:"floating_ip"`
	Ip         *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject         `tfsdk:"ip"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject struct {
	CertificateProfile types.String `tfsdk:"certificate_profile"`
	LocalCertificate   types.String `tfsdk:"local_certificate"`
}
type IpsecTunnelResourceManualKeyObject struct {
	LocalAddress *IpsecTunnelResourceManualKeyLocalAddressObject `tfsdk:"local_address"`
	LocalSpi     types.String                                    `tfsdk:"local_spi"`
	PeerAddress  *IpsecTunnelResourceManualKeyPeerAddressObject  `tfsdk:"peer_address"`
	RemoteSpi    types.String                                    `tfsdk:"remote_spi"`
	Esp          *IpsecTunnelResourceManualKeyEspObject          `tfsdk:"esp"`
	Ah           *IpsecTunnelResourceManualKeyAhObject           `tfsdk:"ah"`
}
type IpsecTunnelResourceManualKeyLocalAddressObject struct {
	Interface  types.String `tfsdk:"interface"`
	FloatingIp types.String `tfsdk:"floating_ip"`
	Ip         types.String `tfsdk:"ip"`
}
type IpsecTunnelResourceManualKeyPeerAddressObject struct {
	Ip types.String `tfsdk:"ip"`
}
type IpsecTunnelResourceManualKeyAhObject struct {
	Md5    *IpsecTunnelResourceManualKeyAhMd5Object    `tfsdk:"md5"`
	Sha1   *IpsecTunnelResourceManualKeyAhSha1Object   `tfsdk:"sha1"`
	Sha256 *IpsecTunnelResourceManualKeyAhSha256Object `tfsdk:"sha256"`
	Sha384 *IpsecTunnelResourceManualKeyAhSha384Object `tfsdk:"sha384"`
	Sha512 *IpsecTunnelResourceManualKeyAhSha512Object `tfsdk:"sha512"`
}
type IpsecTunnelResourceManualKeyAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspObject struct {
	Authentication *IpsecTunnelResourceManualKeyEspAuthenticationObject `tfsdk:"authentication"`
	Encryption     *IpsecTunnelResourceManualKeyEspEncryptionObject     `tfsdk:"encryption"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationObject struct {
	Sha1   *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object   `tfsdk:"sha1"`
	Sha256 *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object `tfsdk:"sha256"`
	Sha384 *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object `tfsdk:"sha384"`
	Sha512 *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object `tfsdk:"sha512"`
	Md5    *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object    `tfsdk:"md5"`
	None   *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject   `tfsdk:"none"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type IpsecTunnelResourceManualKeyEspAuthenticationNoneObject struct {
}
type IpsecTunnelResourceManualKeyEspEncryptionObject struct {
	Key       types.String `tfsdk:"key"`
	Algorithm types.String `tfsdk:"algorithm"`
}

func (r *IpsecTunnelResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ipsec_tunnel"
}

func (r *IpsecTunnelResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func IpsecTunnelResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": IpsecTunnelResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"anti_replay": rsschema.BoolAttribute{
				Description: "Enable Anti-Replay check on this tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anti_replay_window": rsschema.StringAttribute{
				Description: "64,128,256,512,1024,2048,4096",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("1024"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"64",
						"128",
						"256",
						"512",
						"1024",
						"2048",
						"4096",
					}...),
				},
			},

			"disabled": rsschema.BoolAttribute{
				Description: "Disable the IPSec tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_gre_encapsulation": rsschema.BoolAttribute{
				Description: "allow GRE over IPSec",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_interface": rsschema.StringAttribute{
				Description: "to apply IPSec VPN tunnels to tunnel interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipsec_mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("tunnel"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"tunnel",
						"transport",
					}...),
				},
			},

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_flow_label": rsschema.BoolAttribute{
				Description: "Copy IPv6 flow label for 6in6 tunnel from inner packet to IPSec packet (not recommended)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"copy_tos": rsschema.BoolAttribute{
				Description: "Copy IP TOS bits from inner packet to IPSec packet (not recommended)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.BoolAttribute{
				Description: "use IPv6 for the IPSec tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor": IpsecTunnelResourceTunnelMonitorSchema(),

			"auto_key": IpsecTunnelResourceAutoKeySchema(),

			"global_protect_satellite": IpsecTunnelResourceGlobalProtectSatelliteSchema(),

			"manual_key": IpsecTunnelResourceManualKeySchema(),
		},
	}
}

func (o *IpsecTunnelResourceModel) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceTunnelMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"destination_ip": rsschema.StringAttribute{
				Description: "Destination IP to send ICMP probe",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable tunnel monitoring on this tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"proxy_id": rsschema.StringAttribute{
				Description: "Which proxy-id (or proxy-id-v6) the monitoring traffic will use",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tunnel_monitor_profile": rsschema.StringAttribute{
				Description: "monitoring action",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceTunnelMonitorObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceTunnelMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("auto_key"),
				path.MatchRelative().AtParent().AtName("global_protect_satellite"),
				path.MatchRelative().AtParent().AtName("manual_key"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ike_gateway": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyIkeGatewaySchema(),
			},

			"ipsec_crypto_profile": rsschema.StringAttribute{
				Description: "IPSec crypto profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("default"),
			},

			"proxy_id": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyProxyIdSchema(),
			},

			"proxy_id_v6": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: IpsecTunnelResourceAutoKeyProxyIdV6Schema(),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyIkeGatewaySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyIkeGatewaySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelResourceAutoKeyProxyIdProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"number": rsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("number"),
						path.MatchRelative().AtParent().AtName("any"),
						path.MatchRelative().AtParent().AtName("tcp"),
						path.MatchRelative().AtParent().AtName("udp"),
					}...),
				},
			},

			"any": IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema(),

			"tcp": IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema(),

			"udp": IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"local": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents local network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote": rsschema.StringAttribute{
				Description: "IP subnet or IP address represents remote network",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"protocol": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"tcp": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema(),

			"udp": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema(),

			"number": rsschema.Int64Attribute{
				Description: "IP protocol number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"any": IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema(),
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("number"),
				path.MatchRelative().AtParent().AtName("any"),
				path.MatchRelative().AtParent().AtName("tcp"),
				path.MatchRelative().AtParent().AtName("udp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"remote_port": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"external_ca": IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema(),

			"ipv6_preferred": rsschema.BoolAttribute{
				Description: "Prefer to register to portal in ipv6. Only applicable to fqdn portal-address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema(),

			"portal_address": rsschema.StringAttribute{
				Description: "GlobalProtect portal address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"publish_connected_routes": IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema(),

			"publish_routes": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface to communicate with Portal",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema(),

			"ip": IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema(),
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("floating_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Floating IPv6 address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("floating_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "specify exact local IPv6 address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable publishing of connected and static routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating GlobalProtect gateway certificates",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_certificate": rsschema.StringAttribute{
				Description: "GlobalProtect satellite certificate file name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceGlobalProtectSatelliteExternalCaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"remote_spi": rsschema.StringAttribute{
				Description: "Inbound SPI, hex format xxxxxxxx.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": IpsecTunnelResourceManualKeyLocalAddressSchema(),

			"local_spi": rsschema.StringAttribute{
				Description: "Outbound SPI, hex format xxxxxxxx. range 00001000 to 1FFFFFFF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_address": IpsecTunnelResourceManualKeyPeerAddressSchema(),

			"ah": IpsecTunnelResourceManualKeyAhSchema(),

			"esp": IpsecTunnelResourceManualKeyEspSchema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "Interface to termate tunnel",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"floating_ip": rsschema.StringAttribute{
				Description: "Floating IP address in HA Active-Active configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("floating_ip"),
						path.MatchRelative().AtParent().AtName("ip"),
					}...),
				},
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "Tunnel peer IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"md5": IpsecTunnelResourceManualKeyAhMd5Schema(),

			"sha1": IpsecTunnelResourceManualKeyAhSha1Schema(),

			"sha256": IpsecTunnelResourceManualKeyAhSha256Schema(),

			"sha384": IpsecTunnelResourceManualKeyAhSha384Schema(),

			"sha512": IpsecTunnelResourceManualKeyAhSha512Schema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyAhSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyAhSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ah"),
				path.MatchRelative().AtParent().AtName("esp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"authentication": IpsecTunnelResourceManualKeyEspAuthenticationSchema(),

			"encryption": IpsecTunnelResourceManualKeyEspEncryptionSchema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sha512": IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema(),

			"md5": IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema(),

			"none": IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema(),

			"sha1": IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema(),

			"sha256": IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema(),

			"sha384": IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema(),
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func IpsecTunnelResourceManualKeyEspEncryptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("aes-128-cbc"),
			},

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: des: 2, 3des: 6, aes-128-cbc: 4, aes-192-cbc: 6, aes-256-cbc: 8",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := IpsecTunnelResourceManualKeyEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *IpsecTunnelResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = IpsecTunnelResourceSchema()
}

// </ResourceSchema>

func (r *IpsecTunnelResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := ipsec.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, ipsec.NewService(r.client), specifier, ipsec.SpecMatches)
}

func (o *IpsecTunnelResourceModel) CopyToPango(ctx context.Context, obj **ipsec.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tunnelMonitor_entry *ipsec.TunnelMonitor
	if o.TunnelMonitor != nil {
		if *obj != nil && (*obj).TunnelMonitor != nil {
			tunnelMonitor_entry = (*obj).TunnelMonitor
		} else {
			tunnelMonitor_entry = new(ipsec.TunnelMonitor)
		}

		diags.Append(o.TunnelMonitor.CopyToPango(ctx, &tunnelMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	comment_value := o.Comment.ValueStringPointer()
	copyFlowLabel_value := o.CopyFlowLabel.ValueBoolPointer()
	copyTos_value := o.CopyTos.ValueBoolPointer()
	ipv6_value := o.Ipv6.ValueBoolPointer()
	tunnelInterface_value := o.TunnelInterface.ValueStringPointer()
	ipsecMode_value := o.IpsecMode.ValueStringPointer()
	antiReplay_value := o.AntiReplay.ValueBoolPointer()
	antiReplayWindow_value := o.AntiReplayWindow.ValueStringPointer()
	disabled_value := o.Disabled.ValueBoolPointer()
	enableGreEncapsulation_value := o.EnableGreEncapsulation.ValueBoolPointer()
	var globalProtectSatellite_entry *ipsec.GlobalProtectSatellite
	if o.GlobalProtectSatellite != nil {
		if *obj != nil && (*obj).GlobalProtectSatellite != nil {
			globalProtectSatellite_entry = (*obj).GlobalProtectSatellite
		} else {
			globalProtectSatellite_entry = new(ipsec.GlobalProtectSatellite)
		}

		diags.Append(o.GlobalProtectSatellite.CopyToPango(ctx, &globalProtectSatellite_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_entry *ipsec.ManualKey
	if o.ManualKey != nil {
		if *obj != nil && (*obj).ManualKey != nil {
			manualKey_entry = (*obj).ManualKey
		} else {
			manualKey_entry = new(ipsec.ManualKey)
		}

		diags.Append(o.ManualKey.CopyToPango(ctx, &manualKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_entry *ipsec.AutoKey
	if o.AutoKey != nil {
		if *obj != nil && (*obj).AutoKey != nil {
			autoKey_entry = (*obj).AutoKey
		} else {
			autoKey_entry = new(ipsec.AutoKey)
		}

		diags.Append(o.AutoKey.CopyToPango(ctx, &autoKey_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).TunnelMonitor = tunnelMonitor_entry
	(*obj).Comment = comment_value
	(*obj).CopyFlowLabel = copyFlowLabel_value
	(*obj).CopyTos = copyTos_value
	(*obj).Ipv6 = ipv6_value
	(*obj).TunnelInterface = tunnelInterface_value
	(*obj).IpsecMode = ipsecMode_value
	(*obj).AntiReplay = antiReplay_value
	(*obj).AntiReplayWindow = antiReplayWindow_value
	(*obj).Disabled = disabled_value
	(*obj).EnableGreEncapsulation = enableGreEncapsulation_value
	(*obj).GlobalProtectSatellite = globalProtectSatellite_entry
	(*obj).ManualKey = manualKey_entry
	(*obj).AutoKey = autoKey_entry

	return diags
}
func (o *IpsecTunnelResourceTunnelMonitorObject) CopyToPango(ctx context.Context, obj **ipsec.TunnelMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	destinationIp_value := o.DestinationIp.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	proxyId_value := o.ProxyId.ValueStringPointer()
	tunnelMonitorProfile_value := o.TunnelMonitorProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.TunnelMonitor)
	}
	(*obj).DestinationIp = destinationIp_value
	(*obj).Enable = enable_value
	(*obj).ProxyId = proxyId_value
	(*obj).TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	remoteSpi_value := o.RemoteSpi.ValueStringPointer()
	var localAddress_entry *ipsec.ManualKeyLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.ManualKeyLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localSpi_value := o.LocalSpi.ValueStringPointer()
	var peerAddress_entry *ipsec.ManualKeyPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(ipsec.ManualKeyPeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_entry *ipsec.ManualKeyAh
	if o.Ah != nil {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(ipsec.ManualKeyAh)
		}

		diags.Append(o.Ah.CopyToPango(ctx, &ah_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_entry *ipsec.ManualKeyEsp
	if o.Esp != nil {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(ipsec.ManualKeyEsp)
		}

		diags.Append(o.Esp.CopyToPango(ctx, &esp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKey)
	}
	(*obj).RemoteSpi = remoteSpi_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).LocalSpi = localSpi_value
	(*obj).PeerAddress = peerAddress_entry
	(*obj).Ah = ah_entry
	(*obj).Esp = esp_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyPeerAddressObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyPeerAddress)
	}
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyLocalAddressObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	floatingIp_value := o.FloatingIp.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).FloatingIp = floatingIp_value
	(*obj).Ip = ip_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *ipsec.ManualKeyAhMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyAhMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyAhSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyAhSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyAhSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyAhSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *ipsec.ManualKeyAhSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyAhSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyAhSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyAhSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha1Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha256Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha384Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhSha512Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyAhMd5Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *ipsec.ManualKeyEspAuthentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(ipsec.ManualKeyEspAuthentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *ipsec.ManualKeyEspEncryption
	if o.Encryption != nil {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(ipsec.ManualKeyEspEncryption)
		}

		diags.Append(o.Encryption.CopyToPango(ctx, &encryption_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha384_entry *ipsec.ManualKeyEspAuthenticationSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(ipsec.ManualKeyEspAuthenticationSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *ipsec.ManualKeyEspAuthenticationSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(ipsec.ManualKeyEspAuthenticationSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_entry *ipsec.ManualKeyEspAuthenticationMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(ipsec.ManualKeyEspAuthenticationMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *ipsec.ManualKeyEspAuthenticationNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(ipsec.ManualKeyEspAuthenticationNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *ipsec.ManualKeyEspAuthenticationSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(ipsec.ManualKeyEspAuthenticationSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *ipsec.ManualKeyEspAuthenticationSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(ipsec.ManualKeyEspAuthenticationSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthentication)
	}
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).Md5 = md5_entry
	(*obj).None = none_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationNone)
	}

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) CopyToPango(ctx context.Context, obj **ipsec.ManualKeyEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.ManualKeyEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_tf_entries []IpsecTunnelResourceAutoKeyIkeGatewayObject
	var ikeGateway_pango_entries []ipsec.AutoKeyIkeGateway
	{
		d := o.IkeGateway.ElementsAs(ctx, &ikeGateway_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ikeGateway_tf_entries {
			var entry *ipsec.AutoKeyIkeGateway
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ikeGateway_pango_entries = append(ikeGateway_pango_entries, *entry)
		}
	}
	ipsecCryptoProfile_value := o.IpsecCryptoProfile.ValueStringPointer()
	var proxyId_tf_entries []IpsecTunnelResourceAutoKeyProxyIdObject
	var proxyId_pango_entries []ipsec.AutoKeyProxyId
	{
		d := o.ProxyId.ElementsAs(ctx, &proxyId_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyId_tf_entries {
			var entry *ipsec.AutoKeyProxyId
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			proxyId_pango_entries = append(proxyId_pango_entries, *entry)
		}
	}
	var proxyIdV6_tf_entries []IpsecTunnelResourceAutoKeyProxyIdV6Object
	var proxyIdV6_pango_entries []ipsec.AutoKeyProxyIdV6
	{
		d := o.ProxyIdV6.ElementsAs(ctx, &proxyIdV6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range proxyIdV6_tf_entries {
			var entry *ipsec.AutoKeyProxyIdV6
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			proxyIdV6_pango_entries = append(proxyIdV6_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKey)
	}
	(*obj).IkeGateway = ikeGateway_pango_entries
	(*obj).IpsecCryptoProfile = ipsecCryptoProfile_value
	(*obj).ProxyId = proxyId_pango_entries
	(*obj).ProxyIdV6 = proxyIdV6_pango_entries

	return diags
}
func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyIkeGateway, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyIkeGateway)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdProtocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdProtocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyId)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tcp_entry *ipsec.AutoKeyProxyIdProtocolTcp
	if o.Tcp != nil {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdProtocolTcp)
		}

		diags.Append(o.Tcp.CopyToPango(ctx, &tcp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdProtocolUdp
	if o.Udp != nil {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdProtocolUdp)
		}

		diags.Append(o.Udp.CopyToPango(ctx, &udp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdProtocolAny
	if o.Any != nil {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdProtocolAny)
		}

		diags.Append(o.Any.CopyToPango(ctx, &any_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocol)
	}
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry
	(*obj).Number = number_value
	(*obj).Any = any_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	localPort_value := o.LocalPort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdProtocolUdp)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).LocalPort = localPort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	local_value := o.Local.ValueStringPointer()
	remote_value := o.Remote.ValueStringPointer()
	var protocol_entry *ipsec.AutoKeyProxyIdV6Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(ipsec.AutoKeyProxyIdV6Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Local = local_value
	(*obj).Remote = remote_value
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tcp_entry *ipsec.AutoKeyProxyIdV6ProtocolTcp
	if o.Tcp != nil {
		if *obj != nil && (*obj).Tcp != nil {
			tcp_entry = (*obj).Tcp
		} else {
			tcp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
		}

		diags.Append(o.Tcp.CopyToPango(ctx, &tcp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_entry *ipsec.AutoKeyProxyIdV6ProtocolUdp
	if o.Udp != nil {
		if *obj != nil && (*obj).Udp != nil {
			udp_entry = (*obj).Udp
		} else {
			udp_entry = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
		}

		diags.Append(o.Udp.CopyToPango(ctx, &udp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	number_value := o.Number.ValueInt64Pointer()
	var any_entry *ipsec.AutoKeyProxyIdV6ProtocolAny
	if o.Any != nil {
		if *obj != nil && (*obj).Any != nil {
			any_entry = (*obj).Any
		} else {
			any_entry = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
		}

		diags.Append(o.Any.CopyToPango(ctx, &any_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6Protocol)
	}
	(*obj).Tcp = tcp_entry
	(*obj).Udp = udp_entry
	(*obj).Number = number_value
	(*obj).Any = any_entry

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolAny)
	}

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolTcp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) CopyToPango(ctx context.Context, obj **ipsec.AutoKeyProxyIdV6ProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	remotePort_value := o.RemotePort.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ipsec.AutoKeyProxyIdV6ProtocolUdp)
	}
	(*obj).LocalPort = localPort_value
	(*obj).RemotePort = remotePort_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatellite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	portalAddress_value := o.PortalAddress.ValueStringPointer()
	var publishConnectedRoutes_entry *ipsec.GlobalProtectSatellitePublishConnectedRoutes
	if o.PublishConnectedRoutes != nil {
		if *obj != nil && (*obj).PublishConnectedRoutes != nil {
			publishConnectedRoutes_entry = (*obj).PublishConnectedRoutes
		} else {
			publishConnectedRoutes_entry = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
		}

		diags.Append(o.PublishConnectedRoutes.CopyToPango(ctx, &publishConnectedRoutes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	publishRoutes_pango_entries := make([]string, 0)
	diags.Append(o.PublishRoutes.ElementsAs(ctx, &publishRoutes_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var externalCa_entry *ipsec.GlobalProtectSatelliteExternalCa
	if o.ExternalCa != nil {
		if *obj != nil && (*obj).ExternalCa != nil {
			externalCa_entry = (*obj).ExternalCa
		} else {
			externalCa_entry = new(ipsec.GlobalProtectSatelliteExternalCa)
		}

		diags.Append(o.ExternalCa.CopyToPango(ctx, &externalCa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Preferred_value := o.Ipv6Preferred.ValueBoolPointer()
	var localAddress_entry *ipsec.GlobalProtectSatelliteLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(ipsec.GlobalProtectSatelliteLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellite)
	}
	(*obj).PortalAddress = portalAddress_value
	(*obj).PublishConnectedRoutes = publishConnectedRoutes_entry
	(*obj).PublishRoutes = publishRoutes_pango_entries
	(*obj).ExternalCa = externalCa_entry
	(*obj).Ipv6Preferred = ipv6Preferred_value
	(*obj).LocalAddress = localAddress_entry

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteExternalCa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	localCertificate_value := o.LocalCertificate.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteExternalCa)
	}
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).LocalCertificate = localCertificate_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	var ip_entry *ipsec.GlobalProtectSatelliteLocalAddressIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var floatingIp_entry *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp
	if o.FloatingIp != nil {
		if *obj != nil && (*obj).FloatingIp != nil {
			floatingIp_entry = (*obj).FloatingIp
		} else {
			floatingIp_entry = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
		}

		diags.Append(o.FloatingIp.CopyToPango(ctx, &floatingIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_entry
	(*obj).FloatingIp = floatingIp_entry

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv6_value := o.Ipv6.ValueStringPointer()
	ipv4_value := o.Ipv4.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressFloatingIp)
	}
	(*obj).Ipv6 = ipv6_value
	(*obj).Ipv4 = ipv4_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatelliteLocalAddressIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatelliteLocalAddressIp)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyToPango(ctx context.Context, obj **ipsec.GlobalProtectSatellitePublishConnectedRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ipsec.GlobalProtectSatellitePublishConnectedRoutes)
	}
	(*obj).Enable = enable_value

	return diags
}

func (o *IpsecTunnelResourceModel) CopyFromPango(ctx context.Context, obj *ipsec.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var tunnelMonitor_object *IpsecTunnelResourceTunnelMonitorObject
	if obj.TunnelMonitor != nil {
		tunnelMonitor_object = new(IpsecTunnelResourceTunnelMonitorObject)

		diags.Append(tunnelMonitor_object.CopyFromPango(ctx, obj.TunnelMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalProtectSatellite_object *IpsecTunnelResourceGlobalProtectSatelliteObject
	if obj.GlobalProtectSatellite != nil {
		globalProtectSatellite_object = new(IpsecTunnelResourceGlobalProtectSatelliteObject)

		diags.Append(globalProtectSatellite_object.CopyFromPango(ctx, obj.GlobalProtectSatellite, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var manualKey_object *IpsecTunnelResourceManualKeyObject
	if obj.ManualKey != nil {
		manualKey_object = new(IpsecTunnelResourceManualKeyObject)

		diags.Append(manualKey_object.CopyFromPango(ctx, obj.ManualKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var autoKey_object *IpsecTunnelResourceAutoKeyObject
	if obj.AutoKey != nil {
		autoKey_object = new(IpsecTunnelResourceAutoKeyObject)

		diags.Append(autoKey_object.CopyFromPango(ctx, obj.AutoKey, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enableGreEncapsulation_value types.Bool
	if obj.EnableGreEncapsulation != nil {
		enableGreEncapsulation_value = types.BoolValue(*obj.EnableGreEncapsulation)
	}
	var tunnelInterface_value types.String
	if obj.TunnelInterface != nil {
		tunnelInterface_value = types.StringValue(*obj.TunnelInterface)
	}
	var ipsecMode_value types.String
	if obj.IpsecMode != nil {
		ipsecMode_value = types.StringValue(*obj.IpsecMode)
	}
	var antiReplay_value types.Bool
	if obj.AntiReplay != nil {
		antiReplay_value = types.BoolValue(*obj.AntiReplay)
	}
	var antiReplayWindow_value types.String
	if obj.AntiReplayWindow != nil {
		antiReplayWindow_value = types.StringValue(*obj.AntiReplayWindow)
	}
	var disabled_value types.Bool
	if obj.Disabled != nil {
		disabled_value = types.BoolValue(*obj.Disabled)
	}
	var ipv6_value types.Bool
	if obj.Ipv6 != nil {
		ipv6_value = types.BoolValue(*obj.Ipv6)
	}
	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var copyFlowLabel_value types.Bool
	if obj.CopyFlowLabel != nil {
		copyFlowLabel_value = types.BoolValue(*obj.CopyFlowLabel)
	}
	var copyTos_value types.Bool
	if obj.CopyTos != nil {
		copyTos_value = types.BoolValue(*obj.CopyTos)
	}
	o.Name = types.StringValue(obj.Name)
	o.EnableGreEncapsulation = enableGreEncapsulation_value
	o.TunnelInterface = tunnelInterface_value
	o.IpsecMode = ipsecMode_value
	o.AntiReplay = antiReplay_value
	o.AntiReplayWindow = antiReplayWindow_value
	o.Disabled = disabled_value
	o.Ipv6 = ipv6_value
	o.TunnelMonitor = tunnelMonitor_object
	o.Comment = comment_value
	o.CopyFlowLabel = copyFlowLabel_value
	o.CopyTos = copyTos_value
	o.GlobalProtectSatellite = globalProtectSatellite_object
	o.ManualKey = manualKey_object
	o.AutoKey = autoKey_object

	return diags
}

func (o *IpsecTunnelResourceTunnelMonitorObject) CopyFromPango(ctx context.Context, obj *ipsec.TunnelMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var destinationIp_value types.String
	if obj.DestinationIp != nil {
		destinationIp_value = types.StringValue(*obj.DestinationIp)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var proxyId_value types.String
	if obj.ProxyId != nil {
		proxyId_value = types.StringValue(*obj.ProxyId)
	}
	var tunnelMonitorProfile_value types.String
	if obj.TunnelMonitorProfile != nil {
		tunnelMonitorProfile_value = types.StringValue(*obj.TunnelMonitorProfile)
	}
	o.DestinationIp = destinationIp_value
	o.Enable = enable_value
	o.ProxyId = proxyId_value
	o.TunnelMonitorProfile = tunnelMonitorProfile_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ikeGateway_list types.List
	{
		var ikeGateway_tf_entries []IpsecTunnelResourceAutoKeyIkeGatewayObject
		for _, elt := range obj.IkeGateway {
			var entry IpsecTunnelResourceAutoKeyIkeGatewayObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ikeGateway_tf_entries = append(ikeGateway_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ike_gateway")
		ikeGateway_list, list_diags = types.ListValueFrom(ctx, schemaType, ikeGateway_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyId_list types.List
	{
		var proxyId_tf_entries []IpsecTunnelResourceAutoKeyProxyIdObject
		for _, elt := range obj.ProxyId {
			var entry IpsecTunnelResourceAutoKeyProxyIdObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			proxyId_tf_entries = append(proxyId_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id")
		proxyId_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyId_tf_entries)
		diags.Append(list_diags...)
	}
	var proxyIdV6_list types.List
	{
		var proxyIdV6_tf_entries []IpsecTunnelResourceAutoKeyProxyIdV6Object
		for _, elt := range obj.ProxyIdV6 {
			var entry IpsecTunnelResourceAutoKeyProxyIdV6Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			proxyIdV6_tf_entries = append(proxyIdV6_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("proxy_id_v6")
		proxyIdV6_list, list_diags = types.ListValueFrom(ctx, schemaType, proxyIdV6_tf_entries)
		diags.Append(list_diags...)
	}

	var ipsecCryptoProfile_value types.String
	if obj.IpsecCryptoProfile != nil {
		ipsecCryptoProfile_value = types.StringValue(*obj.IpsecCryptoProfile)
	}
	o.IkeGateway = ikeGateway_list
	o.IpsecCryptoProfile = ipsecCryptoProfile_value
	o.ProxyId = proxyId_list
	o.ProxyIdV6 = proxyIdV6_list

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyId, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var protocol_object *IpsecTunnelResourceAutoKeyProxyIdProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IpsecTunnelResourceAutoKeyProxyIdProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Protocol = protocol_object
	o.Local = local_value
	o.Remote = remote_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var any_object *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject
	if obj.Any != nil {
		any_object = new(IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject)

		diags.Append(any_object.CopyFromPango(ctx, obj.Any, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_object *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject
	if obj.Tcp != nil {
		tcp_object = new(IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject)

		diags.Append(tcp_object.CopyFromPango(ctx, obj.Tcp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var udp_object *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject
	if obj.Udp != nil {
		udp_object = new(IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject)

		diags.Append(udp_object.CopyFromPango(ctx, obj.Udp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object
	o.Udp = udp_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolTcpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolUdpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdProtocolAnyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6Object) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var protocol_object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var local_value types.String
	if obj.Local != nil {
		local_value = types.StringValue(*obj.Local)
	}
	var remote_value types.String
	if obj.Remote != nil {
		remote_value = types.StringValue(*obj.Remote)
	}
	o.Name = types.StringValue(obj.Name)
	o.Protocol = protocol_object
	o.Local = local_value
	o.Remote = remote_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var udp_object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject
	if obj.Udp != nil {
		udp_object = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject)

		diags.Append(udp_object.CopyFromPango(ctx, obj.Udp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var any_object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject
	if obj.Any != nil {
		any_object = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject)

		diags.Append(any_object.CopyFromPango(ctx, obj.Any, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var tcp_object *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject
	if obj.Tcp != nil {
		tcp_object = new(IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject)

		diags.Append(tcp_object.CopyFromPango(ctx, obj.Tcp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var number_value types.Int64
	if obj.Number != nil {
		number_value = types.Int64Value(*obj.Number)
	}
	o.Udp = udp_object
	o.Number = number_value
	o.Any = any_object
	o.Tcp = tcp_object

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolAnyObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolAny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolTcpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolTcp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyProxyIdV6ProtocolUdpObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyProxyIdV6ProtocolUdp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.LocalPort = localPort_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *IpsecTunnelResourceAutoKeyIkeGatewayObject) CopyFromPango(ctx context.Context, obj *ipsec.AutoKeyIkeGateway, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatellite, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var publishRoutes_list types.List
	{
		var list_diags diag.Diagnostics
		publishRoutes_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PublishRoutes)
		diags.Append(list_diags...)
	}
	var localAddress_object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var publishConnectedRoutes_object *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject
	if obj.PublishConnectedRoutes != nil {
		publishConnectedRoutes_object = new(IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject)

		diags.Append(publishConnectedRoutes_object.CopyFromPango(ctx, obj.PublishConnectedRoutes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var externalCa_object *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject
	if obj.ExternalCa != nil {
		externalCa_object = new(IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject)

		diags.Append(externalCa_object.CopyFromPango(ctx, obj.ExternalCa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var portalAddress_value types.String
	if obj.PortalAddress != nil {
		portalAddress_value = types.StringValue(*obj.PortalAddress)
	}
	var ipv6Preferred_value types.Bool
	if obj.Ipv6Preferred != nil {
		ipv6Preferred_value = types.BoolValue(*obj.Ipv6Preferred)
	}
	o.LocalAddress = localAddress_object
	o.PortalAddress = portalAddress_value
	o.PublishConnectedRoutes = publishConnectedRoutes_object
	o.PublishRoutes = publishRoutes_list
	o.ExternalCa = externalCa_object
	o.Ipv6Preferred = ipv6Preferred_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var floatingIp_object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject
	if obj.FloatingIp != nil {
		floatingIp_object = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject)

		diags.Append(floatingIp_object.CopyFromPango(ctx, obj.FloatingIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_object *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject
	if obj.Ip != nil {
		ip_object = new(IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Interface = interface_value
	o.FloatingIp = floatingIp_object
	o.Ip = ip_object

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressFloatingIpObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddressFloatingIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteLocalAddressIpObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteLocalAddressIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatellitePublishConnectedRoutesObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatellitePublishConnectedRoutes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *IpsecTunnelResourceGlobalProtectSatelliteExternalCaObject) CopyFromPango(ctx context.Context, obj *ipsec.GlobalProtectSatelliteExternalCa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var localCertificate_value types.String
	if obj.LocalCertificate != nil {
		localCertificate_value = types.StringValue(*obj.LocalCertificate)
	}
	o.CertificateProfile = certificateProfile_value
	o.LocalCertificate = localCertificate_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKey, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_object *IpsecTunnelResourceManualKeyLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(IpsecTunnelResourceManualKeyLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *IpsecTunnelResourceManualKeyPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(IpsecTunnelResourceManualKeyPeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_object *IpsecTunnelResourceManualKeyAhObject
	if obj.Ah != nil {
		ah_object = new(IpsecTunnelResourceManualKeyAhObject)

		diags.Append(ah_object.CopyFromPango(ctx, obj.Ah, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var esp_object *IpsecTunnelResourceManualKeyEspObject
	if obj.Esp != nil {
		esp_object = new(IpsecTunnelResourceManualKeyEspObject)

		diags.Append(esp_object.CopyFromPango(ctx, obj.Esp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var localSpi_value types.String
	if obj.LocalSpi != nil {
		localSpi_value = types.StringValue(*obj.LocalSpi)
	}
	var remoteSpi_value types.String
	if obj.RemoteSpi != nil {
		remoteSpi_value = types.StringValue(*obj.RemoteSpi)
	}
	o.LocalAddress = localAddress_object
	o.LocalSpi = localSpi_value
	o.PeerAddress = peerAddress_object
	o.RemoteSpi = remoteSpi_value
	o.Ah = ah_object
	o.Esp = esp_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyLocalAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var floatingIp_value types.String
	if obj.FloatingIp != nil {
		floatingIp_value = types.StringValue(*obj.FloatingIp)
	}
	o.Interface = interface_value
	o.Ip = ip_value
	o.FloatingIp = floatingIp_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyPeerAddressObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Ip = ip_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha256_object *IpsecTunnelResourceManualKeyAhSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(IpsecTunnelResourceManualKeyAhSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *IpsecTunnelResourceManualKeyAhSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(IpsecTunnelResourceManualKeyAhSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *IpsecTunnelResourceManualKeyAhSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(IpsecTunnelResourceManualKeyAhSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_object *IpsecTunnelResourceManualKeyAhMd5Object
	if obj.Md5 != nil {
		md5_object = new(IpsecTunnelResourceManualKeyAhMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *IpsecTunnelResourceManualKeyAhSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(IpsecTunnelResourceManualKeyAhSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.Md5 = md5_object
	o.Sha1 = sha1_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhMd5Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha1Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha256Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha384Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyAhSha512Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_object *IpsecTunnelResourceManualKeyEspAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(IpsecTunnelResourceManualKeyEspAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_object *IpsecTunnelResourceManualKeyEspEncryptionObject
	if obj.Encryption != nil {
		encryption_object = new(IpsecTunnelResourceManualKeyEspEncryptionObject)

		diags.Append(encryption_object.CopyFromPango(ctx, obj.Encryption, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspEncryptionObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	o.Key = key_value
	o.Algorithm = algorithm_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_object *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object
	if obj.Md5 != nil {
		md5_object = new(IpsecTunnelResourceManualKeyEspAuthenticationMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject
	if obj.None != nil {
		none_object = new(IpsecTunnelResourceManualKeyEspAuthenticationNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(IpsecTunnelResourceManualKeyEspAuthenticationSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(IpsecTunnelResourceManualKeyEspAuthenticationSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(IpsecTunnelResourceManualKeyEspAuthenticationSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(IpsecTunnelResourceManualKeyEspAuthenticationSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.None = none_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *IpsecTunnelResourceManualKeyEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, obj *ipsec.ManualKeyEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (r *IpsecTunnelResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location ipsec.Location

	if state.Location.Template != nil {
		location.Template = &ipsec.TemplateLocation{

			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ipsec.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *ipsec.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (o *IpsecTunnelResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ipsec.Location

	if savestate.Location.Template != nil {
		location.Template = &ipsec.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &ipsec.TemplateStackLocation{

			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *IpsecTunnelResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location ipsec.Location

	if state.Location.Template != nil {
		location.Template = &ipsec.TemplateLocation{

			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ipsec.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *IpsecTunnelResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state IpsecTunnelResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ipsec_tunnel_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location ipsec.Location

	if state.Location.Template != nil {
		location.Template = &ipsec.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &ipsec.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type IpsecTunnelImportState struct {
	Location IpsecTunnelLocation `json:"location"`
	Name     string              `json:"name"`
}

func IpsecTunnelImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location IpsecTunnelLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := IpsecTunnelImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *IpsecTunnelResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj IpsecTunnelImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type IpsecTunnelTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IpsecTunnelTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type IpsecTunnelLocation struct {
	Template      *IpsecTunnelTemplateLocation      `tfsdk:"template"`
	TemplateStack *IpsecTunnelTemplateStackLocation `tfsdk:"template_stack"`
}

func IpsecTunnelLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("template"),
					}...),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o IpsecTunnelTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o IpsecTunnelTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice     *string `json:"ngfw_device"`
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice     *string `json:"ngfw_device"`
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o IpsecTunnelLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Template      *IpsecTunnelTemplateLocation      `json:"template"`
		TemplateStack *IpsecTunnelTemplateStackLocation `json:"template_stack"`
	}{
		Template:      o.Template,
		TemplateStack: o.TemplateStack,
	}

	return json.Marshal(obj)
}

func (o *IpsecTunnelLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template      *IpsecTunnelTemplateLocation      `json:"template"`
		TemplateStack *IpsecTunnelTemplateStackLocation `json:"template_stack"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Template = shadow.Template
	o.TemplateStack = shadow.TemplateStack

	return nil
}
