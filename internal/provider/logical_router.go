package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/logical_router"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &LogicalRouterDataSource{}
	_ datasource.DataSourceWithConfigure = &LogicalRouterDataSource{}
)

func NewLogicalRouterDataSource() datasource.DataSource {
	return &LogicalRouterDataSource{}
}

type LogicalRouterDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service]
}

type LogicalRouterDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type LogicalRouterDataSourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Vrf      types.List   `tfsdk:"vrf"`
}
type LogicalRouterDataSourceVrfObject struct {
	Name                    types.String `tfsdk:"name"`
	Interface               types.List   `tfsdk:"interface"`
	AdministrativeDistances types.Object `tfsdk:"administrative_distances"`
	RibFilter               types.Object `tfsdk:"rib_filter"`
	Bgp                     types.Object `tfsdk:"bgp"`
	RoutingTable            types.Object `tfsdk:"routing_table"`
	Ospf                    types.Object `tfsdk:"ospf"`
	Ospfv3                  types.Object `tfsdk:"ospfv3"`
	Ecmp                    types.Object `tfsdk:"ecmp"`
	Multicast               types.Object `tfsdk:"multicast"`
	Rip                     types.Object `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfAdministrativeDistancesObject struct {
	Static      types.Int64 `tfsdk:"static"`
	StaticIpv6  types.Int64 `tfsdk:"static_ipv6"`
	OspfInter   types.Int64 `tfsdk:"ospf_inter"`
	OspfIntra   types.Int64 `tfsdk:"ospf_intra"`
	OspfExt     types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Inter types.Int64 `tfsdk:"ospfv3_inter"`
	Ospfv3Intra types.Int64 `tfsdk:"ospfv3_intra"`
	Ospfv3Ext   types.Int64 `tfsdk:"ospfv3_ext"`
	BgpInternal types.Int64 `tfsdk:"bgp_internal"`
	BgpExternal types.Int64 `tfsdk:"bgp_external"`
	BgpLocal    types.Int64 `tfsdk:"bgp_local"`
	Rip         types.Int64 `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfRibFilterObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4Object struct {
	Static types.Object `tfsdk:"static"`
	Bgp    types.Object `tfsdk:"bgp"`
	Ospf   types.Object `tfsdk:"ospf"`
	Rip    types.Object `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4OspfObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4RipObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6Object struct {
	Static types.Object `tfsdk:"static"`
	Bgp    types.Object `tfsdk:"bgp"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfBgpObject struct {
	Enable                      types.Bool   `tfsdk:"enable"`
	RouterId                    types.String `tfsdk:"router_id"`
	LocalAs                     types.String `tfsdk:"local_as"`
	InstallRoute                types.Bool   `tfsdk:"install_route"`
	EnforceFirstAs              types.Bool   `tfsdk:"enforce_first_as"`
	FastExternalFailover        types.Bool   `tfsdk:"fast_external_failover"`
	EcmpMultiAs                 types.Bool   `tfsdk:"ecmp_multi_as"`
	DefaultLocalPreference      types.Int64  `tfsdk:"default_local_preference"`
	GracefulShutdown            types.Bool   `tfsdk:"graceful_shutdown"`
	AlwaysAdvertiseNetworkRoute types.Bool   `tfsdk:"always_advertise_network_route"`
	Med                         types.Object `tfsdk:"med"`
	GracefulRestart             types.Object `tfsdk:"graceful_restart"`
	GlobalBfd                   types.Object `tfsdk:"global_bfd"`
	RedistributionProfile       types.Object `tfsdk:"redistribution_profile"`
	AdvertiseNetwork            types.Object `tfsdk:"advertise_network"`
	PeerGroup                   types.List   `tfsdk:"peer_group"`
	AggregateRoutes             types.List   `tfsdk:"aggregate_routes"`
}
type LogicalRouterDataSourceVrfBgpMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type LogicalRouterDataSourceVrfBgpGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
}
type LogicalRouterDataSourceVrfBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject struct {
	Name      types.String `tfsdk:"name"`
	Unicast   types.Bool   `tfsdk:"unicast"`
	Multicast types.Bool   `tfsdk:"multicast"`
	Backdoor  types.Bool   `tfsdk:"backdoor"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject struct {
	Name    types.String `tfsdk:"name"`
	Unicast types.Bool   `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupObject struct {
	Name              types.String `tfsdk:"name"`
	Enable            types.Bool   `tfsdk:"enable"`
	Type              types.Object `tfsdk:"type"`
	AddressFamily     types.Object `tfsdk:"address_family"`
	FilteringProfile  types.Object `tfsdk:"filtering_profile"`
	ConnectionOptions types.Object `tfsdk:"connection_options"`
	Peer              types.List   `tfsdk:"peer"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeObject struct {
	Ibgp types.Object `tfsdk:"ibgp"`
	Ebgp types.Object `tfsdk:"ebgp"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.Int64  `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerObject struct {
	Name                          types.String `tfsdk:"name"`
	Enable                        types.Bool   `tfsdk:"enable"`
	Passive                       types.Bool   `tfsdk:"passive"`
	PeerAs                        types.String `tfsdk:"peer_as"`
	EnableSenderSideLoopDetection types.Bool   `tfsdk:"enable_sender_side_loop_detection"`
	Inherit                       types.Object `tfsdk:"inherit"`
	LocalAddress                  types.Object `tfsdk:"local_address"`
	PeerAddress                   types.Object `tfsdk:"peer_address"`
	ConnectionOptions             types.Object `tfsdk:"connection_options"`
	Bfd                           types.Object `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject struct {
	Yes types.Object `tfsdk:"yes"`
	No  types.Object `tfsdk:"no"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject struct {
	AddressFamily    types.Object `tfsdk:"address_family"`
	FilteringProfile types.Object `tfsdk:"filtering_profile"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.String `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesObject struct {
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Enable      types.Bool   `tfsdk:"enable"`
	SummaryOnly types.Bool   `tfsdk:"summary_only"`
	AsSet       types.Bool   `tfsdk:"as_set"`
	SameMed     types.Bool   `tfsdk:"same_med"`
	Type        types.Object `tfsdk:"type"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterDataSourceVrfRoutingTableObject struct {
	Ip   types.Object `tfsdk:"ip"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject struct {
	Name                   types.String `tfsdk:"name"`
	Destination            types.String `tfsdk:"destination"`
	Interface              types.String `tfsdk:"interface"`
	AdministrativeDistance types.Int64  `tfsdk:"administrative_distance"`
	Metric                 types.Int64  `tfsdk:"metric"`
	Nexthop                types.Object `tfsdk:"nexthop"`
	Bfd                    types.Object `tfsdk:"bfd"`
	PathMonitor            types.Object `tfsdk:"path_monitor"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject struct {
	Discard   types.Object `tfsdk:"discard"`
	IpAddress types.String `tfsdk:"ip_address"`
	NextLr    types.String `tfsdk:"next_lr"`
	Fqdn      types.String `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String `tfsdk:"name"`
	Destination            types.String `tfsdk:"destination"`
	Interface              types.String `tfsdk:"interface"`
	AdministrativeDistance types.Int64  `tfsdk:"administrative_distance"`
	Metric                 types.Int64  `tfsdk:"metric"`
	Nexthop                types.Object `tfsdk:"nexthop"`
	Bfd                    types.Object `tfsdk:"bfd"`
	PathMonitor            types.Object `tfsdk:"path_monitor"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject struct {
	Discard     types.Object `tfsdk:"discard"`
	Ipv6Address types.String `tfsdk:"ipv6_address"`
	Fqdn        types.String `tfsdk:"fqdn"`
	NextLr      types.String `tfsdk:"next_lr"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterDataSourceVrfOspfObject struct {
	RouterId              types.String `tfsdk:"router_id"`
	Enable                types.Bool   `tfsdk:"enable"`
	Rfc1583               types.Bool   `tfsdk:"rfc1583"`
	SpfTimer              types.String `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String `tfsdk:"global_if_timer"`
	RedistributionProfile types.String `tfsdk:"redistribution_profile"`
	GlobalBfd             types.Object `tfsdk:"global_bfd"`
	GracefulRestart       types.Object `tfsdk:"graceful_restart"`
	Area                  types.List   `tfsdk:"area"`
}
type LogicalRouterDataSourceVrfOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterDataSourceVrfOspfAreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNormalObject struct {
	Abr types.Object `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeStubObject struct {
	NoSummary          types.Bool   `tfsdk:"no_summary"`
	Abr                types.Object `tfsdk:"abr"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaObject struct {
	NoSummary                   types.Bool   `tfsdk:"no_summary"`
	DefaultInformationOriginate types.Object `tfsdk:"default_information_originate"`
	Abr                         types.Object `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	MtuIgnore      types.Bool   `tfsdk:"mtu_ignore"`
	Passive        types.Bool   `tfsdk:"passive"`
	Priority       types.Int64  `tfsdk:"priority"`
	Metric         types.Int64  `tfsdk:"metric"`
	Authentication types.String `tfsdk:"authentication"`
	Timing         types.String `tfsdk:"timing"`
	LinkType       types.Object `tfsdk:"link_type"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3Object struct {
	Enable                types.Bool   `tfsdk:"enable"`
	RouterId              types.String `tfsdk:"router_id"`
	DisableTransitTraffic types.Bool   `tfsdk:"disable_transit_traffic"`
	SpfTimer              types.String `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String `tfsdk:"global_if_timer"`
	RedistributionProfile types.String `tfsdk:"redistribution_profile"`
	GlobalBfd             types.Object `tfsdk:"global_bfd"`
	GracefulRestart       types.Object `tfsdk:"graceful_restart"`
	Area                  types.List   `tfsdk:"area"`
}
type LogicalRouterDataSourceVrfOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterDataSourceVrfOspfv3AreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject struct {
	Abr types.Object `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject struct {
	NoSummary          types.Bool   `tfsdk:"no_summary"`
	Abr                types.Object `tfsdk:"abr"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject struct {
	NoSummary                   types.Bool   `tfsdk:"no_summary"`
	DefaultInformationOriginate types.Object `tfsdk:"default_information_originate"`
	Abr                         types.Object `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	MtuIgnore      types.Bool   `tfsdk:"mtu_ignore"`
	Passive        types.Bool   `tfsdk:"passive"`
	Priority       types.Int64  `tfsdk:"priority"`
	Metric         types.Int64  `tfsdk:"metric"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Authentication types.String `tfsdk:"authentication"`
	Timing         types.String `tfsdk:"timing"`
	LinkType       types.Object `tfsdk:"link_type"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
}
type LogicalRouterDataSourceVrfEcmpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	MaxPaths         types.Int64  `tfsdk:"max_paths"`
	SymmetricReturn  types.Bool   `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool   `tfsdk:"strict_source_path"`
	Algorithm        types.Object `tfsdk:"algorithm"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmObject struct {
	IpModulo           types.Object `tfsdk:"ip_modulo"`
	IpHash             types.Object `tfsdk:"ip_hash"`
	WeightedRoundRobin types.Object `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin types.Object `tfsdk:"balanced_round_robin"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject struct {
}
type LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject struct {
}
type LogicalRouterDataSourceVrfMulticastObject struct {
	Enable      types.Bool   `tfsdk:"enable"`
	StaticRoute types.List   `tfsdk:"static_route"`
	Pim         types.Object `tfsdk:"pim"`
	Igmp        types.Object `tfsdk:"igmp"`
	Msdp        types.Object `tfsdk:"msdp"`
}
type LogicalRouterDataSourceVrfMulticastStaticRouteObject struct {
	Name        types.String `tfsdk:"name"`
	Destination types.String `tfsdk:"destination"`
	Interface   types.String `tfsdk:"interface"`
	Preference  types.Int64  `tfsdk:"preference"`
	Nexthop     types.Object `tfsdk:"nexthop"`
}
type LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
}
type LogicalRouterDataSourceVrfMulticastPimObject struct {
	Enable          types.Bool   `tfsdk:"enable"`
	RpfLookupMode   types.String `tfsdk:"rpf_lookup_mode"`
	RouteAgeoutTime types.Int64  `tfsdk:"route_ageout_time"`
	IfTimerGlobal   types.String `tfsdk:"if_timer_global"`
	GroupPermission types.String `tfsdk:"group_permission"`
	SsmAddressSpace types.Object `tfsdk:"ssm_address_space"`
	Rp              types.Object `tfsdk:"rp"`
	SptThreshold    types.List   `tfsdk:"spt_threshold"`
	Interface       types.List   `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject struct {
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpObject struct {
	LocalRp    types.Object `tfsdk:"local_rp"`
	ExternalRp types.List   `tfsdk:"external_rp"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject struct {
	StaticRp    types.Object `tfsdk:"static_rp"`
	CandidateRp types.Object `tfsdk:"candidate_rp"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject struct {
	Interface types.String `tfsdk:"interface"`
	Address   types.String `tfsdk:"address"`
	Override  types.Bool   `tfsdk:"override"`
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject struct {
	Interface             types.String `tfsdk:"interface"`
	Address               types.String `tfsdk:"address"`
	Priority              types.Int64  `tfsdk:"priority"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupList             types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject struct {
	Name      types.String `tfsdk:"name"`
	GroupList types.String `tfsdk:"group_list"`
	Override  types.Bool   `tfsdk:"override"`
}
type LogicalRouterDataSourceVrfMulticastPimSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type LogicalRouterDataSourceVrfMulticastPimInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Description    types.String `tfsdk:"description"`
	DrPriority     types.Int64  `tfsdk:"dr_priority"`
	SendBsm        types.Bool   `tfsdk:"send_bsm"`
	IfTimer        types.String `tfsdk:"if_timer"`
	NeighborFilter types.String `tfsdk:"neighbor_filter"`
}
type LogicalRouterDataSourceVrfMulticastIgmpObject struct {
	Enable  types.Bool   `tfsdk:"enable"`
	Dynamic types.Object `tfsdk:"dynamic"`
	Static  types.List   `tfsdk:"static"`
}
type LogicalRouterDataSourceVrfMulticastIgmpDynamicObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject struct {
	Name                types.String `tfsdk:"name"`
	Version             types.String `tfsdk:"version"`
	Robustness          types.String `tfsdk:"robustness"`
	GroupFilter         types.String `tfsdk:"group_filter"`
	MaxGroups           types.String `tfsdk:"max_groups"`
	MaxSources          types.String `tfsdk:"max_sources"`
	QueryProfile        types.String `tfsdk:"query_profile"`
	RouterAlertPolicing types.Bool   `tfsdk:"router_alert_policing"`
}
type LogicalRouterDataSourceVrfMulticastIgmpStaticObject struct {
	Name          types.String `tfsdk:"name"`
	Interface     types.String `tfsdk:"interface"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
}
type LogicalRouterDataSourceVrfMulticastMsdpObject struct {
	Enable               types.Bool   `tfsdk:"enable"`
	GlobalTimer          types.String `tfsdk:"global_timer"`
	GlobalAuthentication types.String `tfsdk:"global_authentication"`
	OriginatorId         types.Object `tfsdk:"originator_id"`
	Peer                 types.List   `tfsdk:"peer"`
}
type LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerObject struct {
	Name             types.String `tfsdk:"name"`
	Enable           types.Bool   `tfsdk:"enable"`
	PeerAs           types.String `tfsdk:"peer_as"`
	Authentication   types.String `tfsdk:"authentication"`
	MaxSa            types.Int64  `tfsdk:"max_sa"`
	InboundSaFilter  types.String `tfsdk:"inbound_sa_filter"`
	OutboundSaFilter types.String `tfsdk:"outbound_sa_filter"`
	LocalAddress     types.Object `tfsdk:"local_address"`
	PeerAddress      types.Object `tfsdk:"peer_address"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfRipObject struct {
	Enable                       types.Bool   `tfsdk:"enable"`
	DefaultInformationOriginate  types.Bool   `tfsdk:"default_information_originate"`
	GlobalTimer                  types.String `tfsdk:"global_timer"`
	AuthProfile                  types.String `tfsdk:"auth_profile"`
	RedistributionProfile        types.String `tfsdk:"redistribution_profile"`
	GlobalBfd                    types.Object `tfsdk:"global_bfd"`
	GlobalInboundDistributeList  types.Object `tfsdk:"global_inbound_distribute_list"`
	GlobalOutboundDistributeList types.Object `tfsdk:"global_outbound_distribute_list"`
	Interfaces                   types.List   `tfsdk:"interfaces"`
}
type LogicalRouterDataSourceVrfRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterDataSourceVrfRipInterfacesObject struct {
	Name                            types.String `tfsdk:"name"`
	Enable                          types.Bool   `tfsdk:"enable"`
	Mode                            types.String `tfsdk:"mode"`
	SplitHorizon                    types.String `tfsdk:"split_horizon"`
	Authentication                  types.String `tfsdk:"authentication"`
	Bfd                             types.Object `tfsdk:"bfd"`
	InterfaceInboundDistributeList  types.Object `tfsdk:"interface_inbound_distribute_list"`
	InterfaceOutboundDistributeList types.Object `tfsdk:"interface_outbound_distribute_list"`
}
type LogicalRouterDataSourceVrfRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}
type LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}

func (o *LogicalRouterDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj LogicalRouterLocation

	var vrfObj *LogicalRouterDataSourceVrfObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"vrf": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: vrfObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceModel) AncestorName() string {
	return ""
}

func (o LogicalRouterDataSourceModel) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfObject) AttributeTypes() map[string]attr.Type {

	var administrativeDistancesObj *LogicalRouterDataSourceVrfAdministrativeDistancesObject

	var ribFilterObj *LogicalRouterDataSourceVrfRibFilterObject

	var bgpObj *LogicalRouterDataSourceVrfBgpObject

	var routingTableObj *LogicalRouterDataSourceVrfRoutingTableObject

	var ospfObj *LogicalRouterDataSourceVrfOspfObject

	var ospfv3Obj *LogicalRouterDataSourceVrfOspfv3Object

	var ecmpObj *LogicalRouterDataSourceVrfEcmpObject

	var multicastObj *LogicalRouterDataSourceVrfMulticastObject

	var ripObj *LogicalRouterDataSourceVrfRipObject
	return map[string]attr.Type{
		"name": types.StringType,
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"rib_filter": types.ObjectType{
			AttrTypes: ribFilterObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"routing_table": types.ObjectType{
			AttrTypes: routingTableObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfObject) AncestorName() string {
	return "vrf"
}

func (o LogicalRouterDataSourceVrfObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static":       types.Int64Type,
		"static_ipv6":  types.Int64Type,
		"ospf_inter":   types.Int64Type,
		"ospf_intra":   types.Int64Type,
		"ospf_ext":     types.Int64Type,
		"ospfv3_inter": types.Int64Type,
		"ospfv3_intra": types.Int64Type,
		"ospfv3_ext":   types.Int64Type,
		"bgp_internal": types.Int64Type,
		"bgp_external": types.Int64Type,
		"bgp_local":    types.Int64Type,
		"rip":          types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o LogicalRouterDataSourceVrfAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfRibFilterIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfRibFilterIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterObject) AncestorName() string {
	return "rib-filter"
}

func (o LogicalRouterDataSourceVrfRibFilterObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject

	var bgpObj *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject

	var ospfObj *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject

	var ripObj *LogicalRouterDataSourceVrfRibFilterIpv4RipObject
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4RipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4RipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject

	var bgpObj *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject

	var ospfv3Obj *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpObject) AttributeTypes() map[string]attr.Type {

	var medObj *LogicalRouterDataSourceVrfBgpMedObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfBgpGracefulRestartObject

	var globalBfdObj *LogicalRouterDataSourceVrfBgpGlobalBfdObject

	var redistributionProfileObj *LogicalRouterDataSourceVrfBgpRedistributionProfileObject

	var advertiseNetworkObj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject

	var peerGroupObj *LogicalRouterDataSourceVrfBgpPeerGroupObject

	var aggregateRoutesObj *LogicalRouterDataSourceVrfBgpAggregateRoutesObject
	return map[string]attr.Type{
		"enable":                         types.BoolType,
		"router_id":                      types.StringType,
		"local_as":                       types.StringType,
		"install_route":                  types.BoolType,
		"enforce_first_as":               types.BoolType,
		"fast_external_failover":         types.BoolType,
		"ecmp_multi_as":                  types.BoolType,
		"default_local_preference":       types.Int64Type,
		"graceful_shutdown":              types.BoolType,
		"always_advertise_network_route": types.BoolType,
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"redistribution_profile": types.ObjectType{
			AttrTypes: redistributionProfileObj.AttributeTypes(),
		},
		"advertise_network": types.ObjectType{
			AttrTypes: advertiseNetworkObj.AttributeTypes(),
		},
		"peer_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerGroupObj.AttributeTypes(),
			},
		},
		"aggregate_routes": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: aggregateRoutesObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfBgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpMedObject) AncestorName() string {
	return "med"
}

func (o LogicalRouterDataSourceVrfBgpMedObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"stale_route_time":      types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"local_restart_time":    types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfBgpGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfBgpGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileObject) AncestorName() string {
	return "redistribution-profile"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) AncestorName() string {
	return "advertise-network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) AttributeTypes() map[string]attr.Type {

	var networkObj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	return map[string]attr.Type{
		"network": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: networkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
		"backdoor":  types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) AttributeTypes() map[string]attr.Type {

	var networkObj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	return map[string]attr.Type{
		"network": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: networkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":    types.StringType,
		"unicast": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject

	var addressFamilyObj *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject

	var filteringProfileObj *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject

	var connectionOptionsObj *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject

	var peerObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject

	var ebgpObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.Int64Type,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var inheritObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject

	var localAddressObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"passive":                           types.BoolType,
		"peer_as":                           types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"inherit": types.ObjectType{
			AttrTypes: inheritObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) AttributeTypes() map[string]attr.Type {

	var yesObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject

	var noObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject
	return map[string]attr.Type{
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) AncestorName() string {
	return "inherit"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) AncestorName() string {
	return "yes"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) AttributeTypes() map[string]attr.Type {

	var addressFamilyObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject

	var filteringProfileObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	return map[string]attr.Type{
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) AncestorName() string {
	return "no"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.StringType,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject
	return map[string]attr.Type{
		"name":         types.StringType,
		"description":  types.StringType,
		"enable":       types.BoolType,
		"summary_only": types.BoolType,
		"as_set":       types.BoolType,
		"same_med":     types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesObject) AncestorName() string {
	return "aggregate-routes"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableObject) AttributeTypes() map[string]attr.Type {

	var ipObj *LogicalRouterDataSourceVrfRoutingTableIpObject

	var ipv6Obj *LogicalRouterDataSourceVrfRoutingTableIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableObject) AncestorName() string {
	return "routing-table"
}

func (o LogicalRouterDataSourceVrfRoutingTableObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject
	return map[string]attr.Type{
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpObject) AncestorName() string {
	return "ip"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject

	var bfdObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject

	var pathMonitorObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ip_address": types.StringType,
		"next_lr":    types.StringType,
		"fqdn":       types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	var monitorDestinationsObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"failure_condition": types.StringType,
		"hold_time":         types.Int64Type,
		"monitor_destinations": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: monitorDestinationsObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject
	return map[string]attr.Type{
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject

	var bfdObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject

	var pathMonitorObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ipv6_address": types.StringType,
		"fqdn":         types.StringType,
		"next_lr":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	var monitorDestinationsObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"failure_condition": types.StringType,
		"hold_time":         types.Int64Type,
		"monitor_destinations": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: monitorDestinationsObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfOspfGlobalBfdObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfOspfGracefulRestartObject

	var areaObj *LogicalRouterDataSourceVrfOspfAreaObject
	return map[string]attr.Type{
		"router_id":              types.StringType,
		"enable":                 types.BoolType,
		"rfc1583":                types.BoolType,
		"spf_timer":              types.StringType,
		"global_if_timer":        types.StringType,
		"redistribution_profile": types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterDataSourceVrfOspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfOspfAreaTypeObject

	var rangeObj *LogicalRouterDataSourceVrfOspfAreaRangeObject

	var interfaceObj *LogicalRouterDataSourceVrfOspfAreaInterfaceObject

	var virtualLinkObj *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterDataSourceVrfOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject

	var stubObj *LogicalRouterDataSourceVrfOspfAreaTypeStubObject

	var nssaObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	var nssaExtRangeObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterDataSourceVrfOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	return map[string]attr.Type{
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3Object) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject

	var areaObj *LogicalRouterDataSourceVrfOspfv3AreaObject
	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"router_id":               types.StringType,
		"disable_transit_traffic": types.BoolType,
		"spf_timer":               types.StringType,
		"global_if_timer":         types.StringType,
		"redistribution_profile":  types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterDataSourceVrfOspfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfOspfv3AreaTypeObject

	var rangeObj *LogicalRouterDataSourceVrfOspfv3AreaRangeObject

	var interfaceObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject

	var virtualLinkObj *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject

	var stubObj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject

	var nssaObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	var nssaExtRangeObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"instance_id":    types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	return map[string]attr.Type{
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *LogicalRouterDataSourceVrfEcmpAlgorithmObject
	return map[string]attr.Type{
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"symmetric_return":   types.BoolType,
		"strict_source_path": types.BoolType,
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o LogicalRouterDataSourceVrfEcmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var ipModuloObj *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject

	var ipHashObj *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject

	var weightedRoundRobinObj *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject

	var balancedRoundRobinObj *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject
	return map[string]attr.Type{
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
		"hash_seed": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastObject) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterDataSourceVrfMulticastStaticRouteObject

	var pimObj *LogicalRouterDataSourceVrfMulticastPimObject

	var igmpObj *LogicalRouterDataSourceVrfMulticastIgmpObject

	var msdpObj *LogicalRouterDataSourceVrfMulticastMsdpObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"msdp": types.ObjectType{
			AttrTypes: msdpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastObject) AncestorName() string {
	return "multicast"
}

func (o LogicalRouterDataSourceVrfMulticastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"destination": types.StringType,
		"interface":   types.StringType,
		"preference":  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimObject) AttributeTypes() map[string]attr.Type {

	var ssmAddressSpaceObj *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject

	var rpObj *LogicalRouterDataSourceVrfMulticastPimRpObject

	var sptThresholdObj *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject

	var interfaceObj *LogicalRouterDataSourceVrfMulticastPimInterfaceObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"rpf_lookup_mode":   types.StringType,
		"route_ageout_time": types.Int64Type,
		"if_timer_global":   types.StringType,
		"group_permission":  types.StringType,
		"ssm_address_space": types.ObjectType{
			AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
		},
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sptThresholdObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimObject) AncestorName() string {
	return "pim"
}

func (o LogicalRouterDataSourceVrfMulticastPimObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"group_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) AttributeTypes() map[string]attr.Type {

	var localRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject

	var externalRpObj *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject
	return map[string]attr.Type{
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
		"external_rp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: externalRpObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpObject) AncestorName() string {
	return "rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var staticRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject

	var candidateRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject
	return map[string]attr.Type{
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":  types.StringType,
		"address":    types.StringType,
		"override":   types.BoolType,
		"group_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":              types.StringType,
		"address":                types.StringType,
		"priority":               types.Int64Type,
		"advertisement_interval": types.Int64Type,
		"group_list":             types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"group_list": types.StringType,
		"override":   types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"description":     types.StringType,
		"dr_priority":     types.Int64Type,
		"send_bsm":        types.BoolType,
		"if_timer":        types.StringType,
		"neighbor_filter": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfMulticastPimInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject

	var staticObj *LogicalRouterDataSourceVrfMulticastIgmpStaticObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"static": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpObject) AncestorName() string {
	return "igmp"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"version":               types.StringType,
		"robustness":            types.StringType,
		"group_filter":          types.StringType,
		"max_groups":            types.StringType,
		"max_sources":           types.StringType,
		"query_profile":         types.StringType,
		"router_alert_policing": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"interface":      types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpStaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpStaticObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) AttributeTypes() map[string]attr.Type {

	var originatorIdObj *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject

	var peerObj *LogicalRouterDataSourceVrfMulticastMsdpPeerObject
	return map[string]attr.Type{
		"enable":                types.BoolType,
		"global_timer":          types.StringType,
		"global_authentication": types.StringType,
		"originator_id": types.ObjectType{
			AttrTypes: originatorIdObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpObject) AncestorName() string {
	return "msdp"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) AncestorName() string {
	return "originator-id"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject

	var peerAddressObj *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"enable":             types.BoolType,
		"peer_as":            types.StringType,
		"authentication":     types.StringType,
		"max_sa":             types.Int64Type,
		"inbound_sa_filter":  types.StringType,
		"outbound_sa_filter": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfRipGlobalBfdObject

	var globalInboundDistributeListObj *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject

	var globalOutboundDistributeListObj *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject

	var interfacesObj *LogicalRouterDataSourceVrfRipInterfacesObject
	return map[string]attr.Type{
		"enable":                        types.BoolType,
		"default_information_originate": types.BoolType,
		"global_timer":                  types.StringType,
		"auth_profile":                  types.StringType,
		"redistribution_profile":        types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"global_inbound_distribute_list": types.ObjectType{
			AttrTypes: globalInboundDistributeListObj.AttributeTypes(),
		},
		"global_outbound_distribute_list": types.ObjectType{
			AttrTypes: globalOutboundDistributeListObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfacesObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterDataSourceVrfRipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterDataSourceVrfRipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) AncestorName() string {
	return "global-inbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) AncestorName() string {
	return "global-outbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterDataSourceVrfRipInterfacesBfdObject

	var interfaceInboundDistributeListObj *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject

	var interfaceOutboundDistributeListObj *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mode":           types.StringType,
		"split_horizon":  types.StringType,
		"authentication": types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"interface_inbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceInboundDistributeListObj.AttributeTypes(),
		},
		"interface_outbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceOutboundDistributeListObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o LogicalRouterDataSourceVrfRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) AncestorName() string {
	return "interface-inbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AncestorName() string {
	return "interface-outbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) EntryName() *string {
	return nil
}

func (o *LogicalRouterDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_tf_entries []LogicalRouterDataSourceVrfObject
	var vrf_pango_entries []logical_router.Vrf
	{
		d := o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vrf_tf_entries {
			var entry *logical_router.Vrf
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_pango_entries = append(vrf_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vrf = vrf_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var administrativeDistances_entry *logical_router.VrfAdminDists
	if !o.AdministrativeDistances.IsUnknown() && !o.AdministrativeDistances.IsNull() {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(logical_router.VrfAdminDists)
		}
		var object *LogicalRouterDataSourceVrfAdministrativeDistancesObject
		diags.Append(o.AdministrativeDistances.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_entry *logical_router.VrfRibFilter
	if !o.RibFilter.IsUnknown() && !o.RibFilter.IsNull() {
		if *obj != nil && (*obj).RibFilter != nil {
			ribFilter_entry = (*obj).RibFilter
		} else {
			ribFilter_entry = new(logical_router.VrfRibFilter)
		}
		var object *LogicalRouterDataSourceVrfRibFilterObject
		diags.Append(o.RibFilter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ribFilter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfBgp)
		}
		var object *LogicalRouterDataSourceVrfBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *logical_router.VrfRoutingTable
	if !o.RoutingTable.IsUnknown() && !o.RoutingTable.IsNull() {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(logical_router.VrfRoutingTable)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableObject
		diags.Append(o.RoutingTable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routingTable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfOspf)
		}
		var object *LogicalRouterDataSourceVrfOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfOspfv3)
		}
		var object *LogicalRouterDataSourceVrfOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *logical_router.VrfEcmp
	if !o.Ecmp.IsUnknown() && !o.Ecmp.IsNull() {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(logical_router.VrfEcmp)
		}
		var object *LogicalRouterDataSourceVrfEcmpObject
		diags.Append(o.Ecmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *logical_router.VrfMulticast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(logical_router.VrfMulticast)
		}
		var object *LogicalRouterDataSourceVrfMulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRip)
		}
		var object *LogicalRouterDataSourceVrfRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Vrf)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).RibFilter = ribFilter_entry
	(*obj).Bgp = bgp_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Multicast = multicast_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInter_value := o.OspfInter.ValueInt64Pointer()
	ospfIntra_value := o.OspfIntra.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Inter_value := o.Ospfv3Inter.ValueInt64Pointer()
	ospfv3Intra_value := o.Ospfv3Intra.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	bgpInternal_value := o.BgpInternal.ValueInt64Pointer()
	bgpExternal_value := o.BgpExternal.ValueInt64Pointer()
	bgpLocal_value := o.BgpLocal.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfAdminDists)
	}
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInter = ospfInter_value
	(*obj).OspfIntra = ospfIntra_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Inter = ospfv3Inter_value
	(*obj).Ospfv3Intra = ospfv3Intra_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).BgpInternal = bgpInternal_value
	(*obj).BgpExternal = bgpExternal_value
	(*obj).BgpLocal = bgpLocal_value
	(*obj).Rip = rip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfRibFilterIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfRibFilterIpv4)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRibFilterIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRibFilterIpv6)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilter)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv4Static
	if !o.Static.IsUnknown() && !o.Static.IsNull() {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv4Static)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject
		diags.Append(o.Static.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv4Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv4Bgp)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfRibFilterIpv4Ospf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfRibFilterIpv4Ospf)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRibFilterIpv4Rip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRibFilterIpv4Rip)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv4RipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Ospf)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Rip)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv6Static
	if !o.Static.IsUnknown() && !o.Static.IsNull() {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv6Static)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject
		diags.Append(o.Static.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv6Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv6Bgp)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfRibFilterIpv6Ospfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfRibFilterIpv6Ospfv3)
		}
		var object *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Ospfv3)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	fastExternalFailover_value := o.FastExternalFailover.ValueBoolPointer()
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	gracefulShutdown_value := o.GracefulShutdown.ValueBoolPointer()
	alwaysAdvertiseNetworkRoute_value := o.AlwaysAdvertiseNetworkRoute.ValueBoolPointer()
	var med_entry *logical_router.VrfBgpMed
	if !o.Med.IsUnknown() && !o.Med.IsNull() {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(logical_router.VrfBgpMed)
		}
		var object *LogicalRouterDataSourceVrfBgpMedObject
		diags.Append(o.Med.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfBgpGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfBgpGracefulRestart)
		}
		var object *LogicalRouterDataSourceVrfBgpGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_entry *logical_router.VrfBgpGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfBgpGlobalBfd)
		}
		var object *LogicalRouterDataSourceVrfBgpGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_entry *logical_router.VrfBgpRedistributionProfile
	if !o.RedistributionProfile.IsUnknown() && !o.RedistributionProfile.IsNull() {
		if *obj != nil && (*obj).RedistributionProfile != nil {
			redistributionProfile_entry = (*obj).RedistributionProfile
		} else {
			redistributionProfile_entry = new(logical_router.VrfBgpRedistributionProfile)
		}
		var object *LogicalRouterDataSourceVrfBgpRedistributionProfileObject
		diags.Append(o.RedistributionProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redistributionProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_entry *logical_router.VrfBgpAdvertiseNetwork
	if !o.AdvertiseNetwork.IsUnknown() && !o.AdvertiseNetwork.IsNull() {
		if *obj != nil && (*obj).AdvertiseNetwork != nil {
			advertiseNetwork_entry = (*obj).AdvertiseNetwork
		} else {
			advertiseNetwork_entry = new(logical_router.VrfBgpAdvertiseNetwork)
		}
		var object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject
		diags.Append(o.AdvertiseNetwork.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertiseNetwork_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerGroup_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupObject
	var peerGroup_pango_entries []logical_router.VrfBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *logical_router.VrfBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var aggregateRoutes_tf_entries []LogicalRouterDataSourceVrfBgpAggregateRoutesObject
	var aggregateRoutes_pango_entries []logical_router.VrfBgpAggregateRoutes
	{
		d := o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range aggregateRoutes_tf_entries {
			var entry *logical_router.VrfBgpAggregateRoutes
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_pango_entries = append(aggregateRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgp)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).LocalAs = localAs_value
	(*obj).InstallRoute = installRoute_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).FastExternalFailover = fastExternalFailover_value
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulShutdown = gracefulShutdown_value
	(*obj).AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	(*obj).Med = med_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RedistributionProfile = redistributionProfile_entry
	(*obj).AdvertiseNetwork = advertiseNetwork_entry
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).AggregateRoutes = aggregateRoutes_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpMedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpRedistributionProfileIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpRedistributionProfileIpv4)
		}
		var object *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpRedistributionProfileIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpRedistributionProfileIpv6)
		}
		var object *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfile)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv4)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv6)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAdvertiseNetworkIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
		}
		var object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAdvertiseNetworkIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
		}
		var object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetwork)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv4Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv4Network
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()
	backdoor_value := o.Backdoor.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value
	(*obj).Backdoor = backdoor_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv6Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv6Network
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpPeerGroupType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpPeerGroupType)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_entry *logical_router.VrfBgpPeerGroupAddressFamily
	if !o.AddressFamily.IsUnknown() && !o.AddressFamily.IsNull() {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupAddressFamily)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject
		diags.Append(o.AddressFamily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupFilteringProfile
	if !o.FilteringProfile.IsUnknown() && !o.FilteringProfile.IsNull() {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupFilteringProfile)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject
		diags.Append(o.FilteringProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupConnectionOptions)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupPeerObject
	var peer_pango_entries []logical_router.VrfBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Type = type_entry
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *logical_router.VrfBgpPeerGroupTypeIbgp
	if !o.Ibgp.IsUnknown() && !o.Ibgp.IsNull() {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(logical_router.VrfBgpPeerGroupTypeIbgp)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject
		diags.Append(o.Ibgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *logical_router.VrfBgpPeerGroupTypeEbgp
	if !o.Ebgp.IsUnknown() && !o.Ebgp.IsNull() {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(logical_router.VrfBgpPeerGroupTypeEbgp)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject
		diags.Append(o.Ebgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeIbgp)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeEbgp)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	var inherit_entry *logical_router.VrfBgpPeerGroupPeerInherit
	if !o.Inherit.IsUnknown() && !o.Inherit.IsNull() {
		if *obj != nil && (*obj).Inherit != nil {
			inherit_entry = (*obj).Inherit
		} else {
			inherit_entry = new(logical_router.VrfBgpPeerGroupPeerInherit)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject
		diags.Append(o.Inherit.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inherit_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *logical_router.VrfBgpPeerGroupPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfBgpPeerGroupPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupPeerConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfBgpPeerGroupPeerBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfBgpPeerGroupPeerBfd)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).Inherit = inherit_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_entry *logical_router.VrfBgpPeerGroupPeerInheritYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_entry *logical_router.VrfBgpPeerGroupPeerInheritNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInherit)
	}
	(*obj).Yes = yes_entry
	(*obj).No = no_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_entry *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily
	if !o.AddressFamily.IsUnknown() && !o.AddressFamily.IsNull() {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
		diags.Append(o.AddressFamily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile
	if !o.FilteringProfile.IsUnknown() && !o.FilteringProfile.IsNull() {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
		}
		var object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
		diags.Append(o.FilteringProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
	}
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summaryOnly_value := o.SummaryOnly.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	sameMed_value := o.SameMed.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpAggregateRoutesType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpAggregateRoutesType)
		}
		var object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Enable = enable_value
	(*obj).SummaryOnly = summaryOnly_value
	(*obj).AsSet = asSet_value
	(*obj).SameMed = sameMed_value
	(*obj).Type = type_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAggregateRoutesTypeIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
		}
		var object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAggregateRoutesTypeIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
		}
		var object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesType)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *logical_router.VrfRoutingTableIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(logical_router.VrfRoutingTableIp)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRoutingTableIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRoutingTableIpv6)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpStaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpStaticRouteBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitor
	if !o.PathMonitor.IsUnknown() && !o.PathMonitor.IsNull() {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject
		diags.Append(o.PathMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard
	if !o.Discard.IsUnknown() && !o.Discard.IsNull() {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
		diags.Append(o.Discard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).NextLr = nextLr_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpv6StaticRouteBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor
	if !o.PathMonitor.IsUnknown() && !o.PathMonitor.IsNull() {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
		diags.Append(o.PathMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard
	if !o.Discard.IsUnknown() && !o.Discard.IsNull() {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
		}
		var object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
		diags.Append(o.Discard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextLr = nextLr_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routerId_value := o.RouterId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfGlobalBfd)
		}
		var object *LogicalRouterDataSourceVrfOspfGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfGracefulRestart)
		}
		var object *LogicalRouterDataSourceVrfOspfGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterDataSourceVrfOspfAreaObject
	var area_pango_entries []logical_router.VrfOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfArea
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspf)
	}
	(*obj).RouterId = routerId_value
	(*obj).Enable = enable_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfAreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfAreaType)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterDataSourceVrfOspfAreaRangeObject
	var range_pango_entries []logical_router.VrfOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfAreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfAreaTypeNormal)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfAreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfAreaTypeStub)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfAreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfAreaTypeNssa)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfAreaTypeNormalAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNormalAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfAreaTypeStubAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeStubAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate
	if !o.DefaultInformationOriginate.IsUnknown() && !o.DefaultInformationOriginate.IsNull() {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
		diags.Append(o.DefaultInformationOriginate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfAreaTypeNssaAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNssaAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfAreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfAreaInterfaceLinkType)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfAreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaInterfaceBfd)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfOspfAreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaVirtualLinkBfd)
		}
		var object *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfv3GlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfv3GlobalBfd)
		}
		var object *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfv3GracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfv3GracefulRestart)
		}
		var object *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaObject
	var area_pango_entries []logical_router.VrfOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfv3Area
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfv3AreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfv3AreaType)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaRangeObject
	var range_pango_entries []logical_router.VrfOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfv3AreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfv3AreaTypeNormal)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfv3AreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfv3AreaTypeStub)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfv3AreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfv3AreaTypeNssa)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfv3AreaTypeNormalAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfv3AreaTypeStubAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeStubAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate
	if !o.DefaultInformationOriginate.IsUnknown() && !o.DefaultInformationOriginate.IsNull() {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
		diags.Append(o.DefaultInformationOriginate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfv3AreaTypeNssaAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfv3AreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfv3AreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfv3AreaInterfaceBfd)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).InstanceId = instanceId_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
		}
		var object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	var algorithm_entry *logical_router.VrfEcmpAlgorithm
	if !o.Algorithm.IsUnknown() && !o.Algorithm.IsNull() {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(logical_router.VrfEcmpAlgorithm)
		}
		var object *LogicalRouterDataSourceVrfEcmpAlgorithmObject
		diags.Append(o.Algorithm.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmp)
	}
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).Algorithm = algorithm_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *logical_router.VrfEcmpAlgorithmIpModulo
	if !o.IpModulo.IsUnknown() && !o.IpModulo.IsNull() {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(logical_router.VrfEcmpAlgorithmIpModulo)
		}
		var object *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject
		diags.Append(o.IpModulo.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *logical_router.VrfEcmpAlgorithmIpHash
	if !o.IpHash.IsUnknown() && !o.IpHash.IsNull() {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(logical_router.VrfEcmpAlgorithmIpHash)
		}
		var object *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject
		diags.Append(o.IpHash.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobin
	if !o.WeightedRoundRobin.IsUnknown() && !o.WeightedRoundRobin.IsNull() {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
		}
		var object *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject
		diags.Append(o.WeightedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *logical_router.VrfEcmpAlgorithmBalancedRoundRobin
	if !o.BalancedRoundRobin.IsUnknown() && !o.BalancedRoundRobin.IsNull() {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
		}
		var object *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject
		diags.Append(o.BalancedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfMulticastStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfMulticastStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfMulticastStaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}
	var pim_entry *logical_router.VrfMulticastPim
	if !o.Pim.IsUnknown() && !o.Pim.IsNull() {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(logical_router.VrfMulticastPim)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimObject
		diags.Append(o.Pim.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *logical_router.VrfMulticastIgmp
	if !o.Igmp.IsUnknown() && !o.Igmp.IsNull() {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(logical_router.VrfMulticastIgmp)
		}
		var object *LogicalRouterDataSourceVrfMulticastIgmpObject
		diags.Append(o.Igmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_entry *logical_router.VrfMulticastMsdp
	if !o.Msdp.IsUnknown() && !o.Msdp.IsNull() {
		if *obj != nil && (*obj).Msdp != nil {
			msdp_entry = (*obj).Msdp
		} else {
			msdp_entry = new(logical_router.VrfMulticastMsdp)
		}
		var object *LogicalRouterDataSourceVrfMulticastMsdpObject
		diags.Append(o.Msdp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &msdp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticast)
	}
	(*obj).Enable = enable_value
	(*obj).StaticRoute = staticRoute_pango_entries
	(*obj).Pim = pim_entry
	(*obj).Igmp = igmp_entry
	(*obj).Msdp = msdp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	preference_value := o.Preference.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfMulticastStaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfMulticastStaticRouteNexthop)
		}
		var object *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Preference = preference_value
	(*obj).Nexthop = nexthop_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRouteNexthop)
	}
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	rpfLookupMode_value := o.RpfLookupMode.ValueStringPointer()
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	ifTimerGlobal_value := o.IfTimerGlobal.ValueStringPointer()
	groupPermission_value := o.GroupPermission.ValueStringPointer()
	var ssmAddressSpace_entry *logical_router.VrfMulticastPimSsmAddressSpace
	if !o.SsmAddressSpace.IsUnknown() && !o.SsmAddressSpace.IsNull() {
		if *obj != nil && (*obj).SsmAddressSpace != nil {
			ssmAddressSpace_entry = (*obj).SsmAddressSpace
		} else {
			ssmAddressSpace_entry = new(logical_router.VrfMulticastPimSsmAddressSpace)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject
		diags.Append(o.SsmAddressSpace.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ssmAddressSpace_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_entry *logical_router.VrfMulticastPimRp
	if !o.Rp.IsUnknown() && !o.Rp.IsNull() {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(logical_router.VrfMulticastPimRp)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimRpObject
		diags.Append(o.Rp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []LogicalRouterDataSourceVrfMulticastPimSptThresholdObject
	var sptThreshold_pango_entries []logical_router.VrfMulticastPimSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *logical_router.VrfMulticastPimSptThreshold
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfMulticastPimInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastPimInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastPimInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPim)
	}
	(*obj).Enable = enable_value
	(*obj).RpfLookupMode = rpfLookupMode_value
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).IfTimerGlobal = ifTimerGlobal_value
	(*obj).GroupPermission = groupPermission_value
	(*obj).SsmAddressSpace = ssmAddressSpace_entry
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSsmAddressSpace)
	}
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localRp_entry *logical_router.VrfMulticastPimRpLocalRp
	if !o.LocalRp.IsUnknown() && !o.LocalRp.IsNull() {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(logical_router.VrfMulticastPimRpLocalRp)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject
		diags.Append(o.LocalRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var externalRp_tf_entries []LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject
	var externalRp_pango_entries []logical_router.VrfMulticastPimRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *logical_router.VrfMulticastPimRpExternalRp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRp)
	}
	(*obj).LocalRp = localRp_entry
	(*obj).ExternalRp = externalRp_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_entry *logical_router.VrfMulticastPimRpLocalRpStaticRp
	if !o.StaticRp.IsUnknown() && !o.StaticRp.IsNull() {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject
		diags.Append(o.StaticRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_entry *logical_router.VrfMulticastPimRpLocalRpCandidateRp
	if !o.CandidateRp.IsUnknown() && !o.CandidateRp.IsNull() {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
		}
		var object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject
		diags.Append(o.CandidateRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRp)
	}
	(*obj).StaticRp = staticRp_entry
	(*obj).CandidateRp = candidateRp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Override = override_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Priority = priority_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupList = groupList_value
	(*obj).Override = override_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	sendBsm_value := o.SendBsm.ValueBoolPointer()
	ifTimer_value := o.IfTimer.ValueStringPointer()
	neighborFilter_value := o.NeighborFilter.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).DrPriority = drPriority_value
	(*obj).SendBsm = sendBsm_value
	(*obj).IfTimer = ifTimer_value
	(*obj).NeighborFilter = neighborFilter_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var dynamic_entry *logical_router.VrfMulticastIgmpDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(logical_router.VrfMulticastIgmpDynamic)
		}
		var object *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var static_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpStaticObject
	var static_pango_entries []logical_router.VrfMulticastIgmpStatic
	{
		d := o.Static.ElementsAs(ctx, &static_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range static_tf_entries {
			var entry *logical_router.VrfMulticastIgmpStatic
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			static_pango_entries = append(static_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Dynamic = dynamic_entry
	(*obj).Static = static_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastIgmpDynamicInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastIgmpDynamicInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamic)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	version_value := o.Version.ValueStringPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	groupFilter_value := o.GroupFilter.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	queryProfile_value := o.QueryProfile.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamicInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Version = version_value
	(*obj).Robustness = robustness_value
	(*obj).GroupFilter = groupFilter_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).QueryProfile = queryProfile_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpStatic)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	globalAuthentication_value := o.GlobalAuthentication.ValueStringPointer()
	var originatorId_entry *logical_router.VrfMulticastMsdpOriginatorId
	if !o.OriginatorId.IsUnknown() && !o.OriginatorId.IsNull() {
		if *obj != nil && (*obj).OriginatorId != nil {
			originatorId_entry = (*obj).OriginatorId
		} else {
			originatorId_entry = new(logical_router.VrfMulticastMsdpOriginatorId)
		}
		var object *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject
		diags.Append(o.OriginatorId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &originatorId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterDataSourceVrfMulticastMsdpPeerObject
	var peer_pango_entries []logical_router.VrfMulticastMsdpPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfMulticastMsdpPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdp)
	}
	(*obj).Enable = enable_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).GlobalAuthentication = globalAuthentication_value
	(*obj).OriginatorId = originatorId_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpOriginatorId)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	maxSa_value := o.MaxSa.ValueInt64Pointer()
	inboundSaFilter_value := o.InboundSaFilter.ValueStringPointer()
	outboundSaFilter_value := o.OutboundSaFilter.ValueStringPointer()
	var localAddress_entry *logical_router.VrfMulticastMsdpPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
		}
		var object *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfMulticastMsdpPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
		}
		var object *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).Authentication = authentication_value
	(*obj).MaxSa = maxSa_value
	(*obj).InboundSaFilter = inboundSaFilter_value
	(*obj).OutboundSaFilter = outboundSaFilter_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	defaultInformationOriginate_value := o.DefaultInformationOriginate.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	authProfile_value := o.AuthProfile.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfRipGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfRipGlobalBfd)
		}
		var object *LogicalRouterDataSourceVrfRipGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_entry *logical_router.VrfRipGlobalInboundDistributeList
	if !o.GlobalInboundDistributeList.IsUnknown() && !o.GlobalInboundDistributeList.IsNull() {
		if *obj != nil && (*obj).GlobalInboundDistributeList != nil {
			globalInboundDistributeList_entry = (*obj).GlobalInboundDistributeList
		} else {
			globalInboundDistributeList_entry = new(logical_router.VrfRipGlobalInboundDistributeList)
		}
		var object *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject
		diags.Append(o.GlobalInboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_entry *logical_router.VrfRipGlobalOutboundDistributeList
	if !o.GlobalOutboundDistributeList.IsUnknown() && !o.GlobalOutboundDistributeList.IsNull() {
		if *obj != nil && (*obj).GlobalOutboundDistributeList != nil {
			globalOutboundDistributeList_entry = (*obj).GlobalOutboundDistributeList
		} else {
			globalOutboundDistributeList_entry = new(logical_router.VrfRipGlobalOutboundDistributeList)
		}
		var object *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject
		diags.Append(o.GlobalOutboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []LogicalRouterDataSourceVrfRipInterfacesObject
	var interfaces_pango_entries []logical_router.VrfRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *logical_router.VrfRipInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRip)
	}
	(*obj).Enable = enable_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).AuthProfile = authProfile_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GlobalInboundDistributeList = globalInboundDistributeList_entry
	(*obj).GlobalOutboundDistributeList = globalOutboundDistributeList_entry
	(*obj).Interface = interfaces_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalInboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mode_value := o.Mode.ValueStringPointer()
	splitHorizon_value := o.SplitHorizon.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfRipInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRipInterfaceBfd)
		}
		var object *LogicalRouterDataSourceVrfRipInterfacesBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceInboundDistributeList
	if !o.InterfaceInboundDistributeList.IsUnknown() && !o.InterfaceInboundDistributeList.IsNull() {
		if *obj != nil && (*obj).InterfaceInboundDistributeList != nil {
			interfaceInboundDistributeList_entry = (*obj).InterfaceInboundDistributeList
		} else {
			interfaceInboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
		}
		var object *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject
		diags.Append(o.InterfaceInboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &interfaceInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList
	if !o.InterfaceOutboundDistributeList.IsUnknown() && !o.InterfaceOutboundDistributeList.IsNull() {
		if *obj != nil && (*obj).InterfaceOutboundDistributeList != nil {
			interfaceOutboundDistributeList_entry = (*obj).InterfaceOutboundDistributeList
		} else {
			interfaceOutboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
		}
		var object *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject
		diags.Append(o.InterfaceOutboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &interfaceOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Mode = mode_value
	(*obj).SplitHorizon = splitHorizon_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).InterfaceInboundDistributeList = interfaceInboundDistributeList_entry
	(*obj).InterfaceOutboundDistributeList = interfaceOutboundDistributeList_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_list types.List
	{
		var vrf_tf_entries []LogicalRouterDataSourceVrfObject
		if !o.Vrf.IsNull() {
			diags.Append(o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Vrf {
			entry := LogicalRouterDataSourceVrfObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(vrf_tf_entries) {
				entry = vrf_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(vrf_tf_entries) {
				vrf_tf_entries[idx] = entry
			} else {
				vrf_tf_entries = append(vrf_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vrf")
		vrf_list, list_diags = types.ListValueFrom(ctx, schemaType, vrf_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vrf = vrf_list

	return diags
}

func (o *LogicalRouterDataSourceVrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistances_obj *LogicalRouterDataSourceVrfAdministrativeDistancesObject
	if o.AdministrativeDistances.IsNull() {
		administrativeDistances_obj = new(LogicalRouterDataSourceVrfAdministrativeDistancesObject)
	} else {
		diags.Append(o.AdministrativeDistances.As(ctx, &administrativeDistances_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	administrativeDistances_object := types.ObjectNull(administrativeDistances_obj.AttributeTypes())
	if obj.AdminDists != nil {
		diags.Append(administrativeDistances_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		administrativeDistances_object, diags_tmp = types.ObjectValueFrom(ctx, administrativeDistances_obj.AttributeTypes(), administrativeDistances_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ribFilter_obj *LogicalRouterDataSourceVrfRibFilterObject
	if o.RibFilter.IsNull() {
		ribFilter_obj = new(LogicalRouterDataSourceVrfRibFilterObject)
	} else {
		diags.Append(o.RibFilter.As(ctx, &ribFilter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ribFilter_object := types.ObjectNull(ribFilter_obj.AttributeTypes())
	if obj.RibFilter != nil {
		diags.Append(ribFilter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RibFilter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ribFilter_object, diags_tmp = types.ObjectValueFrom(ctx, ribFilter_obj.AttributeTypes(), ribFilter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterDataSourceVrfBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterDataSourceVrfBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routingTable_obj *LogicalRouterDataSourceVrfRoutingTableObject
	if o.RoutingTable.IsNull() {
		routingTable_obj = new(LogicalRouterDataSourceVrfRoutingTableObject)
	} else {
		diags.Append(o.RoutingTable.As(ctx, &routingTable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routingTable_object := types.ObjectNull(routingTable_obj.AttributeTypes())
	if obj.RoutingTable != nil {
		diags.Append(routingTable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RoutingTable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routingTable_object, diags_tmp = types.ObjectValueFrom(ctx, routingTable_obj.AttributeTypes(), routingTable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *LogicalRouterDataSourceVrfOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(LogicalRouterDataSourceVrfOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *LogicalRouterDataSourceVrfOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(LogicalRouterDataSourceVrfOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ecmp_obj *LogicalRouterDataSourceVrfEcmpObject
	if o.Ecmp.IsNull() {
		ecmp_obj = new(LogicalRouterDataSourceVrfEcmpObject)
	} else {
		diags.Append(o.Ecmp.As(ctx, &ecmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ecmp_object := types.ObjectNull(ecmp_obj.AttributeTypes())
	if obj.Ecmp != nil {
		diags.Append(ecmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ecmp_object, diags_tmp = types.ObjectValueFrom(ctx, ecmp_obj.AttributeTypes(), ecmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var multicast_obj *LogicalRouterDataSourceVrfMulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(LogicalRouterDataSourceVrfMulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *LogicalRouterDataSourceVrfRipObject
	if o.Rip.IsNull() {
		rip_obj = new(LogicalRouterDataSourceVrfRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_list
	o.AdministrativeDistances = administrativeDistances_object
	o.RibFilter = ribFilter_object
	o.Bgp = bgp_object
	o.RoutingTable = routingTable_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Ecmp = ecmp_object
	o.Multicast = multicast_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ospfInter_value types.Int64
	if obj.OspfInter != nil {
		ospfInter_value = types.Int64Value(*obj.OspfInter)
	}
	var ospfIntra_value types.Int64
	if obj.OspfIntra != nil {
		ospfIntra_value = types.Int64Value(*obj.OspfIntra)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Inter_value types.Int64
	if obj.Ospfv3Inter != nil {
		ospfv3Inter_value = types.Int64Value(*obj.Ospfv3Inter)
	}
	var ospfv3Intra_value types.Int64
	if obj.Ospfv3Intra != nil {
		ospfv3Intra_value = types.Int64Value(*obj.Ospfv3Intra)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var bgpInternal_value types.Int64
	if obj.BgpInternal != nil {
		bgpInternal_value = types.Int64Value(*obj.BgpInternal)
	}
	var bgpExternal_value types.Int64
	if obj.BgpExternal != nil {
		bgpExternal_value = types.Int64Value(*obj.BgpExternal)
	}
	var bgpLocal_value types.Int64
	if obj.BgpLocal != nil {
		bgpLocal_value = types.Int64Value(*obj.BgpLocal)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value
	o.OspfInter = ospfInter_value
	o.OspfIntra = ospfIntra_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Inter = ospfv3Inter_value
	o.Ospfv3Intra = ospfv3Intra_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.BgpInternal = bgpInternal_value
	o.BgpExternal = bgpExternal_value
	o.BgpLocal = bgpLocal_value
	o.Rip = rip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterDataSourceVrfRibFilterIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterDataSourceVrfRibFilterIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterDataSourceVrfRibFilterIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterDataSourceVrfRibFilterIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_obj *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject
	if o.Static.IsNull() {
		static_obj = new(LogicalRouterDataSourceVrfRibFilterIpv4StaticObject)
	} else {
		diags.Append(o.Static.As(ctx, &static_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	static_object := types.ObjectNull(static_obj.AttributeTypes())
	if obj.Static != nil {
		diags.Append(static_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		static_object, diags_tmp = types.ObjectValueFrom(ctx, static_obj.AttributeTypes(), static_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterDataSourceVrfRibFilterIpv4BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(LogicalRouterDataSourceVrfRibFilterIpv4OspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *LogicalRouterDataSourceVrfRibFilterIpv4RipObject
	if o.Rip.IsNull() {
		rip_obj = new(LogicalRouterDataSourceVrfRibFilterIpv4RipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_obj *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject
	if o.Static.IsNull() {
		static_obj = new(LogicalRouterDataSourceVrfRibFilterIpv6StaticObject)
	} else {
		diags.Append(o.Static.As(ctx, &static_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	static_object := types.ObjectNull(static_obj.AttributeTypes())
	if obj.Static != nil {
		diags.Append(static_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		static_object, diags_tmp = types.ObjectValueFrom(ctx, static_obj.AttributeTypes(), static_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterDataSourceVrfRibFilterIpv6BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupObject
		if !o.PeerGroup.IsNull() {
			diags.Append(o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PeerGroup {
			entry := LogicalRouterDataSourceVrfBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peerGroup_tf_entries) {
				entry = peerGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peerGroup_tf_entries) {
				peerGroup_tf_entries[idx] = entry
			} else {
				peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRoutes_list types.List
	{
		var aggregateRoutes_tf_entries []LogicalRouterDataSourceVrfBgpAggregateRoutesObject
		if !o.AggregateRoutes.IsNull() {
			diags.Append(o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AggregateRoutes {
			entry := LogicalRouterDataSourceVrfBgpAggregateRoutesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(aggregateRoutes_tf_entries) {
				entry = aggregateRoutes_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(aggregateRoutes_tf_entries) {
				aggregateRoutes_tf_entries[idx] = entry
			} else {
				aggregateRoutes_tf_entries = append(aggregateRoutes_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("aggregate_routes")
		aggregateRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, aggregateRoutes_tf_entries)
		diags.Append(list_diags...)
	}

	var med_obj *LogicalRouterDataSourceVrfBgpMedObject
	if o.Med.IsNull() {
		med_obj = new(LogicalRouterDataSourceVrfBgpMedObject)
	} else {
		diags.Append(o.Med.As(ctx, &med_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	med_object := types.ObjectNull(med_obj.AttributeTypes())
	if obj.Med != nil {
		diags.Append(med_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		med_object, diags_tmp = types.ObjectValueFrom(ctx, med_obj.AttributeTypes(), med_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterDataSourceVrfBgpGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterDataSourceVrfBgpGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalBfd_obj *LogicalRouterDataSourceVrfBgpGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterDataSourceVrfBgpGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redistributionProfile_obj *LogicalRouterDataSourceVrfBgpRedistributionProfileObject
	if o.RedistributionProfile.IsNull() {
		redistributionProfile_obj = new(LogicalRouterDataSourceVrfBgpRedistributionProfileObject)
	} else {
		diags.Append(o.RedistributionProfile.As(ctx, &redistributionProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redistributionProfile_object := types.ObjectNull(redistributionProfile_obj.AttributeTypes())
	if obj.RedistributionProfile != nil {
		diags.Append(redistributionProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RedistributionProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redistributionProfile_object, diags_tmp = types.ObjectValueFrom(ctx, redistributionProfile_obj.AttributeTypes(), redistributionProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertiseNetwork_obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject
	if o.AdvertiseNetwork.IsNull() {
		advertiseNetwork_obj = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject)
	} else {
		diags.Append(o.AdvertiseNetwork.As(ctx, &advertiseNetwork_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertiseNetwork_object := types.ObjectNull(advertiseNetwork_obj.AttributeTypes())
	if obj.AdvertiseNetwork != nil {
		diags.Append(advertiseNetwork_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdvertiseNetwork, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertiseNetwork_object, diags_tmp = types.ObjectValueFrom(ctx, advertiseNetwork_obj.AttributeTypes(), advertiseNetwork_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var fastExternalFailover_value types.Bool
	if obj.FastExternalFailover != nil {
		fastExternalFailover_value = types.BoolValue(*obj.FastExternalFailover)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var gracefulShutdown_value types.Bool
	if obj.GracefulShutdown != nil {
		gracefulShutdown_value = types.BoolValue(*obj.GracefulShutdown)
	}
	var alwaysAdvertiseNetworkRoute_value types.Bool
	if obj.AlwaysAdvertiseNetworkRoute != nil {
		alwaysAdvertiseNetworkRoute_value = types.BoolValue(*obj.AlwaysAdvertiseNetworkRoute)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.LocalAs = localAs_value
	o.InstallRoute = installRoute_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.FastExternalFailover = fastExternalFailover_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulShutdown = gracefulShutdown_value
	o.AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	o.Med = med_object
	o.GracefulRestart = gracefulRestart_object
	o.GlobalBfd = globalBfd_object
	o.RedistributionProfile = redistributionProfile_object
	o.AdvertiseNetwork = advertiseNetwork_object
	o.PeerGroup = peerGroup_list
	o.AggregateRoutes = aggregateRoutes_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpMedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	o.Enable = enable_value
	o.StaleRouteTime = staleRouteTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.LocalRestartTime = localRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject
		if !o.Network.IsNull() {
			diags.Append(o.Network.ElementsAs(ctx, &network_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Network {
			entry := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(network_tf_entries) {
				entry = network_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(network_tf_entries) {
				network_tf_entries[idx] = entry
			} else {
				network_tf_entries = append(network_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	var backdoor_value types.Bool
	if obj.Backdoor != nil {
		backdoor_value = types.BoolValue(*obj.Backdoor)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value
	o.Multicast = multicast_value
	o.Backdoor = backdoor_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject
		if !o.Network.IsNull() {
			diags.Append(o.Network.ElementsAs(ctx, &network_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Network {
			entry := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(network_tf_entries) {
				entry = network_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(network_tf_entries) {
				network_tf_entries[idx] = entry
			} else {
				network_tf_entries = append(network_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := LogicalRouterDataSourceVrfBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var addressFamily_obj *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject
	if o.AddressFamily.IsNull() {
		addressFamily_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject)
	} else {
		diags.Append(o.AddressFamily.As(ctx, &addressFamily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addressFamily_object := types.ObjectNull(addressFamily_obj.AttributeTypes())
	if obj.AddressFamily != nil {
		diags.Append(addressFamily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addressFamily_object, diags_tmp = types.ObjectValueFrom(ctx, addressFamily_obj.AttributeTypes(), addressFamily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var filteringProfile_obj *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject
	if o.FilteringProfile.IsNull() {
		filteringProfile_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject)
	} else {
		diags.Append(o.FilteringProfile.As(ctx, &filteringProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filteringProfile_object := types.ObjectNull(filteringProfile_obj.AttributeTypes())
	if obj.FilteringProfile != nil {
		diags.Append(filteringProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filteringProfile_object, diags_tmp = types.ObjectValueFrom(ctx, filteringProfile_obj.AttributeTypes(), filteringProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Type = type_object
	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object
	o.ConnectionOptions = connectionOptions_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ibgp_obj *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject
	if o.Ibgp.IsNull() {
		ibgp_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject)
	} else {
		diags.Append(o.Ibgp.As(ctx, &ibgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgp_object := types.ObjectNull(ibgp_obj.AttributeTypes())
	if obj.Ibgp != nil {
		diags.Append(ibgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgp_object, diags_tmp = types.ObjectValueFrom(ctx, ibgp_obj.AttributeTypes(), ibgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgp_obj *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject
	if o.Ebgp.IsNull() {
		ebgp_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject)
	} else {
		diags.Append(o.Ebgp.As(ctx, &ebgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgp_object := types.ObjectNull(ebgp_obj.AttributeTypes())
	if obj.Ebgp != nil {
		diags.Append(ebgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgp_object, diags_tmp = types.ObjectValueFrom(ctx, ebgp_obj.AttributeTypes(), ebgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var inherit_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject
	if o.Inherit.IsNull() {
		inherit_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject)
	} else {
		diags.Append(o.Inherit.As(ctx, &inherit_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inherit_object := types.ObjectNull(inherit_obj.AttributeTypes())
	if obj.Inherit != nil {
		diags.Append(inherit_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Inherit, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inherit_object, diags_tmp = types.ObjectValueFrom(ctx, inherit_obj.AttributeTypes(), inherit_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.PeerAs = peerAs_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.Inherit = inherit_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var yes_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject
	if o.Yes.IsNull() {
		yes_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var no_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject
	if o.No.IsNull() {
		no_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Yes = yes_object
	o.No = no_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addressFamily_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
	if o.AddressFamily.IsNull() {
		addressFamily_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject)
	} else {
		diags.Append(o.AddressFamily.As(ctx, &addressFamily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addressFamily_object := types.ObjectNull(addressFamily_obj.AttributeTypes())
	if obj.AddressFamily != nil {
		diags.Append(addressFamily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addressFamily_object, diags_tmp = types.ObjectValueFrom(ctx, addressFamily_obj.AttributeTypes(), addressFamily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var filteringProfile_obj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	if o.FilteringProfile.IsNull() {
		filteringProfile_obj = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject)
	} else {
		diags.Append(o.FilteringProfile.As(ctx, &filteringProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filteringProfile_object := types.ObjectNull(filteringProfile_obj.AttributeTypes())
	if obj.FilteringProfile != nil {
		diags.Append(filteringProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filteringProfile_object, diags_tmp = types.ObjectValueFrom(ctx, filteringProfile_obj.AttributeTypes(), filteringProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.String
	if obj.Multihop != nil {
		multihop_value = types.StringValue(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summaryOnly_value types.Bool
	if obj.SummaryOnly != nil {
		summaryOnly_value = types.BoolValue(*obj.SummaryOnly)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	var sameMed_value types.Bool
	if obj.SameMed != nil {
		sameMed_value = types.BoolValue(*obj.SameMed)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Enable = enable_value
	o.SummaryOnly = summaryOnly_value
	o.AsSet = asSet_value
	o.SameMed = sameMed_value
	o.Type = type_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_obj *LogicalRouterDataSourceVrfRoutingTableIpObject
	if o.Ip.IsNull() {
		ip_obj = new(LogicalRouterDataSourceVrfRoutingTableIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterDataSourceVrfRoutingTableIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterDataSourceVrfRoutingTableIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pathMonitor_obj *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject
	if o.PathMonitor.IsNull() {
		pathMonitor_obj = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject)
	} else {
		diags.Append(o.PathMonitor.As(ctx, &pathMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pathMonitor_object := types.ObjectNull(pathMonitor_obj.AttributeTypes())
	if obj.PathMonitor != nil {
		diags.Append(pathMonitor_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pathMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, pathMonitor_obj.AttributeTypes(), pathMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var discard_obj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
	if o.Discard.IsNull() {
		discard_obj = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject)
	} else {
		diags.Append(o.Discard.As(ctx, &discard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	discard_object := types.ObjectNull(discard_obj.AttributeTypes())
	if obj.Discard != nil {
		diags.Append(discard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		discard_object, diags_tmp = types.ObjectValueFrom(ctx, discard_obj.AttributeTypes(), discard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.NextLr = nextLr_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		if !o.MonitorDestinations.IsNull() {
			diags.Append(o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MonitorDestinations {
			entry := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(monitorDestinations_tf_entries) {
				entry = monitorDestinations_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(monitorDestinations_tf_entries) {
				monitorDestinations_tf_entries[idx] = entry
			} else {
				monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pathMonitor_obj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	if o.PathMonitor.IsNull() {
		pathMonitor_obj = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject)
	} else {
		diags.Append(o.PathMonitor.As(ctx, &pathMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pathMonitor_object := types.ObjectNull(pathMonitor_obj.AttributeTypes())
	if obj.PathMonitor != nil {
		diags.Append(pathMonitor_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pathMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, pathMonitor_obj.AttributeTypes(), pathMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var discard_obj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
	if o.Discard.IsNull() {
		discard_obj = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject)
	} else {
		diags.Append(o.Discard.As(ctx, &discard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	discard_object := types.ObjectNull(discard_obj.AttributeTypes())
	if obj.Discard != nil {
		diags.Append(discard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		discard_object, diags_tmp = types.ObjectValueFrom(ctx, discard_obj.AttributeTypes(), discard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextLr = nextLr_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		if !o.MonitorDestinations.IsNull() {
			diags.Append(o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MonitorDestinations {
			entry := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(monitorDestinations_tf_entries) {
				entry = monitorDestinations_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(monitorDestinations_tf_entries) {
				monitorDestinations_tf_entries[idx] = entry
			} else {
				monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterDataSourceVrfOspfAreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := LogicalRouterDataSourceVrfOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterDataSourceVrfOspfGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterDataSourceVrfOspfGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterDataSourceVrfOspfGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterDataSourceVrfOspfGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.RouterId = routerId_value
	o.Enable = enable_value
	o.Rfc1583 = rfc1583_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterDataSourceVrfOspfAreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := LogicalRouterDataSourceVrfOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterDataSourceVrfOspfAreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *LogicalRouterDataSourceVrfOspfAreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultInformationOriginate_obj *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
	if o.DefaultInformationOriginate.IsNull() {
		defaultInformationOriginate_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject)
	} else {
		diags.Append(o.DefaultInformationOriginate.As(ctx, &defaultInformationOriginate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultInformationOriginate_object := types.ObjectNull(defaultInformationOriginate_obj.AttributeTypes())
	if obj.DefaultInformationOriginate != nil {
		diags.Append(defaultInformationOriginate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultInformationOriginate_object, diags_tmp = types.ObjectValueFrom(ctx, defaultInformationOriginate_obj.AttributeTypes(), defaultInformationOriginate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var abr_obj *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var linkType_obj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := LogicalRouterDataSourceVrfOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterDataSourceVrfOspfv3GlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterDataSourceVrfOspfv3GracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := LogicalRouterDataSourceVrfOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultInformationOriginate_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
	if o.DefaultInformationOriginate.IsNull() {
		defaultInformationOriginate_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject)
	} else {
		diags.Append(o.DefaultInformationOriginate.As(ctx, &defaultInformationOriginate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultInformationOriginate_object := types.ObjectNull(defaultInformationOriginate_obj.AttributeTypes())
	if obj.DefaultInformationOriginate != nil {
		diags.Append(defaultInformationOriginate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultInformationOriginate_object, diags_tmp = types.ObjectValueFrom(ctx, defaultInformationOriginate_obj.AttributeTypes(), defaultInformationOriginate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var abr_obj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var linkType_obj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.InstanceId = instanceId_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_obj *LogicalRouterDataSourceVrfEcmpAlgorithmObject
	if o.Algorithm.IsNull() {
		algorithm_obj = new(LogicalRouterDataSourceVrfEcmpAlgorithmObject)
	} else {
		diags.Append(o.Algorithm.As(ctx, &algorithm_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	algorithm_object := types.ObjectNull(algorithm_obj.AttributeTypes())
	if obj.Algorithm != nil {
		diags.Append(algorithm_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		algorithm_object, diags_tmp = types.ObjectValueFrom(ctx, algorithm_obj.AttributeTypes(), algorithm_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipModulo_obj *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject
	if o.IpModulo.IsNull() {
		ipModulo_obj = new(LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject)
	} else {
		diags.Append(o.IpModulo.As(ctx, &ipModulo_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipModulo_object := types.ObjectNull(ipModulo_obj.AttributeTypes())
	if obj.IpModulo != nil {
		diags.Append(ipModulo_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipModulo_object, diags_tmp = types.ObjectValueFrom(ctx, ipModulo_obj.AttributeTypes(), ipModulo_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipHash_obj *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject
	if o.IpHash.IsNull() {
		ipHash_obj = new(LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject)
	} else {
		diags.Append(o.IpHash.As(ctx, &ipHash_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipHash_object := types.ObjectNull(ipHash_obj.AttributeTypes())
	if obj.IpHash != nil {
		diags.Append(ipHash_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipHash_object, diags_tmp = types.ObjectValueFrom(ctx, ipHash_obj.AttributeTypes(), ipHash_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weightedRoundRobin_obj *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject
	if o.WeightedRoundRobin.IsNull() {
		weightedRoundRobin_obj = new(LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject)
	} else {
		diags.Append(o.WeightedRoundRobin.As(ctx, &weightedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weightedRoundRobin_object := types.ObjectNull(weightedRoundRobin_obj.AttributeTypes())
	if obj.WeightedRoundRobin != nil {
		diags.Append(weightedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weightedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, weightedRoundRobin_obj.AttributeTypes(), weightedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var balancedRoundRobin_obj *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject
	if o.BalancedRoundRobin.IsNull() {
		balancedRoundRobin_obj = new(LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject)
	} else {
		diags.Append(o.BalancedRoundRobin.As(ctx, &balancedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	balancedRoundRobin_object := types.ObjectNull(balancedRoundRobin_obj.AttributeTypes())
	if obj.BalancedRoundRobin != nil {
		diags.Append(balancedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		balancedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, balancedRoundRobin_obj.AttributeTypes(), balancedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object
	o.WeightedRoundRobin = weightedRoundRobin_object
	o.BalancedRoundRobin = balancedRoundRobin_object

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfMulticastStaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfMulticastStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	var pim_obj *LogicalRouterDataSourceVrfMulticastPimObject
	if o.Pim.IsNull() {
		pim_obj = new(LogicalRouterDataSourceVrfMulticastPimObject)
	} else {
		diags.Append(o.Pim.As(ctx, &pim_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pim_object := types.ObjectNull(pim_obj.AttributeTypes())
	if obj.Pim != nil {
		diags.Append(pim_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pim_object, diags_tmp = types.ObjectValueFrom(ctx, pim_obj.AttributeTypes(), pim_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var igmp_obj *LogicalRouterDataSourceVrfMulticastIgmpObject
	if o.Igmp.IsNull() {
		igmp_obj = new(LogicalRouterDataSourceVrfMulticastIgmpObject)
	} else {
		diags.Append(o.Igmp.As(ctx, &igmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	igmp_object := types.ObjectNull(igmp_obj.AttributeTypes())
	if obj.Igmp != nil {
		diags.Append(igmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		igmp_object, diags_tmp = types.ObjectValueFrom(ctx, igmp_obj.AttributeTypes(), igmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var msdp_obj *LogicalRouterDataSourceVrfMulticastMsdpObject
	if o.Msdp.IsNull() {
		msdp_obj = new(LogicalRouterDataSourceVrfMulticastMsdpObject)
	} else {
		diags.Append(o.Msdp.As(ctx, &msdp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	msdp_object := types.ObjectNull(msdp_obj.AttributeTypes())
	if obj.Msdp != nil {
		diags.Append(msdp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Msdp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		msdp_object, diags_tmp = types.ObjectValueFrom(ctx, msdp_obj.AttributeTypes(), msdp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.StaticRoute = staticRoute_list
	o.Pim = pim_object
	o.Igmp = igmp_object
	o.Msdp = msdp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var preference_value types.Int64
	if obj.Preference != nil {
		preference_value = types.Int64Value(*obj.Preference)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.Preference = preference_value
	o.Nexthop = nexthop_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.IpAddress = ipAddress_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []LogicalRouterDataSourceVrfMulticastPimSptThresholdObject
		if !o.SptThreshold.IsNull() {
			diags.Append(o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SptThreshold {
			entry := LogicalRouterDataSourceVrfMulticastPimSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sptThreshold_tf_entries) {
				entry = sptThreshold_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sptThreshold_tf_entries) {
				sptThreshold_tf_entries[idx] = entry
			} else {
				sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfMulticastPimInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfMulticastPimInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	var ssmAddressSpace_obj *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject
	if o.SsmAddressSpace.IsNull() {
		ssmAddressSpace_obj = new(LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject)
	} else {
		diags.Append(o.SsmAddressSpace.As(ctx, &ssmAddressSpace_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ssmAddressSpace_object := types.ObjectNull(ssmAddressSpace_obj.AttributeTypes())
	if obj.SsmAddressSpace != nil {
		diags.Append(ssmAddressSpace_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SsmAddressSpace, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ssmAddressSpace_object, diags_tmp = types.ObjectValueFrom(ctx, ssmAddressSpace_obj.AttributeTypes(), ssmAddressSpace_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rp_obj *LogicalRouterDataSourceVrfMulticastPimRpObject
	if o.Rp.IsNull() {
		rp_obj = new(LogicalRouterDataSourceVrfMulticastPimRpObject)
	} else {
		diags.Append(o.Rp.As(ctx, &rp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rp_object := types.ObjectNull(rp_obj.AttributeTypes())
	if obj.Rp != nil {
		diags.Append(rp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rp_object, diags_tmp = types.ObjectValueFrom(ctx, rp_obj.AttributeTypes(), rp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rpfLookupMode_value types.String
	if obj.RpfLookupMode != nil {
		rpfLookupMode_value = types.StringValue(*obj.RpfLookupMode)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	var ifTimerGlobal_value types.String
	if obj.IfTimerGlobal != nil {
		ifTimerGlobal_value = types.StringValue(*obj.IfTimerGlobal)
	}
	var groupPermission_value types.String
	if obj.GroupPermission != nil {
		groupPermission_value = types.StringValue(*obj.GroupPermission)
	}
	o.Enable = enable_value
	o.RpfLookupMode = rpfLookupMode_value
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.IfTimerGlobal = ifTimerGlobal_value
	o.GroupPermission = groupPermission_value
	o.SsmAddressSpace = ssmAddressSpace_object
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject
		if !o.ExternalRp.IsNull() {
			diags.Append(o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExternalRp {
			entry := LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(externalRp_tf_entries) {
				entry = externalRp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(externalRp_tf_entries) {
				externalRp_tf_entries[idx] = entry
			} else {
				externalRp_tf_entries = append(externalRp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}

	var localRp_obj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject
	if o.LocalRp.IsNull() {
		localRp_obj = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject)
	} else {
		diags.Append(o.LocalRp.As(ctx, &localRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localRp_object := types.ObjectNull(localRp_obj.AttributeTypes())
	if obj.LocalRp != nil {
		diags.Append(localRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localRp_object, diags_tmp = types.ObjectValueFrom(ctx, localRp_obj.AttributeTypes(), localRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.LocalRp = localRp_object
	o.ExternalRp = externalRp_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var staticRp_obj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject
	if o.StaticRp.IsNull() {
		staticRp_obj = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject)
	} else {
		diags.Append(o.StaticRp.As(ctx, &staticRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticRp_object := types.ObjectNull(staticRp_obj.AttributeTypes())
	if obj.StaticRp != nil {
		diags.Append(staticRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticRp_object, diags_tmp = types.ObjectValueFrom(ctx, staticRp_obj.AttributeTypes(), staticRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var candidateRp_obj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject
	if o.CandidateRp.IsNull() {
		candidateRp_obj = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject)
	} else {
		diags.Append(o.CandidateRp.As(ctx, &candidateRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	candidateRp_object := types.ObjectNull(candidateRp_obj.AttributeTypes())
	if obj.CandidateRp != nil {
		diags.Append(candidateRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		candidateRp_object, diags_tmp = types.ObjectValueFrom(ctx, candidateRp_obj.AttributeTypes(), candidateRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.StaticRp = staticRp_object
	o.CandidateRp = candidateRp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Override = override_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Priority = priority_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupList = groupList_value
	o.Override = override_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var sendBsm_value types.Bool
	if obj.SendBsm != nil {
		sendBsm_value = types.BoolValue(*obj.SendBsm)
	}
	var ifTimer_value types.String
	if obj.IfTimer != nil {
		ifTimer_value = types.StringValue(*obj.IfTimer)
	}
	var neighborFilter_value types.String
	if obj.NeighborFilter != nil {
		neighborFilter_value = types.StringValue(*obj.NeighborFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.DrPriority = drPriority_value
	o.SendBsm = sendBsm_value
	o.IfTimer = ifTimer_value
	o.NeighborFilter = neighborFilter_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_list types.List
	{
		var static_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpStaticObject
		if !o.Static.IsNull() {
			diags.Append(o.Static.ElementsAs(ctx, &static_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Static {
			entry := LogicalRouterDataSourceVrfMulticastIgmpStaticObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(static_tf_entries) {
				entry = static_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(static_tf_entries) {
				static_tf_entries[idx] = entry
			} else {
				static_tf_entries = append(static_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static")
		static_list, list_diags = types.ListValueFrom(ctx, schemaType, static_tf_entries)
		diags.Append(list_diags...)
	}

	var dynamic_obj *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(LogicalRouterDataSourceVrfMulticastIgmpDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Dynamic = dynamic_object
	o.Static = static_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var groupFilter_value types.String
	if obj.GroupFilter != nil {
		groupFilter_value = types.StringValue(*obj.GroupFilter)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var queryProfile_value types.String
	if obj.QueryProfile != nil {
		queryProfile_value = types.StringValue(*obj.QueryProfile)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Version = version_value
	o.Robustness = robustness_value
	o.GroupFilter = groupFilter_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.QueryProfile = queryProfile_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterDataSourceVrfMulticastMsdpPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := LogicalRouterDataSourceVrfMulticastMsdpPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var originatorId_obj *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject
	if o.OriginatorId.IsNull() {
		originatorId_obj = new(LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject)
	} else {
		diags.Append(o.OriginatorId.As(ctx, &originatorId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	originatorId_object := types.ObjectNull(originatorId_obj.AttributeTypes())
	if obj.OriginatorId != nil {
		diags.Append(originatorId_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.OriginatorId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		originatorId_object, diags_tmp = types.ObjectValueFrom(ctx, originatorId_obj.AttributeTypes(), originatorId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var globalAuthentication_value types.String
	if obj.GlobalAuthentication != nil {
		globalAuthentication_value = types.StringValue(*obj.GlobalAuthentication)
	}
	o.Enable = enable_value
	o.GlobalTimer = globalTimer_value
	o.GlobalAuthentication = globalAuthentication_value
	o.OriginatorId = originatorId_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localAddress_obj *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var maxSa_value types.Int64
	if obj.MaxSa != nil {
		maxSa_value = types.Int64Value(*obj.MaxSa)
	}
	var inboundSaFilter_value types.String
	if obj.InboundSaFilter != nil {
		inboundSaFilter_value = types.StringValue(*obj.InboundSaFilter)
	}
	var outboundSaFilter_value types.String
	if obj.OutboundSaFilter != nil {
		outboundSaFilter_value = types.StringValue(*obj.OutboundSaFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.Authentication = authentication_value
	o.MaxSa = maxSa_value
	o.InboundSaFilter = inboundSaFilter_value
	o.OutboundSaFilter = outboundSaFilter_value
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []LogicalRouterDataSourceVrfRipInterfacesObject
		if !o.Interfaces.IsNull() {
			diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaces_tf_entries) {
				entry = interfaces_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaces_tf_entries) {
				interfaces_tf_entries[idx] = entry
			} else {
				interfaces_tf_entries = append(interfaces_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterDataSourceVrfRipGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterDataSourceVrfRipGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalInboundDistributeList_obj *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject
	if o.GlobalInboundDistributeList.IsNull() {
		globalInboundDistributeList_obj = new(LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject)
	} else {
		diags.Append(o.GlobalInboundDistributeList.As(ctx, &globalInboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalInboundDistributeList_object := types.ObjectNull(globalInboundDistributeList_obj.AttributeTypes())
	if obj.GlobalInboundDistributeList != nil {
		diags.Append(globalInboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalInboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, globalInboundDistributeList_obj.AttributeTypes(), globalInboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalOutboundDistributeList_obj *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject
	if o.GlobalOutboundDistributeList.IsNull() {
		globalOutboundDistributeList_obj = new(LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject)
	} else {
		diags.Append(o.GlobalOutboundDistributeList.As(ctx, &globalOutboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalOutboundDistributeList_object := types.ObjectNull(globalOutboundDistributeList_obj.AttributeTypes())
	if obj.GlobalOutboundDistributeList != nil {
		diags.Append(globalOutboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalOutboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, globalOutboundDistributeList_obj.AttributeTypes(), globalOutboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var defaultInformationOriginate_value types.Bool
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_value = types.BoolValue(*obj.DefaultInformationOriginate)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var authProfile_value types.String
	if obj.AuthProfile != nil {
		authProfile_value = types.StringValue(*obj.AuthProfile)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.DefaultInformationOriginate = defaultInformationOriginate_value
	o.GlobalTimer = globalTimer_value
	o.AuthProfile = authProfile_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GlobalInboundDistributeList = globalInboundDistributeList_object
	o.GlobalOutboundDistributeList = globalOutboundDistributeList_object
	o.Interfaces = interfaces_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *LogicalRouterDataSourceVrfRipInterfacesBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterDataSourceVrfRipInterfacesBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interfaceInboundDistributeList_obj *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject
	if o.InterfaceInboundDistributeList.IsNull() {
		interfaceInboundDistributeList_obj = new(LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject)
	} else {
		diags.Append(o.InterfaceInboundDistributeList.As(ctx, &interfaceInboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceInboundDistributeList_object := types.ObjectNull(interfaceInboundDistributeList_obj.AttributeTypes())
	if obj.InterfaceInboundDistributeList != nil {
		diags.Append(interfaceInboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InterfaceInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		interfaceInboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, interfaceInboundDistributeList_obj.AttributeTypes(), interfaceInboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interfaceOutboundDistributeList_obj *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	if o.InterfaceOutboundDistributeList.IsNull() {
		interfaceOutboundDistributeList_obj = new(LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject)
	} else {
		diags.Append(o.InterfaceOutboundDistributeList.As(ctx, &interfaceOutboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceOutboundDistributeList_object := types.ObjectNull(interfaceOutboundDistributeList_obj.AttributeTypes())
	if obj.InterfaceOutboundDistributeList != nil {
		diags.Append(interfaceOutboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InterfaceOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		interfaceOutboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, interfaceOutboundDistributeList_obj.AttributeTypes(), interfaceOutboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var splitHorizon_value types.String
	if obj.SplitHorizon != nil {
		splitHorizon_value = types.StringValue(*obj.SplitHorizon)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Mode = mode_value
	o.SplitHorizon = splitHorizon_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.InterfaceInboundDistributeList = interfaceInboundDistributeList_object
	o.InterfaceOutboundDistributeList = interfaceOutboundDistributeList_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func LogicalRouterDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": LogicalRouterDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vrf": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceModel) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"administrative_distances": LogicalRouterDataSourceVrfAdministrativeDistancesSchema(),

			"rib_filter": LogicalRouterDataSourceVrfRibFilterSchema(),

			"bgp": LogicalRouterDataSourceVrfBgpSchema(),

			"routing_table": LogicalRouterDataSourceVrfRoutingTableSchema(),

			"ospf": LogicalRouterDataSourceVrfOspfSchema(),

			"ospfv3": LogicalRouterDataSourceVrfOspfv3Schema(),

			"ecmp": LogicalRouterDataSourceVrfEcmpSchema(),

			"multicast": LogicalRouterDataSourceVrfMulticastSchema(),

			"rip": LogicalRouterDataSourceVrfRipSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfAdministrativeDistancesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": dsschema.Int64Attribute{
				Description: "Set IPv4 Static Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": dsschema.Int64Attribute{
				Description: "Set IPv6 Static Routes  Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_inter": dsschema.Int64Attribute{
				Description: "Set OSPF Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_intra": dsschema.Int64Attribute{
				Description: "Set OSPF Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": dsschema.Int64Attribute{
				Description: "Set OSPF External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_inter": dsschema.Int64Attribute{
				Description: "Set OSPFv3 Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_intra": dsschema.Int64Attribute{
				Description: "Set OSPFv3 Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": dsschema.Int64Attribute{
				Description: "Set OSPFv3 External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_internal": dsschema.Int64Attribute{
				Description: "Set BGP AS Internal Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_external": dsschema.Int64Attribute{
				Description: "Set BGP AS External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_local": dsschema.Int64Attribute{
				Description: "Set BGP Local Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": dsschema.Int64Attribute{
				Description: "Set RIP Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfRibFilterIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfRibFilterIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema(),

			"bgp": LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema(),

			"ospf": LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema(),

			"rip": LogicalRouterDataSourceVrfRibFilterIpv4RipSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on OSPF Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4RipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on RIP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4RipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema(),

			"bgp": LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema(),

			"ospfv3": LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on OSPFv3 Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": dsschema.StringAttribute{
				Description: "local AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"install_route": dsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": dsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_external_failover": dsschema.BoolAttribute{
				Description: "Immediately reset session if a link to a directly connected external peer goes down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ecmp_multi_as": dsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": dsschema.Int64Attribute{
				Description: "Global Default Local Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"graceful_shutdown": dsschema.BoolAttribute{
				Description: "Gracefully Shutdown BGP following RFC-8326",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"always_advertise_network_route": dsschema.BoolAttribute{
				Description: "Always advertise network routes even if not present in RIB",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": LogicalRouterDataSourceVrfBgpMedSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfBgpGracefulRestartSchema(),

			"global_bfd": LogicalRouterDataSourceVrfBgpGlobalBfdSchema(),

			"redistribution_profile": LogicalRouterDataSourceVrfBgpRedistributionProfileSchema(),

			"advertise_network": LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema(),

			"peer_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpPeerGroupSchema(),
			},

			"aggregate_routes": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAggregateRoutesSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpMedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"always_compare_med": dsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": dsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpMedObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": dsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_peer_restart_time": dsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": dsschema.Int64Attribute{
				Description: "local restart time to advertise to peer Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"network": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": dsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": dsschema.BoolAttribute{
				Description: "Multicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"backdoor": dsschema.BoolAttribute{
				Description: "Mark network as backdoor route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"network": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": dsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema(),

			"address_family": LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema(),

			"filtering_profile": LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema(),

			"connection_options": LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ibgp": LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema(),

			"ebgp": LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"timers": dsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.Int64Attribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": dsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "If enabled, open messages are not sent to this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherit": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema(),

			"local_address": LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"yes": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema(),

			"no": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"address_family": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema(),

			"filtering_profile": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"timers": dsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.StringAttribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": dsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Aggregate Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable Aggregation for this Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary_only": dsschema.BoolAttribute{
				Description: "Send only Summary Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": dsschema.BoolAttribute{
				Description: "Generate AS set path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"same_med": dsschema.BoolAttribute{
				Description: "Aggregate Routes only if they have same MED Attributes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"summary_prefix": dsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"summary_prefix": dsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": LogicalRouterDataSourceVrfRoutingTableIpSchema(),

			"ipv6": LogicalRouterDataSourceVrfRoutingTableIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema(),

			"bfd": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"discard": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema(),

			"ip_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": dsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("next_lr"),
				path.MatchRelative().AtParent().AtName("fqdn"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema(),

			"bfd": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema(),

			"path_monitor": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"discard": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": dsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_lr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": dsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": dsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": dsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfOspfGlobalBfdSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfOspfGracefulRestartSchema(),

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfOspfAreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema(),

			"stub": LogicalRouterDataSourceVrfOspfAreaTypeStubSchema(),

			"nssa": LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema(),

			"default_route_metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric_type": dsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": dsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPF instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_transit_traffic": dsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": dsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": dsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema(),

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfOspfv3AreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema(),

			"stub": LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema(),

			"nssa": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema(),

			"default_route_metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric_type": dsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": dsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": dsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": dsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": dsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": LogicalRouterDataSourceVrfEcmpAlgorithmSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_modulo": LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema(),

			"ip_hash": LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema(),

			"weighted_round_robin": LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"src_only": dsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": dsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": dsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastStaticRouteSchema(),
			},

			"pim": LogicalRouterDataSourceVrfMulticastPimSchema(),

			"igmp": LogicalRouterDataSourceVrfMulticastIgmpSchema(),

			"msdp": LogicalRouterDataSourceVrfMulticastMsdpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastStaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preference": dsschema.Int64Attribute{
				Description: "administrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rpf_lookup_mode": dsschema.StringAttribute{
				Description: "RPF Lookup Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_ageout_time": dsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer_global": dsschema.StringAttribute{
				Description: "Global Interface Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_permission": dsschema.StringAttribute{
				Description: "ASM/SSM group permission",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssm_address_space": LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema(),

			"rp": LogicalRouterDataSourceVrfMulticastPimRpSchema(),

			"spt_threshold": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"group_list": dsschema.StringAttribute{
				Description: "SSM Group Prefix List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema(),

			"external_rp": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema(),

			"candidate_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "local RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": dsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": dsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_bsm": dsschema.BoolAttribute{
				Description: "Send BSM",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer": dsschema.StringAttribute{
				Description: "Interface Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_filter": dsschema.StringAttribute{
				Description: "Set the filter for neighbor list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dynamic": LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema(),

			"static": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastIgmpStaticSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"version": dsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": dsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_filter": dsschema.StringAttribute{
				Description: "ASM/SSM Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_groups": dsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sources": dsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"query_profile": dsschema.StringAttribute{
				Description: "IGMP Query Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": dsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpStaticSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "multicast interfaces",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": dsschema.StringAttribute{
				Description: "source-address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": dsschema.StringAttribute{
				Description: "Global timer profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_authentication": dsschema.StringAttribute{
				Description: "Global authentication profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastMsdpPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface of originator",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sa": dsschema.Int64Attribute{
				Description: "Maximum number of SA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_sa_filter": dsschema.StringAttribute{
				Description: "Inbound SA Filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_sa_filter": dsschema.StringAttribute{
				Description: "Outbound SA Filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema(),

			"peer_address": LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface to accept MSDP connection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": dsschema.BoolAttribute{
				Description: "advertise default route in RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": dsschema.StringAttribute{
				Description: "timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.StringAttribute{
				Description: "Authentication profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfRipGlobalBfdSchema(),

			"global_inbound_distribute_list": LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema(),

			"global_outbound_distribute_list": LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema(),

			"interfaces": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRipInterfacesSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable RIP on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"split_horizon": dsschema.StringAttribute{
				Description: "Split horizon options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterDataSourceVrfRipInterfacesBfdSchema(),

			"interface_inbound_distribute_list": LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema(),

			"interface_outbound_distribute_list": LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceLocationSchema() rsschema.Attribute {
	return LogicalRouterLocationSchema()
}

// Metadata returns the data source type name.
func (d *LogicalRouterDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_logical_router"
}

// Schema defines the schema for this data source.
func (d *LogicalRouterDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = LogicalRouterDataSourceSchema()
}

// Configure prepares the struct.
func (d *LogicalRouterDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := logical_router.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service](d.client, logical_router.NewService(d.client), batchSize, specifier, logical_router.SpecMatches)
}
func (o *LogicalRouterDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state LogicalRouterDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &logical_router.NgfwLocation{}
			var innerLocation LogicalRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &LogicalRouterResource{}
	_ resource.ResourceWithConfigure   = &LogicalRouterResource{}
	_ resource.ResourceWithImportState = &LogicalRouterResource{}
)

func NewLogicalRouterResource() resource.Resource {
	if _, found := resourceFuncMap["panos_logical_router"]; !found {
		resourceFuncMap["panos_logical_router"] = resourceFuncs{
			CreateImportId: LogicalRouterImportStateCreator,
		}
	}
	return &LogicalRouterResource{}
}

type LogicalRouterResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service]
}

func LogicalRouterResourceLocationSchema() rsschema.Attribute {
	return LogicalRouterLocationSchema()
}

type LogicalRouterResourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Vrf      types.List   `tfsdk:"vrf"`
}
type LogicalRouterResourceVrfObject struct {
	Name                    types.String `tfsdk:"name"`
	Interface               types.List   `tfsdk:"interface"`
	AdministrativeDistances types.Object `tfsdk:"administrative_distances"`
	RibFilter               types.Object `tfsdk:"rib_filter"`
	Bgp                     types.Object `tfsdk:"bgp"`
	RoutingTable            types.Object `tfsdk:"routing_table"`
	Ospf                    types.Object `tfsdk:"ospf"`
	Ospfv3                  types.Object `tfsdk:"ospfv3"`
	Ecmp                    types.Object `tfsdk:"ecmp"`
	Multicast               types.Object `tfsdk:"multicast"`
	Rip                     types.Object `tfsdk:"rip"`
}
type LogicalRouterResourceVrfAdministrativeDistancesObject struct {
	Static      types.Int64 `tfsdk:"static"`
	StaticIpv6  types.Int64 `tfsdk:"static_ipv6"`
	OspfInter   types.Int64 `tfsdk:"ospf_inter"`
	OspfIntra   types.Int64 `tfsdk:"ospf_intra"`
	OspfExt     types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Inter types.Int64 `tfsdk:"ospfv3_inter"`
	Ospfv3Intra types.Int64 `tfsdk:"ospfv3_intra"`
	Ospfv3Ext   types.Int64 `tfsdk:"ospfv3_ext"`
	BgpInternal types.Int64 `tfsdk:"bgp_internal"`
	BgpExternal types.Int64 `tfsdk:"bgp_external"`
	BgpLocal    types.Int64 `tfsdk:"bgp_local"`
	Rip         types.Int64 `tfsdk:"rip"`
}
type LogicalRouterResourceVrfRibFilterObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfRibFilterIpv4Object struct {
	Static types.Object `tfsdk:"static"`
	Bgp    types.Object `tfsdk:"bgp"`
	Ospf   types.Object `tfsdk:"ospf"`
	Rip    types.Object `tfsdk:"rip"`
}
type LogicalRouterResourceVrfRibFilterIpv4StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4OspfObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4RipObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6Object struct {
	Static types.Object `tfsdk:"static"`
	Bgp    types.Object `tfsdk:"bgp"`
	Ospfv3 types.Object `tfsdk:"ospfv3"`
}
type LogicalRouterResourceVrfRibFilterIpv6StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfBgpObject struct {
	Enable                      types.Bool   `tfsdk:"enable"`
	RouterId                    types.String `tfsdk:"router_id"`
	LocalAs                     types.String `tfsdk:"local_as"`
	InstallRoute                types.Bool   `tfsdk:"install_route"`
	EnforceFirstAs              types.Bool   `tfsdk:"enforce_first_as"`
	FastExternalFailover        types.Bool   `tfsdk:"fast_external_failover"`
	EcmpMultiAs                 types.Bool   `tfsdk:"ecmp_multi_as"`
	DefaultLocalPreference      types.Int64  `tfsdk:"default_local_preference"`
	GracefulShutdown            types.Bool   `tfsdk:"graceful_shutdown"`
	AlwaysAdvertiseNetworkRoute types.Bool   `tfsdk:"always_advertise_network_route"`
	Med                         types.Object `tfsdk:"med"`
	GracefulRestart             types.Object `tfsdk:"graceful_restart"`
	GlobalBfd                   types.Object `tfsdk:"global_bfd"`
	RedistributionProfile       types.Object `tfsdk:"redistribution_profile"`
	AdvertiseNetwork            types.Object `tfsdk:"advertise_network"`
	PeerGroup                   types.List   `tfsdk:"peer_group"`
	AggregateRoutes             types.List   `tfsdk:"aggregate_routes"`
}
type LogicalRouterResourceVrfBgpMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type LogicalRouterResourceVrfBgpGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
}
type LogicalRouterResourceVrfBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject struct {
	Name      types.String `tfsdk:"name"`
	Unicast   types.Bool   `tfsdk:"unicast"`
	Multicast types.Bool   `tfsdk:"multicast"`
	Backdoor  types.Bool   `tfsdk:"backdoor"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject struct {
	Name    types.String `tfsdk:"name"`
	Unicast types.Bool   `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpPeerGroupObject struct {
	Name              types.String `tfsdk:"name"`
	Enable            types.Bool   `tfsdk:"enable"`
	Type              types.Object `tfsdk:"type"`
	AddressFamily     types.Object `tfsdk:"address_family"`
	FilteringProfile  types.Object `tfsdk:"filtering_profile"`
	ConnectionOptions types.Object `tfsdk:"connection_options"`
	Peer              types.List   `tfsdk:"peer"`
}
type LogicalRouterResourceVrfBgpPeerGroupTypeObject struct {
	Ibgp types.Object `tfsdk:"ibgp"`
	Ebgp types.Object `tfsdk:"ebgp"`
}
type LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.Int64  `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerObject struct {
	Name                          types.String `tfsdk:"name"`
	Enable                        types.Bool   `tfsdk:"enable"`
	Passive                       types.Bool   `tfsdk:"passive"`
	PeerAs                        types.String `tfsdk:"peer_as"`
	EnableSenderSideLoopDetection types.Bool   `tfsdk:"enable_sender_side_loop_detection"`
	Inherit                       types.Object `tfsdk:"inherit"`
	LocalAddress                  types.Object `tfsdk:"local_address"`
	PeerAddress                   types.Object `tfsdk:"peer_address"`
	ConnectionOptions             types.Object `tfsdk:"connection_options"`
	Bfd                           types.Object `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject struct {
	Yes types.Object `tfsdk:"yes"`
	No  types.Object `tfsdk:"no"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject struct {
	AddressFamily    types.Object `tfsdk:"address_family"`
	FilteringProfile types.Object `tfsdk:"filtering_profile"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.String `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesObject struct {
	Name        types.String `tfsdk:"name"`
	Description types.String `tfsdk:"description"`
	Enable      types.Bool   `tfsdk:"enable"`
	SummaryOnly types.Bool   `tfsdk:"summary_only"`
	AsSet       types.Bool   `tfsdk:"as_set"`
	SameMed     types.Bool   `tfsdk:"same_med"`
	Type        types.Object `tfsdk:"type"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeObject struct {
	Ipv4 types.Object `tfsdk:"ipv4"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterResourceVrfRoutingTableObject struct {
	Ip   types.Object `tfsdk:"ip"`
	Ipv6 types.Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteObject struct {
	Name                   types.String `tfsdk:"name"`
	Destination            types.String `tfsdk:"destination"`
	Interface              types.String `tfsdk:"interface"`
	AdministrativeDistance types.Int64  `tfsdk:"administrative_distance"`
	Metric                 types.Int64  `tfsdk:"metric"`
	Nexthop                types.Object `tfsdk:"nexthop"`
	Bfd                    types.Object `tfsdk:"bfd"`
	PathMonitor            types.Object `tfsdk:"path_monitor"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject struct {
	Discard   types.Object `tfsdk:"discard"`
	IpAddress types.String `tfsdk:"ip_address"`
	NextLr    types.String `tfsdk:"next_lr"`
	Fqdn      types.String `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterResourceVrfRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String `tfsdk:"name"`
	Destination            types.String `tfsdk:"destination"`
	Interface              types.String `tfsdk:"interface"`
	AdministrativeDistance types.Int64  `tfsdk:"administrative_distance"`
	Metric                 types.Int64  `tfsdk:"metric"`
	Nexthop                types.Object `tfsdk:"nexthop"`
	Bfd                    types.Object `tfsdk:"bfd"`
	PathMonitor            types.Object `tfsdk:"path_monitor"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject struct {
	Discard     types.Object `tfsdk:"discard"`
	Ipv6Address types.String `tfsdk:"ipv6_address"`
	Fqdn        types.String `tfsdk:"fqdn"`
	NextLr      types.String `tfsdk:"next_lr"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterResourceVrfOspfObject struct {
	RouterId              types.String `tfsdk:"router_id"`
	Enable                types.Bool   `tfsdk:"enable"`
	Rfc1583               types.Bool   `tfsdk:"rfc1583"`
	SpfTimer              types.String `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String `tfsdk:"global_if_timer"`
	RedistributionProfile types.String `tfsdk:"redistribution_profile"`
	GlobalBfd             types.Object `tfsdk:"global_bfd"`
	GracefulRestart       types.Object `tfsdk:"graceful_restart"`
	Area                  types.List   `tfsdk:"area"`
}
type LogicalRouterResourceVrfOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterResourceVrfOspfAreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type LogicalRouterResourceVrfOspfAreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type LogicalRouterResourceVrfOspfAreaTypeNormalObject struct {
	Abr types.Object `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfAreaTypeStubObject struct {
	NoSummary          types.Bool   `tfsdk:"no_summary"`
	Abr                types.Object `tfsdk:"abr"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
}
type LogicalRouterResourceVrfOspfAreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaObject struct {
	NoSummary                   types.Bool   `tfsdk:"no_summary"`
	DefaultInformationOriginate types.Object `tfsdk:"default_information_originate"`
	Abr                         types.Object `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	MtuIgnore      types.Bool   `tfsdk:"mtu_ignore"`
	Passive        types.Bool   `tfsdk:"passive"`
	Priority       types.Int64  `tfsdk:"priority"`
	Metric         types.Int64  `tfsdk:"metric"`
	Authentication types.String `tfsdk:"authentication"`
	Timing         types.String `tfsdk:"timing"`
	LinkType       types.Object `tfsdk:"link_type"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfAreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3Object struct {
	Enable                types.Bool   `tfsdk:"enable"`
	RouterId              types.String `tfsdk:"router_id"`
	DisableTransitTraffic types.Bool   `tfsdk:"disable_transit_traffic"`
	SpfTimer              types.String `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String `tfsdk:"global_if_timer"`
	RedistributionProfile types.String `tfsdk:"redistribution_profile"`
	GlobalBfd             types.Object `tfsdk:"global_bfd"`
	GracefulRestart       types.Object `tfsdk:"graceful_restart"`
	Area                  types.List   `tfsdk:"area"`
}
type LogicalRouterResourceVrfOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterResourceVrfOspfv3AreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNormalObject struct {
	Abr types.Object `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeStubObject struct {
	NoSummary          types.Bool   `tfsdk:"no_summary"`
	Abr                types.Object `tfsdk:"abr"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaObject struct {
	NoSummary                   types.Bool   `tfsdk:"no_summary"`
	DefaultInformationOriginate types.Object `tfsdk:"default_information_originate"`
	Abr                         types.Object `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	MtuIgnore      types.Bool   `tfsdk:"mtu_ignore"`
	Passive        types.Bool   `tfsdk:"passive"`
	Priority       types.Int64  `tfsdk:"priority"`
	Metric         types.Int64  `tfsdk:"metric"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Authentication types.String `tfsdk:"authentication"`
	Timing         types.String `tfsdk:"timing"`
	LinkType       types.Object `tfsdk:"link_type"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
}
type LogicalRouterResourceVrfEcmpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	MaxPaths         types.Int64  `tfsdk:"max_paths"`
	SymmetricReturn  types.Bool   `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool   `tfsdk:"strict_source_path"`
	Algorithm        types.Object `tfsdk:"algorithm"`
}
type LogicalRouterResourceVrfEcmpAlgorithmObject struct {
	IpModulo           types.Object `tfsdk:"ip_modulo"`
	IpHash             types.Object `tfsdk:"ip_hash"`
	WeightedRoundRobin types.Object `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin types.Object `tfsdk:"balanced_round_robin"`
}
type LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject struct {
}
type LogicalRouterResourceVrfEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject struct {
}
type LogicalRouterResourceVrfMulticastObject struct {
	Enable      types.Bool   `tfsdk:"enable"`
	StaticRoute types.List   `tfsdk:"static_route"`
	Pim         types.Object `tfsdk:"pim"`
	Igmp        types.Object `tfsdk:"igmp"`
	Msdp        types.Object `tfsdk:"msdp"`
}
type LogicalRouterResourceVrfMulticastStaticRouteObject struct {
	Name        types.String `tfsdk:"name"`
	Destination types.String `tfsdk:"destination"`
	Interface   types.String `tfsdk:"interface"`
	Preference  types.Int64  `tfsdk:"preference"`
	Nexthop     types.Object `tfsdk:"nexthop"`
}
type LogicalRouterResourceVrfMulticastStaticRouteNexthopObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
}
type LogicalRouterResourceVrfMulticastPimObject struct {
	Enable          types.Bool   `tfsdk:"enable"`
	RpfLookupMode   types.String `tfsdk:"rpf_lookup_mode"`
	RouteAgeoutTime types.Int64  `tfsdk:"route_ageout_time"`
	IfTimerGlobal   types.String `tfsdk:"if_timer_global"`
	GroupPermission types.String `tfsdk:"group_permission"`
	SsmAddressSpace types.Object `tfsdk:"ssm_address_space"`
	Rp              types.Object `tfsdk:"rp"`
	SptThreshold    types.List   `tfsdk:"spt_threshold"`
	Interface       types.List   `tfsdk:"interface"`
}
type LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject struct {
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpObject struct {
	LocalRp    types.Object `tfsdk:"local_rp"`
	ExternalRp types.List   `tfsdk:"external_rp"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpObject struct {
	StaticRp    types.Object `tfsdk:"static_rp"`
	CandidateRp types.Object `tfsdk:"candidate_rp"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject struct {
	Interface types.String `tfsdk:"interface"`
	Address   types.String `tfsdk:"address"`
	Override  types.Bool   `tfsdk:"override"`
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject struct {
	Interface             types.String `tfsdk:"interface"`
	Address               types.String `tfsdk:"address"`
	Priority              types.Int64  `tfsdk:"priority"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupList             types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpExternalRpObject struct {
	Name      types.String `tfsdk:"name"`
	GroupList types.String `tfsdk:"group_list"`
	Override  types.Bool   `tfsdk:"override"`
}
type LogicalRouterResourceVrfMulticastPimSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type LogicalRouterResourceVrfMulticastPimInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Description    types.String `tfsdk:"description"`
	DrPriority     types.Int64  `tfsdk:"dr_priority"`
	SendBsm        types.Bool   `tfsdk:"send_bsm"`
	IfTimer        types.String `tfsdk:"if_timer"`
	NeighborFilter types.String `tfsdk:"neighbor_filter"`
}
type LogicalRouterResourceVrfMulticastIgmpObject struct {
	Enable  types.Bool   `tfsdk:"enable"`
	Dynamic types.Object `tfsdk:"dynamic"`
	Static  types.List   `tfsdk:"static"`
}
type LogicalRouterResourceVrfMulticastIgmpDynamicObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject struct {
	Name                types.String `tfsdk:"name"`
	Version             types.String `tfsdk:"version"`
	Robustness          types.String `tfsdk:"robustness"`
	GroupFilter         types.String `tfsdk:"group_filter"`
	MaxGroups           types.String `tfsdk:"max_groups"`
	MaxSources          types.String `tfsdk:"max_sources"`
	QueryProfile        types.String `tfsdk:"query_profile"`
	RouterAlertPolicing types.Bool   `tfsdk:"router_alert_policing"`
}
type LogicalRouterResourceVrfMulticastIgmpStaticObject struct {
	Name          types.String `tfsdk:"name"`
	Interface     types.String `tfsdk:"interface"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
}
type LogicalRouterResourceVrfMulticastMsdpObject struct {
	Enable               types.Bool   `tfsdk:"enable"`
	GlobalTimer          types.String `tfsdk:"global_timer"`
	GlobalAuthentication types.String `tfsdk:"global_authentication"`
	OriginatorId         types.Object `tfsdk:"originator_id"`
	Peer                 types.List   `tfsdk:"peer"`
}
type LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerObject struct {
	Name             types.String `tfsdk:"name"`
	Enable           types.Bool   `tfsdk:"enable"`
	PeerAs           types.String `tfsdk:"peer_as"`
	Authentication   types.String `tfsdk:"authentication"`
	MaxSa            types.Int64  `tfsdk:"max_sa"`
	InboundSaFilter  types.String `tfsdk:"inbound_sa_filter"`
	OutboundSaFilter types.String `tfsdk:"outbound_sa_filter"`
	LocalAddress     types.Object `tfsdk:"local_address"`
	PeerAddress      types.Object `tfsdk:"peer_address"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfRipObject struct {
	Enable                       types.Bool   `tfsdk:"enable"`
	DefaultInformationOriginate  types.Bool   `tfsdk:"default_information_originate"`
	GlobalTimer                  types.String `tfsdk:"global_timer"`
	AuthProfile                  types.String `tfsdk:"auth_profile"`
	RedistributionProfile        types.String `tfsdk:"redistribution_profile"`
	GlobalBfd                    types.Object `tfsdk:"global_bfd"`
	GlobalInboundDistributeList  types.Object `tfsdk:"global_inbound_distribute_list"`
	GlobalOutboundDistributeList types.Object `tfsdk:"global_outbound_distribute_list"`
	Interfaces                   types.List   `tfsdk:"interfaces"`
}
type LogicalRouterResourceVrfRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRipGlobalInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterResourceVrfRipInterfacesObject struct {
	Name                            types.String `tfsdk:"name"`
	Enable                          types.Bool   `tfsdk:"enable"`
	Mode                            types.String `tfsdk:"mode"`
	SplitHorizon                    types.String `tfsdk:"split_horizon"`
	Authentication                  types.String `tfsdk:"authentication"`
	Bfd                             types.Object `tfsdk:"bfd"`
	InterfaceInboundDistributeList  types.Object `tfsdk:"interface_inbound_distribute_list"`
	InterfaceOutboundDistributeList types.Object `tfsdk:"interface_outbound_distribute_list"`
}
type LogicalRouterResourceVrfRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}
type LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}

func (o *LogicalRouterResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func LogicalRouterResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": LogicalRouterResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vrf": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceModel) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"administrative_distances": LogicalRouterResourceVrfAdministrativeDistancesSchema(),

			"rib_filter": LogicalRouterResourceVrfRibFilterSchema(),

			"bgp": LogicalRouterResourceVrfBgpSchema(),

			"routing_table": LogicalRouterResourceVrfRoutingTableSchema(),

			"ospf": LogicalRouterResourceVrfOspfSchema(),

			"ospfv3": LogicalRouterResourceVrfOspfv3Schema(),

			"ecmp": LogicalRouterResourceVrfEcmpSchema(),

			"multicast": LogicalRouterResourceVrfMulticastSchema(),

			"rip": LogicalRouterResourceVrfRipSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfAdministrativeDistancesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": rsschema.Int64Attribute{
				Description: "Set IPv4 Static Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"static_ipv6": rsschema.Int64Attribute{
				Description: "Set IPv6 Static Routes  Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"ospf_inter": rsschema.Int64Attribute{
				Description: "Set OSPF Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospf_intra": rsschema.Int64Attribute{
				Description: "Set OSPF Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospf_ext": rsschema.Int64Attribute{
				Description: "Set OSPF External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_inter": rsschema.Int64Attribute{
				Description: "Set OSPFv3 Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_intra": rsschema.Int64Attribute{
				Description: "Set OSPFv3 Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_ext": rsschema.Int64Attribute{
				Description: "Set OSPFv3 External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"bgp_internal": rsschema.Int64Attribute{
				Description: "Set BGP AS Internal Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"bgp_external": rsschema.Int64Attribute{
				Description: "Set BGP AS External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"bgp_local": rsschema.Int64Attribute{
				Description: "Set BGP Local Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"rip": rsschema.Int64Attribute{
				Description: "Set RIP Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfRibFilterIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfRibFilterIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": LogicalRouterResourceVrfRibFilterIpv4StaticSchema(),

			"bgp": LogicalRouterResourceVrfRibFilterIpv4BgpSchema(),

			"ospf": LogicalRouterResourceVrfRibFilterIpv4OspfSchema(),

			"rip": LogicalRouterResourceVrfRibFilterIpv4RipSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4StaticSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4BgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4OspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on OSPF Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4OspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4RipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on RIP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4RipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": LogicalRouterResourceVrfRibFilterIpv6StaticSchema(),

			"bgp": LogicalRouterResourceVrfRibFilterIpv6BgpSchema(),

			"ospfv3": LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6StaticSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6BgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on OSPFv3 Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": rsschema.StringAttribute{
				Description: "local AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"install_route": rsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": rsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_external_failover": rsschema.BoolAttribute{
				Description: "Immediately reset session if a link to a directly connected external peer goes down",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ecmp_multi_as": rsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": rsschema.Int64Attribute{
				Description: "Global Default Local Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},

			"graceful_shutdown": rsschema.BoolAttribute{
				Description: "Gracefully Shutdown BGP following RFC-8326",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"always_advertise_network_route": rsschema.BoolAttribute{
				Description: "Always advertise network routes even if not present in RIB",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": LogicalRouterResourceVrfBgpMedSchema(),

			"graceful_restart": LogicalRouterResourceVrfBgpGracefulRestartSchema(),

			"global_bfd": LogicalRouterResourceVrfBgpGlobalBfdSchema(),

			"redistribution_profile": LogicalRouterResourceVrfBgpRedistributionProfileSchema(),

			"advertise_network": LogicalRouterResourceVrfBgpAdvertiseNetworkSchema(),

			"peer_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpPeerGroupSchema(),
			},

			"aggregate_routes": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAggregateRoutesSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpMedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"always_compare_med": rsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": rsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpMedObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": rsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"max_peer_restart_time": rsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"local_restart_time": rsschema.Int64Attribute{
				Description: "local restart time to advertise to peer Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"network": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": rsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": rsschema.BoolAttribute{
				Description: "Multicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"backdoor": rsschema.BoolAttribute{
				Description: "Mark network as backdoor route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"network": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": rsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfBgpPeerGroupTypeSchema(),

			"address_family": LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema(),

			"filtering_profile": LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema(),

			"connection_options": LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema(),

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ibgp": LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema(),

			"ebgp": LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"timers": rsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": rsschema.Int64Attribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": rsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "If enabled, open messages are not sent to this peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherit": LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema(),

			"local_address": LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"yes": LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema(),

			"no": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address_family": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema(),

			"filtering_profile": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"timers": rsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"multihop": rsschema.StringAttribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"dampening": rsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Aggregate Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable Aggregation for this Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary_only": rsschema.BoolAttribute{
				Description: "Send only Summary Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": rsschema.BoolAttribute{
				Description: "Generate AS set path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"same_med": rsschema.BoolAttribute{
				Description: "Aggregate Routes only if they have same MED Attributes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"summary_prefix": rsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"summary_prefix": rsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": LogicalRouterResourceVrfRoutingTableIpSchema(),

			"ipv6": LogicalRouterResourceVrfRoutingTableIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"nexthop": LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema(),

			"bfd": LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"discard": LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema(),

			"ip_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": rsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("next_lr"),
				path.MatchRelative().AtParent().AtName("fqdn"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"nexthop": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema(),

			"bfd": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema(),

			"path_monitor": LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"discard": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": rsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_lr"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": rsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": rsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": rsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfOspfGlobalBfdSchema(),

			"graceful_restart": LogicalRouterResourceVrfOspfGracefulRestartSchema(),

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfOspfAreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": LogicalRouterResourceVrfOspfAreaTypeNormalSchema(),

			"stub": LogicalRouterResourceVrfOspfAreaTypeStubSchema(),

			"nssa": LogicalRouterResourceVrfOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"abr": LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema(),

			"default_route_metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"metric_type": rsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF on this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": rsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPF instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_transit_traffic": rsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": rsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": rsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfOspfv3GlobalBfdSchema(),

			"graceful_restart": LogicalRouterResourceVrfOspfv3GracefulRestartSchema(),

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3GlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3GracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfOspfv3AreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema(),

			"stub": LogicalRouterResourceVrfOspfv3AreaTypeStubSchema(),

			"nssa": LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema(),

			"default_route_metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"metric_type": rsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": rsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": rsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"symmetric_return": rsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": rsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": LogicalRouterResourceVrfEcmpAlgorithmSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_modulo": LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema(),

			"ip_hash": LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema(),

			"weighted_round_robin": LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"src_only": rsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": rsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": rsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastStaticRouteSchema(),
			},

			"pim": LogicalRouterResourceVrfMulticastPimSchema(),

			"igmp": LogicalRouterResourceVrfMulticastIgmpSchema(),

			"msdp": LogicalRouterResourceVrfMulticastMsdpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastStaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preference": rsschema.Int64Attribute{
				Description: "administrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rpf_lookup_mode": rsschema.StringAttribute{
				Description: "RPF Lookup Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("mrib-then-urib"),
			},

			"route_ageout_time": rsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(210),
			},

			"if_timer_global": rsschema.StringAttribute{
				Description: "Global Interface Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_permission": rsschema.StringAttribute{
				Description: "ASM/SSM group permission",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssm_address_space": LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema(),

			"rp": LogicalRouterResourceVrfMulticastPimRpSchema(),

			"spt_threshold": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimSptThresholdSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"group_list": rsschema.StringAttribute{
				Description: "SSM Group Prefix List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpSchema(),

			"external_rp": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimRpExternalRpSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema(),

			"candidate_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": rsschema.StringAttribute{
				Description: "local RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": rsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(192),
			},

			"advertisement_interval": rsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpExternalRpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSptThresholdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("0"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": rsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"send_bsm": rsschema.BoolAttribute{
				Description: "Send BSM",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer": rsschema.StringAttribute{
				Description: "Interface Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_filter": rsschema.StringAttribute{
				Description: "Set the filter for neighbor list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dynamic": LogicalRouterResourceVrfMulticastIgmpDynamicSchema(),

			"static": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastIgmpStaticSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"version": rsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("3"),
			},

			"robustness": rsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2"),
			},

			"group_filter": rsschema.StringAttribute{
				Description: "ASM/SSM Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"max_groups": rsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"max_sources": rsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"query_profile": rsschema.StringAttribute{
				Description: "IGMP Query Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": rsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpStaticSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "multicast interfaces",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": rsschema.StringAttribute{
				Description: "source-address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": rsschema.StringAttribute{
				Description: "Global timer profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_authentication": rsschema.StringAttribute{
				Description: "Global authentication profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema(),

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastMsdpPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface of originator",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"max_sa": rsschema.Int64Attribute{
				Description: "Maximum number of SA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"inbound_sa_filter": rsschema.StringAttribute{
				Description: "Inbound SA Filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_sa_filter": rsschema.StringAttribute{
				Description: "Outbound SA Filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema(),

			"peer_address": LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept MSDP connection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": rsschema.BoolAttribute{
				Description: "advertise default route in RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": rsschema.StringAttribute{
				Description: "timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.StringAttribute{
				Description: "Authentication profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfRipGlobalBfdSchema(),

			"global_inbound_distribute_list": LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema(),

			"global_outbound_distribute_list": LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema(),

			"interfaces": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRipInterfacesSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable RIP on this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("active"),
			},

			"split_horizon": rsschema.StringAttribute{
				Description: "Split horizon options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("split-horizon"),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterResourceVrfRipInterfacesBfdSchema(),

			"interface_inbound_distribute_list": LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema(),

			"interface_outbound_distribute_list": LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *LogicalRouterResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_logical_router"
}

func (o *LogicalRouterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = LogicalRouterResourceSchema()
}

// </ResourceSchema>

func (o *LogicalRouterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := logical_router.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service](o.client, logical_router.NewService(o.client), batchSize, specifier, logical_router.SpecMatches)
}

func (o *LogicalRouterResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj LogicalRouterLocation

	var vrfObj *LogicalRouterResourceVrfObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"vrf": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: vrfObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceModel) AncestorName() string {
	return ""
}

func (o LogicalRouterResourceModel) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfObject) AttributeTypes() map[string]attr.Type {

	var administrativeDistancesObj *LogicalRouterResourceVrfAdministrativeDistancesObject

	var ribFilterObj *LogicalRouterResourceVrfRibFilterObject

	var bgpObj *LogicalRouterResourceVrfBgpObject

	var routingTableObj *LogicalRouterResourceVrfRoutingTableObject

	var ospfObj *LogicalRouterResourceVrfOspfObject

	var ospfv3Obj *LogicalRouterResourceVrfOspfv3Object

	var ecmpObj *LogicalRouterResourceVrfEcmpObject

	var multicastObj *LogicalRouterResourceVrfMulticastObject

	var ripObj *LogicalRouterResourceVrfRipObject
	return map[string]attr.Type{
		"name": types.StringType,
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"rib_filter": types.ObjectType{
			AttrTypes: ribFilterObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"routing_table": types.ObjectType{
			AttrTypes: routingTableObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfObject) AncestorName() string {
	return "vrf"
}

func (o LogicalRouterResourceVrfObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static":       types.Int64Type,
		"static_ipv6":  types.Int64Type,
		"ospf_inter":   types.Int64Type,
		"ospf_intra":   types.Int64Type,
		"ospf_ext":     types.Int64Type,
		"ospfv3_inter": types.Int64Type,
		"ospfv3_intra": types.Int64Type,
		"ospfv3_ext":   types.Int64Type,
		"bgp_internal": types.Int64Type,
		"bgp_external": types.Int64Type,
		"bgp_local":    types.Int64Type,
		"rip":          types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o LogicalRouterResourceVrfAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfRibFilterIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfRibFilterIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterObject) AncestorName() string {
	return "rib-filter"
}

func (o LogicalRouterResourceVrfRibFilterObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterResourceVrfRibFilterIpv4StaticObject

	var bgpObj *LogicalRouterResourceVrfRibFilterIpv4BgpObject

	var ospfObj *LogicalRouterResourceVrfRibFilterIpv4OspfObject

	var ripObj *LogicalRouterResourceVrfRibFilterIpv4RipObject
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfRibFilterIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfRibFilterIpv4StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfRibFilterIpv4BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4OspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterResourceVrfRibFilterIpv4OspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4RipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterResourceVrfRibFilterIpv4RipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterResourceVrfRibFilterIpv6StaticObject

	var bgpObj *LogicalRouterResourceVrfRibFilterIpv6BgpObject

	var ospfv3Obj *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfRibFilterIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfRibFilterIpv6StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfRibFilterIpv6BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpObject) AttributeTypes() map[string]attr.Type {

	var medObj *LogicalRouterResourceVrfBgpMedObject

	var gracefulRestartObj *LogicalRouterResourceVrfBgpGracefulRestartObject

	var globalBfdObj *LogicalRouterResourceVrfBgpGlobalBfdObject

	var redistributionProfileObj *LogicalRouterResourceVrfBgpRedistributionProfileObject

	var advertiseNetworkObj *LogicalRouterResourceVrfBgpAdvertiseNetworkObject

	var peerGroupObj *LogicalRouterResourceVrfBgpPeerGroupObject

	var aggregateRoutesObj *LogicalRouterResourceVrfBgpAggregateRoutesObject
	return map[string]attr.Type{
		"enable":                         types.BoolType,
		"router_id":                      types.StringType,
		"local_as":                       types.StringType,
		"install_route":                  types.BoolType,
		"enforce_first_as":               types.BoolType,
		"fast_external_failover":         types.BoolType,
		"ecmp_multi_as":                  types.BoolType,
		"default_local_preference":       types.Int64Type,
		"graceful_shutdown":              types.BoolType,
		"always_advertise_network_route": types.BoolType,
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"redistribution_profile": types.ObjectType{
			AttrTypes: redistributionProfileObj.AttributeTypes(),
		},
		"advertise_network": types.ObjectType{
			AttrTypes: advertiseNetworkObj.AttributeTypes(),
		},
		"peer_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerGroupObj.AttributeTypes(),
			},
		},
		"aggregate_routes": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: aggregateRoutesObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfBgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfBgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpMedObject) AncestorName() string {
	return "med"
}

func (o LogicalRouterResourceVrfBgpMedObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"stale_route_time":      types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"local_restart_time":    types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfBgpGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfBgpGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileObject) AncestorName() string {
	return "redistribution-profile"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkObject) AncestorName() string {
	return "advertise-network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) AttributeTypes() map[string]attr.Type {

	var networkObj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	return map[string]attr.Type{
		"network": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: networkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
		"backdoor":  types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) AttributeTypes() map[string]attr.Type {

	var networkObj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	return map[string]attr.Type{
		"network": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: networkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":    types.StringType,
		"unicast": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfBgpPeerGroupTypeObject

	var addressFamilyObj *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject

	var filteringProfileObj *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject

	var connectionOptionsObj *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject

	var peerObj *LogicalRouterResourceVrfBgpPeerGroupPeerObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o LogicalRouterResourceVrfBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject

	var ebgpObj *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.Int64Type,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var inheritObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject

	var localAddressObj *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"passive":                           types.BoolType,
		"peer_as":                           types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"inherit": types.ObjectType{
			AttrTypes: inheritObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) AttributeTypes() map[string]attr.Type {

	var yesObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject

	var noObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject
	return map[string]attr.Type{
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) AncestorName() string {
	return "inherit"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) AncestorName() string {
	return "yes"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) AttributeTypes() map[string]attr.Type {

	var addressFamilyObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject

	var filteringProfileObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	return map[string]attr.Type{
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) AncestorName() string {
	return "no"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.StringType,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject
	return map[string]attr.Type{
		"name":         types.StringType,
		"description":  types.StringType,
		"enable":       types.BoolType,
		"summary_only": types.BoolType,
		"as_set":       types.BoolType,
		"same_med":     types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesObject) AncestorName() string {
	return "aggregate-routes"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableObject) AttributeTypes() map[string]attr.Type {

	var ipObj *LogicalRouterResourceVrfRoutingTableIpObject

	var ipv6Obj *LogicalRouterResourceVrfRoutingTableIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableObject) AncestorName() string {
	return "routing-table"
}

func (o LogicalRouterResourceVrfRoutingTableObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpObject) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject
	return map[string]attr.Type{
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpObject) AncestorName() string {
	return "ip"
}

func (o LogicalRouterResourceVrfRoutingTableIpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject

	var bfdObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject

	var pathMonitorObj *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ip_address": types.StringType,
		"next_lr":    types.StringType,
		"fqdn":       types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	var monitorDestinationsObj *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"failure_condition": types.StringType,
		"hold_time":         types.Int64Type,
		"monitor_destinations": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: monitorDestinationsObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject
	return map[string]attr.Type{
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject

	var bfdObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject

	var pathMonitorObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ipv6_address": types.StringType,
		"fqdn":         types.StringType,
		"next_lr":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	var monitorDestinationsObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"failure_condition": types.StringType,
		"hold_time":         types.Int64Type,
		"monitor_destinations": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: monitorDestinationsObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfOspfGlobalBfdObject

	var gracefulRestartObj *LogicalRouterResourceVrfOspfGracefulRestartObject

	var areaObj *LogicalRouterResourceVrfOspfAreaObject
	return map[string]attr.Type{
		"router_id":              types.StringType,
		"enable":                 types.BoolType,
		"rfc1583":                types.BoolType,
		"spf_timer":              types.StringType,
		"global_if_timer":        types.StringType,
		"redistribution_profile": types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterResourceVrfOspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfOspfAreaTypeObject

	var rangeObj *LogicalRouterResourceVrfOspfAreaRangeObject

	var interfaceObj *LogicalRouterResourceVrfOspfAreaInterfaceObject

	var virtualLinkObj *LogicalRouterResourceVrfOspfAreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterResourceVrfOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterResourceVrfOspfAreaTypeNormalObject

	var stubObj *LogicalRouterResourceVrfOspfAreaTypeStubObject

	var nssaObj *LogicalRouterResourceVrfOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	var nssaExtRangeObj *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterResourceVrfOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	return map[string]attr.Type{
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3Object) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfOspfv3GlobalBfdObject

	var gracefulRestartObj *LogicalRouterResourceVrfOspfv3GracefulRestartObject

	var areaObj *LogicalRouterResourceVrfOspfv3AreaObject
	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"router_id":               types.StringType,
		"disable_transit_traffic": types.BoolType,
		"spf_timer":               types.StringType,
		"global_if_timer":         types.StringType,
		"redistribution_profile":  types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterResourceVrfOspfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfOspfv3AreaTypeObject

	var rangeObj *LogicalRouterResourceVrfOspfv3AreaRangeObject

	var interfaceObj *LogicalRouterResourceVrfOspfv3AreaInterfaceObject

	var virtualLinkObj *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterResourceVrfOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject

	var stubObj *LogicalRouterResourceVrfOspfv3AreaTypeStubObject

	var nssaObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	var nssaExtRangeObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterResourceVrfOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"instance_id":    types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	return map[string]attr.Type{
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *LogicalRouterResourceVrfEcmpAlgorithmObject
	return map[string]attr.Type{
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"symmetric_return":   types.BoolType,
		"strict_source_path": types.BoolType,
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o LogicalRouterResourceVrfEcmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var ipModuloObj *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject

	var ipHashObj *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject

	var weightedRoundRobinObj *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject

	var balancedRoundRobinObj *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject
	return map[string]attr.Type{
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
		"hash_seed": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastObject) AttributeTypes() map[string]attr.Type {

	var staticRouteObj *LogicalRouterResourceVrfMulticastStaticRouteObject

	var pimObj *LogicalRouterResourceVrfMulticastPimObject

	var igmpObj *LogicalRouterResourceVrfMulticastIgmpObject

	var msdpObj *LogicalRouterResourceVrfMulticastMsdpObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"static_route": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticRouteObj.AttributeTypes(),
			},
		},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"msdp": types.ObjectType{
			AttrTypes: msdpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastObject) AncestorName() string {
	return "multicast"
}

func (o LogicalRouterResourceVrfMulticastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"destination": types.StringType,
		"interface":   types.StringType,
		"preference":  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfMulticastStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimObject) AttributeTypes() map[string]attr.Type {

	var ssmAddressSpaceObj *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject

	var rpObj *LogicalRouterResourceVrfMulticastPimRpObject

	var sptThresholdObj *LogicalRouterResourceVrfMulticastPimSptThresholdObject

	var interfaceObj *LogicalRouterResourceVrfMulticastPimInterfaceObject
	return map[string]attr.Type{
		"enable":            types.BoolType,
		"rpf_lookup_mode":   types.StringType,
		"route_ageout_time": types.Int64Type,
		"if_timer_global":   types.StringType,
		"group_permission":  types.StringType,
		"ssm_address_space": types.ObjectType{
			AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
		},
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sptThresholdObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfMulticastPimObject) AncestorName() string {
	return "pim"
}

func (o LogicalRouterResourceVrfMulticastPimObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"group_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpObject) AttributeTypes() map[string]attr.Type {

	var localRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpObject

	var externalRpObj *LogicalRouterResourceVrfMulticastPimRpExternalRpObject
	return map[string]attr.Type{
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
		"external_rp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: externalRpObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpObject) AncestorName() string {
	return "rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var staticRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject

	var candidateRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject
	return map[string]attr.Type{
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":  types.StringType,
		"address":    types.StringType,
		"override":   types.BoolType,
		"group_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":              types.StringType,
		"address":                types.StringType,
		"priority":               types.Int64Type,
		"advertisement_interval": types.Int64Type,
		"group_list":             types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"group_list": types.StringType,
		"override":   types.BoolType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o LogicalRouterResourceVrfMulticastPimSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"description":     types.StringType,
		"dr_priority":     types.Int64Type,
		"send_bsm":        types.BoolType,
		"if_timer":        types.StringType,
		"neighbor_filter": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfMulticastPimInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastIgmpObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *LogicalRouterResourceVrfMulticastIgmpDynamicObject

	var staticObj *LogicalRouterResourceVrfMulticastIgmpStaticObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"static": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: staticObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpObject) AncestorName() string {
	return "igmp"
}

func (o LogicalRouterResourceVrfMulticastIgmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"version":               types.StringType,
		"robustness":            types.StringType,
		"group_filter":          types.StringType,
		"max_groups":            types.StringType,
		"max_sources":           types.StringType,
		"query_profile":         types.StringType,
		"router_alert_policing": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"interface":      types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpStaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfMulticastIgmpStaticObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastMsdpObject) AttributeTypes() map[string]attr.Type {

	var originatorIdObj *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject

	var peerObj *LogicalRouterResourceVrfMulticastMsdpPeerObject
	return map[string]attr.Type{
		"enable":                types.BoolType,
		"global_timer":          types.StringType,
		"global_authentication": types.StringType,
		"originator_id": types.ObjectType{
			AttrTypes: originatorIdObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpObject) AncestorName() string {
	return "msdp"
}

func (o LogicalRouterResourceVrfMulticastMsdpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) AncestorName() string {
	return "originator-id"
}

func (o LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject

	var peerAddressObj *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"enable":             types.BoolType,
		"peer_as":            types.StringType,
		"authentication":     types.StringType,
		"max_sa":             types.Int64Type,
		"inbound_sa_filter":  types.StringType,
		"outbound_sa_filter": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfRipGlobalBfdObject

	var globalInboundDistributeListObj *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject

	var globalOutboundDistributeListObj *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject

	var interfacesObj *LogicalRouterResourceVrfRipInterfacesObject
	return map[string]attr.Type{
		"enable":                        types.BoolType,
		"default_information_originate": types.BoolType,
		"global_timer":                  types.StringType,
		"auth_profile":                  types.StringType,
		"redistribution_profile":        types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"global_inbound_distribute_list": types.ObjectType{
			AttrTypes: globalInboundDistributeListObj.AttributeTypes(),
		},
		"global_outbound_distribute_list": types.ObjectType{
			AttrTypes: globalOutboundDistributeListObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfacesObj.AttributeTypes(),
			},
		},
	}
}

func (o LogicalRouterResourceVrfRipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterResourceVrfRipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) AncestorName() string {
	return "global-inbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) AncestorName() string {
	return "global-outbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterResourceVrfRipInterfacesBfdObject

	var interfaceInboundDistributeListObj *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject

	var interfaceOutboundDistributeListObj *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mode":           types.StringType,
		"split_horizon":  types.StringType,
		"authentication": types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"interface_inbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceInboundDistributeListObj.AttributeTypes(),
		},
		"interface_outbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceOutboundDistributeListObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o LogicalRouterResourceVrfRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) AncestorName() string {
	return "interface-inbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AncestorName() string {
	return "interface-outbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) EntryName() *string {
	return nil
}

func (o *LogicalRouterResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_tf_entries []LogicalRouterResourceVrfObject
	var vrf_pango_entries []logical_router.Vrf
	{
		d := o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vrf_tf_entries {
			var entry *logical_router.Vrf
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_pango_entries = append(vrf_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vrf = vrf_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var administrativeDistances_entry *logical_router.VrfAdminDists
	if !o.AdministrativeDistances.IsUnknown() && !o.AdministrativeDistances.IsNull() {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(logical_router.VrfAdminDists)
		}
		var object *LogicalRouterResourceVrfAdministrativeDistancesObject
		diags.Append(o.AdministrativeDistances.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_entry *logical_router.VrfRibFilter
	if !o.RibFilter.IsUnknown() && !o.RibFilter.IsNull() {
		if *obj != nil && (*obj).RibFilter != nil {
			ribFilter_entry = (*obj).RibFilter
		} else {
			ribFilter_entry = new(logical_router.VrfRibFilter)
		}
		var object *LogicalRouterResourceVrfRibFilterObject
		diags.Append(o.RibFilter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ribFilter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfBgp)
		}
		var object *LogicalRouterResourceVrfBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *logical_router.VrfRoutingTable
	if !o.RoutingTable.IsUnknown() && !o.RoutingTable.IsNull() {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(logical_router.VrfRoutingTable)
		}
		var object *LogicalRouterResourceVrfRoutingTableObject
		diags.Append(o.RoutingTable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routingTable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfOspf)
		}
		var object *LogicalRouterResourceVrfOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfOspfv3)
		}
		var object *LogicalRouterResourceVrfOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *logical_router.VrfEcmp
	if !o.Ecmp.IsUnknown() && !o.Ecmp.IsNull() {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(logical_router.VrfEcmp)
		}
		var object *LogicalRouterResourceVrfEcmpObject
		diags.Append(o.Ecmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *logical_router.VrfMulticast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(logical_router.VrfMulticast)
		}
		var object *LogicalRouterResourceVrfMulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRip)
		}
		var object *LogicalRouterResourceVrfRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Vrf)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).RibFilter = ribFilter_entry
	(*obj).Bgp = bgp_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Multicast = multicast_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInter_value := o.OspfInter.ValueInt64Pointer()
	ospfIntra_value := o.OspfIntra.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Inter_value := o.Ospfv3Inter.ValueInt64Pointer()
	ospfv3Intra_value := o.Ospfv3Intra.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	bgpInternal_value := o.BgpInternal.ValueInt64Pointer()
	bgpExternal_value := o.BgpExternal.ValueInt64Pointer()
	bgpLocal_value := o.BgpLocal.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfAdminDists)
	}
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInter = ospfInter_value
	(*obj).OspfIntra = ospfIntra_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Inter = ospfv3Inter_value
	(*obj).Ospfv3Intra = ospfv3Intra_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).BgpInternal = bgpInternal_value
	(*obj).BgpExternal = bgpExternal_value
	(*obj).BgpLocal = bgpLocal_value
	(*obj).Rip = rip_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfRibFilterIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfRibFilterIpv4)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRibFilterIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRibFilterIpv6)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilter)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv4Static
	if !o.Static.IsUnknown() && !o.Static.IsNull() {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv4Static)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv4StaticObject
		diags.Append(o.Static.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv4Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv4Bgp)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv4BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfRibFilterIpv4Ospf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfRibFilterIpv4Ospf)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv4OspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRibFilterIpv4Rip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRibFilterIpv4Rip)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv4RipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Ospf)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Rip)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv6Static
	if !o.Static.IsUnknown() && !o.Static.IsNull() {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv6Static)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv6StaticObject
		diags.Append(o.Static.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv6Bgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv6Bgp)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv6BgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfRibFilterIpv6Ospfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfRibFilterIpv6Ospfv3)
		}
		var object *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Ospfv3)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	fastExternalFailover_value := o.FastExternalFailover.ValueBoolPointer()
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	gracefulShutdown_value := o.GracefulShutdown.ValueBoolPointer()
	alwaysAdvertiseNetworkRoute_value := o.AlwaysAdvertiseNetworkRoute.ValueBoolPointer()
	var med_entry *logical_router.VrfBgpMed
	if !o.Med.IsUnknown() && !o.Med.IsNull() {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(logical_router.VrfBgpMed)
		}
		var object *LogicalRouterResourceVrfBgpMedObject
		diags.Append(o.Med.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfBgpGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfBgpGracefulRestart)
		}
		var object *LogicalRouterResourceVrfBgpGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_entry *logical_router.VrfBgpGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfBgpGlobalBfd)
		}
		var object *LogicalRouterResourceVrfBgpGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_entry *logical_router.VrfBgpRedistributionProfile
	if !o.RedistributionProfile.IsUnknown() && !o.RedistributionProfile.IsNull() {
		if *obj != nil && (*obj).RedistributionProfile != nil {
			redistributionProfile_entry = (*obj).RedistributionProfile
		} else {
			redistributionProfile_entry = new(logical_router.VrfBgpRedistributionProfile)
		}
		var object *LogicalRouterResourceVrfBgpRedistributionProfileObject
		diags.Append(o.RedistributionProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redistributionProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_entry *logical_router.VrfBgpAdvertiseNetwork
	if !o.AdvertiseNetwork.IsUnknown() && !o.AdvertiseNetwork.IsNull() {
		if *obj != nil && (*obj).AdvertiseNetwork != nil {
			advertiseNetwork_entry = (*obj).AdvertiseNetwork
		} else {
			advertiseNetwork_entry = new(logical_router.VrfBgpAdvertiseNetwork)
		}
		var object *LogicalRouterResourceVrfBgpAdvertiseNetworkObject
		diags.Append(o.AdvertiseNetwork.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertiseNetwork_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerGroup_tf_entries []LogicalRouterResourceVrfBgpPeerGroupObject
	var peerGroup_pango_entries []logical_router.VrfBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *logical_router.VrfBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var aggregateRoutes_tf_entries []LogicalRouterResourceVrfBgpAggregateRoutesObject
	var aggregateRoutes_pango_entries []logical_router.VrfBgpAggregateRoutes
	{
		d := o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range aggregateRoutes_tf_entries {
			var entry *logical_router.VrfBgpAggregateRoutes
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_pango_entries = append(aggregateRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgp)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).LocalAs = localAs_value
	(*obj).InstallRoute = installRoute_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).FastExternalFailover = fastExternalFailover_value
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulShutdown = gracefulShutdown_value
	(*obj).AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	(*obj).Med = med_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RedistributionProfile = redistributionProfile_entry
	(*obj).AdvertiseNetwork = advertiseNetwork_entry
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).AggregateRoutes = aggregateRoutes_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpMedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpRedistributionProfileIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpRedistributionProfileIpv4)
		}
		var object *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpRedistributionProfileIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpRedistributionProfileIpv6)
		}
		var object *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfile)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv4)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv6)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAdvertiseNetworkIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
		}
		var object *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAdvertiseNetworkIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
		}
		var object *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetwork)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv4Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv4Network
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()
	backdoor_value := o.Backdoor.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value
	(*obj).Backdoor = backdoor_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv6Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv6Network
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpPeerGroupType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpPeerGroupType)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_entry *logical_router.VrfBgpPeerGroupAddressFamily
	if !o.AddressFamily.IsUnknown() && !o.AddressFamily.IsNull() {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupAddressFamily)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject
		diags.Append(o.AddressFamily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupFilteringProfile
	if !o.FilteringProfile.IsUnknown() && !o.FilteringProfile.IsNull() {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupFilteringProfile)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject
		diags.Append(o.FilteringProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupConnectionOptions)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterResourceVrfBgpPeerGroupPeerObject
	var peer_pango_entries []logical_router.VrfBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Type = type_entry
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *logical_router.VrfBgpPeerGroupTypeIbgp
	if !o.Ibgp.IsUnknown() && !o.Ibgp.IsNull() {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(logical_router.VrfBgpPeerGroupTypeIbgp)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject
		diags.Append(o.Ibgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *logical_router.VrfBgpPeerGroupTypeEbgp
	if !o.Ebgp.IsUnknown() && !o.Ebgp.IsNull() {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(logical_router.VrfBgpPeerGroupTypeEbgp)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject
		diags.Append(o.Ebgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeIbgp)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeEbgp)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	var inherit_entry *logical_router.VrfBgpPeerGroupPeerInherit
	if !o.Inherit.IsUnknown() && !o.Inherit.IsNull() {
		if *obj != nil && (*obj).Inherit != nil {
			inherit_entry = (*obj).Inherit
		} else {
			inherit_entry = new(logical_router.VrfBgpPeerGroupPeerInherit)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject
		diags.Append(o.Inherit.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inherit_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *logical_router.VrfBgpPeerGroupPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfBgpPeerGroupPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupPeerConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfBgpPeerGroupPeerBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfBgpPeerGroupPeerBfd)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).Inherit = inherit_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_entry *logical_router.VrfBgpPeerGroupPeerInheritYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_entry *logical_router.VrfBgpPeerGroupPeerInheritNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInherit)
	}
	(*obj).Yes = yes_entry
	(*obj).No = no_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_entry *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily
	if !o.AddressFamily.IsUnknown() && !o.AddressFamily.IsNull() {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
		diags.Append(o.AddressFamily.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile
	if !o.FilteringProfile.IsUnknown() && !o.FilteringProfile.IsNull() {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
		}
		var object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
		diags.Append(o.FilteringProfile.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
	}
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summaryOnly_value := o.SummaryOnly.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	sameMed_value := o.SameMed.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpAggregateRoutesType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpAggregateRoutesType)
		}
		var object *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Enable = enable_value
	(*obj).SummaryOnly = summaryOnly_value
	(*obj).AsSet = asSet_value
	(*obj).SameMed = sameMed_value
	(*obj).Type = type_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAggregateRoutesTypeIpv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
		}
		var object *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAggregateRoutesTypeIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
		}
		var object *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesType)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *logical_router.VrfRoutingTableIp
	if !o.Ip.IsUnknown() && !o.Ip.IsNull() {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(logical_router.VrfRoutingTableIp)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpObject
		diags.Append(o.Ip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRoutingTableIpv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRoutingTableIpv6)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpStaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpStaticRouteBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitor
	if !o.PathMonitor.IsUnknown() && !o.PathMonitor.IsNull() {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject
		diags.Append(o.PathMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard
	if !o.Discard.IsUnknown() && !o.Discard.IsNull() {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
		diags.Append(o.Discard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).NextLr = nextLr_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpv6StaticRouteBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor
	if !o.PathMonitor.IsUnknown() && !o.PathMonitor.IsNull() {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
		diags.Append(o.PathMonitor.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard
	if !o.Discard.IsUnknown() && !o.Discard.IsNull() {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
		}
		var object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
		diags.Append(o.Discard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextLr = nextLr_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routerId_value := o.RouterId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfGlobalBfd)
		}
		var object *LogicalRouterResourceVrfOspfGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfGracefulRestart)
		}
		var object *LogicalRouterResourceVrfOspfGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterResourceVrfOspfAreaObject
	var area_pango_entries []logical_router.VrfOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfArea
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspf)
	}
	(*obj).RouterId = routerId_value
	(*obj).Enable = enable_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfAreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfAreaType)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterResourceVrfOspfAreaRangeObject
	var range_pango_entries []logical_router.VrfOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterResourceVrfOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfAreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfAreaTypeNormal)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfAreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfAreaTypeStub)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfAreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfAreaTypeNssa)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfAreaTypeNormalAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNormalAbr)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfAreaTypeStubAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeStubAbr)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate
	if !o.DefaultInformationOriginate.IsUnknown() && !o.DefaultInformationOriginate.IsNull() {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
		diags.Append(o.DefaultInformationOriginate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfAreaTypeNssaAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNssaAbr)
		}
		var object *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfAreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfAreaInterfaceLinkType)
		}
		var object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfAreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaInterfaceBfd)
		}
		var object *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
		}
		var object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
		}
		var object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
		}
		var object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfOspfAreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaVirtualLinkBfd)
		}
		var object *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfv3GlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfv3GlobalBfd)
		}
		var object *LogicalRouterResourceVrfOspfv3GlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfv3GracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfv3GracefulRestart)
		}
		var object *LogicalRouterResourceVrfOspfv3GracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterResourceVrfOspfv3AreaObject
	var area_pango_entries []logical_router.VrfOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfv3Area
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfv3AreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfv3AreaType)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterResourceVrfOspfv3AreaRangeObject
	var range_pango_entries []logical_router.VrfOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfv3AreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfv3AreaTypeNormal)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfv3AreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfv3AreaTypeStub)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfv3AreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfv3AreaTypeNssa)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfv3AreaTypeNormalAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfv3AreaTypeStubAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeStubAbr)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate
	if !o.DefaultInformationOriginate.IsUnknown() && !o.DefaultInformationOriginate.IsNull() {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
		diags.Append(o.DefaultInformationOriginate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfv3AreaTypeNssaAbr
	if !o.Abr.IsUnknown() && !o.Abr.IsNull() {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject
		diags.Append(o.Abr.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfv3AreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfv3AreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfv3AreaInterfaceBfd)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).InstanceId = instanceId_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
		}
		var object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	var algorithm_entry *logical_router.VrfEcmpAlgorithm
	if !o.Algorithm.IsUnknown() && !o.Algorithm.IsNull() {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(logical_router.VrfEcmpAlgorithm)
		}
		var object *LogicalRouterResourceVrfEcmpAlgorithmObject
		diags.Append(o.Algorithm.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmp)
	}
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).Algorithm = algorithm_entry

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *logical_router.VrfEcmpAlgorithmIpModulo
	if !o.IpModulo.IsUnknown() && !o.IpModulo.IsNull() {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(logical_router.VrfEcmpAlgorithmIpModulo)
		}
		var object *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject
		diags.Append(o.IpModulo.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *logical_router.VrfEcmpAlgorithmIpHash
	if !o.IpHash.IsUnknown() && !o.IpHash.IsNull() {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(logical_router.VrfEcmpAlgorithmIpHash)
		}
		var object *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject
		diags.Append(o.IpHash.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobin
	if !o.WeightedRoundRobin.IsUnknown() && !o.WeightedRoundRobin.IsNull() {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
		}
		var object *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject
		diags.Append(o.WeightedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *logical_router.VrfEcmpAlgorithmBalancedRoundRobin
	if !o.BalancedRoundRobin.IsUnknown() && !o.BalancedRoundRobin.IsNull() {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
		}
		var object *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject
		diags.Append(o.BalancedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *LogicalRouterResourceVrfMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var staticRoute_tf_entries []LogicalRouterResourceVrfMulticastStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfMulticastStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfMulticastStaticRoute
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}
	var pim_entry *logical_router.VrfMulticastPim
	if !o.Pim.IsUnknown() && !o.Pim.IsNull() {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(logical_router.VrfMulticastPim)
		}
		var object *LogicalRouterResourceVrfMulticastPimObject
		diags.Append(o.Pim.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *logical_router.VrfMulticastIgmp
	if !o.Igmp.IsUnknown() && !o.Igmp.IsNull() {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(logical_router.VrfMulticastIgmp)
		}
		var object *LogicalRouterResourceVrfMulticastIgmpObject
		diags.Append(o.Igmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_entry *logical_router.VrfMulticastMsdp
	if !o.Msdp.IsUnknown() && !o.Msdp.IsNull() {
		if *obj != nil && (*obj).Msdp != nil {
			msdp_entry = (*obj).Msdp
		} else {
			msdp_entry = new(logical_router.VrfMulticastMsdp)
		}
		var object *LogicalRouterResourceVrfMulticastMsdpObject
		diags.Append(o.Msdp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &msdp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticast)
	}
	(*obj).Enable = enable_value
	(*obj).StaticRoute = staticRoute_pango_entries
	(*obj).Pim = pim_entry
	(*obj).Igmp = igmp_entry
	(*obj).Msdp = msdp_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	preference_value := o.Preference.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfMulticastStaticRouteNexthop
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfMulticastStaticRouteNexthop)
		}
		var object *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject
		diags.Append(o.Nexthop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Preference = preference_value
	(*obj).Nexthop = nexthop_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRouteNexthop)
	}
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	rpfLookupMode_value := o.RpfLookupMode.ValueStringPointer()
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	ifTimerGlobal_value := o.IfTimerGlobal.ValueStringPointer()
	groupPermission_value := o.GroupPermission.ValueStringPointer()
	var ssmAddressSpace_entry *logical_router.VrfMulticastPimSsmAddressSpace
	if !o.SsmAddressSpace.IsUnknown() && !o.SsmAddressSpace.IsNull() {
		if *obj != nil && (*obj).SsmAddressSpace != nil {
			ssmAddressSpace_entry = (*obj).SsmAddressSpace
		} else {
			ssmAddressSpace_entry = new(logical_router.VrfMulticastPimSsmAddressSpace)
		}
		var object *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject
		diags.Append(o.SsmAddressSpace.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ssmAddressSpace_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_entry *logical_router.VrfMulticastPimRp
	if !o.Rp.IsUnknown() && !o.Rp.IsNull() {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(logical_router.VrfMulticastPimRp)
		}
		var object *LogicalRouterResourceVrfMulticastPimRpObject
		diags.Append(o.Rp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []LogicalRouterResourceVrfMulticastPimSptThresholdObject
	var sptThreshold_pango_entries []logical_router.VrfMulticastPimSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *logical_router.VrfMulticastPimSptThreshold
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfMulticastPimInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastPimInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastPimInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPim)
	}
	(*obj).Enable = enable_value
	(*obj).RpfLookupMode = rpfLookupMode_value
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).IfTimerGlobal = ifTimerGlobal_value
	(*obj).GroupPermission = groupPermission_value
	(*obj).SsmAddressSpace = ssmAddressSpace_entry
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSsmAddressSpace)
	}
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localRp_entry *logical_router.VrfMulticastPimRpLocalRp
	if !o.LocalRp.IsUnknown() && !o.LocalRp.IsNull() {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(logical_router.VrfMulticastPimRpLocalRp)
		}
		var object *LogicalRouterResourceVrfMulticastPimRpLocalRpObject
		diags.Append(o.LocalRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var externalRp_tf_entries []LogicalRouterResourceVrfMulticastPimRpExternalRpObject
	var externalRp_pango_entries []logical_router.VrfMulticastPimRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *logical_router.VrfMulticastPimRpExternalRp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRp)
	}
	(*obj).LocalRp = localRp_entry
	(*obj).ExternalRp = externalRp_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_entry *logical_router.VrfMulticastPimRpLocalRpStaticRp
	if !o.StaticRp.IsUnknown() && !o.StaticRp.IsNull() {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
		}
		var object *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject
		diags.Append(o.StaticRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_entry *logical_router.VrfMulticastPimRpLocalRpCandidateRp
	if !o.CandidateRp.IsUnknown() && !o.CandidateRp.IsNull() {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
		}
		var object *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject
		diags.Append(o.CandidateRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRp)
	}
	(*obj).StaticRp = staticRp_entry
	(*obj).CandidateRp = candidateRp_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Override = override_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Priority = priority_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupList = groupList_value
	(*obj).Override = override_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	sendBsm_value := o.SendBsm.ValueBoolPointer()
	ifTimer_value := o.IfTimer.ValueStringPointer()
	neighborFilter_value := o.NeighborFilter.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).DrPriority = drPriority_value
	(*obj).SendBsm = sendBsm_value
	(*obj).IfTimer = ifTimer_value
	(*obj).NeighborFilter = neighborFilter_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var dynamic_entry *logical_router.VrfMulticastIgmpDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(logical_router.VrfMulticastIgmpDynamic)
		}
		var object *LogicalRouterResourceVrfMulticastIgmpDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var static_tf_entries []LogicalRouterResourceVrfMulticastIgmpStaticObject
	var static_pango_entries []logical_router.VrfMulticastIgmpStatic
	{
		d := o.Static.ElementsAs(ctx, &static_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range static_tf_entries {
			var entry *logical_router.VrfMulticastIgmpStatic
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			static_pango_entries = append(static_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Dynamic = dynamic_entry
	(*obj).Static = static_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastIgmpDynamicInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastIgmpDynamicInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamic)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	version_value := o.Version.ValueStringPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	groupFilter_value := o.GroupFilter.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	queryProfile_value := o.QueryProfile.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamicInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Version = version_value
	(*obj).Robustness = robustness_value
	(*obj).GroupFilter = groupFilter_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).QueryProfile = queryProfile_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpStatic)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	globalAuthentication_value := o.GlobalAuthentication.ValueStringPointer()
	var originatorId_entry *logical_router.VrfMulticastMsdpOriginatorId
	if !o.OriginatorId.IsUnknown() && !o.OriginatorId.IsNull() {
		if *obj != nil && (*obj).OriginatorId != nil {
			originatorId_entry = (*obj).OriginatorId
		} else {
			originatorId_entry = new(logical_router.VrfMulticastMsdpOriginatorId)
		}
		var object *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject
		diags.Append(o.OriginatorId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &originatorId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterResourceVrfMulticastMsdpPeerObject
	var peer_pango_entries []logical_router.VrfMulticastMsdpPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfMulticastMsdpPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdp)
	}
	(*obj).Enable = enable_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).GlobalAuthentication = globalAuthentication_value
	(*obj).OriginatorId = originatorId_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpOriginatorId)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	maxSa_value := o.MaxSa.ValueInt64Pointer()
	inboundSaFilter_value := o.InboundSaFilter.ValueStringPointer()
	outboundSaFilter_value := o.OutboundSaFilter.ValueStringPointer()
	var localAddress_entry *logical_router.VrfMulticastMsdpPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
		}
		var object *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfMulticastMsdpPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
		}
		var object *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).Authentication = authentication_value
	(*obj).MaxSa = maxSa_value
	(*obj).InboundSaFilter = inboundSaFilter_value
	(*obj).OutboundSaFilter = outboundSaFilter_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	defaultInformationOriginate_value := o.DefaultInformationOriginate.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	authProfile_value := o.AuthProfile.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfRipGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfRipGlobalBfd)
		}
		var object *LogicalRouterResourceVrfRipGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_entry *logical_router.VrfRipGlobalInboundDistributeList
	if !o.GlobalInboundDistributeList.IsUnknown() && !o.GlobalInboundDistributeList.IsNull() {
		if *obj != nil && (*obj).GlobalInboundDistributeList != nil {
			globalInboundDistributeList_entry = (*obj).GlobalInboundDistributeList
		} else {
			globalInboundDistributeList_entry = new(logical_router.VrfRipGlobalInboundDistributeList)
		}
		var object *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject
		diags.Append(o.GlobalInboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_entry *logical_router.VrfRipGlobalOutboundDistributeList
	if !o.GlobalOutboundDistributeList.IsUnknown() && !o.GlobalOutboundDistributeList.IsNull() {
		if *obj != nil && (*obj).GlobalOutboundDistributeList != nil {
			globalOutboundDistributeList_entry = (*obj).GlobalOutboundDistributeList
		} else {
			globalOutboundDistributeList_entry = new(logical_router.VrfRipGlobalOutboundDistributeList)
		}
		var object *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject
		diags.Append(o.GlobalOutboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []LogicalRouterResourceVrfRipInterfacesObject
	var interfaces_pango_entries []logical_router.VrfRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *logical_router.VrfRipInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRip)
	}
	(*obj).Enable = enable_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).AuthProfile = authProfile_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GlobalInboundDistributeList = globalInboundDistributeList_entry
	(*obj).GlobalOutboundDistributeList = globalOutboundDistributeList_entry
	(*obj).Interface = interfaces_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalInboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mode_value := o.Mode.ValueStringPointer()
	splitHorizon_value := o.SplitHorizon.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfRipInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRipInterfaceBfd)
		}
		var object *LogicalRouterResourceVrfRipInterfacesBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceInboundDistributeList
	if !o.InterfaceInboundDistributeList.IsUnknown() && !o.InterfaceInboundDistributeList.IsNull() {
		if *obj != nil && (*obj).InterfaceInboundDistributeList != nil {
			interfaceInboundDistributeList_entry = (*obj).InterfaceInboundDistributeList
		} else {
			interfaceInboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
		}
		var object *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject
		diags.Append(o.InterfaceInboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &interfaceInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList
	if !o.InterfaceOutboundDistributeList.IsUnknown() && !o.InterfaceOutboundDistributeList.IsNull() {
		if *obj != nil && (*obj).InterfaceOutboundDistributeList != nil {
			interfaceOutboundDistributeList_entry = (*obj).InterfaceOutboundDistributeList
		} else {
			interfaceOutboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
		}
		var object *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject
		diags.Append(o.InterfaceOutboundDistributeList.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &interfaceOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Mode = mode_value
	(*obj).SplitHorizon = splitHorizon_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).InterfaceInboundDistributeList = interfaceInboundDistributeList_entry
	(*obj).InterfaceOutboundDistributeList = interfaceOutboundDistributeList_entry

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_list types.List
	{
		var vrf_tf_entries []LogicalRouterResourceVrfObject
		if !o.Vrf.IsNull() {
			diags.Append(o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Vrf {
			entry := LogicalRouterResourceVrfObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(vrf_tf_entries) {
				entry = vrf_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(vrf_tf_entries) {
				vrf_tf_entries[idx] = entry
			} else {
				vrf_tf_entries = append(vrf_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vrf")
		vrf_list, list_diags = types.ListValueFrom(ctx, schemaType, vrf_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vrf = vrf_list

	return diags
}

func (o *LogicalRouterResourceVrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistances_obj *LogicalRouterResourceVrfAdministrativeDistancesObject
	if o.AdministrativeDistances.IsNull() {
		administrativeDistances_obj = new(LogicalRouterResourceVrfAdministrativeDistancesObject)
	} else {
		diags.Append(o.AdministrativeDistances.As(ctx, &administrativeDistances_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	administrativeDistances_object := types.ObjectNull(administrativeDistances_obj.AttributeTypes())
	if obj.AdminDists != nil {
		diags.Append(administrativeDistances_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		administrativeDistances_object, diags_tmp = types.ObjectValueFrom(ctx, administrativeDistances_obj.AttributeTypes(), administrativeDistances_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ribFilter_obj *LogicalRouterResourceVrfRibFilterObject
	if o.RibFilter.IsNull() {
		ribFilter_obj = new(LogicalRouterResourceVrfRibFilterObject)
	} else {
		diags.Append(o.RibFilter.As(ctx, &ribFilter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ribFilter_object := types.ObjectNull(ribFilter_obj.AttributeTypes())
	if obj.RibFilter != nil {
		diags.Append(ribFilter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RibFilter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ribFilter_object, diags_tmp = types.ObjectValueFrom(ctx, ribFilter_obj.AttributeTypes(), ribFilter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterResourceVrfBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterResourceVrfBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routingTable_obj *LogicalRouterResourceVrfRoutingTableObject
	if o.RoutingTable.IsNull() {
		routingTable_obj = new(LogicalRouterResourceVrfRoutingTableObject)
	} else {
		diags.Append(o.RoutingTable.As(ctx, &routingTable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routingTable_object := types.ObjectNull(routingTable_obj.AttributeTypes())
	if obj.RoutingTable != nil {
		diags.Append(routingTable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RoutingTable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routingTable_object, diags_tmp = types.ObjectValueFrom(ctx, routingTable_obj.AttributeTypes(), routingTable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *LogicalRouterResourceVrfOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(LogicalRouterResourceVrfOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *LogicalRouterResourceVrfOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(LogicalRouterResourceVrfOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ecmp_obj *LogicalRouterResourceVrfEcmpObject
	if o.Ecmp.IsNull() {
		ecmp_obj = new(LogicalRouterResourceVrfEcmpObject)
	} else {
		diags.Append(o.Ecmp.As(ctx, &ecmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ecmp_object := types.ObjectNull(ecmp_obj.AttributeTypes())
	if obj.Ecmp != nil {
		diags.Append(ecmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ecmp_object, diags_tmp = types.ObjectValueFrom(ctx, ecmp_obj.AttributeTypes(), ecmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var multicast_obj *LogicalRouterResourceVrfMulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(LogicalRouterResourceVrfMulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *LogicalRouterResourceVrfRipObject
	if o.Rip.IsNull() {
		rip_obj = new(LogicalRouterResourceVrfRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_list
	o.AdministrativeDistances = administrativeDistances_object
	o.RibFilter = ribFilter_object
	o.Bgp = bgp_object
	o.RoutingTable = routingTable_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Ecmp = ecmp_object
	o.Multicast = multicast_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ospfInter_value types.Int64
	if obj.OspfInter != nil {
		ospfInter_value = types.Int64Value(*obj.OspfInter)
	}
	var ospfIntra_value types.Int64
	if obj.OspfIntra != nil {
		ospfIntra_value = types.Int64Value(*obj.OspfIntra)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Inter_value types.Int64
	if obj.Ospfv3Inter != nil {
		ospfv3Inter_value = types.Int64Value(*obj.Ospfv3Inter)
	}
	var ospfv3Intra_value types.Int64
	if obj.Ospfv3Intra != nil {
		ospfv3Intra_value = types.Int64Value(*obj.Ospfv3Intra)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var bgpInternal_value types.Int64
	if obj.BgpInternal != nil {
		bgpInternal_value = types.Int64Value(*obj.BgpInternal)
	}
	var bgpExternal_value types.Int64
	if obj.BgpExternal != nil {
		bgpExternal_value = types.Int64Value(*obj.BgpExternal)
	}
	var bgpLocal_value types.Int64
	if obj.BgpLocal != nil {
		bgpLocal_value = types.Int64Value(*obj.BgpLocal)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value
	o.OspfInter = ospfInter_value
	o.OspfIntra = ospfIntra_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Inter = ospfv3Inter_value
	o.Ospfv3Intra = ospfv3Intra_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.BgpInternal = bgpInternal_value
	o.BgpExternal = bgpExternal_value
	o.BgpLocal = bgpLocal_value
	o.Rip = rip_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterResourceVrfRibFilterIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterResourceVrfRibFilterIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterResourceVrfRibFilterIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterResourceVrfRibFilterIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_obj *LogicalRouterResourceVrfRibFilterIpv4StaticObject
	if o.Static.IsNull() {
		static_obj = new(LogicalRouterResourceVrfRibFilterIpv4StaticObject)
	} else {
		diags.Append(o.Static.As(ctx, &static_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	static_object := types.ObjectNull(static_obj.AttributeTypes())
	if obj.Static != nil {
		diags.Append(static_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		static_object, diags_tmp = types.ObjectValueFrom(ctx, static_obj.AttributeTypes(), static_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterResourceVrfRibFilterIpv4BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterResourceVrfRibFilterIpv4BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *LogicalRouterResourceVrfRibFilterIpv4OspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(LogicalRouterResourceVrfRibFilterIpv4OspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *LogicalRouterResourceVrfRibFilterIpv4RipObject
	if o.Rip.IsNull() {
		rip_obj = new(LogicalRouterResourceVrfRibFilterIpv4RipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_obj *LogicalRouterResourceVrfRibFilterIpv6StaticObject
	if o.Static.IsNull() {
		static_obj = new(LogicalRouterResourceVrfRibFilterIpv6StaticObject)
	} else {
		diags.Append(o.Static.As(ctx, &static_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	static_object := types.ObjectNull(static_obj.AttributeTypes())
	if obj.Static != nil {
		diags.Append(static_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		static_object, diags_tmp = types.ObjectValueFrom(ctx, static_obj.AttributeTypes(), static_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *LogicalRouterResourceVrfRibFilterIpv6BgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(LogicalRouterResourceVrfRibFilterIpv6BgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []LogicalRouterResourceVrfBgpPeerGroupObject
		if !o.PeerGroup.IsNull() {
			diags.Append(o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PeerGroup {
			entry := LogicalRouterResourceVrfBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peerGroup_tf_entries) {
				entry = peerGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peerGroup_tf_entries) {
				peerGroup_tf_entries[idx] = entry
			} else {
				peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRoutes_list types.List
	{
		var aggregateRoutes_tf_entries []LogicalRouterResourceVrfBgpAggregateRoutesObject
		if !o.AggregateRoutes.IsNull() {
			diags.Append(o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AggregateRoutes {
			entry := LogicalRouterResourceVrfBgpAggregateRoutesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(aggregateRoutes_tf_entries) {
				entry = aggregateRoutes_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(aggregateRoutes_tf_entries) {
				aggregateRoutes_tf_entries[idx] = entry
			} else {
				aggregateRoutes_tf_entries = append(aggregateRoutes_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("aggregate_routes")
		aggregateRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, aggregateRoutes_tf_entries)
		diags.Append(list_diags...)
	}

	var med_obj *LogicalRouterResourceVrfBgpMedObject
	if o.Med.IsNull() {
		med_obj = new(LogicalRouterResourceVrfBgpMedObject)
	} else {
		diags.Append(o.Med.As(ctx, &med_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	med_object := types.ObjectNull(med_obj.AttributeTypes())
	if obj.Med != nil {
		diags.Append(med_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		med_object, diags_tmp = types.ObjectValueFrom(ctx, med_obj.AttributeTypes(), med_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterResourceVrfBgpGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterResourceVrfBgpGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalBfd_obj *LogicalRouterResourceVrfBgpGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterResourceVrfBgpGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redistributionProfile_obj *LogicalRouterResourceVrfBgpRedistributionProfileObject
	if o.RedistributionProfile.IsNull() {
		redistributionProfile_obj = new(LogicalRouterResourceVrfBgpRedistributionProfileObject)
	} else {
		diags.Append(o.RedistributionProfile.As(ctx, &redistributionProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redistributionProfile_object := types.ObjectNull(redistributionProfile_obj.AttributeTypes())
	if obj.RedistributionProfile != nil {
		diags.Append(redistributionProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RedistributionProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redistributionProfile_object, diags_tmp = types.ObjectValueFrom(ctx, redistributionProfile_obj.AttributeTypes(), redistributionProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertiseNetwork_obj *LogicalRouterResourceVrfBgpAdvertiseNetworkObject
	if o.AdvertiseNetwork.IsNull() {
		advertiseNetwork_obj = new(LogicalRouterResourceVrfBgpAdvertiseNetworkObject)
	} else {
		diags.Append(o.AdvertiseNetwork.As(ctx, &advertiseNetwork_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertiseNetwork_object := types.ObjectNull(advertiseNetwork_obj.AttributeTypes())
	if obj.AdvertiseNetwork != nil {
		diags.Append(advertiseNetwork_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdvertiseNetwork, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertiseNetwork_object, diags_tmp = types.ObjectValueFrom(ctx, advertiseNetwork_obj.AttributeTypes(), advertiseNetwork_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var fastExternalFailover_value types.Bool
	if obj.FastExternalFailover != nil {
		fastExternalFailover_value = types.BoolValue(*obj.FastExternalFailover)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var gracefulShutdown_value types.Bool
	if obj.GracefulShutdown != nil {
		gracefulShutdown_value = types.BoolValue(*obj.GracefulShutdown)
	}
	var alwaysAdvertiseNetworkRoute_value types.Bool
	if obj.AlwaysAdvertiseNetworkRoute != nil {
		alwaysAdvertiseNetworkRoute_value = types.BoolValue(*obj.AlwaysAdvertiseNetworkRoute)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.LocalAs = localAs_value
	o.InstallRoute = installRoute_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.FastExternalFailover = fastExternalFailover_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulShutdown = gracefulShutdown_value
	o.AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	o.Med = med_object
	o.GracefulRestart = gracefulRestart_object
	o.GlobalBfd = globalBfd_object
	o.RedistributionProfile = redistributionProfile_object
	o.AdvertiseNetwork = advertiseNetwork_object
	o.PeerGroup = peerGroup_list
	o.AggregateRoutes = aggregateRoutes_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpMedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	o.Enable = enable_value
	o.StaleRouteTime = staleRouteTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.LocalRestartTime = localRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject
		if !o.Network.IsNull() {
			diags.Append(o.Network.ElementsAs(ctx, &network_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Network {
			entry := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(network_tf_entries) {
				entry = network_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(network_tf_entries) {
				network_tf_entries[idx] = entry
			} else {
				network_tf_entries = append(network_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	var backdoor_value types.Bool
	if obj.Backdoor != nil {
		backdoor_value = types.BoolValue(*obj.Backdoor)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value
	o.Multicast = multicast_value
	o.Backdoor = backdoor_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject
		if !o.Network.IsNull() {
			diags.Append(o.Network.ElementsAs(ctx, &network_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Network {
			entry := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(network_tf_entries) {
				entry = network_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(network_tf_entries) {
				network_tf_entries[idx] = entry
			} else {
				network_tf_entries = append(network_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterResourceVrfBgpPeerGroupPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := LogicalRouterResourceVrfBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterResourceVrfBgpPeerGroupTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterResourceVrfBgpPeerGroupTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var addressFamily_obj *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject
	if o.AddressFamily.IsNull() {
		addressFamily_obj = new(LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject)
	} else {
		diags.Append(o.AddressFamily.As(ctx, &addressFamily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addressFamily_object := types.ObjectNull(addressFamily_obj.AttributeTypes())
	if obj.AddressFamily != nil {
		diags.Append(addressFamily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addressFamily_object, diags_tmp = types.ObjectValueFrom(ctx, addressFamily_obj.AttributeTypes(), addressFamily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var filteringProfile_obj *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject
	if o.FilteringProfile.IsNull() {
		filteringProfile_obj = new(LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject)
	} else {
		diags.Append(o.FilteringProfile.As(ctx, &filteringProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filteringProfile_object := types.ObjectNull(filteringProfile_obj.AttributeTypes())
	if obj.FilteringProfile != nil {
		diags.Append(filteringProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filteringProfile_object, diags_tmp = types.ObjectValueFrom(ctx, filteringProfile_obj.AttributeTypes(), filteringProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Type = type_object
	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object
	o.ConnectionOptions = connectionOptions_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ibgp_obj *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject
	if o.Ibgp.IsNull() {
		ibgp_obj = new(LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject)
	} else {
		diags.Append(o.Ibgp.As(ctx, &ibgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgp_object := types.ObjectNull(ibgp_obj.AttributeTypes())
	if obj.Ibgp != nil {
		diags.Append(ibgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgp_object, diags_tmp = types.ObjectValueFrom(ctx, ibgp_obj.AttributeTypes(), ibgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgp_obj *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject
	if o.Ebgp.IsNull() {
		ebgp_obj = new(LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject)
	} else {
		diags.Append(o.Ebgp.As(ctx, &ebgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgp_object := types.ObjectNull(ebgp_obj.AttributeTypes())
	if obj.Ebgp != nil {
		diags.Append(ebgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgp_object, diags_tmp = types.ObjectValueFrom(ctx, ebgp_obj.AttributeTypes(), ebgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var inherit_obj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject
	if o.Inherit.IsNull() {
		inherit_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject)
	} else {
		diags.Append(o.Inherit.As(ctx, &inherit_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inherit_object := types.ObjectNull(inherit_obj.AttributeTypes())
	if obj.Inherit != nil {
		diags.Append(inherit_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Inherit, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inherit_object, diags_tmp = types.ObjectValueFrom(ctx, inherit_obj.AttributeTypes(), inherit_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.PeerAs = peerAs_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.Inherit = inherit_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var yes_obj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject
	if o.Yes.IsNull() {
		yes_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var no_obj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject
	if o.No.IsNull() {
		no_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Yes = yes_object
	o.No = no_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addressFamily_obj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
	if o.AddressFamily.IsNull() {
		addressFamily_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject)
	} else {
		diags.Append(o.AddressFamily.As(ctx, &addressFamily_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addressFamily_object := types.ObjectNull(addressFamily_obj.AttributeTypes())
	if obj.AddressFamily != nil {
		diags.Append(addressFamily_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addressFamily_object, diags_tmp = types.ObjectValueFrom(ctx, addressFamily_obj.AttributeTypes(), addressFamily_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var filteringProfile_obj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	if o.FilteringProfile.IsNull() {
		filteringProfile_obj = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject)
	} else {
		diags.Append(o.FilteringProfile.As(ctx, &filteringProfile_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filteringProfile_object := types.ObjectNull(filteringProfile_obj.AttributeTypes())
	if obj.FilteringProfile != nil {
		diags.Append(filteringProfile_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filteringProfile_object, diags_tmp = types.ObjectValueFrom(ctx, filteringProfile_obj.AttributeTypes(), filteringProfile_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.String
	if obj.Multihop != nil {
		multihop_value = types.StringValue(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summaryOnly_value types.Bool
	if obj.SummaryOnly != nil {
		summaryOnly_value = types.BoolValue(*obj.SummaryOnly)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	var sameMed_value types.Bool
	if obj.SameMed != nil {
		sameMed_value = types.BoolValue(*obj.SameMed)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Enable = enable_value
	o.SummaryOnly = summaryOnly_value
	o.AsSet = asSet_value
	o.SameMed = sameMed_value
	o.Type = type_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_obj *LogicalRouterResourceVrfRoutingTableIpObject
	if o.Ip.IsNull() {
		ip_obj = new(LogicalRouterResourceVrfRoutingTableIpObject)
	} else {
		diags.Append(o.Ip.As(ctx, &ip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ip_object := types.ObjectNull(ip_obj.AttributeTypes())
	if obj.Ip != nil {
		diags.Append(ip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ip_object, diags_tmp = types.ObjectValueFrom(ctx, ip_obj.AttributeTypes(), ip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *LogicalRouterResourceVrfRoutingTableIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(LogicalRouterResourceVrfRoutingTableIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfRoutingTableIpStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pathMonitor_obj *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject
	if o.PathMonitor.IsNull() {
		pathMonitor_obj = new(LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject)
	} else {
		diags.Append(o.PathMonitor.As(ctx, &pathMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pathMonitor_object := types.ObjectNull(pathMonitor_obj.AttributeTypes())
	if obj.PathMonitor != nil {
		diags.Append(pathMonitor_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pathMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, pathMonitor_obj.AttributeTypes(), pathMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var discard_obj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
	if o.Discard.IsNull() {
		discard_obj = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject)
	} else {
		diags.Append(o.Discard.As(ctx, &discard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	discard_object := types.ObjectNull(discard_obj.AttributeTypes())
	if obj.Discard != nil {
		diags.Append(discard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		discard_object, diags_tmp = types.ObjectValueFrom(ctx, discard_obj.AttributeTypes(), discard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.NextLr = nextLr_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		if !o.MonitorDestinations.IsNull() {
			diags.Append(o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MonitorDestinations {
			entry := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(monitorDestinations_tf_entries) {
				entry = monitorDestinations_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(monitorDestinations_tf_entries) {
				monitorDestinations_tf_entries[idx] = entry
			} else {
				monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pathMonitor_obj *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	if o.PathMonitor.IsNull() {
		pathMonitor_obj = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject)
	} else {
		diags.Append(o.PathMonitor.As(ctx, &pathMonitor_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pathMonitor_object := types.ObjectNull(pathMonitor_obj.AttributeTypes())
	if obj.PathMonitor != nil {
		diags.Append(pathMonitor_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pathMonitor_object, diags_tmp = types.ObjectValueFrom(ctx, pathMonitor_obj.AttributeTypes(), pathMonitor_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var discard_obj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
	if o.Discard.IsNull() {
		discard_obj = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject)
	} else {
		diags.Append(o.Discard.As(ctx, &discard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	discard_object := types.ObjectNull(discard_obj.AttributeTypes())
	if obj.Discard != nil {
		diags.Append(discard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		discard_object, diags_tmp = types.ObjectValueFrom(ctx, discard_obj.AttributeTypes(), discard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextLr = nextLr_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		if !o.MonitorDestinations.IsNull() {
			diags.Append(o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.MonitorDestinations {
			entry := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(monitorDestinations_tf_entries) {
				entry = monitorDestinations_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(monitorDestinations_tf_entries) {
				monitorDestinations_tf_entries[idx] = entry
			} else {
				monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterResourceVrfOspfAreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := LogicalRouterResourceVrfOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterResourceVrfOspfGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterResourceVrfOspfGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterResourceVrfOspfGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterResourceVrfOspfGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.RouterId = routerId_value
	o.Enable = enable_value
	o.Rfc1583 = rfc1583_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterResourceVrfOspfAreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := LogicalRouterResourceVrfOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterResourceVrfOspfAreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := LogicalRouterResourceVrfOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterResourceVrfOspfAreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterResourceVrfOspfAreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *LogicalRouterResourceVrfOspfAreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(LogicalRouterResourceVrfOspfAreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *LogicalRouterResourceVrfOspfAreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(LogicalRouterResourceVrfOspfAreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *LogicalRouterResourceVrfOspfAreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(LogicalRouterResourceVrfOspfAreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfAreaTypeStubAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultInformationOriginate_obj *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
	if o.DefaultInformationOriginate.IsNull() {
		defaultInformationOriginate_obj = new(LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject)
	} else {
		diags.Append(o.DefaultInformationOriginate.As(ctx, &defaultInformationOriginate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultInformationOriginate_object := types.ObjectNull(defaultInformationOriginate_obj.AttributeTypes())
	if obj.DefaultInformationOriginate != nil {
		diags.Append(defaultInformationOriginate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultInformationOriginate_object, diags_tmp = types.ObjectValueFrom(ctx, defaultInformationOriginate_obj.AttributeTypes(), defaultInformationOriginate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var abr_obj *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var linkType_obj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfOspfAreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterResourceVrfOspfv3AreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := LogicalRouterResourceVrfOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterResourceVrfOspfv3GlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterResourceVrfOspfv3GlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *LogicalRouterResourceVrfOspfv3GracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(LogicalRouterResourceVrfOspfv3GracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterResourceVrfOspfv3AreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := LogicalRouterResourceVrfOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *LogicalRouterResourceVrfOspfv3AreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *LogicalRouterResourceVrfOspfv3AreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var abr_obj *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultInformationOriginate_obj *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
	if o.DefaultInformationOriginate.IsNull() {
		defaultInformationOriginate_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject)
	} else {
		diags.Append(o.DefaultInformationOriginate.As(ctx, &defaultInformationOriginate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultInformationOriginate_object := types.ObjectNull(defaultInformationOriginate_obj.AttributeTypes())
	if obj.DefaultInformationOriginate != nil {
		diags.Append(defaultInformationOriginate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultInformationOriginate_object, diags_tmp = types.ObjectValueFrom(ctx, defaultInformationOriginate_obj.AttributeTypes(), defaultInformationOriginate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var abr_obj *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject
	if o.Abr.IsNull() {
		abr_obj = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject)
	} else {
		diags.Append(o.Abr.As(ctx, &abr_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	abr_object := types.ObjectNull(abr_obj.AttributeTypes())
	if obj.Abr != nil {
		diags.Append(abr_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		abr_object, diags_tmp = types.ObjectValueFrom(ctx, abr_obj.AttributeTypes(), abr_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var linkType_obj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.InstanceId = instanceId_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_obj *LogicalRouterResourceVrfEcmpAlgorithmObject
	if o.Algorithm.IsNull() {
		algorithm_obj = new(LogicalRouterResourceVrfEcmpAlgorithmObject)
	} else {
		diags.Append(o.Algorithm.As(ctx, &algorithm_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	algorithm_object := types.ObjectNull(algorithm_obj.AttributeTypes())
	if obj.Algorithm != nil {
		diags.Append(algorithm_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		algorithm_object, diags_tmp = types.ObjectValueFrom(ctx, algorithm_obj.AttributeTypes(), algorithm_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipModulo_obj *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject
	if o.IpModulo.IsNull() {
		ipModulo_obj = new(LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject)
	} else {
		diags.Append(o.IpModulo.As(ctx, &ipModulo_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipModulo_object := types.ObjectNull(ipModulo_obj.AttributeTypes())
	if obj.IpModulo != nil {
		diags.Append(ipModulo_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipModulo_object, diags_tmp = types.ObjectValueFrom(ctx, ipModulo_obj.AttributeTypes(), ipModulo_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipHash_obj *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject
	if o.IpHash.IsNull() {
		ipHash_obj = new(LogicalRouterResourceVrfEcmpAlgorithmIpHashObject)
	} else {
		diags.Append(o.IpHash.As(ctx, &ipHash_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipHash_object := types.ObjectNull(ipHash_obj.AttributeTypes())
	if obj.IpHash != nil {
		diags.Append(ipHash_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipHash_object, diags_tmp = types.ObjectValueFrom(ctx, ipHash_obj.AttributeTypes(), ipHash_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weightedRoundRobin_obj *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject
	if o.WeightedRoundRobin.IsNull() {
		weightedRoundRobin_obj = new(LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject)
	} else {
		diags.Append(o.WeightedRoundRobin.As(ctx, &weightedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weightedRoundRobin_object := types.ObjectNull(weightedRoundRobin_obj.AttributeTypes())
	if obj.WeightedRoundRobin != nil {
		diags.Append(weightedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weightedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, weightedRoundRobin_obj.AttributeTypes(), weightedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var balancedRoundRobin_obj *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject
	if o.BalancedRoundRobin.IsNull() {
		balancedRoundRobin_obj = new(LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject)
	} else {
		diags.Append(o.BalancedRoundRobin.As(ctx, &balancedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	balancedRoundRobin_object := types.ObjectNull(balancedRoundRobin_obj.AttributeTypes())
	if obj.BalancedRoundRobin != nil {
		diags.Append(balancedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		balancedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, balancedRoundRobin_obj.AttributeTypes(), balancedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object
	o.WeightedRoundRobin = weightedRoundRobin_object
	o.BalancedRoundRobin = balancedRoundRobin_object

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfMulticastStaticRouteObject
		if !o.StaticRoute.IsNull() {
			diags.Append(o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfMulticastStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(staticRoute_tf_entries) {
				entry = staticRoute_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(staticRoute_tf_entries) {
				staticRoute_tf_entries[idx] = entry
			} else {
				staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	var pim_obj *LogicalRouterResourceVrfMulticastPimObject
	if o.Pim.IsNull() {
		pim_obj = new(LogicalRouterResourceVrfMulticastPimObject)
	} else {
		diags.Append(o.Pim.As(ctx, &pim_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pim_object := types.ObjectNull(pim_obj.AttributeTypes())
	if obj.Pim != nil {
		diags.Append(pim_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pim_object, diags_tmp = types.ObjectValueFrom(ctx, pim_obj.AttributeTypes(), pim_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var igmp_obj *LogicalRouterResourceVrfMulticastIgmpObject
	if o.Igmp.IsNull() {
		igmp_obj = new(LogicalRouterResourceVrfMulticastIgmpObject)
	} else {
		diags.Append(o.Igmp.As(ctx, &igmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	igmp_object := types.ObjectNull(igmp_obj.AttributeTypes())
	if obj.Igmp != nil {
		diags.Append(igmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		igmp_object, diags_tmp = types.ObjectValueFrom(ctx, igmp_obj.AttributeTypes(), igmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var msdp_obj *LogicalRouterResourceVrfMulticastMsdpObject
	if o.Msdp.IsNull() {
		msdp_obj = new(LogicalRouterResourceVrfMulticastMsdpObject)
	} else {
		diags.Append(o.Msdp.As(ctx, &msdp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	msdp_object := types.ObjectNull(msdp_obj.AttributeTypes())
	if obj.Msdp != nil {
		diags.Append(msdp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Msdp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		msdp_object, diags_tmp = types.ObjectValueFrom(ctx, msdp_obj.AttributeTypes(), msdp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.StaticRoute = staticRoute_list
	o.Pim = pim_object
	o.Igmp = igmp_object
	o.Msdp = msdp_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nexthop_obj *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject
	if o.Nexthop.IsNull() {
		nexthop_obj = new(LogicalRouterResourceVrfMulticastStaticRouteNexthopObject)
	} else {
		diags.Append(o.Nexthop.As(ctx, &nexthop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nexthop_object := types.ObjectNull(nexthop_obj.AttributeTypes())
	if obj.Nexthop != nil {
		diags.Append(nexthop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nexthop_object, diags_tmp = types.ObjectValueFrom(ctx, nexthop_obj.AttributeTypes(), nexthop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var preference_value types.Int64
	if obj.Preference != nil {
		preference_value = types.Int64Value(*obj.Preference)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.Preference = preference_value
	o.Nexthop = nexthop_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.IpAddress = ipAddress_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []LogicalRouterResourceVrfMulticastPimSptThresholdObject
		if !o.SptThreshold.IsNull() {
			diags.Append(o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SptThreshold {
			entry := LogicalRouterResourceVrfMulticastPimSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sptThreshold_tf_entries) {
				entry = sptThreshold_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sptThreshold_tf_entries) {
				sptThreshold_tf_entries[idx] = entry
			} else {
				sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfMulticastPimInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfMulticastPimInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	var ssmAddressSpace_obj *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject
	if o.SsmAddressSpace.IsNull() {
		ssmAddressSpace_obj = new(LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject)
	} else {
		diags.Append(o.SsmAddressSpace.As(ctx, &ssmAddressSpace_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ssmAddressSpace_object := types.ObjectNull(ssmAddressSpace_obj.AttributeTypes())
	if obj.SsmAddressSpace != nil {
		diags.Append(ssmAddressSpace_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SsmAddressSpace, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ssmAddressSpace_object, diags_tmp = types.ObjectValueFrom(ctx, ssmAddressSpace_obj.AttributeTypes(), ssmAddressSpace_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rp_obj *LogicalRouterResourceVrfMulticastPimRpObject
	if o.Rp.IsNull() {
		rp_obj = new(LogicalRouterResourceVrfMulticastPimRpObject)
	} else {
		diags.Append(o.Rp.As(ctx, &rp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rp_object := types.ObjectNull(rp_obj.AttributeTypes())
	if obj.Rp != nil {
		diags.Append(rp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rp_object, diags_tmp = types.ObjectValueFrom(ctx, rp_obj.AttributeTypes(), rp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rpfLookupMode_value types.String
	if obj.RpfLookupMode != nil {
		rpfLookupMode_value = types.StringValue(*obj.RpfLookupMode)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	var ifTimerGlobal_value types.String
	if obj.IfTimerGlobal != nil {
		ifTimerGlobal_value = types.StringValue(*obj.IfTimerGlobal)
	}
	var groupPermission_value types.String
	if obj.GroupPermission != nil {
		groupPermission_value = types.StringValue(*obj.GroupPermission)
	}
	o.Enable = enable_value
	o.RpfLookupMode = rpfLookupMode_value
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.IfTimerGlobal = ifTimerGlobal_value
	o.GroupPermission = groupPermission_value
	o.SsmAddressSpace = ssmAddressSpace_object
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []LogicalRouterResourceVrfMulticastPimRpExternalRpObject
		if !o.ExternalRp.IsNull() {
			diags.Append(o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExternalRp {
			entry := LogicalRouterResourceVrfMulticastPimRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(externalRp_tf_entries) {
				entry = externalRp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(externalRp_tf_entries) {
				externalRp_tf_entries[idx] = entry
			} else {
				externalRp_tf_entries = append(externalRp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}

	var localRp_obj *LogicalRouterResourceVrfMulticastPimRpLocalRpObject
	if o.LocalRp.IsNull() {
		localRp_obj = new(LogicalRouterResourceVrfMulticastPimRpLocalRpObject)
	} else {
		diags.Append(o.LocalRp.As(ctx, &localRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localRp_object := types.ObjectNull(localRp_obj.AttributeTypes())
	if obj.LocalRp != nil {
		diags.Append(localRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localRp_object, diags_tmp = types.ObjectValueFrom(ctx, localRp_obj.AttributeTypes(), localRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.LocalRp = localRp_object
	o.ExternalRp = externalRp_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var staticRp_obj *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject
	if o.StaticRp.IsNull() {
		staticRp_obj = new(LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject)
	} else {
		diags.Append(o.StaticRp.As(ctx, &staticRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticRp_object := types.ObjectNull(staticRp_obj.AttributeTypes())
	if obj.StaticRp != nil {
		diags.Append(staticRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticRp_object, diags_tmp = types.ObjectValueFrom(ctx, staticRp_obj.AttributeTypes(), staticRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var candidateRp_obj *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject
	if o.CandidateRp.IsNull() {
		candidateRp_obj = new(LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject)
	} else {
		diags.Append(o.CandidateRp.As(ctx, &candidateRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	candidateRp_object := types.ObjectNull(candidateRp_obj.AttributeTypes())
	if obj.CandidateRp != nil {
		diags.Append(candidateRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		candidateRp_object, diags_tmp = types.ObjectValueFrom(ctx, candidateRp_obj.AttributeTypes(), candidateRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.StaticRp = staticRp_object
	o.CandidateRp = candidateRp_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Override = override_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Priority = priority_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupList = groupList_value
	o.Override = override_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var sendBsm_value types.Bool
	if obj.SendBsm != nil {
		sendBsm_value = types.BoolValue(*obj.SendBsm)
	}
	var ifTimer_value types.String
	if obj.IfTimer != nil {
		ifTimer_value = types.StringValue(*obj.IfTimer)
	}
	var neighborFilter_value types.String
	if obj.NeighborFilter != nil {
		neighborFilter_value = types.StringValue(*obj.NeighborFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.DrPriority = drPriority_value
	o.SendBsm = sendBsm_value
	o.IfTimer = ifTimer_value
	o.NeighborFilter = neighborFilter_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_list types.List
	{
		var static_tf_entries []LogicalRouterResourceVrfMulticastIgmpStaticObject
		if !o.Static.IsNull() {
			diags.Append(o.Static.ElementsAs(ctx, &static_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Static {
			entry := LogicalRouterResourceVrfMulticastIgmpStaticObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(static_tf_entries) {
				entry = static_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(static_tf_entries) {
				static_tf_entries[idx] = entry
			} else {
				static_tf_entries = append(static_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static")
		static_list, list_diags = types.ListValueFrom(ctx, schemaType, static_tf_entries)
		diags.Append(list_diags...)
	}

	var dynamic_obj *LogicalRouterResourceVrfMulticastIgmpDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(LogicalRouterResourceVrfMulticastIgmpDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Dynamic = dynamic_object
	o.Static = static_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var groupFilter_value types.String
	if obj.GroupFilter != nil {
		groupFilter_value = types.StringValue(*obj.GroupFilter)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var queryProfile_value types.String
	if obj.QueryProfile != nil {
		queryProfile_value = types.StringValue(*obj.QueryProfile)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Version = version_value
	o.Robustness = robustness_value
	o.GroupFilter = groupFilter_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.QueryProfile = queryProfile_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterResourceVrfMulticastMsdpPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := LogicalRouterResourceVrfMulticastMsdpPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var originatorId_obj *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject
	if o.OriginatorId.IsNull() {
		originatorId_obj = new(LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject)
	} else {
		diags.Append(o.OriginatorId.As(ctx, &originatorId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	originatorId_object := types.ObjectNull(originatorId_obj.AttributeTypes())
	if obj.OriginatorId != nil {
		diags.Append(originatorId_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.OriginatorId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		originatorId_object, diags_tmp = types.ObjectValueFrom(ctx, originatorId_obj.AttributeTypes(), originatorId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var globalAuthentication_value types.String
	if obj.GlobalAuthentication != nil {
		globalAuthentication_value = types.StringValue(*obj.GlobalAuthentication)
	}
	o.Enable = enable_value
	o.GlobalTimer = globalTimer_value
	o.GlobalAuthentication = globalAuthentication_value
	o.OriginatorId = originatorId_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localAddress_obj *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var maxSa_value types.Int64
	if obj.MaxSa != nil {
		maxSa_value = types.Int64Value(*obj.MaxSa)
	}
	var inboundSaFilter_value types.String
	if obj.InboundSaFilter != nil {
		inboundSaFilter_value = types.StringValue(*obj.InboundSaFilter)
	}
	var outboundSaFilter_value types.String
	if obj.OutboundSaFilter != nil {
		outboundSaFilter_value = types.StringValue(*obj.OutboundSaFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.Authentication = authentication_value
	o.MaxSa = maxSa_value
	o.InboundSaFilter = inboundSaFilter_value
	o.OutboundSaFilter = outboundSaFilter_value
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []LogicalRouterResourceVrfRipInterfacesObject
		if !o.Interfaces.IsNull() {
			diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaces_tf_entries) {
				entry = interfaces_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaces_tf_entries) {
				interfaces_tf_entries[idx] = entry
			} else {
				interfaces_tf_entries = append(interfaces_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *LogicalRouterResourceVrfRipGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(LogicalRouterResourceVrfRipGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalInboundDistributeList_obj *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject
	if o.GlobalInboundDistributeList.IsNull() {
		globalInboundDistributeList_obj = new(LogicalRouterResourceVrfRipGlobalInboundDistributeListObject)
	} else {
		diags.Append(o.GlobalInboundDistributeList.As(ctx, &globalInboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalInboundDistributeList_object := types.ObjectNull(globalInboundDistributeList_obj.AttributeTypes())
	if obj.GlobalInboundDistributeList != nil {
		diags.Append(globalInboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalInboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, globalInboundDistributeList_obj.AttributeTypes(), globalInboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var globalOutboundDistributeList_obj *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject
	if o.GlobalOutboundDistributeList.IsNull() {
		globalOutboundDistributeList_obj = new(LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject)
	} else {
		diags.Append(o.GlobalOutboundDistributeList.As(ctx, &globalOutboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalOutboundDistributeList_object := types.ObjectNull(globalOutboundDistributeList_obj.AttributeTypes())
	if obj.GlobalOutboundDistributeList != nil {
		diags.Append(globalOutboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalOutboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, globalOutboundDistributeList_obj.AttributeTypes(), globalOutboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var defaultInformationOriginate_value types.Bool
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_value = types.BoolValue(*obj.DefaultInformationOriginate)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var authProfile_value types.String
	if obj.AuthProfile != nil {
		authProfile_value = types.StringValue(*obj.AuthProfile)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.DefaultInformationOriginate = defaultInformationOriginate_value
	o.GlobalTimer = globalTimer_value
	o.AuthProfile = authProfile_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GlobalInboundDistributeList = globalInboundDistributeList_object
	o.GlobalOutboundDistributeList = globalOutboundDistributeList_object
	o.Interfaces = interfaces_list

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *LogicalRouterResourceVrfRipInterfacesBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(LogicalRouterResourceVrfRipInterfacesBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interfaceInboundDistributeList_obj *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject
	if o.InterfaceInboundDistributeList.IsNull() {
		interfaceInboundDistributeList_obj = new(LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject)
	} else {
		diags.Append(o.InterfaceInboundDistributeList.As(ctx, &interfaceInboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceInboundDistributeList_object := types.ObjectNull(interfaceInboundDistributeList_obj.AttributeTypes())
	if obj.InterfaceInboundDistributeList != nil {
		diags.Append(interfaceInboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InterfaceInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		interfaceInboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, interfaceInboundDistributeList_obj.AttributeTypes(), interfaceInboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var interfaceOutboundDistributeList_obj *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	if o.InterfaceOutboundDistributeList.IsNull() {
		interfaceOutboundDistributeList_obj = new(LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject)
	} else {
		diags.Append(o.InterfaceOutboundDistributeList.As(ctx, &interfaceOutboundDistributeList_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceOutboundDistributeList_object := types.ObjectNull(interfaceOutboundDistributeList_obj.AttributeTypes())
	if obj.InterfaceOutboundDistributeList != nil {
		diags.Append(interfaceOutboundDistributeList_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.InterfaceOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		interfaceOutboundDistributeList_object, diags_tmp = types.ObjectValueFrom(ctx, interfaceOutboundDistributeList_obj.AttributeTypes(), interfaceOutboundDistributeList_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var splitHorizon_value types.String
	if obj.SplitHorizon != nil {
		splitHorizon_value = types.StringValue(*obj.SplitHorizon)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Mode = mode_value
	o.SplitHorizon = splitHorizon_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.InterfaceInboundDistributeList = interfaceInboundDistributeList_object
	o.InterfaceOutboundDistributeList = interfaceOutboundDistributeList_object

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *LogicalRouterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &logical_router.NgfwLocation{}
			var innerLocation LogicalRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *logical_router.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *LogicalRouterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &logical_router.NgfwLocation{}
			var innerLocation LogicalRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *LogicalRouterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &logical_router.NgfwLocation{}
			var innerLocation LogicalRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *logical_router.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *LogicalRouterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &logical_router.NgfwLocation{}
			var innerLocation LogicalRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type LogicalRouterImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o LogicalRouterImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *LogicalRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}
	var location_object *LogicalRouterLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *LogicalRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func LogicalRouterImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := LogicalRouterImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *LogicalRouterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj LogicalRouterImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type LogicalRouterVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type LogicalRouterTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type LogicalRouterTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type LogicalRouterNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type LogicalRouterLocation struct {
	Vsys          types.Object `tfsdk:"vsys"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
	Ngfw          types.Object `tfsdk:"ngfw"`
}

func LogicalRouterLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Virtual System",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The Virtual System name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("vsys"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("ngfw"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o LogicalRouterVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o LogicalRouterTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o LogicalRouterTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o LogicalRouterNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o LogicalRouterLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Vsys          *LogicalRouterVsysLocation          `json:"vsys,omitempty"`
		Template      *LogicalRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *LogicalRouterTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *LogicalRouterNgfwLocation          `json:"ngfw,omitempty"`
	}
	var vsys_object *LogicalRouterVsysLocation
	{
		diags := o.Vsys.As(context.TODO(), &vsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal vsys into JSON document", diags.Errors())
		}
	}
	var template_object *LogicalRouterTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *LogicalRouterTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}
	var ngfw_object *LogicalRouterNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Vsys:          vsys_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
		Ngfw:          ngfw_object,
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Vsys          *LogicalRouterVsysLocation          `json:"vsys,omitempty"`
		Template      *LogicalRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *LogicalRouterTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *LogicalRouterNgfwLocation          `json:"ngfw,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var vsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		vsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Vsys.AttributeTypes(), shadow.Vsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into vsys", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	o.Vsys = vsys_object
	o.Template = template_object
	o.TemplateStack = templateStack_object
	o.Ngfw = ngfw_object

	return nil
}

func (o *LogicalRouterVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
		"name":        types.StringType,
	}
}
func (o *LogicalRouterTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *LogicalRouterTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *LogicalRouterNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *LogicalRouterLocation) AttributeTypes() map[string]attr.Type {
	var vsysObj LogicalRouterVsysLocation
	var templateObj LogicalRouterTemplateLocation
	var templateStackObj LogicalRouterTemplateStackLocation
	var ngfwObj LogicalRouterNgfwLocation
	return map[string]attr.Type{
		"vsys": types.ObjectType{
			AttrTypes: vsysObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
	}
}
