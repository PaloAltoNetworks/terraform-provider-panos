package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/logical_router"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &LogicalRouterDataSource{}
	_ datasource.DataSourceWithConfigure = &LogicalRouterDataSource{}
)

func NewLogicalRouterDataSource() datasource.DataSource {
	return &LogicalRouterDataSource{}
}

type LogicalRouterDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service]
}

type LogicalRouterDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type LogicalRouterDataSourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Vrf      types.List   `tfsdk:"vrf"`
}
type LogicalRouterDataSourceVrfObject struct {
	Name                    types.String                                             `tfsdk:"name"`
	Interface               types.List                                               `tfsdk:"interface"`
	AdministrativeDistances *LogicalRouterDataSourceVrfAdministrativeDistancesObject `tfsdk:"administrative_distances"`
	RibFilter               *LogicalRouterDataSourceVrfRibFilterObject               `tfsdk:"rib_filter"`
	Bgp                     *LogicalRouterDataSourceVrfBgpObject                     `tfsdk:"bgp"`
	RoutingTable            *LogicalRouterDataSourceVrfRoutingTableObject            `tfsdk:"routing_table"`
	Ospf                    *LogicalRouterDataSourceVrfOspfObject                    `tfsdk:"ospf"`
	Ospfv3                  *LogicalRouterDataSourceVrfOspfv3Object                  `tfsdk:"ospfv3"`
	Ecmp                    *LogicalRouterDataSourceVrfEcmpObject                    `tfsdk:"ecmp"`
	Multicast               *LogicalRouterDataSourceVrfMulticastObject               `tfsdk:"multicast"`
	Rip                     *LogicalRouterDataSourceVrfRipObject                     `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfAdministrativeDistancesObject struct {
	Static      types.Int64 `tfsdk:"static"`
	StaticIpv6  types.Int64 `tfsdk:"static_ipv6"`
	OspfInter   types.Int64 `tfsdk:"ospf_inter"`
	OspfIntra   types.Int64 `tfsdk:"ospf_intra"`
	OspfExt     types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Inter types.Int64 `tfsdk:"ospfv3_inter"`
	Ospfv3Intra types.Int64 `tfsdk:"ospfv3_intra"`
	Ospfv3Ext   types.Int64 `tfsdk:"ospfv3_ext"`
	BgpInternal types.Int64 `tfsdk:"bgp_internal"`
	BgpExternal types.Int64 `tfsdk:"bgp_external"`
	BgpLocal    types.Int64 `tfsdk:"bgp_local"`
	Rip         types.Int64 `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfRibFilterObject struct {
	Ipv4 *LogicalRouterDataSourceVrfRibFilterIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterDataSourceVrfRibFilterIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4Object struct {
	Static *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject `tfsdk:"static"`
	Bgp    *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject    `tfsdk:"bgp"`
	Ospf   *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject   `tfsdk:"ospf"`
	Rip    *LogicalRouterDataSourceVrfRibFilterIpv4RipObject    `tfsdk:"rip"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4OspfObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv4RipObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6Object struct {
	Static *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject `tfsdk:"static"`
	Bgp    *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject    `tfsdk:"bgp"`
	Ospfv3 *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object `tfsdk:"ospfv3"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterDataSourceVrfBgpObject struct {
	Enable                      types.Bool                                                `tfsdk:"enable"`
	RouterId                    types.String                                              `tfsdk:"router_id"`
	LocalAs                     types.String                                              `tfsdk:"local_as"`
	InstallRoute                types.Bool                                                `tfsdk:"install_route"`
	EnforceFirstAs              types.Bool                                                `tfsdk:"enforce_first_as"`
	FastExternalFailover        types.Bool                                                `tfsdk:"fast_external_failover"`
	EcmpMultiAs                 types.Bool                                                `tfsdk:"ecmp_multi_as"`
	DefaultLocalPreference      types.Int64                                               `tfsdk:"default_local_preference"`
	GracefulShutdown            types.Bool                                                `tfsdk:"graceful_shutdown"`
	AlwaysAdvertiseNetworkRoute types.Bool                                                `tfsdk:"always_advertise_network_route"`
	Med                         *LogicalRouterDataSourceVrfBgpMedObject                   `tfsdk:"med"`
	GracefulRestart             *LogicalRouterDataSourceVrfBgpGracefulRestartObject       `tfsdk:"graceful_restart"`
	GlobalBfd                   *LogicalRouterDataSourceVrfBgpGlobalBfdObject             `tfsdk:"global_bfd"`
	RedistributionProfile       *LogicalRouterDataSourceVrfBgpRedistributionProfileObject `tfsdk:"redistribution_profile"`
	AdvertiseNetwork            *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject      `tfsdk:"advertise_network"`
	PeerGroup                   types.List                                                `tfsdk:"peer_group"`
	AggregateRoutes             types.List                                                `tfsdk:"aggregate_routes"`
}
type LogicalRouterDataSourceVrfBgpMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type LogicalRouterDataSourceVrfBgpGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
}
type LogicalRouterDataSourceVrfBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileObject struct {
	Ipv4 *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject struct {
	Ipv4 *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject struct {
	Name      types.String `tfsdk:"name"`
	Unicast   types.Bool   `tfsdk:"unicast"`
	Multicast types.Bool   `tfsdk:"multicast"`
	Backdoor  types.Bool   `tfsdk:"backdoor"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject struct {
	Name    types.String `tfsdk:"name"`
	Unicast types.Bool   `tfsdk:"unicast"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupObject struct {
	Name              types.String                                                   `tfsdk:"name"`
	Enable            types.Bool                                                     `tfsdk:"enable"`
	Type              *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject              `tfsdk:"type"`
	AddressFamily     *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject     `tfsdk:"address_family"`
	FilteringProfile  *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject  `tfsdk:"filtering_profile"`
	ConnectionOptions *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject `tfsdk:"connection_options"`
	Peer              types.List                                                     `tfsdk:"peer"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeObject struct {
	Ibgp *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject `tfsdk:"ibgp"`
	Ebgp *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject `tfsdk:"ebgp"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.Int64  `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerObject struct {
	Name                          types.String                                                       `tfsdk:"name"`
	Enable                        types.Bool                                                         `tfsdk:"enable"`
	Passive                       types.Bool                                                         `tfsdk:"passive"`
	PeerAs                        types.String                                                       `tfsdk:"peer_as"`
	EnableSenderSideLoopDetection types.Bool                                                         `tfsdk:"enable_sender_side_loop_detection"`
	Inherit                       *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject           `tfsdk:"inherit"`
	LocalAddress                  *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject      `tfsdk:"local_address"`
	PeerAddress                   *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject       `tfsdk:"peer_address"`
	ConnectionOptions             *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject `tfsdk:"connection_options"`
	Bfd                           *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject               `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject struct {
	Yes *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject `tfsdk:"yes"`
	No  *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject  `tfsdk:"no"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject struct {
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject struct {
	AddressFamily    *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject    `tfsdk:"address_family"`
	FilteringProfile *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject `tfsdk:"filtering_profile"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.String `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesObject struct {
	Name        types.String                                            `tfsdk:"name"`
	Description types.String                                            `tfsdk:"description"`
	Enable      types.Bool                                              `tfsdk:"enable"`
	SummaryOnly types.Bool                                              `tfsdk:"summary_only"`
	AsSet       types.Bool                                              `tfsdk:"as_set"`
	SameMed     types.Bool                                              `tfsdk:"same_med"`
	Type        *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject `tfsdk:"type"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject struct {
	Ipv4 *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterDataSourceVrfRoutingTableObject struct {
	Ip   *LogicalRouterDataSourceVrfRoutingTableIpObject   `tfsdk:"ip"`
	Ipv6 *LogicalRouterDataSourceVrfRoutingTableIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterDataSourceVrfRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject struct {
	Name                   types.String                                                          `tfsdk:"name"`
	Destination            types.String                                                          `tfsdk:"destination"`
	Interface              types.String                                                          `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                           `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                           `tfsdk:"metric"`
	Nexthop                *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject     `tfsdk:"nexthop"`
	Bfd                    *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject `tfsdk:"path_monitor"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject struct {
	Discard   *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject `tfsdk:"discard"`
	IpAddress types.String                                                             `tfsdk:"ip_address"`
	NextLr    types.String                                                             `tfsdk:"next_lr"`
	Fqdn      types.String                                                             `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String                                                            `tfsdk:"name"`
	Destination            types.String                                                            `tfsdk:"destination"`
	Interface              types.String                                                            `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                             `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                             `tfsdk:"metric"`
	Nexthop                *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject     `tfsdk:"nexthop"`
	Bfd                    *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject `tfsdk:"path_monitor"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject struct {
	Discard     *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject `tfsdk:"discard"`
	Ipv6Address types.String                                                               `tfsdk:"ipv6_address"`
	Fqdn        types.String                                                               `tfsdk:"fqdn"`
	NextLr      types.String                                                               `tfsdk:"next_lr"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterDataSourceVrfOspfObject struct {
	RouterId              types.String                                         `tfsdk:"router_id"`
	Enable                types.Bool                                           `tfsdk:"enable"`
	Rfc1583               types.Bool                                           `tfsdk:"rfc1583"`
	SpfTimer              types.String                                         `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String                                         `tfsdk:"global_if_timer"`
	RedistributionProfile types.String                                         `tfsdk:"redistribution_profile"`
	GlobalBfd             *LogicalRouterDataSourceVrfOspfGlobalBfdObject       `tfsdk:"global_bfd"`
	GracefulRestart       *LogicalRouterDataSourceVrfOspfGracefulRestartObject `tfsdk:"graceful_restart"`
	Area                  types.List                                           `tfsdk:"area"`
}
type LogicalRouterDataSourceVrfOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterDataSourceVrfOspfAreaObject struct {
	Name           types.String                                  `tfsdk:"name"`
	Authentication types.String                                  `tfsdk:"authentication"`
	Type           *LogicalRouterDataSourceVrfOspfAreaTypeObject `tfsdk:"type"`
	Range          types.List                                    `tfsdk:"range"`
	Interface      types.List                                    `tfsdk:"interface"`
	VirtualLink    types.List                                    `tfsdk:"virtual_link"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeObject struct {
	Normal *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject `tfsdk:"normal"`
	Stub   *LogicalRouterDataSourceVrfOspfAreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject   `tfsdk:"nssa"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNormalObject struct {
	Abr *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeStubObject struct {
	NoSummary          types.Bool                                           `tfsdk:"no_summary"`
	Abr                *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject `tfsdk:"abr"`
	DefaultRouteMetric types.Int64                                          `tfsdk:"default_route_metric"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaObject struct {
	NoSummary                   types.Bool                                                                   `tfsdk:"no_summary"`
	DefaultInformationOriginate *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject `tfsdk:"default_information_originate"`
	Abr                         *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject                         `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceObject struct {
	Name           types.String                                               `tfsdk:"name"`
	Enable         types.Bool                                                 `tfsdk:"enable"`
	MtuIgnore      types.Bool                                                 `tfsdk:"mtu_ignore"`
	Passive        types.Bool                                                 `tfsdk:"passive"`
	Priority       types.Int64                                                `tfsdk:"priority"`
	Metric         types.Int64                                                `tfsdk:"metric"`
	Authentication types.String                                               `tfsdk:"authentication"`
	Timing         types.String                                               `tfsdk:"timing"`
	LinkType       *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Bfd            *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject struct {
	Broadcast *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject struct {
	Name           types.String                                            `tfsdk:"name"`
	NeighborId     types.String                                            `tfsdk:"neighbor_id"`
	TransitAreaId  types.String                                            `tfsdk:"transit_area_id"`
	Enable         types.Bool                                              `tfsdk:"enable"`
	InstanceId     types.Int64                                             `tfsdk:"instance_id"`
	Timing         types.String                                            `tfsdk:"timing"`
	Authentication types.String                                            `tfsdk:"authentication"`
	Bfd            *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3Object struct {
	Enable                types.Bool                                             `tfsdk:"enable"`
	RouterId              types.String                                           `tfsdk:"router_id"`
	DisableTransitTraffic types.Bool                                             `tfsdk:"disable_transit_traffic"`
	SpfTimer              types.String                                           `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String                                           `tfsdk:"global_if_timer"`
	RedistributionProfile types.String                                           `tfsdk:"redistribution_profile"`
	GlobalBfd             *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject       `tfsdk:"global_bfd"`
	GracefulRestart       *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject `tfsdk:"graceful_restart"`
	Area                  types.List                                             `tfsdk:"area"`
}
type LogicalRouterDataSourceVrfOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterDataSourceVrfOspfv3AreaObject struct {
	Name           types.String                                    `tfsdk:"name"`
	Authentication types.String                                    `tfsdk:"authentication"`
	Type           *LogicalRouterDataSourceVrfOspfv3AreaTypeObject `tfsdk:"type"`
	Range          types.List                                      `tfsdk:"range"`
	Interface      types.List                                      `tfsdk:"interface"`
	VirtualLink    types.List                                      `tfsdk:"virtual_link"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeObject struct {
	Normal *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject `tfsdk:"normal"`
	Stub   *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject   `tfsdk:"nssa"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject struct {
	Abr *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject struct {
	NoSummary          types.Bool                                             `tfsdk:"no_summary"`
	Abr                *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject `tfsdk:"abr"`
	DefaultRouteMetric types.Int64                                            `tfsdk:"default_route_metric"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject struct {
	NoSummary                   types.Bool                                                                     `tfsdk:"no_summary"`
	DefaultInformationOriginate *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject `tfsdk:"default_information_originate"`
	Abr                         *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject                         `tfsdk:"abr"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject struct {
	Name           types.String                                                 `tfsdk:"name"`
	Enable         types.Bool                                                   `tfsdk:"enable"`
	MtuIgnore      types.Bool                                                   `tfsdk:"mtu_ignore"`
	Passive        types.Bool                                                   `tfsdk:"passive"`
	Priority       types.Int64                                                  `tfsdk:"priority"`
	Metric         types.Int64                                                  `tfsdk:"metric"`
	InstanceId     types.Int64                                                  `tfsdk:"instance_id"`
	Authentication types.String                                                 `tfsdk:"authentication"`
	Timing         types.String                                                 `tfsdk:"timing"`
	LinkType       *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Bfd            *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
}
type LogicalRouterDataSourceVrfEcmpObject struct {
	Enable           types.Bool                                     `tfsdk:"enable"`
	MaxPaths         types.Int64                                    `tfsdk:"max_paths"`
	SymmetricReturn  types.Bool                                     `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool                                     `tfsdk:"strict_source_path"`
	Algorithm        *LogicalRouterDataSourceVrfEcmpAlgorithmObject `tfsdk:"algorithm"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmObject struct {
	IpModulo           *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
	IpHash             *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	WeightedRoundRobin *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject struct {
}
type LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject struct {
}
type LogicalRouterDataSourceVrfMulticastObject struct {
	Enable      types.Bool                                     `tfsdk:"enable"`
	StaticRoute types.List                                     `tfsdk:"static_route"`
	Pim         *LogicalRouterDataSourceVrfMulticastPimObject  `tfsdk:"pim"`
	Igmp        *LogicalRouterDataSourceVrfMulticastIgmpObject `tfsdk:"igmp"`
	Msdp        *LogicalRouterDataSourceVrfMulticastMsdpObject `tfsdk:"msdp"`
}
type LogicalRouterDataSourceVrfMulticastStaticRouteObject struct {
	Name        types.String                                                 `tfsdk:"name"`
	Destination types.String                                                 `tfsdk:"destination"`
	Interface   types.String                                                 `tfsdk:"interface"`
	Preference  types.Int64                                                  `tfsdk:"preference"`
	Nexthop     *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject `tfsdk:"nexthop"`
}
type LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
}
type LogicalRouterDataSourceVrfMulticastPimObject struct {
	Enable          types.Bool                                                   `tfsdk:"enable"`
	RpfLookupMode   types.String                                                 `tfsdk:"rpf_lookup_mode"`
	RouteAgeoutTime types.Int64                                                  `tfsdk:"route_ageout_time"`
	IfTimerGlobal   types.String                                                 `tfsdk:"if_timer_global"`
	GroupPermission types.String                                                 `tfsdk:"group_permission"`
	SsmAddressSpace *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject `tfsdk:"ssm_address_space"`
	Rp              *LogicalRouterDataSourceVrfMulticastPimRpObject              `tfsdk:"rp"`
	SptThreshold    types.List                                                   `tfsdk:"spt_threshold"`
	Interface       types.List                                                   `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject struct {
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpObject struct {
	LocalRp    *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject `tfsdk:"local_rp"`
	ExternalRp types.List                                             `tfsdk:"external_rp"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject struct {
	StaticRp    *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject    `tfsdk:"static_rp"`
	CandidateRp *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject `tfsdk:"candidate_rp"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject struct {
	Interface types.String `tfsdk:"interface"`
	Address   types.String `tfsdk:"address"`
	Override  types.Bool   `tfsdk:"override"`
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject struct {
	Interface             types.String `tfsdk:"interface"`
	Address               types.String `tfsdk:"address"`
	Priority              types.Int64  `tfsdk:"priority"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupList             types.String `tfsdk:"group_list"`
}
type LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject struct {
	Name      types.String `tfsdk:"name"`
	GroupList types.String `tfsdk:"group_list"`
	Override  types.Bool   `tfsdk:"override"`
}
type LogicalRouterDataSourceVrfMulticastPimSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type LogicalRouterDataSourceVrfMulticastPimInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Description    types.String `tfsdk:"description"`
	DrPriority     types.Int64  `tfsdk:"dr_priority"`
	SendBsm        types.Bool   `tfsdk:"send_bsm"`
	IfTimer        types.String `tfsdk:"if_timer"`
	NeighborFilter types.String `tfsdk:"neighbor_filter"`
}
type LogicalRouterDataSourceVrfMulticastIgmpObject struct {
	Enable  types.Bool                                            `tfsdk:"enable"`
	Dynamic *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject `tfsdk:"dynamic"`
	Static  types.List                                            `tfsdk:"static"`
}
type LogicalRouterDataSourceVrfMulticastIgmpDynamicObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject struct {
	Name                types.String `tfsdk:"name"`
	Version             types.String `tfsdk:"version"`
	Robustness          types.String `tfsdk:"robustness"`
	GroupFilter         types.String `tfsdk:"group_filter"`
	MaxGroups           types.String `tfsdk:"max_groups"`
	MaxSources          types.String `tfsdk:"max_sources"`
	QueryProfile        types.String `tfsdk:"query_profile"`
	RouterAlertPolicing types.Bool   `tfsdk:"router_alert_policing"`
}
type LogicalRouterDataSourceVrfMulticastIgmpStaticObject struct {
	Name          types.String `tfsdk:"name"`
	Interface     types.String `tfsdk:"interface"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
}
type LogicalRouterDataSourceVrfMulticastMsdpObject struct {
	Enable               types.Bool                                                 `tfsdk:"enable"`
	GlobalTimer          types.String                                               `tfsdk:"global_timer"`
	GlobalAuthentication types.String                                               `tfsdk:"global_authentication"`
	OriginatorId         *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject `tfsdk:"originator_id"`
	Peer                 types.List                                                 `tfsdk:"peer"`
}
type LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerObject struct {
	Name             types.String                                                   `tfsdk:"name"`
	Enable           types.Bool                                                     `tfsdk:"enable"`
	PeerAs           types.String                                                   `tfsdk:"peer_as"`
	Authentication   types.String                                                   `tfsdk:"authentication"`
	MaxSa            types.Int64                                                    `tfsdk:"max_sa"`
	InboundSaFilter  types.String                                                   `tfsdk:"inbound_sa_filter"`
	OutboundSaFilter types.String                                                   `tfsdk:"outbound_sa_filter"`
	LocalAddress     *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject `tfsdk:"local_address"`
	PeerAddress      *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject  `tfsdk:"peer_address"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterDataSourceVrfRipObject struct {
	Enable                       types.Bool                                                       `tfsdk:"enable"`
	DefaultInformationOriginate  types.Bool                                                       `tfsdk:"default_information_originate"`
	GlobalTimer                  types.String                                                     `tfsdk:"global_timer"`
	AuthProfile                  types.String                                                     `tfsdk:"auth_profile"`
	RedistributionProfile        types.String                                                     `tfsdk:"redistribution_profile"`
	GlobalBfd                    *LogicalRouterDataSourceVrfRipGlobalBfdObject                    `tfsdk:"global_bfd"`
	GlobalInboundDistributeList  *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject  `tfsdk:"global_inbound_distribute_list"`
	GlobalOutboundDistributeList *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject `tfsdk:"global_outbound_distribute_list"`
	Interfaces                   types.List                                                       `tfsdk:"interfaces"`
}
type LogicalRouterDataSourceVrfRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterDataSourceVrfRipInterfacesObject struct {
	Name                            types.String                                                                  `tfsdk:"name"`
	Enable                          types.Bool                                                                    `tfsdk:"enable"`
	Mode                            types.String                                                                  `tfsdk:"mode"`
	SplitHorizon                    types.String                                                                  `tfsdk:"split_horizon"`
	Authentication                  types.String                                                                  `tfsdk:"authentication"`
	Bfd                             *LogicalRouterDataSourceVrfRipInterfacesBfdObject                             `tfsdk:"bfd"`
	InterfaceInboundDistributeList  *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject  `tfsdk:"interface_inbound_distribute_list"`
	InterfaceOutboundDistributeList *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject `tfsdk:"interface_outbound_distribute_list"`
}
type LogicalRouterDataSourceVrfRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}
type LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}

func (o *LogicalRouterDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj LogicalRouterLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"vrf":  types.ListType{},
	}
}

func (o LogicalRouterDataSourceModel) AncestorName() string {
	return ""
}

func (o LogicalRouterDataSourceModel) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfObject) AttributeTypes() map[string]attr.Type {

	var administrativeDistancesObj *LogicalRouterDataSourceVrfAdministrativeDistancesObject

	var ribFilterObj *LogicalRouterDataSourceVrfRibFilterObject

	var bgpObj *LogicalRouterDataSourceVrfBgpObject

	var routingTableObj *LogicalRouterDataSourceVrfRoutingTableObject

	var ospfObj *LogicalRouterDataSourceVrfOspfObject

	var ospfv3Obj *LogicalRouterDataSourceVrfOspfv3Object

	var ecmpObj *LogicalRouterDataSourceVrfEcmpObject

	var multicastObj *LogicalRouterDataSourceVrfMulticastObject

	var ripObj *LogicalRouterDataSourceVrfRipObject
	return map[string]attr.Type{
		"name":      types.StringType,
		"interface": types.ListType{},
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"rib_filter": types.ObjectType{
			AttrTypes: ribFilterObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"routing_table": types.ObjectType{
			AttrTypes: routingTableObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfObject) AncestorName() string {
	return "vrf"
}

func (o LogicalRouterDataSourceVrfObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static":       types.Int64Type,
		"static_ipv6":  types.Int64Type,
		"ospf_inter":   types.Int64Type,
		"ospf_intra":   types.Int64Type,
		"ospf_ext":     types.Int64Type,
		"ospfv3_inter": types.Int64Type,
		"ospfv3_intra": types.Int64Type,
		"ospfv3_ext":   types.Int64Type,
		"bgp_internal": types.Int64Type,
		"bgp_external": types.Int64Type,
		"bgp_local":    types.Int64Type,
		"rip":          types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o LogicalRouterDataSourceVrfAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfRibFilterIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfRibFilterIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterObject) AncestorName() string {
	return "rib-filter"
}

func (o LogicalRouterDataSourceVrfRibFilterObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject

	var bgpObj *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject

	var ospfObj *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject

	var ripObj *LogicalRouterDataSourceVrfRibFilterIpv4RipObject
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4RipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv4RipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject

	var bgpObj *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject

	var ospfv3Obj *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpObject) AttributeTypes() map[string]attr.Type {

	var medObj *LogicalRouterDataSourceVrfBgpMedObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfBgpGracefulRestartObject

	var globalBfdObj *LogicalRouterDataSourceVrfBgpGlobalBfdObject

	var redistributionProfileObj *LogicalRouterDataSourceVrfBgpRedistributionProfileObject

	var advertiseNetworkObj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject

	return map[string]attr.Type{
		"enable":                         types.BoolType,
		"router_id":                      types.StringType,
		"local_as":                       types.StringType,
		"install_route":                  types.BoolType,
		"enforce_first_as":               types.BoolType,
		"fast_external_failover":         types.BoolType,
		"ecmp_multi_as":                  types.BoolType,
		"default_local_preference":       types.Int64Type,
		"graceful_shutdown":              types.BoolType,
		"always_advertise_network_route": types.BoolType,
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"redistribution_profile": types.ObjectType{
			AttrTypes: redistributionProfileObj.AttributeTypes(),
		},
		"advertise_network": types.ObjectType{
			AttrTypes: advertiseNetworkObj.AttributeTypes(),
		},
		"peer_group":       types.ListType{},
		"aggregate_routes": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfBgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterDataSourceVrfBgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpMedObject) AncestorName() string {
	return "med"
}

func (o LogicalRouterDataSourceVrfBgpMedObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"stale_route_time":      types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"local_restart_time":    types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfBgpGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfBgpGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileObject) AncestorName() string {
	return "redistribution-profile"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) AncestorName() string {
	return "advertise-network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"network": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
		"backdoor":  types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"network": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":    types.StringType,
		"unicast": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject

	var addressFamilyObj *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject

	var filteringProfileObj *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject

	var connectionOptionsObj *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject

	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"peer": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject

	var ebgpObj *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.Int64Type,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var inheritObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject

	var localAddressObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"passive":                           types.BoolType,
		"peer_as":                           types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"inherit": types.ObjectType{
			AttrTypes: inheritObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) AttributeTypes() map[string]attr.Type {

	var yesObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject

	var noObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject
	return map[string]attr.Type{
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) AncestorName() string {
	return "inherit"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) AncestorName() string {
	return "yes"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) AttributeTypes() map[string]attr.Type {

	var addressFamilyObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject

	var filteringProfileObj *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	return map[string]attr.Type{
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) AncestorName() string {
	return "no"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.StringType,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject
	return map[string]attr.Type{
		"name":         types.StringType,
		"description":  types.StringType,
		"enable":       types.BoolType,
		"summary_only": types.BoolType,
		"as_set":       types.BoolType,
		"same_med":     types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesObject) AncestorName() string {
	return "aggregate-routes"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object

	var ipv6Obj *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableObject) AttributeTypes() map[string]attr.Type {

	var ipObj *LogicalRouterDataSourceVrfRoutingTableIpObject

	var ipv6Obj *LogicalRouterDataSourceVrfRoutingTableIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableObject) AncestorName() string {
	return "routing-table"
}

func (o LogicalRouterDataSourceVrfRoutingTableObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static_route": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpObject) AncestorName() string {
	return "ip"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject

	var bfdObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject

	var pathMonitorObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ip_address": types.StringType,
		"next_lr":    types.StringType,
		"fqdn":       types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":               types.BoolType,
		"failure_condition":    types.StringType,
		"hold_time":            types.Int64Type,
		"monitor_destinations": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static_route": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject

	var bfdObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject

	var pathMonitorObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ipv6_address": types.StringType,
		"fqdn":         types.StringType,
		"next_lr":      types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":               types.BoolType,
		"failure_condition":    types.StringType,
		"hold_time":            types.Int64Type,
		"monitor_destinations": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfOspfGlobalBfdObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfOspfGracefulRestartObject

	return map[string]attr.Type{
		"router_id":              types.StringType,
		"enable":                 types.BoolType,
		"rfc1583":                types.BoolType,
		"spf_timer":              types.StringType,
		"global_if_timer":        types.StringType,
		"redistribution_profile": types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterDataSourceVrfOspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfOspfAreaTypeObject

	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range":        types.ListType{},
		"interface":    types.ListType{},
		"virtual_link": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterDataSourceVrfOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject

	var stubObj *LogicalRouterDataSourceVrfOspfAreaTypeStubObject

	var nssaObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range":       types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterDataSourceVrfOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"neighbor": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3Object) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject

	var gracefulRestartObj *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject

	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"router_id":               types.StringType,
		"disable_transit_traffic": types.BoolType,
		"spf_timer":               types.StringType,
		"global_if_timer":         types.StringType,
		"redistribution_profile":  types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterDataSourceVrfOspfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterDataSourceVrfOspfv3AreaTypeObject

	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range":        types.ListType{},
		"interface":    types.ListType{},
		"virtual_link": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject

	var stubObj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject

	var nssaObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range":       types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"instance_id":    types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"neighbor": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *LogicalRouterDataSourceVrfEcmpAlgorithmObject
	return map[string]attr.Type{
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"symmetric_return":   types.BoolType,
		"strict_source_path": types.BoolType,
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o LogicalRouterDataSourceVrfEcmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var ipModuloObj *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject

	var ipHashObj *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject

	var weightedRoundRobinObj *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject

	var balancedRoundRobinObj *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject
	return map[string]attr.Type{
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
		"hash_seed": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastObject) AttributeTypes() map[string]attr.Type {

	var pimObj *LogicalRouterDataSourceVrfMulticastPimObject

	var igmpObj *LogicalRouterDataSourceVrfMulticastIgmpObject

	var msdpObj *LogicalRouterDataSourceVrfMulticastMsdpObject
	return map[string]attr.Type{
		"enable":       types.BoolType,
		"static_route": types.ListType{},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"msdp": types.ObjectType{
			AttrTypes: msdpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastObject) AncestorName() string {
	return "multicast"
}

func (o LogicalRouterDataSourceVrfMulticastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"destination": types.StringType,
		"interface":   types.StringType,
		"preference":  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimObject) AttributeTypes() map[string]attr.Type {

	var ssmAddressSpaceObj *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject

	var rpObj *LogicalRouterDataSourceVrfMulticastPimRpObject

	return map[string]attr.Type{
		"enable":            types.BoolType,
		"rpf_lookup_mode":   types.StringType,
		"route_ageout_time": types.Int64Type,
		"if_timer_global":   types.StringType,
		"group_permission":  types.StringType,
		"ssm_address_space": types.ObjectType{
			AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
		},
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{},
		"interface":     types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimObject) AncestorName() string {
	return "pim"
}

func (o LogicalRouterDataSourceVrfMulticastPimObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"group_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) AttributeTypes() map[string]attr.Type {

	var localRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject

	return map[string]attr.Type{
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
		"external_rp": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpObject) AncestorName() string {
	return "rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var staticRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject

	var candidateRpObj *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject
	return map[string]attr.Type{
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":  types.StringType,
		"address":    types.StringType,
		"override":   types.BoolType,
		"group_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":              types.StringType,
		"address":                types.StringType,
		"priority":               types.Int64Type,
		"advertisement_interval": types.Int64Type,
		"group_list":             types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"group_list": types.StringType,
		"override":   types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"description":     types.StringType,
		"dr_priority":     types.Int64Type,
		"send_bsm":        types.BoolType,
		"if_timer":        types.StringType,
		"neighbor_filter": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastPimInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfMulticastPimInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"static": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpObject) AncestorName() string {
	return "igmp"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"version":               types.StringType,
		"robustness":            types.StringType,
		"group_filter":          types.StringType,
		"max_groups":            types.StringType,
		"max_sources":           types.StringType,
		"query_profile":         types.StringType,
		"router_alert_policing": types.BoolType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"interface":      types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastIgmpStaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterDataSourceVrfMulticastIgmpStaticObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) AttributeTypes() map[string]attr.Type {

	var originatorIdObj *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"global_timer":          types.StringType,
		"global_authentication": types.StringType,
		"originator_id": types.ObjectType{
			AttrTypes: originatorIdObj.AttributeTypes(),
		},
		"peer": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpObject) AncestorName() string {
	return "msdp"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) AncestorName() string {
	return "originator-id"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject

	var peerAddressObj *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"enable":             types.BoolType,
		"peer_as":            types.StringType,
		"authentication":     types.StringType,
		"max_sa":             types.Int64Type,
		"inbound_sa_filter":  types.StringType,
		"outbound_sa_filter": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterDataSourceVrfRipGlobalBfdObject

	var globalInboundDistributeListObj *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject

	var globalOutboundDistributeListObj *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject

	return map[string]attr.Type{
		"enable":                        types.BoolType,
		"default_information_originate": types.BoolType,
		"global_timer":                  types.StringType,
		"auth_profile":                  types.StringType,
		"redistribution_profile":        types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"global_inbound_distribute_list": types.ObjectType{
			AttrTypes: globalInboundDistributeListObj.AttributeTypes(),
		},
		"global_outbound_distribute_list": types.ObjectType{
			AttrTypes: globalOutboundDistributeListObj.AttributeTypes(),
		},
		"interfaces": types.ListType{},
	}
}

func (o LogicalRouterDataSourceVrfRipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterDataSourceVrfRipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterDataSourceVrfRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) AncestorName() string {
	return "global-inbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) AncestorName() string {
	return "global-outbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterDataSourceVrfRipInterfacesBfdObject

	var interfaceInboundDistributeListObj *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject

	var interfaceOutboundDistributeListObj *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mode":           types.StringType,
		"split_horizon":  types.StringType,
		"authentication": types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"interface_inbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceInboundDistributeListObj.AttributeTypes(),
		},
		"interface_outbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceOutboundDistributeListObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o LogicalRouterDataSourceVrfRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterDataSourceVrfRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) AncestorName() string {
	return "interface-inbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AncestorName() string {
	return "interface-outbound-distribute-list"
}

func (o LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) EntryName() *string {
	return nil
}

func (o *LogicalRouterDataSourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_tf_entries []LogicalRouterDataSourceVrfObject
	var vrf_pango_entries []logical_router.Vrf
	{
		d := o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vrf_tf_entries {
			var entry *logical_router.Vrf
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_pango_entries = append(vrf_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vrf = vrf_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var administrativeDistances_entry *logical_router.VrfAdminDists
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(logical_router.VrfAdminDists)
		}
		// ModelOrObject: Object
		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, append(ancestors, o), &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_entry *logical_router.VrfRibFilter
	if o.RibFilter != nil {
		if *obj != nil && (*obj).RibFilter != nil {
			ribFilter_entry = (*obj).RibFilter
		} else {
			ribFilter_entry = new(logical_router.VrfRibFilter)
		}
		// ModelOrObject: Object
		diags.Append(o.RibFilter.CopyToPango(ctx, append(ancestors, o), &ribFilter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfBgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *logical_router.VrfRoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(logical_router.VrfRoutingTable)
		}
		// ModelOrObject: Object
		diags.Append(o.RoutingTable.CopyToPango(ctx, append(ancestors, o), &routingTable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfOspf)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospf.CopyToPango(ctx, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfOspfv3)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospfv3.CopyToPango(ctx, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *logical_router.VrfEcmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(logical_router.VrfEcmp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ecmp.CopyToPango(ctx, append(ancestors, o), &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *logical_router.VrfMulticast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(logical_router.VrfMulticast)
		}
		// ModelOrObject: Object
		diags.Append(o.Multicast.CopyToPango(ctx, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRip)
		}
		// ModelOrObject: Object
		diags.Append(o.Rip.CopyToPango(ctx, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Vrf)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).RibFilter = ribFilter_entry
	(*obj).Bgp = bgp_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Multicast = multicast_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInter_value := o.OspfInter.ValueInt64Pointer()
	ospfIntra_value := o.OspfIntra.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Inter_value := o.Ospfv3Inter.ValueInt64Pointer()
	ospfv3Intra_value := o.Ospfv3Intra.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	bgpInternal_value := o.BgpInternal.ValueInt64Pointer()
	bgpExternal_value := o.BgpExternal.ValueInt64Pointer()
	bgpLocal_value := o.BgpLocal.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfAdminDists)
	}
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInter = ospfInter_value
	(*obj).OspfIntra = ospfIntra_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Inter = ospfv3Inter_value
	(*obj).Ospfv3Intra = ospfv3Intra_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).BgpInternal = bgpInternal_value
	(*obj).BgpExternal = bgpExternal_value
	(*obj).BgpLocal = bgpLocal_value
	(*obj).Rip = rip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfRibFilterIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfRibFilterIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRibFilterIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRibFilterIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilter)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv4Static
	if o.Static != nil {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv4Static)
		}
		// ModelOrObject: Object
		diags.Append(o.Static.CopyToPango(ctx, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv4Bgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv4Bgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfRibFilterIpv4Ospf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfRibFilterIpv4Ospf)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospf.CopyToPango(ctx, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRibFilterIpv4Rip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRibFilterIpv4Rip)
		}
		// ModelOrObject: Object
		diags.Append(o.Rip.CopyToPango(ctx, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Ospf)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Rip)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv6Static
	if o.Static != nil {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv6Static)
		}
		// ModelOrObject: Object
		diags.Append(o.Static.CopyToPango(ctx, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv6Bgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv6Bgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfRibFilterIpv6Ospfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfRibFilterIpv6Ospfv3)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospfv3.CopyToPango(ctx, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Ospfv3)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	fastExternalFailover_value := o.FastExternalFailover.ValueBoolPointer()
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	gracefulShutdown_value := o.GracefulShutdown.ValueBoolPointer()
	alwaysAdvertiseNetworkRoute_value := o.AlwaysAdvertiseNetworkRoute.ValueBoolPointer()
	var med_entry *logical_router.VrfBgpMed
	if o.Med != nil {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(logical_router.VrfBgpMed)
		}
		// ModelOrObject: Object
		diags.Append(o.Med.CopyToPango(ctx, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfBgpGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfBgpGracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_entry *logical_router.VrfBgpGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfBgpGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_entry *logical_router.VrfBgpRedistributionProfile
	if o.RedistributionProfile != nil {
		if *obj != nil && (*obj).RedistributionProfile != nil {
			redistributionProfile_entry = (*obj).RedistributionProfile
		} else {
			redistributionProfile_entry = new(logical_router.VrfBgpRedistributionProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.RedistributionProfile.CopyToPango(ctx, append(ancestors, o), &redistributionProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_entry *logical_router.VrfBgpAdvertiseNetwork
	if o.AdvertiseNetwork != nil {
		if *obj != nil && (*obj).AdvertiseNetwork != nil {
			advertiseNetwork_entry = (*obj).AdvertiseNetwork
		} else {
			advertiseNetwork_entry = new(logical_router.VrfBgpAdvertiseNetwork)
		}
		// ModelOrObject: Object
		diags.Append(o.AdvertiseNetwork.CopyToPango(ctx, append(ancestors, o), &advertiseNetwork_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerGroup_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupObject
	var peerGroup_pango_entries []logical_router.VrfBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *logical_router.VrfBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var aggregateRoutes_tf_entries []LogicalRouterDataSourceVrfBgpAggregateRoutesObject
	var aggregateRoutes_pango_entries []logical_router.VrfBgpAggregateRoutes
	{
		d := o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range aggregateRoutes_tf_entries {
			var entry *logical_router.VrfBgpAggregateRoutes
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_pango_entries = append(aggregateRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgp)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).LocalAs = localAs_value
	(*obj).InstallRoute = installRoute_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).FastExternalFailover = fastExternalFailover_value
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulShutdown = gracefulShutdown_value
	(*obj).AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	(*obj).Med = med_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RedistributionProfile = redistributionProfile_entry
	(*obj).AdvertiseNetwork = advertiseNetwork_entry
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).AggregateRoutes = aggregateRoutes_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpMedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpRedistributionProfileIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpRedistributionProfileIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpRedistributionProfileIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpRedistributionProfileIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfile)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv4)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv6)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAdvertiseNetworkIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAdvertiseNetworkIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetwork)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv4Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv4Network
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()
	backdoor_value := o.Backdoor.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value
	(*obj).Backdoor = backdoor_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv6Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv6Network
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpPeerGroupType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpPeerGroupType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_entry *logical_router.VrfBgpPeerGroupAddressFamily
	if o.AddressFamily != nil {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupAddressFamily)
		}
		// ModelOrObject: Object
		diags.Append(o.AddressFamily.CopyToPango(ctx, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupFilteringProfile
	if o.FilteringProfile != nil {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupFilteringProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.FilteringProfile.CopyToPango(ctx, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupConnectionOptions)
		}
		// ModelOrObject: Object
		diags.Append(o.ConnectionOptions.CopyToPango(ctx, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupPeerObject
	var peer_pango_entries []logical_router.VrfBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Type = type_entry
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *logical_router.VrfBgpPeerGroupTypeIbgp
	if o.Ibgp != nil {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(logical_router.VrfBgpPeerGroupTypeIbgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ibgp.CopyToPango(ctx, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *logical_router.VrfBgpPeerGroupTypeEbgp
	if o.Ebgp != nil {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(logical_router.VrfBgpPeerGroupTypeEbgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ebgp.CopyToPango(ctx, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeIbgp)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeEbgp)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	var inherit_entry *logical_router.VrfBgpPeerGroupPeerInherit
	if o.Inherit != nil {
		if *obj != nil && (*obj).Inherit != nil {
			inherit_entry = (*obj).Inherit
		} else {
			inherit_entry = new(logical_router.VrfBgpPeerGroupPeerInherit)
		}
		// ModelOrObject: Object
		diags.Append(o.Inherit.CopyToPango(ctx, append(ancestors, o), &inherit_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *logical_router.VrfBgpPeerGroupPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalAddress.CopyToPango(ctx, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfBgpPeerGroupPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.PeerAddress.CopyToPango(ctx, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupPeerConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
		}
		// ModelOrObject: Object
		diags.Append(o.ConnectionOptions.CopyToPango(ctx, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfBgpPeerGroupPeerBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfBgpPeerGroupPeerBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).Inherit = inherit_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_entry *logical_router.VrfBgpPeerGroupPeerInheritYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
		}
		// ModelOrObject: Object
		diags.Append(o.Yes.CopyToPango(ctx, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_entry *logical_router.VrfBgpPeerGroupPeerInheritNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
		}
		// ModelOrObject: Object
		diags.Append(o.No.CopyToPango(ctx, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInherit)
	}
	(*obj).Yes = yes_entry
	(*obj).No = no_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_entry *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily
	if o.AddressFamily != nil {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
		}
		// ModelOrObject: Object
		diags.Append(o.AddressFamily.CopyToPango(ctx, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile
	if o.FilteringProfile != nil {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.FilteringProfile.CopyToPango(ctx, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
	}
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summaryOnly_value := o.SummaryOnly.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	sameMed_value := o.SameMed.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpAggregateRoutesType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpAggregateRoutesType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Enable = enable_value
	(*obj).SummaryOnly = summaryOnly_value
	(*obj).AsSet = asSet_value
	(*obj).SameMed = sameMed_value
	(*obj).Type = type_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAggregateRoutesTypeIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAggregateRoutesTypeIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesType)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *logical_router.VrfRoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(logical_router.VrfRoutingTableIp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ip.CopyToPango(ctx, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRoutingTableIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpStaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
		}
		// ModelOrObject: Object
		diags.Append(o.PathMonitor.CopyToPango(ctx, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
		}
		// ModelOrObject: Object
		diags.Append(o.Discard.CopyToPango(ctx, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).NextLr = nextLr_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpv6StaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
		}
		// ModelOrObject: Object
		diags.Append(o.PathMonitor.CopyToPango(ctx, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
		}
		// ModelOrObject: Object
		diags.Append(o.Discard.CopyToPango(ctx, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextLr = nextLr_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routerId_value := o.RouterId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfGracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterDataSourceVrfOspfAreaObject
	var area_pango_entries []logical_router.VrfOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfArea
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspf)
	}
	(*obj).RouterId = routerId_value
	(*obj).Enable = enable_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfAreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfAreaType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterDataSourceVrfOspfAreaRangeObject
	var range_pango_entries []logical_router.VrfOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfAreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfAreaTypeNormal)
		}
		// ModelOrObject: Object
		diags.Append(o.Normal.CopyToPango(ctx, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfAreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfAreaTypeStub)
		}
		// ModelOrObject: Object
		diags.Append(o.Stub.CopyToPango(ctx, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfAreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfAreaTypeNssa)
		}
		// ModelOrObject: Object
		diags.Append(o.Nssa.CopyToPango(ctx, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfAreaTypeNormalAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNormalAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfAreaTypeStubAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeStubAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate
	if o.DefaultInformationOriginate != nil {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
		}
		// ModelOrObject: Object
		diags.Append(o.DefaultInformationOriginate.CopyToPango(ctx, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfAreaTypeNssaAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNssaAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfAreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfAreaInterfaceLinkType)
		}
		// ModelOrObject: Object
		diags.Append(o.LinkType.CopyToPango(ctx, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfAreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
		}
		// ModelOrObject: Object
		diags.Append(o.Broadcast.CopyToPango(ctx, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
		}
		// ModelOrObject: Object
		diags.Append(o.P2p.CopyToPango(ctx, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
		}
		// ModelOrObject: Object
		diags.Append(o.P2mp.CopyToPango(ctx, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfOspfAreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaVirtualLinkBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfv3GlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfv3GlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfv3GracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfv3GracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaObject
	var area_pango_entries []logical_router.VrfOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfv3Area
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfv3AreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfv3AreaType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaRangeObject
	var range_pango_entries []logical_router.VrfOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfv3AreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfv3AreaTypeNormal)
		}
		// ModelOrObject: Object
		diags.Append(o.Normal.CopyToPango(ctx, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfv3AreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfv3AreaTypeStub)
		}
		// ModelOrObject: Object
		diags.Append(o.Stub.CopyToPango(ctx, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfv3AreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfv3AreaTypeNssa)
		}
		// ModelOrObject: Object
		diags.Append(o.Nssa.CopyToPango(ctx, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfv3AreaTypeNormalAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfv3AreaTypeStubAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeStubAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate
	if o.DefaultInformationOriginate != nil {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
		}
		// ModelOrObject: Object
		diags.Append(o.DefaultInformationOriginate.CopyToPango(ctx, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfv3AreaTypeNssaAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfv3AreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
		}
		// ModelOrObject: Object
		diags.Append(o.LinkType.CopyToPango(ctx, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfv3AreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfv3AreaInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).InstanceId = instanceId_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		// ModelOrObject: Object
		diags.Append(o.Broadcast.CopyToPango(ctx, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
		}
		// ModelOrObject: Object
		diags.Append(o.P2p.CopyToPango(ctx, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
		}
		// ModelOrObject: Object
		diags.Append(o.P2mp.CopyToPango(ctx, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	var algorithm_entry *logical_router.VrfEcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(logical_router.VrfEcmpAlgorithm)
		}
		// ModelOrObject: Object
		diags.Append(o.Algorithm.CopyToPango(ctx, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmp)
	}
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).Algorithm = algorithm_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *logical_router.VrfEcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(logical_router.VrfEcmpAlgorithmIpModulo)
		}
		// ModelOrObject: Object
		diags.Append(o.IpModulo.CopyToPango(ctx, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *logical_router.VrfEcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(logical_router.VrfEcmpAlgorithmIpHash)
		}
		// ModelOrObject: Object
		diags.Append(o.IpHash.CopyToPango(ctx, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
		}
		// ModelOrObject: Object
		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *logical_router.VrfEcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
		}
		// ModelOrObject: Object
		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var staticRoute_tf_entries []LogicalRouterDataSourceVrfMulticastStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfMulticastStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfMulticastStaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}
	var pim_entry *logical_router.VrfMulticastPim
	if o.Pim != nil {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(logical_router.VrfMulticastPim)
		}
		// ModelOrObject: Object
		diags.Append(o.Pim.CopyToPango(ctx, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *logical_router.VrfMulticastIgmp
	if o.Igmp != nil {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(logical_router.VrfMulticastIgmp)
		}
		// ModelOrObject: Object
		diags.Append(o.Igmp.CopyToPango(ctx, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_entry *logical_router.VrfMulticastMsdp
	if o.Msdp != nil {
		if *obj != nil && (*obj).Msdp != nil {
			msdp_entry = (*obj).Msdp
		} else {
			msdp_entry = new(logical_router.VrfMulticastMsdp)
		}
		// ModelOrObject: Object
		diags.Append(o.Msdp.CopyToPango(ctx, append(ancestors, o), &msdp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticast)
	}
	(*obj).Enable = enable_value
	(*obj).StaticRoute = staticRoute_pango_entries
	(*obj).Pim = pim_entry
	(*obj).Igmp = igmp_entry
	(*obj).Msdp = msdp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	preference_value := o.Preference.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfMulticastStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfMulticastStaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Preference = preference_value
	(*obj).Nexthop = nexthop_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRouteNexthop)
	}
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	rpfLookupMode_value := o.RpfLookupMode.ValueStringPointer()
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	ifTimerGlobal_value := o.IfTimerGlobal.ValueStringPointer()
	groupPermission_value := o.GroupPermission.ValueStringPointer()
	var ssmAddressSpace_entry *logical_router.VrfMulticastPimSsmAddressSpace
	if o.SsmAddressSpace != nil {
		if *obj != nil && (*obj).SsmAddressSpace != nil {
			ssmAddressSpace_entry = (*obj).SsmAddressSpace
		} else {
			ssmAddressSpace_entry = new(logical_router.VrfMulticastPimSsmAddressSpace)
		}
		// ModelOrObject: Object
		diags.Append(o.SsmAddressSpace.CopyToPango(ctx, append(ancestors, o), &ssmAddressSpace_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_entry *logical_router.VrfMulticastPimRp
	if o.Rp != nil {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(logical_router.VrfMulticastPimRp)
		}
		// ModelOrObject: Object
		diags.Append(o.Rp.CopyToPango(ctx, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []LogicalRouterDataSourceVrfMulticastPimSptThresholdObject
	var sptThreshold_pango_entries []logical_router.VrfMulticastPimSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *logical_router.VrfMulticastPimSptThreshold
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterDataSourceVrfMulticastPimInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastPimInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastPimInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPim)
	}
	(*obj).Enable = enable_value
	(*obj).RpfLookupMode = rpfLookupMode_value
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).IfTimerGlobal = ifTimerGlobal_value
	(*obj).GroupPermission = groupPermission_value
	(*obj).SsmAddressSpace = ssmAddressSpace_entry
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSsmAddressSpace)
	}
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localRp_entry *logical_router.VrfMulticastPimRpLocalRp
	if o.LocalRp != nil {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(logical_router.VrfMulticastPimRpLocalRp)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalRp.CopyToPango(ctx, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var externalRp_tf_entries []LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject
	var externalRp_pango_entries []logical_router.VrfMulticastPimRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *logical_router.VrfMulticastPimRpExternalRp
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRp)
	}
	(*obj).LocalRp = localRp_entry
	(*obj).ExternalRp = externalRp_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_entry *logical_router.VrfMulticastPimRpLocalRpStaticRp
	if o.StaticRp != nil {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
		}
		// ModelOrObject: Object
		diags.Append(o.StaticRp.CopyToPango(ctx, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_entry *logical_router.VrfMulticastPimRpLocalRpCandidateRp
	if o.CandidateRp != nil {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
		}
		// ModelOrObject: Object
		diags.Append(o.CandidateRp.CopyToPango(ctx, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRp)
	}
	(*obj).StaticRp = staticRp_entry
	(*obj).CandidateRp = candidateRp_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Override = override_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Priority = priority_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupList = groupList_value
	(*obj).Override = override_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	sendBsm_value := o.SendBsm.ValueBoolPointer()
	ifTimer_value := o.IfTimer.ValueStringPointer()
	neighborFilter_value := o.NeighborFilter.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).DrPriority = drPriority_value
	(*obj).SendBsm = sendBsm_value
	(*obj).IfTimer = ifTimer_value
	(*obj).NeighborFilter = neighborFilter_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var dynamic_entry *logical_router.VrfMulticastIgmpDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(logical_router.VrfMulticastIgmpDynamic)
		}
		// ModelOrObject: Object
		diags.Append(o.Dynamic.CopyToPango(ctx, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var static_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpStaticObject
	var static_pango_entries []logical_router.VrfMulticastIgmpStatic
	{
		d := o.Static.ElementsAs(ctx, &static_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range static_tf_entries {
			var entry *logical_router.VrfMulticastIgmpStatic
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			static_pango_entries = append(static_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Dynamic = dynamic_entry
	(*obj).Static = static_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastIgmpDynamicInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastIgmpDynamicInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamic)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	version_value := o.Version.ValueStringPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	groupFilter_value := o.GroupFilter.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	queryProfile_value := o.QueryProfile.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamicInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Version = version_value
	(*obj).Robustness = robustness_value
	(*obj).GroupFilter = groupFilter_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).QueryProfile = queryProfile_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpStatic)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	globalAuthentication_value := o.GlobalAuthentication.ValueStringPointer()
	var originatorId_entry *logical_router.VrfMulticastMsdpOriginatorId
	if o.OriginatorId != nil {
		if *obj != nil && (*obj).OriginatorId != nil {
			originatorId_entry = (*obj).OriginatorId
		} else {
			originatorId_entry = new(logical_router.VrfMulticastMsdpOriginatorId)
		}
		// ModelOrObject: Object
		diags.Append(o.OriginatorId.CopyToPango(ctx, append(ancestors, o), &originatorId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterDataSourceVrfMulticastMsdpPeerObject
	var peer_pango_entries []logical_router.VrfMulticastMsdpPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfMulticastMsdpPeer
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdp)
	}
	(*obj).Enable = enable_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).GlobalAuthentication = globalAuthentication_value
	(*obj).OriginatorId = originatorId_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpOriginatorId)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	maxSa_value := o.MaxSa.ValueInt64Pointer()
	inboundSaFilter_value := o.InboundSaFilter.ValueStringPointer()
	outboundSaFilter_value := o.OutboundSaFilter.ValueStringPointer()
	var localAddress_entry *logical_router.VrfMulticastMsdpPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalAddress.CopyToPango(ctx, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfMulticastMsdpPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.PeerAddress.CopyToPango(ctx, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).Authentication = authentication_value
	(*obj).MaxSa = maxSa_value
	(*obj).InboundSaFilter = inboundSaFilter_value
	(*obj).OutboundSaFilter = outboundSaFilter_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	defaultInformationOriginate_value := o.DefaultInformationOriginate.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	authProfile_value := o.AuthProfile.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfRipGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfRipGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_entry *logical_router.VrfRipGlobalInboundDistributeList
	if o.GlobalInboundDistributeList != nil {
		if *obj != nil && (*obj).GlobalInboundDistributeList != nil {
			globalInboundDistributeList_entry = (*obj).GlobalInboundDistributeList
		} else {
			globalInboundDistributeList_entry = new(logical_router.VrfRipGlobalInboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalInboundDistributeList.CopyToPango(ctx, append(ancestors, o), &globalInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_entry *logical_router.VrfRipGlobalOutboundDistributeList
	if o.GlobalOutboundDistributeList != nil {
		if *obj != nil && (*obj).GlobalOutboundDistributeList != nil {
			globalOutboundDistributeList_entry = (*obj).GlobalOutboundDistributeList
		} else {
			globalOutboundDistributeList_entry = new(logical_router.VrfRipGlobalOutboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalOutboundDistributeList.CopyToPango(ctx, append(ancestors, o), &globalOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []LogicalRouterDataSourceVrfRipInterfacesObject
	var interfaces_pango_entries []logical_router.VrfRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *logical_router.VrfRipInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRip)
	}
	(*obj).Enable = enable_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).AuthProfile = authProfile_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GlobalInboundDistributeList = globalInboundDistributeList_entry
	(*obj).GlobalOutboundDistributeList = globalOutboundDistributeList_entry
	(*obj).Interface = interfaces_pango_entries

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalInboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mode_value := o.Mode.ValueStringPointer()
	splitHorizon_value := o.SplitHorizon.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfRipInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRipInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceInboundDistributeList
	if o.InterfaceInboundDistributeList != nil {
		if *obj != nil && (*obj).InterfaceInboundDistributeList != nil {
			interfaceInboundDistributeList_entry = (*obj).InterfaceInboundDistributeList
		} else {
			interfaceInboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.InterfaceInboundDistributeList.CopyToPango(ctx, append(ancestors, o), &interfaceInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList
	if o.InterfaceOutboundDistributeList != nil {
		if *obj != nil && (*obj).InterfaceOutboundDistributeList != nil {
			interfaceOutboundDistributeList_entry = (*obj).InterfaceOutboundDistributeList
		} else {
			interfaceOutboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.InterfaceOutboundDistributeList.CopyToPango(ctx, append(ancestors, o), &interfaceOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Mode = mode_value
	(*obj).SplitHorizon = splitHorizon_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).InterfaceInboundDistributeList = interfaceInboundDistributeList_entry
	(*obj).InterfaceOutboundDistributeList = interfaceOutboundDistributeList_entry

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}
func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_list types.List
	{
		var vrf_tf_entries []LogicalRouterDataSourceVrfObject
		for _, elt := range obj.Vrf {
			entry := LogicalRouterDataSourceVrfObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_tf_entries = append(vrf_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vrf")
		vrf_list, list_diags = types.ListValueFrom(ctx, schemaType, vrf_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vrf = vrf_list

	return diags
}

func (o *LogicalRouterDataSourceVrfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_object *LogicalRouterDataSourceVrfAdministrativeDistancesObject
	if obj.AdminDists != nil {
		administrativeDistances_object = new(LogicalRouterDataSourceVrfAdministrativeDistancesObject)
		diags.Append(administrativeDistances_object.CopyFromPango(ctx, append(ancestors, o), obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_object *LogicalRouterDataSourceVrfRibFilterObject
	if obj.RibFilter != nil {
		ribFilter_object = new(LogicalRouterDataSourceVrfRibFilterObject)
		diags.Append(ribFilter_object.CopyFromPango(ctx, append(ancestors, o), obj.RibFilter, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterDataSourceVrfBgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterDataSourceVrfBgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *LogicalRouterDataSourceVrfRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(LogicalRouterDataSourceVrfRoutingTableObject)
		diags.Append(routingTable_object.CopyFromPango(ctx, append(ancestors, o), obj.RoutingTable, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *LogicalRouterDataSourceVrfOspfObject
	if obj.Ospf != nil {
		ospf_object = new(LogicalRouterDataSourceVrfOspfObject)
		diags.Append(ospf_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *LogicalRouterDataSourceVrfOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(LogicalRouterDataSourceVrfOspfv3Object)
		diags.Append(ospfv3_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_object *LogicalRouterDataSourceVrfEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(LogicalRouterDataSourceVrfEcmpObject)
		diags.Append(ecmp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *LogicalRouterDataSourceVrfMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(LogicalRouterDataSourceVrfMulticastObject)
		diags.Append(multicast_object.CopyFromPango(ctx, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *LogicalRouterDataSourceVrfRipObject
	if obj.Rip != nil {
		rip_object = new(LogicalRouterDataSourceVrfRipObject)
		diags.Append(rip_object.CopyFromPango(ctx, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_list
	o.AdministrativeDistances = administrativeDistances_object
	o.RibFilter = ribFilter_object
	o.Bgp = bgp_object
	o.RoutingTable = routingTable_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Ecmp = ecmp_object
	o.Multicast = multicast_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ospfInter_value types.Int64
	if obj.OspfInter != nil {
		ospfInter_value = types.Int64Value(*obj.OspfInter)
	}
	var ospfIntra_value types.Int64
	if obj.OspfIntra != nil {
		ospfIntra_value = types.Int64Value(*obj.OspfIntra)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Inter_value types.Int64
	if obj.Ospfv3Inter != nil {
		ospfv3Inter_value = types.Int64Value(*obj.Ospfv3Inter)
	}
	var ospfv3Intra_value types.Int64
	if obj.Ospfv3Intra != nil {
		ospfv3Intra_value = types.Int64Value(*obj.Ospfv3Intra)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var bgpInternal_value types.Int64
	if obj.BgpInternal != nil {
		bgpInternal_value = types.Int64Value(*obj.BgpInternal)
	}
	var bgpExternal_value types.Int64
	if obj.BgpExternal != nil {
		bgpExternal_value = types.Int64Value(*obj.BgpExternal)
	}
	var bgpLocal_value types.Int64
	if obj.BgpLocal != nil {
		bgpLocal_value = types.Int64Value(*obj.BgpLocal)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value
	o.OspfInter = ospfInter_value
	o.OspfIntra = ospfIntra_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Inter = ospfv3Inter_value
	o.Ospfv3Intra = ospfv3Intra_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.BgpInternal = bgpInternal_value
	o.BgpExternal = bgpExternal_value
	o.BgpLocal = bgpLocal_value
	o.Rip = rip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterDataSourceVrfRibFilterIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterDataSourceVrfRibFilterIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterDataSourceVrfRibFilterIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterDataSourceVrfRibFilterIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_object *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject
	if obj.Static != nil {
		static_object = new(LogicalRouterDataSourceVrfRibFilterIpv4StaticObject)
		diags.Append(static_object.CopyFromPango(ctx, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterDataSourceVrfRibFilterIpv4BgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject
	if obj.Ospf != nil {
		ospf_object = new(LogicalRouterDataSourceVrfRibFilterIpv4OspfObject)
		diags.Append(ospf_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *LogicalRouterDataSourceVrfRibFilterIpv4RipObject
	if obj.Rip != nil {
		rip_object = new(LogicalRouterDataSourceVrfRibFilterIpv4RipObject)
		diags.Append(rip_object.CopyFromPango(ctx, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_object *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject
	if obj.Static != nil {
		static_object = new(LogicalRouterDataSourceVrfRibFilterIpv6StaticObject)
		diags.Append(static_object.CopyFromPango(ctx, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterDataSourceVrfRibFilterIpv6BgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object)
		diags.Append(ospfv3_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupObject
		for _, elt := range obj.PeerGroup {
			entry := LogicalRouterDataSourceVrfBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRoutes_list types.List
	{
		var aggregateRoutes_tf_entries []LogicalRouterDataSourceVrfBgpAggregateRoutesObject
		for _, elt := range obj.AggregateRoutes {
			entry := LogicalRouterDataSourceVrfBgpAggregateRoutesObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_tf_entries = append(aggregateRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("aggregate_routes")
		aggregateRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, aggregateRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	var med_object *LogicalRouterDataSourceVrfBgpMedObject
	if obj.Med != nil {
		med_object = new(LogicalRouterDataSourceVrfBgpMedObject)
		diags.Append(med_object.CopyFromPango(ctx, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterDataSourceVrfBgpGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterDataSourceVrfBgpGracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *LogicalRouterDataSourceVrfBgpGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterDataSourceVrfBgpGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_object *LogicalRouterDataSourceVrfBgpRedistributionProfileObject
	if obj.RedistributionProfile != nil {
		redistributionProfile_object = new(LogicalRouterDataSourceVrfBgpRedistributionProfileObject)
		diags.Append(redistributionProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.RedistributionProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject
	if obj.AdvertiseNetwork != nil {
		advertiseNetwork_object = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject)
		diags.Append(advertiseNetwork_object.CopyFromPango(ctx, append(ancestors, o), obj.AdvertiseNetwork, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var fastExternalFailover_value types.Bool
	if obj.FastExternalFailover != nil {
		fastExternalFailover_value = types.BoolValue(*obj.FastExternalFailover)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var gracefulShutdown_value types.Bool
	if obj.GracefulShutdown != nil {
		gracefulShutdown_value = types.BoolValue(*obj.GracefulShutdown)
	}
	var alwaysAdvertiseNetworkRoute_value types.Bool
	if obj.AlwaysAdvertiseNetworkRoute != nil {
		alwaysAdvertiseNetworkRoute_value = types.BoolValue(*obj.AlwaysAdvertiseNetworkRoute)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.LocalAs = localAs_value
	o.InstallRoute = installRoute_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.FastExternalFailover = fastExternalFailover_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulShutdown = gracefulShutdown_value
	o.AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	o.Med = med_object
	o.GracefulRestart = gracefulRestart_object
	o.GlobalBfd = globalBfd_object
	o.RedistributionProfile = redistributionProfile_object
	o.AdvertiseNetwork = advertiseNetwork_object
	o.PeerGroup = peerGroup_list
	o.AggregateRoutes = aggregateRoutes_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpMedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	o.Enable = enable_value
	o.StaleRouteTime = staleRouteTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.LocalRestartTime = localRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject
		for _, elt := range obj.Network {
			entry := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			network_tf_entries = append(network_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	var backdoor_value types.Bool
	if obj.Backdoor != nil {
		backdoor_value = types.BoolValue(*obj.Backdoor)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value
	o.Multicast = multicast_value
	o.Backdoor = backdoor_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject
		for _, elt := range obj.Network {
			entry := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			network_tf_entries = append(network_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterDataSourceVrfBgpPeerGroupPeerObject
		for _, elt := range obj.Peer {
			entry := LogicalRouterDataSourceVrfBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_object *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject
	if obj.AddressFamily != nil {
		addressFamily_object = new(LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject)
		diags.Append(addressFamily_object.CopyFromPango(ctx, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_object *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject
	if obj.FilteringProfile != nil {
		filteringProfile_object = new(LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject)
		diags.Append(filteringProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject)
		diags.Append(connectionOptions_object.CopyFromPango(ctx, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Type = type_object
	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object
	o.ConnectionOptions = connectionOptions_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_object *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject
	if obj.Ibgp != nil {
		ibgp_object = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject)
		diags.Append(ibgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_object *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject
	if obj.Ebgp != nil {
		ebgp_object = new(LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject)
		diags.Append(ebgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var inherit_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject
	if obj.Inherit != nil {
		inherit_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject)
		diags.Append(inherit_object.CopyFromPango(ctx, append(ancestors, o), obj.Inherit, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject)
		diags.Append(localAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject)
		diags.Append(peerAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject)
		diags.Append(connectionOptions_object.CopyFromPango(ctx, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.PeerAs = peerAs_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.Inherit = inherit_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject
	if obj.Yes != nil {
		yes_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject)
		diags.Append(yes_object.CopyFromPango(ctx, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject
	if obj.No != nil {
		no_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject)
		diags.Append(no_object.CopyFromPango(ctx, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Yes = yes_object
	o.No = no_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
	if obj.AddressFamily != nil {
		addressFamily_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject)
		diags.Append(addressFamily_object.CopyFromPango(ctx, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_object *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	if obj.FilteringProfile != nil {
		filteringProfile_object = new(LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject)
		diags.Append(filteringProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.String
	if obj.Multihop != nil {
		multihop_value = types.StringValue(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summaryOnly_value types.Bool
	if obj.SummaryOnly != nil {
		summaryOnly_value = types.BoolValue(*obj.SummaryOnly)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	var sameMed_value types.Bool
	if obj.SameMed != nil {
		sameMed_value = types.BoolValue(*obj.SameMed)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Enable = enable_value
	o.SummaryOnly = summaryOnly_value
	o.AsSet = asSet_value
	o.SameMed = sameMed_value
	o.Type = type_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *LogicalRouterDataSourceVrfRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(LogicalRouterDataSourceVrfRoutingTableIpObject)
		diags.Append(ip_object.CopyFromPango(ctx, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterDataSourceVrfRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterDataSourceVrfRoutingTableIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject)
		diags.Append(pathMonitor_object.CopyFromPango(ctx, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_object *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject)
		diags.Append(discard_object.CopyFromPango(ctx, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.NextLr = nextLr_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			entry := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject)
		diags.Append(pathMonitor_object.CopyFromPango(ctx, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_object *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject)
		diags.Append(discard_object.CopyFromPango(ctx, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextLr = nextLr_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			entry := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterDataSourceVrfOspfAreaObject
		for _, elt := range obj.Area {
			entry := LogicalRouterDataSourceVrfOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterDataSourceVrfOspfGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterDataSourceVrfOspfGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterDataSourceVrfOspfGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterDataSourceVrfOspfGracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.RouterId = routerId_value
	o.Enable = enable_value
	o.Rfc1583 = rfc1583_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterDataSourceVrfOspfAreaRangeObject
		for _, elt := range obj.Range {
			entry := LogicalRouterDataSourceVrfOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			entry := LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterDataSourceVrfOspfAreaTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterDataSourceVrfOspfAreaTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(LogicalRouterDataSourceVrfOspfAreaTypeNormalObject)
		diags.Append(normal_object.CopyFromPango(ctx, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *LogicalRouterDataSourceVrfOspfAreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(LogicalRouterDataSourceVrfOspfAreaTypeStubObject)
		diags.Append(stub_object.CopyFromPango(ctx, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaObject)
		diags.Append(nssa_object.CopyFromPango(ctx, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultInformationOriginate_object *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_object = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject)
		diags.Append(defaultInformationOriginate_object.CopyFromPango(ctx, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_object *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			entry := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var linkType_object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject)
		diags.Append(linkType_object.CopyFromPango(ctx, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject)
		diags.Append(broadcast_object.CopyFromPango(ctx, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject)
		diags.Append(p2p_object.CopyFromPango(ctx, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject)
		diags.Append(p2mp_object.CopyFromPango(ctx, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
		for _, elt := range obj.Neighbor {
			entry := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaObject
		for _, elt := range obj.Area {
			entry := LogicalRouterDataSourceVrfOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterDataSourceVrfOspfv3GlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterDataSourceVrfOspfv3GracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaRangeObject
		for _, elt := range obj.Range {
			entry := LogicalRouterDataSourceVrfOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			entry := LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterDataSourceVrfOspfv3AreaTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject)
		diags.Append(normal_object.CopyFromPango(ctx, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject)
		diags.Append(stub_object.CopyFromPango(ctx, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject)
		diags.Append(nssa_object.CopyFromPango(ctx, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultInformationOriginate_object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject)
		diags.Append(defaultInformationOriginate_object.CopyFromPango(ctx, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_object *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			entry := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var linkType_object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject)
		diags.Append(linkType_object.CopyFromPango(ctx, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.InstanceId = instanceId_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject)
		diags.Append(broadcast_object.CopyFromPango(ctx, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject)
		diags.Append(p2p_object.CopyFromPango(ctx, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject)
		diags.Append(p2mp_object.CopyFromPango(ctx, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
		for _, elt := range obj.Neighbor {
			entry := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *LogicalRouterDataSourceVrfEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(LogicalRouterDataSourceVrfEcmpAlgorithmObject)
		diags.Append(algorithm_object.CopyFromPango(ctx, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_object *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject)
		diags.Append(ipModulo_object.CopyFromPango(ctx, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject)
		diags.Append(ipHash_object.CopyFromPango(ctx, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_object *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject)
		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_object *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject)
		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object
	o.WeightedRoundRobin = weightedRoundRobin_object
	o.BalancedRoundRobin = balancedRoundRobin_object

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterDataSourceVrfMulticastStaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterDataSourceVrfMulticastStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}
	var pim_object *LogicalRouterDataSourceVrfMulticastPimObject
	if obj.Pim != nil {
		pim_object = new(LogicalRouterDataSourceVrfMulticastPimObject)
		diags.Append(pim_object.CopyFromPango(ctx, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_object *LogicalRouterDataSourceVrfMulticastIgmpObject
	if obj.Igmp != nil {
		igmp_object = new(LogicalRouterDataSourceVrfMulticastIgmpObject)
		diags.Append(igmp_object.CopyFromPango(ctx, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_object *LogicalRouterDataSourceVrfMulticastMsdpObject
	if obj.Msdp != nil {
		msdp_object = new(LogicalRouterDataSourceVrfMulticastMsdpObject)
		diags.Append(msdp_object.CopyFromPango(ctx, append(ancestors, o), obj.Msdp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.StaticRoute = staticRoute_list
	o.Pim = pim_object
	o.Igmp = igmp_object
	o.Msdp = msdp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var preference_value types.Int64
	if obj.Preference != nil {
		preference_value = types.Int64Value(*obj.Preference)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.Preference = preference_value
	o.Nexthop = nexthop_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.IpAddress = ipAddress_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []LogicalRouterDataSourceVrfMulticastPimSptThresholdObject
		for _, elt := range obj.SptThreshold {
			entry := LogicalRouterDataSourceVrfMulticastPimSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfMulticastPimInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfMulticastPimInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var ssmAddressSpace_object *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject
	if obj.SsmAddressSpace != nil {
		ssmAddressSpace_object = new(LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject)
		diags.Append(ssmAddressSpace_object.CopyFromPango(ctx, append(ancestors, o), obj.SsmAddressSpace, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_object *LogicalRouterDataSourceVrfMulticastPimRpObject
	if obj.Rp != nil {
		rp_object = new(LogicalRouterDataSourceVrfMulticastPimRpObject)
		diags.Append(rp_object.CopyFromPango(ctx, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rpfLookupMode_value types.String
	if obj.RpfLookupMode != nil {
		rpfLookupMode_value = types.StringValue(*obj.RpfLookupMode)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	var ifTimerGlobal_value types.String
	if obj.IfTimerGlobal != nil {
		ifTimerGlobal_value = types.StringValue(*obj.IfTimerGlobal)
	}
	var groupPermission_value types.String
	if obj.GroupPermission != nil {
		groupPermission_value = types.StringValue(*obj.GroupPermission)
	}
	o.Enable = enable_value
	o.RpfLookupMode = rpfLookupMode_value
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.IfTimerGlobal = ifTimerGlobal_value
	o.GroupPermission = groupPermission_value
	o.SsmAddressSpace = ssmAddressSpace_object
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject
		for _, elt := range obj.ExternalRp {
			entry := LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_tf_entries = append(externalRp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}
	var localRp_object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject
	if obj.LocalRp != nil {
		localRp_object = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject)
		diags.Append(localRp_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.LocalRp = localRp_object
	o.ExternalRp = externalRp_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject
	if obj.StaticRp != nil {
		staticRp_object = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject)
		diags.Append(staticRp_object.CopyFromPango(ctx, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_object *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject
	if obj.CandidateRp != nil {
		candidateRp_object = new(LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject)
		diags.Append(candidateRp_object.CopyFromPango(ctx, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.StaticRp = staticRp_object
	o.CandidateRp = candidateRp_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Override = override_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Priority = priority_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupList = groupList_value
	o.Override = override_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var sendBsm_value types.Bool
	if obj.SendBsm != nil {
		sendBsm_value = types.BoolValue(*obj.SendBsm)
	}
	var ifTimer_value types.String
	if obj.IfTimer != nil {
		ifTimer_value = types.StringValue(*obj.IfTimer)
	}
	var neighborFilter_value types.String
	if obj.NeighborFilter != nil {
		neighborFilter_value = types.StringValue(*obj.NeighborFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.DrPriority = drPriority_value
	o.SendBsm = sendBsm_value
	o.IfTimer = ifTimer_value
	o.NeighborFilter = neighborFilter_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_list types.List
	{
		var static_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpStaticObject
		for _, elt := range obj.Static {
			entry := LogicalRouterDataSourceVrfMulticastIgmpStaticObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			static_tf_entries = append(static_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static")
		static_list, list_diags = types.ListValueFrom(ctx, schemaType, static_tf_entries)
		diags.Append(list_diags...)
	}
	var dynamic_object *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(LogicalRouterDataSourceVrfMulticastIgmpDynamicObject)
		diags.Append(dynamic_object.CopyFromPango(ctx, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Dynamic = dynamic_object
	o.Static = static_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var groupFilter_value types.String
	if obj.GroupFilter != nil {
		groupFilter_value = types.StringValue(*obj.GroupFilter)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var queryProfile_value types.String
	if obj.QueryProfile != nil {
		queryProfile_value = types.StringValue(*obj.QueryProfile)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Version = version_value
	o.Robustness = robustness_value
	o.GroupFilter = groupFilter_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.QueryProfile = queryProfile_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterDataSourceVrfMulticastMsdpPeerObject
		for _, elt := range obj.Peer {
			entry := LogicalRouterDataSourceVrfMulticastMsdpPeerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var originatorId_object *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject
	if obj.OriginatorId != nil {
		originatorId_object = new(LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject)
		diags.Append(originatorId_object.CopyFromPango(ctx, append(ancestors, o), obj.OriginatorId, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var globalAuthentication_value types.String
	if obj.GlobalAuthentication != nil {
		globalAuthentication_value = types.StringValue(*obj.GlobalAuthentication)
	}
	o.Enable = enable_value
	o.GlobalTimer = globalTimer_value
	o.GlobalAuthentication = globalAuthentication_value
	o.OriginatorId = originatorId_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_object *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject)
		diags.Append(localAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject)
		diags.Append(peerAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var maxSa_value types.Int64
	if obj.MaxSa != nil {
		maxSa_value = types.Int64Value(*obj.MaxSa)
	}
	var inboundSaFilter_value types.String
	if obj.InboundSaFilter != nil {
		inboundSaFilter_value = types.StringValue(*obj.InboundSaFilter)
	}
	var outboundSaFilter_value types.String
	if obj.OutboundSaFilter != nil {
		outboundSaFilter_value = types.StringValue(*obj.OutboundSaFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.Authentication = authentication_value
	o.MaxSa = maxSa_value
	o.InboundSaFilter = inboundSaFilter_value
	o.OutboundSaFilter = outboundSaFilter_value
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []LogicalRouterDataSourceVrfRipInterfacesObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterDataSourceVrfRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterDataSourceVrfRipGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterDataSourceVrfRipGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_object *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject
	if obj.GlobalInboundDistributeList != nil {
		globalInboundDistributeList_object = new(LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject)
		diags.Append(globalInboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_object *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject
	if obj.GlobalOutboundDistributeList != nil {
		globalOutboundDistributeList_object = new(LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject)
		diags.Append(globalOutboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var defaultInformationOriginate_value types.Bool
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_value = types.BoolValue(*obj.DefaultInformationOriginate)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var authProfile_value types.String
	if obj.AuthProfile != nil {
		authProfile_value = types.StringValue(*obj.AuthProfile)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.DefaultInformationOriginate = defaultInformationOriginate_value
	o.GlobalTimer = globalTimer_value
	o.AuthProfile = authProfile_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GlobalInboundDistributeList = globalInboundDistributeList_object
	o.GlobalOutboundDistributeList = globalOutboundDistributeList_object
	o.Interfaces = interfaces_list

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *LogicalRouterDataSourceVrfRipInterfacesBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterDataSourceVrfRipInterfacesBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_object *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject
	if obj.InterfaceInboundDistributeList != nil {
		interfaceInboundDistributeList_object = new(LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject)
		diags.Append(interfaceInboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.InterfaceInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_object *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	if obj.InterfaceOutboundDistributeList != nil {
		interfaceOutboundDistributeList_object = new(LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject)
		diags.Append(interfaceOutboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.InterfaceOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var splitHorizon_value types.String
	if obj.SplitHorizon != nil {
		splitHorizon_value = types.StringValue(*obj.SplitHorizon)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Mode = mode_value
	o.SplitHorizon = splitHorizon_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.InterfaceInboundDistributeList = interfaceInboundDistributeList_object
	o.InterfaceOutboundDistributeList = interfaceOutboundDistributeList_object

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func LogicalRouterDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": LogicalRouterDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vrf": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceModel) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"administrative_distances": LogicalRouterDataSourceVrfAdministrativeDistancesSchema(),

			"rib_filter": LogicalRouterDataSourceVrfRibFilterSchema(),

			"bgp": LogicalRouterDataSourceVrfBgpSchema(),

			"routing_table": LogicalRouterDataSourceVrfRoutingTableSchema(),

			"ospf": LogicalRouterDataSourceVrfOspfSchema(),

			"ospfv3": LogicalRouterDataSourceVrfOspfv3Schema(),

			"ecmp": LogicalRouterDataSourceVrfEcmpSchema(),

			"multicast": LogicalRouterDataSourceVrfMulticastSchema(),

			"rip": LogicalRouterDataSourceVrfRipSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfAdministrativeDistancesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": dsschema.Int64Attribute{
				Description: "Set IPv4 Static Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": dsschema.Int64Attribute{
				Description: "Set IPv6 Static Routes  Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_inter": dsschema.Int64Attribute{
				Description: "Set OSPF Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_intra": dsschema.Int64Attribute{
				Description: "Set OSPF Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": dsschema.Int64Attribute{
				Description: "Set OSPF External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_inter": dsschema.Int64Attribute{
				Description: "Set OSPFv3 Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_intra": dsschema.Int64Attribute{
				Description: "Set OSPFv3 Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": dsschema.Int64Attribute{
				Description: "Set OSPFv3 External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_internal": dsschema.Int64Attribute{
				Description: "Set BGP AS Internal Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_external": dsschema.Int64Attribute{
				Description: "Set BGP AS External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bgp_local": dsschema.Int64Attribute{
				Description: "Set BGP Local Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": dsschema.Int64Attribute{
				Description: "Set RIP Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfRibFilterIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfRibFilterIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema(),

			"bgp": LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema(),

			"ospf": LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema(),

			"rip": LogicalRouterDataSourceVrfRibFilterIpv4RipSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on OSPF Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4OspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4OspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv4RipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on RIP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv4RipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv4RipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static": LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema(),

			"bgp": LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema(),

			"ospfv3": LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_map": dsschema.StringAttribute{
				Description: "Apply Route-Map on OSPFv3 Routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRibFilterIpv6Ospfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": dsschema.StringAttribute{
				Description: "local AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"install_route": dsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": dsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_external_failover": dsschema.BoolAttribute{
				Description: "Immediately reset session if a link to a directly connected external peer goes down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ecmp_multi_as": dsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": dsschema.Int64Attribute{
				Description: "Global Default Local Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"graceful_shutdown": dsschema.BoolAttribute{
				Description: "Gracefully Shutdown BGP following RFC-8326",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"always_advertise_network_route": dsschema.BoolAttribute{
				Description: "Always advertise network routes even if not present in RIB",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": LogicalRouterDataSourceVrfBgpMedSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfBgpGracefulRestartSchema(),

			"global_bfd": LogicalRouterDataSourceVrfBgpGlobalBfdSchema(),

			"redistribution_profile": LogicalRouterDataSourceVrfBgpRedistributionProfileSchema(),

			"advertise_network": LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema(),

			"peer_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpPeerGroupSchema(),
			},

			"aggregate_routes": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAggregateRoutesSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpMedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"always_compare_med": dsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": dsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpMedObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": dsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_peer_restart_time": dsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": dsschema.Int64Attribute{
				Description: "local restart time to advertise to peer Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpRedistributionProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"network": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": dsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": dsschema.BoolAttribute{
				Description: "Multicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"backdoor": dsschema.BoolAttribute{
				Description: "Mark network as backdoor route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv4NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"network": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": dsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAdvertiseNetworkIpv6NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema(),

			"address_family": LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema(),

			"filtering_profile": LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema(),

			"connection_options": LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ibgp": LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema(),

			"ebgp": LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"timers": dsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.Int64Attribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": dsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "If enabled, open messages are not sent to this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherit": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema(),

			"local_address": LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"yes": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema(),

			"no": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"address_family": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema(),

			"filtering_profile": LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": dsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": dsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"timers": dsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.StringAttribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": dsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "Describe Aggregate Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable Aggregation for this Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary_only": dsschema.BoolAttribute{
				Description: "Send only Summary Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": dsschema.BoolAttribute{
				Description: "Generate AS set path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"same_med": dsschema.BoolAttribute{
				Description: "Aggregate Routes only if they have same MED Attributes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ipv4": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema(),

			"ipv6": LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"summary_prefix": dsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"summary_prefix": dsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": dsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfBgpAggregateRoutesTypeIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": LogicalRouterDataSourceVrfRoutingTableIpSchema(),

			"ipv6": LogicalRouterDataSourceVrfRoutingTableIpv6Schema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema(),

			"bfd": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"discard": LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema(),

			"ip_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": dsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("next_lr"),
				path.MatchRelative().AtParent().AtName("fqdn"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema(),

			"bfd": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema(),

			"path_monitor": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"discard": LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": dsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_lr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": dsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": dsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": dsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfOspfGlobalBfdSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfOspfGracefulRestartSchema(),

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfOspfAreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema(),

			"stub": LogicalRouterDataSourceVrfOspfAreaTypeStubSchema(),

			"nssa": LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema(),

			"default_route_metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric_type": dsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": dsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPF instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_transit_traffic": dsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": dsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": dsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema(),

			"graceful_restart": LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema(),

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterDataSourceVrfOspfv3AreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema(),

			"stub": LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema(),

			"nssa": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema(),

			"default_route_metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"no_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric_type": dsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"import_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": dsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": dsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": dsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": dsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": dsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": dsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": dsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": dsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": dsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": LogicalRouterDataSourceVrfEcmpAlgorithmSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_modulo": LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema(),

			"ip_hash": LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema(),

			"weighted_round_robin": LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"src_only": dsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": dsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": dsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastStaticRouteSchema(),
			},

			"pim": LogicalRouterDataSourceVrfMulticastPimSchema(),

			"igmp": LogicalRouterDataSourceVrfMulticastIgmpSchema(),

			"msdp": LogicalRouterDataSourceVrfMulticastMsdpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastStaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preference": dsschema.Int64Attribute{
				Description: "administrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rpf_lookup_mode": dsschema.StringAttribute{
				Description: "RPF Lookup Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_ageout_time": dsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer_global": dsschema.StringAttribute{
				Description: "Global Interface Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_permission": dsschema.StringAttribute{
				Description: "ASM/SSM group permission",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssm_address_space": LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema(),

			"rp": LogicalRouterDataSourceVrfMulticastPimRpSchema(),

			"spt_threshold": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"group_list": dsschema.StringAttribute{
				Description: "SSM Group Prefix List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema(),

			"external_rp": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema(),

			"candidate_rp": LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "local RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": dsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_list": dsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastPimInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": dsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_bsm": dsschema.BoolAttribute{
				Description: "Send BSM",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer": dsschema.StringAttribute{
				Description: "Interface Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_filter": dsschema.StringAttribute{
				Description: "Set the filter for neighbor list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastPimInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastPimInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dynamic": LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema(),

			"static": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastIgmpStaticSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"version": dsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": dsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_filter": dsschema.StringAttribute{
				Description: "ASM/SSM Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_groups": dsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sources": dsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"query_profile": dsschema.StringAttribute{
				Description: "IGMP Query Timer Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": dsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpDynamicInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastIgmpStaticSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "multicast interfaces",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": dsschema.StringAttribute{
				Description: "source-address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastIgmpStaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastIgmpStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": dsschema.StringAttribute{
				Description: "Global timer profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_authentication": dsschema.StringAttribute{
				Description: "Global authentication profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfMulticastMsdpPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface of originator",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpOriginatorIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sa": dsschema.Int64Attribute{
				Description: "Maximum number of SA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_sa_filter": dsschema.StringAttribute{
				Description: "Inbound SA Filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_sa_filter": dsschema.StringAttribute{
				Description: "Outbound SA Filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema(),

			"peer_address": LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface to accept MSDP connection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfMulticastMsdpPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": dsschema.BoolAttribute{
				Description: "advertise default route in RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": dsschema.StringAttribute{
				Description: "timer setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.StringAttribute{
				Description: "Authentication profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": dsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterDataSourceVrfRipGlobalBfdSchema(),

			"global_inbound_distribute_list": LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema(),

			"global_outbound_distribute_list": LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema(),

			"interfaces": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: LogicalRouterDataSourceVrfRipInterfacesSchema(),
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipGlobalOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable RIP on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"split_horizon": dsschema.StringAttribute{
				Description: "Split horizon options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterDataSourceVrfRipInterfacesBfdSchema(),

			"interface_inbound_distribute_list": LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema(),

			"interface_outbound_distribute_list": LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema(),
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesInterfaceInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_list": dsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterDataSourceVrfRipInterfacesInterfaceOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterDataSourceLocationSchema() rsschema.Attribute {
	return LogicalRouterLocationSchema()
}

// Metadata returns the data source type name.
func (d *LogicalRouterDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_logical_router"
}

// Schema defines the schema for this data source.
func (d *LogicalRouterDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = LogicalRouterDataSourceSchema()
}

// Configure prepares the struct.
func (d *LogicalRouterDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := logical_router.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service](d.client, logical_router.NewService(d.client), batchSize, specifier, logical_router.SpecMatches)
}
func (o *LogicalRouterDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state LogicalRouterDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &LogicalRouterResource{}
	_ resource.ResourceWithConfigure   = &LogicalRouterResource{}
	_ resource.ResourceWithImportState = &LogicalRouterResource{}
)

func NewLogicalRouterResource() resource.Resource {
	if _, found := resourceFuncMap["panos_logical_router"]; !found {
		resourceFuncMap["panos_logical_router"] = resourceFuncs{
			CreateImportId: LogicalRouterImportStateCreator,
		}
	}
	return &LogicalRouterResource{}
}

type LogicalRouterResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service]
}

func LogicalRouterResourceLocationSchema() rsschema.Attribute {
	return LogicalRouterLocationSchema()
}

type LogicalRouterResourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Vrf      types.List   `tfsdk:"vrf"`
}
type LogicalRouterResourceVrfObject struct {
	Name                    types.String                                           `tfsdk:"name"`
	Interface               types.List                                             `tfsdk:"interface"`
	AdministrativeDistances *LogicalRouterResourceVrfAdministrativeDistancesObject `tfsdk:"administrative_distances"`
	RibFilter               *LogicalRouterResourceVrfRibFilterObject               `tfsdk:"rib_filter"`
	Bgp                     *LogicalRouterResourceVrfBgpObject                     `tfsdk:"bgp"`
	RoutingTable            *LogicalRouterResourceVrfRoutingTableObject            `tfsdk:"routing_table"`
	Ospf                    *LogicalRouterResourceVrfOspfObject                    `tfsdk:"ospf"`
	Ospfv3                  *LogicalRouterResourceVrfOspfv3Object                  `tfsdk:"ospfv3"`
	Ecmp                    *LogicalRouterResourceVrfEcmpObject                    `tfsdk:"ecmp"`
	Multicast               *LogicalRouterResourceVrfMulticastObject               `tfsdk:"multicast"`
	Rip                     *LogicalRouterResourceVrfRipObject                     `tfsdk:"rip"`
}
type LogicalRouterResourceVrfAdministrativeDistancesObject struct {
	Static      types.Int64 `tfsdk:"static"`
	StaticIpv6  types.Int64 `tfsdk:"static_ipv6"`
	OspfInter   types.Int64 `tfsdk:"ospf_inter"`
	OspfIntra   types.Int64 `tfsdk:"ospf_intra"`
	OspfExt     types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Inter types.Int64 `tfsdk:"ospfv3_inter"`
	Ospfv3Intra types.Int64 `tfsdk:"ospfv3_intra"`
	Ospfv3Ext   types.Int64 `tfsdk:"ospfv3_ext"`
	BgpInternal types.Int64 `tfsdk:"bgp_internal"`
	BgpExternal types.Int64 `tfsdk:"bgp_external"`
	BgpLocal    types.Int64 `tfsdk:"bgp_local"`
	Rip         types.Int64 `tfsdk:"rip"`
}
type LogicalRouterResourceVrfRibFilterObject struct {
	Ipv4 *LogicalRouterResourceVrfRibFilterIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterResourceVrfRibFilterIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfRibFilterIpv4Object struct {
	Static *LogicalRouterResourceVrfRibFilterIpv4StaticObject `tfsdk:"static"`
	Bgp    *LogicalRouterResourceVrfRibFilterIpv4BgpObject    `tfsdk:"bgp"`
	Ospf   *LogicalRouterResourceVrfRibFilterIpv4OspfObject   `tfsdk:"ospf"`
	Rip    *LogicalRouterResourceVrfRibFilterIpv4RipObject    `tfsdk:"rip"`
}
type LogicalRouterResourceVrfRibFilterIpv4StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4OspfObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv4RipObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6Object struct {
	Static *LogicalRouterResourceVrfRibFilterIpv6StaticObject `tfsdk:"static"`
	Bgp    *LogicalRouterResourceVrfRibFilterIpv6BgpObject    `tfsdk:"bgp"`
	Ospfv3 *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object `tfsdk:"ospfv3"`
}
type LogicalRouterResourceVrfRibFilterIpv6StaticObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6BgpObject struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object struct {
	RouteMap types.String `tfsdk:"route_map"`
}
type LogicalRouterResourceVrfBgpObject struct {
	Enable                      types.Bool                                              `tfsdk:"enable"`
	RouterId                    types.String                                            `tfsdk:"router_id"`
	LocalAs                     types.String                                            `tfsdk:"local_as"`
	InstallRoute                types.Bool                                              `tfsdk:"install_route"`
	EnforceFirstAs              types.Bool                                              `tfsdk:"enforce_first_as"`
	FastExternalFailover        types.Bool                                              `tfsdk:"fast_external_failover"`
	EcmpMultiAs                 types.Bool                                              `tfsdk:"ecmp_multi_as"`
	DefaultLocalPreference      types.Int64                                             `tfsdk:"default_local_preference"`
	GracefulShutdown            types.Bool                                              `tfsdk:"graceful_shutdown"`
	AlwaysAdvertiseNetworkRoute types.Bool                                              `tfsdk:"always_advertise_network_route"`
	Med                         *LogicalRouterResourceVrfBgpMedObject                   `tfsdk:"med"`
	GracefulRestart             *LogicalRouterResourceVrfBgpGracefulRestartObject       `tfsdk:"graceful_restart"`
	GlobalBfd                   *LogicalRouterResourceVrfBgpGlobalBfdObject             `tfsdk:"global_bfd"`
	RedistributionProfile       *LogicalRouterResourceVrfBgpRedistributionProfileObject `tfsdk:"redistribution_profile"`
	AdvertiseNetwork            *LogicalRouterResourceVrfBgpAdvertiseNetworkObject      `tfsdk:"advertise_network"`
	PeerGroup                   types.List                                              `tfsdk:"peer_group"`
	AggregateRoutes             types.List                                              `tfsdk:"aggregate_routes"`
}
type LogicalRouterResourceVrfBgpMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type LogicalRouterResourceVrfBgpGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
}
type LogicalRouterResourceVrfBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileObject struct {
	Ipv4 *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object struct {
	Unicast types.String `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkObject struct {
	Ipv4 *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject struct {
	Name      types.String `tfsdk:"name"`
	Unicast   types.Bool   `tfsdk:"unicast"`
	Multicast types.Bool   `tfsdk:"multicast"`
	Backdoor  types.Bool   `tfsdk:"backdoor"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object struct {
	Network types.List `tfsdk:"network"`
}
type LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject struct {
	Name    types.String `tfsdk:"name"`
	Unicast types.Bool   `tfsdk:"unicast"`
}
type LogicalRouterResourceVrfBgpPeerGroupObject struct {
	Name              types.String                                                 `tfsdk:"name"`
	Enable            types.Bool                                                   `tfsdk:"enable"`
	Type              *LogicalRouterResourceVrfBgpPeerGroupTypeObject              `tfsdk:"type"`
	AddressFamily     *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject     `tfsdk:"address_family"`
	FilteringProfile  *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject  `tfsdk:"filtering_profile"`
	ConnectionOptions *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject `tfsdk:"connection_options"`
	Peer              types.List                                                   `tfsdk:"peer"`
}
type LogicalRouterResourceVrfBgpPeerGroupTypeObject struct {
	Ibgp *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject `tfsdk:"ibgp"`
	Ebgp *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject `tfsdk:"ebgp"`
}
type LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.Int64  `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerObject struct {
	Name                          types.String                                                     `tfsdk:"name"`
	Enable                        types.Bool                                                       `tfsdk:"enable"`
	Passive                       types.Bool                                                       `tfsdk:"passive"`
	PeerAs                        types.String                                                     `tfsdk:"peer_as"`
	EnableSenderSideLoopDetection types.Bool                                                       `tfsdk:"enable_sender_side_loop_detection"`
	Inherit                       *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject           `tfsdk:"inherit"`
	LocalAddress                  *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject      `tfsdk:"local_address"`
	PeerAddress                   *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject       `tfsdk:"peer_address"`
	ConnectionOptions             *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject `tfsdk:"connection_options"`
	Bfd                           *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject               `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject struct {
	Yes *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject `tfsdk:"yes"`
	No  *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject  `tfsdk:"no"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject struct {
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject struct {
	AddressFamily    *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject    `tfsdk:"address_family"`
	FilteringProfile *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject `tfsdk:"filtering_profile"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject struct {
	Ipv4 types.String `tfsdk:"ipv4"`
	Ipv6 types.String `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject struct {
	Timers         types.String `tfsdk:"timers"`
	Multihop       types.String `tfsdk:"multihop"`
	Authentication types.String `tfsdk:"authentication"`
	Dampening      types.String `tfsdk:"dampening"`
}
type LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesObject struct {
	Name        types.String                                          `tfsdk:"name"`
	Description types.String                                          `tfsdk:"description"`
	Enable      types.Bool                                            `tfsdk:"enable"`
	SummaryOnly types.Bool                                            `tfsdk:"summary_only"`
	AsSet       types.Bool                                            `tfsdk:"as_set"`
	SameMed     types.Bool                                            `tfsdk:"same_med"`
	Type        *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject `tfsdk:"type"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeObject struct {
	Ipv4 *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object `tfsdk:"ipv4"`
	Ipv6 *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object struct {
	SummaryPrefix types.String `tfsdk:"summary_prefix"`
	SuppressMap   types.String `tfsdk:"suppress_map"`
	AttributeMap  types.String `tfsdk:"attribute_map"`
}
type LogicalRouterResourceVrfRoutingTableObject struct {
	Ip   *LogicalRouterResourceVrfRoutingTableIpObject   `tfsdk:"ip"`
	Ipv6 *LogicalRouterResourceVrfRoutingTableIpv6Object `tfsdk:"ipv6"`
}
type LogicalRouterResourceVrfRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteObject struct {
	Name                   types.String                                                        `tfsdk:"name"`
	Destination            types.String                                                        `tfsdk:"destination"`
	Interface              types.String                                                        `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                         `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                         `tfsdk:"metric"`
	Nexthop                *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject     `tfsdk:"nexthop"`
	Bfd                    *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject `tfsdk:"path_monitor"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject struct {
	Discard   *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject `tfsdk:"discard"`
	IpAddress types.String                                                           `tfsdk:"ip_address"`
	NextLr    types.String                                                           `tfsdk:"next_lr"`
	Fqdn      types.String                                                           `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterResourceVrfRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String                                                          `tfsdk:"name"`
	Destination            types.String                                                          `tfsdk:"destination"`
	Interface              types.String                                                          `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                           `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                           `tfsdk:"metric"`
	Nexthop                *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject     `tfsdk:"nexthop"`
	Bfd                    *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject `tfsdk:"path_monitor"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject struct {
	Discard     *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject `tfsdk:"discard"`
	Ipv6Address types.String                                                             `tfsdk:"ipv6_address"`
	Fqdn        types.String                                                             `tfsdk:"fqdn"`
	NextLr      types.String                                                             `tfsdk:"next_lr"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type LogicalRouterResourceVrfOspfObject struct {
	RouterId              types.String                                       `tfsdk:"router_id"`
	Enable                types.Bool                                         `tfsdk:"enable"`
	Rfc1583               types.Bool                                         `tfsdk:"rfc1583"`
	SpfTimer              types.String                                       `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String                                       `tfsdk:"global_if_timer"`
	RedistributionProfile types.String                                       `tfsdk:"redistribution_profile"`
	GlobalBfd             *LogicalRouterResourceVrfOspfGlobalBfdObject       `tfsdk:"global_bfd"`
	GracefulRestart       *LogicalRouterResourceVrfOspfGracefulRestartObject `tfsdk:"graceful_restart"`
	Area                  types.List                                         `tfsdk:"area"`
}
type LogicalRouterResourceVrfOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterResourceVrfOspfAreaObject struct {
	Name           types.String                                `tfsdk:"name"`
	Authentication types.String                                `tfsdk:"authentication"`
	Type           *LogicalRouterResourceVrfOspfAreaTypeObject `tfsdk:"type"`
	Range          types.List                                  `tfsdk:"range"`
	Interface      types.List                                  `tfsdk:"interface"`
	VirtualLink    types.List                                  `tfsdk:"virtual_link"`
}
type LogicalRouterResourceVrfOspfAreaTypeObject struct {
	Normal *LogicalRouterResourceVrfOspfAreaTypeNormalObject `tfsdk:"normal"`
	Stub   *LogicalRouterResourceVrfOspfAreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *LogicalRouterResourceVrfOspfAreaTypeNssaObject   `tfsdk:"nssa"`
}
type LogicalRouterResourceVrfOspfAreaTypeNormalObject struct {
	Abr *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfAreaTypeStubObject struct {
	NoSummary          types.Bool                                         `tfsdk:"no_summary"`
	Abr                *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject `tfsdk:"abr"`
	DefaultRouteMetric types.Int64                                        `tfsdk:"default_route_metric"`
}
type LogicalRouterResourceVrfOspfAreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaObject struct {
	NoSummary                   types.Bool                                                                 `tfsdk:"no_summary"`
	DefaultInformationOriginate *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject `tfsdk:"default_information_originate"`
	Abr                         *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject                         `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceObject struct {
	Name           types.String                                             `tfsdk:"name"`
	Enable         types.Bool                                               `tfsdk:"enable"`
	MtuIgnore      types.Bool                                               `tfsdk:"mtu_ignore"`
	Passive        types.Bool                                               `tfsdk:"passive"`
	Priority       types.Int64                                              `tfsdk:"priority"`
	Metric         types.Int64                                              `tfsdk:"metric"`
	Authentication types.String                                             `tfsdk:"authentication"`
	Timing         types.String                                             `tfsdk:"timing"`
	LinkType       *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Bfd            *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject struct {
	Broadcast *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterResourceVrfOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfAreaVirtualLinkObject struct {
	Name           types.String                                          `tfsdk:"name"`
	NeighborId     types.String                                          `tfsdk:"neighbor_id"`
	TransitAreaId  types.String                                          `tfsdk:"transit_area_id"`
	Enable         types.Bool                                            `tfsdk:"enable"`
	InstanceId     types.Int64                                           `tfsdk:"instance_id"`
	Timing         types.String                                          `tfsdk:"timing"`
	Authentication types.String                                          `tfsdk:"authentication"`
	Bfd            *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3Object struct {
	Enable                types.Bool                                           `tfsdk:"enable"`
	RouterId              types.String                                         `tfsdk:"router_id"`
	DisableTransitTraffic types.Bool                                           `tfsdk:"disable_transit_traffic"`
	SpfTimer              types.String                                         `tfsdk:"spf_timer"`
	GlobalIfTimer         types.String                                         `tfsdk:"global_if_timer"`
	RedistributionProfile types.String                                         `tfsdk:"redistribution_profile"`
	GlobalBfd             *LogicalRouterResourceVrfOspfv3GlobalBfdObject       `tfsdk:"global_bfd"`
	GracefulRestart       *LogicalRouterResourceVrfOspfv3GracefulRestartObject `tfsdk:"graceful_restart"`
	Area                  types.List                                           `tfsdk:"area"`
}
type LogicalRouterResourceVrfOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	StrictLsaChecking      types.Bool  `tfsdk:"strict_lsa_checking"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
}
type LogicalRouterResourceVrfOspfv3AreaObject struct {
	Name           types.String                                  `tfsdk:"name"`
	Authentication types.String                                  `tfsdk:"authentication"`
	Type           *LogicalRouterResourceVrfOspfv3AreaTypeObject `tfsdk:"type"`
	Range          types.List                                    `tfsdk:"range"`
	Interface      types.List                                    `tfsdk:"interface"`
	VirtualLink    types.List                                    `tfsdk:"virtual_link"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeObject struct {
	Normal *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject `tfsdk:"normal"`
	Stub   *LogicalRouterResourceVrfOspfv3AreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject   `tfsdk:"nssa"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNormalObject struct {
	Abr *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeStubObject struct {
	NoSummary          types.Bool                                           `tfsdk:"no_summary"`
	Abr                *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject `tfsdk:"abr"`
	DefaultRouteMetric types.Int64                                          `tfsdk:"default_route_metric"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaObject struct {
	NoSummary                   types.Bool                                                                   `tfsdk:"no_summary"`
	DefaultInformationOriginate *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject `tfsdk:"default_information_originate"`
	Abr                         *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject                         `tfsdk:"abr"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject struct {
	Metric     types.Int64  `tfsdk:"metric"`
	MetricType types.String `tfsdk:"metric_type"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject struct {
	ImportList         types.String `tfsdk:"import_list"`
	ExportList         types.String `tfsdk:"export_list"`
	InboundFilterList  types.String `tfsdk:"inbound_filter_list"`
	OutboundFilterList types.String `tfsdk:"outbound_filter_list"`
	NssaExtRange       types.List   `tfsdk:"nssa_ext_range"`
}
type LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Bool   `tfsdk:"advertise"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceObject struct {
	Name           types.String                                               `tfsdk:"name"`
	Enable         types.Bool                                                 `tfsdk:"enable"`
	MtuIgnore      types.Bool                                                 `tfsdk:"mtu_ignore"`
	Passive        types.Bool                                                 `tfsdk:"passive"`
	Priority       types.Int64                                                `tfsdk:"priority"`
	Metric         types.Int64                                                `tfsdk:"metric"`
	InstanceId     types.Int64                                                `tfsdk:"instance_id"`
	Authentication types.String                                               `tfsdk:"authentication"`
	Timing         types.String                                               `tfsdk:"timing"`
	LinkType       *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Bfd            *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject struct {
	Neighbor types.List `tfsdk:"neighbor"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
}
type LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject struct {
	Name           types.String `tfsdk:"name"`
	NeighborId     types.String `tfsdk:"neighbor_id"`
	TransitAreaId  types.String `tfsdk:"transit_area_id"`
	Enable         types.Bool   `tfsdk:"enable"`
	InstanceId     types.Int64  `tfsdk:"instance_id"`
	Timing         types.String `tfsdk:"timing"`
	Authentication types.String `tfsdk:"authentication"`
}
type LogicalRouterResourceVrfEcmpObject struct {
	Enable           types.Bool                                   `tfsdk:"enable"`
	MaxPaths         types.Int64                                  `tfsdk:"max_paths"`
	SymmetricReturn  types.Bool                                   `tfsdk:"symmetric_return"`
	StrictSourcePath types.Bool                                   `tfsdk:"strict_source_path"`
	Algorithm        *LogicalRouterResourceVrfEcmpAlgorithmObject `tfsdk:"algorithm"`
}
type LogicalRouterResourceVrfEcmpAlgorithmObject struct {
	IpModulo           *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
	IpHash             *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	WeightedRoundRobin *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
}
type LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject struct {
}
type LogicalRouterResourceVrfEcmpAlgorithmIpHashObject struct {
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
}
type LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject struct {
}
type LogicalRouterResourceVrfMulticastObject struct {
	Enable      types.Bool                                   `tfsdk:"enable"`
	StaticRoute types.List                                   `tfsdk:"static_route"`
	Pim         *LogicalRouterResourceVrfMulticastPimObject  `tfsdk:"pim"`
	Igmp        *LogicalRouterResourceVrfMulticastIgmpObject `tfsdk:"igmp"`
	Msdp        *LogicalRouterResourceVrfMulticastMsdpObject `tfsdk:"msdp"`
}
type LogicalRouterResourceVrfMulticastStaticRouteObject struct {
	Name        types.String                                               `tfsdk:"name"`
	Destination types.String                                               `tfsdk:"destination"`
	Interface   types.String                                               `tfsdk:"interface"`
	Preference  types.Int64                                                `tfsdk:"preference"`
	Nexthop     *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject `tfsdk:"nexthop"`
}
type LogicalRouterResourceVrfMulticastStaticRouteNexthopObject struct {
	IpAddress types.String `tfsdk:"ip_address"`
}
type LogicalRouterResourceVrfMulticastPimObject struct {
	Enable          types.Bool                                                 `tfsdk:"enable"`
	RpfLookupMode   types.String                                               `tfsdk:"rpf_lookup_mode"`
	RouteAgeoutTime types.Int64                                                `tfsdk:"route_ageout_time"`
	IfTimerGlobal   types.String                                               `tfsdk:"if_timer_global"`
	GroupPermission types.String                                               `tfsdk:"group_permission"`
	SsmAddressSpace *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject `tfsdk:"ssm_address_space"`
	Rp              *LogicalRouterResourceVrfMulticastPimRpObject              `tfsdk:"rp"`
	SptThreshold    types.List                                                 `tfsdk:"spt_threshold"`
	Interface       types.List                                                 `tfsdk:"interface"`
}
type LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject struct {
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpObject struct {
	LocalRp    *LogicalRouterResourceVrfMulticastPimRpLocalRpObject `tfsdk:"local_rp"`
	ExternalRp types.List                                           `tfsdk:"external_rp"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpObject struct {
	StaticRp    *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject    `tfsdk:"static_rp"`
	CandidateRp *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject `tfsdk:"candidate_rp"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject struct {
	Interface types.String `tfsdk:"interface"`
	Address   types.String `tfsdk:"address"`
	Override  types.Bool   `tfsdk:"override"`
	GroupList types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject struct {
	Interface             types.String `tfsdk:"interface"`
	Address               types.String `tfsdk:"address"`
	Priority              types.Int64  `tfsdk:"priority"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupList             types.String `tfsdk:"group_list"`
}
type LogicalRouterResourceVrfMulticastPimRpExternalRpObject struct {
	Name      types.String `tfsdk:"name"`
	GroupList types.String `tfsdk:"group_list"`
	Override  types.Bool   `tfsdk:"override"`
}
type LogicalRouterResourceVrfMulticastPimSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type LogicalRouterResourceVrfMulticastPimInterfaceObject struct {
	Name           types.String `tfsdk:"name"`
	Description    types.String `tfsdk:"description"`
	DrPriority     types.Int64  `tfsdk:"dr_priority"`
	SendBsm        types.Bool   `tfsdk:"send_bsm"`
	IfTimer        types.String `tfsdk:"if_timer"`
	NeighborFilter types.String `tfsdk:"neighbor_filter"`
}
type LogicalRouterResourceVrfMulticastIgmpObject struct {
	Enable  types.Bool                                          `tfsdk:"enable"`
	Dynamic *LogicalRouterResourceVrfMulticastIgmpDynamicObject `tfsdk:"dynamic"`
	Static  types.List                                          `tfsdk:"static"`
}
type LogicalRouterResourceVrfMulticastIgmpDynamicObject struct {
	Interface types.List `tfsdk:"interface"`
}
type LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject struct {
	Name                types.String `tfsdk:"name"`
	Version             types.String `tfsdk:"version"`
	Robustness          types.String `tfsdk:"robustness"`
	GroupFilter         types.String `tfsdk:"group_filter"`
	MaxGroups           types.String `tfsdk:"max_groups"`
	MaxSources          types.String `tfsdk:"max_sources"`
	QueryProfile        types.String `tfsdk:"query_profile"`
	RouterAlertPolicing types.Bool   `tfsdk:"router_alert_policing"`
}
type LogicalRouterResourceVrfMulticastIgmpStaticObject struct {
	Name          types.String `tfsdk:"name"`
	Interface     types.String `tfsdk:"interface"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
}
type LogicalRouterResourceVrfMulticastMsdpObject struct {
	Enable               types.Bool                                               `tfsdk:"enable"`
	GlobalTimer          types.String                                             `tfsdk:"global_timer"`
	GlobalAuthentication types.String                                             `tfsdk:"global_authentication"`
	OriginatorId         *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject `tfsdk:"originator_id"`
	Peer                 types.List                                               `tfsdk:"peer"`
}
type LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerObject struct {
	Name             types.String                                                 `tfsdk:"name"`
	Enable           types.Bool                                                   `tfsdk:"enable"`
	PeerAs           types.String                                                 `tfsdk:"peer_as"`
	Authentication   types.String                                                 `tfsdk:"authentication"`
	MaxSa            types.Int64                                                  `tfsdk:"max_sa"`
	InboundSaFilter  types.String                                                 `tfsdk:"inbound_sa_filter"`
	OutboundSaFilter types.String                                                 `tfsdk:"outbound_sa_filter"`
	LocalAddress     *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject `tfsdk:"local_address"`
	PeerAddress      *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject  `tfsdk:"peer_address"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type LogicalRouterResourceVrfRipObject struct {
	Enable                       types.Bool                                                     `tfsdk:"enable"`
	DefaultInformationOriginate  types.Bool                                                     `tfsdk:"default_information_originate"`
	GlobalTimer                  types.String                                                   `tfsdk:"global_timer"`
	AuthProfile                  types.String                                                   `tfsdk:"auth_profile"`
	RedistributionProfile        types.String                                                   `tfsdk:"redistribution_profile"`
	GlobalBfd                    *LogicalRouterResourceVrfRipGlobalBfdObject                    `tfsdk:"global_bfd"`
	GlobalInboundDistributeList  *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject  `tfsdk:"global_inbound_distribute_list"`
	GlobalOutboundDistributeList *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject `tfsdk:"global_outbound_distribute_list"`
	Interfaces                   types.List                                                     `tfsdk:"interfaces"`
}
type LogicalRouterResourceVrfRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRipGlobalInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
}
type LogicalRouterResourceVrfRipInterfacesObject struct {
	Name                            types.String                                                                `tfsdk:"name"`
	Enable                          types.Bool                                                                  `tfsdk:"enable"`
	Mode                            types.String                                                                `tfsdk:"mode"`
	SplitHorizon                    types.String                                                                `tfsdk:"split_horizon"`
	Authentication                  types.String                                                                `tfsdk:"authentication"`
	Bfd                             *LogicalRouterResourceVrfRipInterfacesBfdObject                             `tfsdk:"bfd"`
	InterfaceInboundDistributeList  *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject  `tfsdk:"interface_inbound_distribute_list"`
	InterfaceOutboundDistributeList *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject `tfsdk:"interface_outbound_distribute_list"`
}
type LogicalRouterResourceVrfRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}
type LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject struct {
	AccessList types.String `tfsdk:"access_list"`
	Metric     types.Int64  `tfsdk:"metric"`
}

func (r *LogicalRouterResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func LogicalRouterResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": LogicalRouterResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vrf": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceModel) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"administrative_distances": LogicalRouterResourceVrfAdministrativeDistancesSchema(),

			"rib_filter": LogicalRouterResourceVrfRibFilterSchema(),

			"bgp": LogicalRouterResourceVrfBgpSchema(),

			"routing_table": LogicalRouterResourceVrfRoutingTableSchema(),

			"ospf": LogicalRouterResourceVrfOspfSchema(),

			"ospfv3": LogicalRouterResourceVrfOspfv3Schema(),

			"ecmp": LogicalRouterResourceVrfEcmpSchema(),

			"multicast": LogicalRouterResourceVrfMulticastSchema(),

			"rip": LogicalRouterResourceVrfRipSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfAdministrativeDistancesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": rsschema.Int64Attribute{
				Description: "Set IPv4 Static Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"static_ipv6": rsschema.Int64Attribute{
				Description: "Set IPv6 Static Routes  Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"ospf_inter": rsschema.Int64Attribute{
				Description: "Set OSPF Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospf_intra": rsschema.Int64Attribute{
				Description: "Set OSPF Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospf_ext": rsschema.Int64Attribute{
				Description: "Set OSPF External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_inter": rsschema.Int64Attribute{
				Description: "Set OSPFv3 Inter Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_intra": rsschema.Int64Attribute{
				Description: "Set OSPFv3 Intra Area Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_ext": rsschema.Int64Attribute{
				Description: "Set OSPFv3 External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"bgp_internal": rsschema.Int64Attribute{
				Description: "Set BGP AS Internal Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"bgp_external": rsschema.Int64Attribute{
				Description: "Set BGP AS External Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"bgp_local": rsschema.Int64Attribute{
				Description: "Set BGP Local Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"rip": rsschema.Int64Attribute{
				Description: "Set RIP Routes Administrative Distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfRibFilterIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfRibFilterIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": LogicalRouterResourceVrfRibFilterIpv4StaticSchema(),

			"bgp": LogicalRouterResourceVrfRibFilterIpv4BgpSchema(),

			"ospf": LogicalRouterResourceVrfRibFilterIpv4OspfSchema(),

			"rip": LogicalRouterResourceVrfRibFilterIpv4RipSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4StaticSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4BgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4OspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on OSPF Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4OspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv4RipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on RIP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv4RipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static": LogicalRouterResourceVrfRibFilterIpv6StaticSchema(),

			"bgp": LogicalRouterResourceVrfRibFilterIpv6BgpSchema(),

			"ospfv3": LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6StaticSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on Static Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6StaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6BgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on BGP Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6BgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_map": rsschema.StringAttribute{
				Description: "Apply Route-Map on OSPFv3 Routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRibFilterIpv6Ospfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": rsschema.StringAttribute{
				Description: "local AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"install_route": rsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": rsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fast_external_failover": rsschema.BoolAttribute{
				Description: "Immediately reset session if a link to a directly connected external peer goes down",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ecmp_multi_as": rsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": rsschema.Int64Attribute{
				Description: "Global Default Local Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},

			"graceful_shutdown": rsschema.BoolAttribute{
				Description: "Gracefully Shutdown BGP following RFC-8326",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"always_advertise_network_route": rsschema.BoolAttribute{
				Description: "Always advertise network routes even if not present in RIB",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": LogicalRouterResourceVrfBgpMedSchema(),

			"graceful_restart": LogicalRouterResourceVrfBgpGracefulRestartSchema(),

			"global_bfd": LogicalRouterResourceVrfBgpGlobalBfdSchema(),

			"redistribution_profile": LogicalRouterResourceVrfBgpRedistributionProfileSchema(),

			"advertise_network": LogicalRouterResourceVrfBgpAdvertiseNetworkSchema(),

			"peer_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpPeerGroupSchema(),
			},

			"aggregate_routes": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAggregateRoutesSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpMedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"always_compare_med": rsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": rsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpMedObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": rsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"max_peer_restart_time": rsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"local_restart_time": rsschema.Int64Attribute{
				Description: "local restart time to advertise to peer Default:120 (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.StringAttribute{
				Description: "Redistribution Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpRedistributionProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"network": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": rsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": rsschema.BoolAttribute{
				Description: "Multicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"backdoor": rsschema.BoolAttribute{
				Description: "Mark network as backdoor route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"network": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"unicast": rsschema.BoolAttribute{
				Description: "Unicast Network configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfBgpPeerGroupTypeSchema(),

			"address_family": LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema(),

			"filtering_profile": LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema(),

			"connection_options": LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema(),

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ibgp": LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema(),

			"ebgp": LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"timers": rsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": rsschema.Int64Attribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening": rsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "If enabled, open messages are not sent to this peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherit": LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema(),

			"local_address": LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"yes": LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema(),

			"no": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("yes"),
				path.MatchRelative().AtParent().AtName("no"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address_family": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema(),

			"filtering_profile": LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "Enable IPv4 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},

			"ipv6": rsschema.StringAttribute{
				Description: "Enable IPv6 route exchange",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": rsschema.StringAttribute{
				Description: "IPv4 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},

			"ipv6": rsschema.StringAttribute{
				Description: "IPv6 Filtering Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"timers": rsschema.StringAttribute{
				Description: "Timer Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"multihop": rsschema.StringAttribute{
				Description: "Multi-hop value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"dampening": rsschema.StringAttribute{
				Description: "Dampening Profile Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "Describe Aggregate Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable Aggregation for this Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary_only": rsschema.BoolAttribute{
				Description: "Send only Summary Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": rsschema.BoolAttribute{
				Description: "Generate AS set path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"same_med": rsschema.BoolAttribute{
				Description: "Aggregate Routes only if they have same MED Attributes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ipv4": LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema(),

			"ipv6": LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"summary_prefix": rsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"summary_prefix": rsschema.StringAttribute{
				Description: "Aggregating Address Prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"suppress_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to select routes to be suppressed",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"attribute_map": rsschema.StringAttribute{
				Description: "Specify Route-Map to set attributes of aggregate prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": LogicalRouterResourceVrfRoutingTableIpSchema(),

			"ipv6": LogicalRouterResourceVrfRoutingTableIpv6Schema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"nexthop": LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema(),

			"bfd": LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"discard": LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema(),

			"ip_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": rsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("next_lr"),
				path.MatchRelative().AtParent().AtName("fqdn"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"nexthop": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema(),

			"bfd": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema(),

			"path_monitor": LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"discard": LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": rsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_lr": rsschema.StringAttribute{
				Description: "Next-Hop Logical Router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_lr"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": rsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": rsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": rsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfOspfGlobalBfdSchema(),

			"graceful_restart": LogicalRouterResourceVrfOspfGracefulRestartSchema(),

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfOspfAreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": LogicalRouterResourceVrfOspfAreaTypeNormalSchema(),

			"stub": LogicalRouterResourceVrfOspfAreaTypeStubSchema(),

			"nssa": LogicalRouterResourceVrfOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"abr": LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema(),

			"default_route_metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"metric_type": rsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF on this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": rsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPF instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"disable_transit_traffic": rsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_timer": rsschema.StringAttribute{
				Description: "SPF timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_if_timer": rsschema.StringAttribute{
				Description: "Global protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfOspfv3GlobalBfdSchema(),

			"graceful_restart": LogicalRouterResourceVrfOspfv3GracefulRestartSchema(),

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3Object) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3GlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3GracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_lsa_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication profile name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": LogicalRouterResourceVrfOspfv3AreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema(),

			"stub": LogicalRouterResourceVrfOspfv3AreaTypeStubSchema(),

			"nssa": LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema(),

			"default_route_metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeStubAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"no_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema(),

			"abr": LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"metric_type": rsschema.StringAttribute{
				Description: "metric type to be used when redistribute default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("type-2"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"import_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced from other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_list": rsschema.StringAttribute{
				Description: "Set the filter for networks announced to other areas",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inbound_filter_list": rsschema.StringAttribute{
				Description: "Inbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_filter_list": rsschema.StringAttribute{
				Description: "Outbound filter list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": rsschema.BoolAttribute{
				Description: "do summarization and advertise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mtu_ignore": rsschema.BoolAttribute{
				Description: "Ignore mtu when try to establish adjacency",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema(),

			"bfd": LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Neighbor priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"timing": rsschema.StringAttribute{
				Description: "Protocol timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": rsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"symmetric_return": rsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": rsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": LogicalRouterResourceVrfEcmpAlgorithmSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_modulo": LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema(),

			"ip_hash": LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema(),

			"weighted_round_robin": LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"src_only": rsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": rsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hash_seed": rsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastStaticRouteSchema(),
			},

			"pim": LogicalRouterResourceVrfMulticastPimSchema(),

			"igmp": LogicalRouterResourceVrfMulticastIgmpSchema(),

			"msdp": LogicalRouterResourceVrfMulticastMsdpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastStaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preference": rsschema.Int64Attribute{
				Description: "administrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rpf_lookup_mode": rsschema.StringAttribute{
				Description: "RPF Lookup Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("mrib-then-urib"),
			},

			"route_ageout_time": rsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(210),
			},

			"if_timer_global": rsschema.StringAttribute{
				Description: "Global Interface Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_permission": rsschema.StringAttribute{
				Description: "ASM/SSM group permission",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssm_address_space": LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema(),

			"rp": LogicalRouterResourceVrfMulticastPimRpSchema(),

			"spt_threshold": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimSptThresholdSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"group_list": rsschema.StringAttribute{
				Description: "SSM Group Prefix List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpSchema(),

			"external_rp": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastPimRpExternalRpSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema(),

			"candidate_rp": LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": rsschema.StringAttribute{
				Description: "local RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("static_rp"),
				path.MatchRelative().AtParent().AtName("candidate_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": rsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(192),
			},

			"advertisement_interval": rsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimRpExternalRpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_list": rsschema.StringAttribute{
				Description: "Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimSptThresholdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("0"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastPimInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": rsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"send_bsm": rsschema.BoolAttribute{
				Description: "Send BSM",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"if_timer": rsschema.StringAttribute{
				Description: "Interface Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_filter": rsschema.StringAttribute{
				Description: "Set the filter for neighbor list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastPimInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dynamic": LogicalRouterResourceVrfMulticastIgmpDynamicSchema(),

			"static": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastIgmpStaticSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"version": rsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("3"),
			},

			"robustness": rsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2"),
			},

			"group_filter": rsschema.StringAttribute{
				Description: "ASM/SSM Group Access List",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"max_groups": rsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"max_sources": rsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"query_profile": rsschema.StringAttribute{
				Description: "IGMP Query Timer Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": rsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastIgmpStaticSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "multicast interfaces",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": rsschema.StringAttribute{
				Description: "source-address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastIgmpStaticSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": rsschema.StringAttribute{
				Description: "Global timer profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_authentication": rsschema.StringAttribute{
				Description: "Global authentication profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"originator_id": LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema(),

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfMulticastMsdpPeerSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface of originator",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpOriginatorIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("inherit"),
			},

			"max_sa": rsschema.Int64Attribute{
				Description: "Maximum number of SA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"inbound_sa_filter": rsschema.StringAttribute{
				Description: "Inbound SA Filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"outbound_sa_filter": rsschema.StringAttribute{
				Description: "Outbound SA Filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_address": LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema(),

			"peer_address": LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept MSDP connection",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "Peer FQDN Address Object",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_information_originate": rsschema.BoolAttribute{
				Description: "advertise default route in RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_timer": rsschema.StringAttribute{
				Description: "timer setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.StringAttribute{
				Description: "Authentication profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redistribution_profile": rsschema.StringAttribute{
				Description: "Redistribution profile setting",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": LogicalRouterResourceVrfRipGlobalBfdSchema(),

			"global_inbound_distribute_list": LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema(),

			"global_outbound_distribute_list": LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema(),

			"interfaces": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: LogicalRouterResourceVrfRipInterfacesSchema(),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipGlobalOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable RIP on this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("active"),
			},

			"split_horizon": rsschema.StringAttribute{
				Description: "Split horizon options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("split-horizon"),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": LogicalRouterResourceVrfRipInterfacesBfdSchema(),

			"interface_inbound_distribute_list": LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema(),

			"interface_outbound_distribute_list": LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema(),
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-lr-global-setting"),
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_list": rsschema.StringAttribute{
				Description: "access-list name from filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) getTypeFor(name string) attr.Type {
	schema := LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *LogicalRouterResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_logical_router"
}

func (r *LogicalRouterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = LogicalRouterResourceSchema()
}

// </ResourceSchema>

func (r *LogicalRouterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
	specifier, _, err := logical_router.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	r.manager = sdkmanager.NewEntryObjectManager[*logical_router.Entry, logical_router.Location, *logical_router.Service](r.client, logical_router.NewService(r.client), batchSize, specifier, logical_router.SpecMatches)
}

func (o *LogicalRouterResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj LogicalRouterLocation

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"vrf":  types.ListType{},
	}
}

func (o LogicalRouterResourceModel) AncestorName() string {
	return ""
}

func (o LogicalRouterResourceModel) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfObject) AttributeTypes() map[string]attr.Type {

	var administrativeDistancesObj *LogicalRouterResourceVrfAdministrativeDistancesObject

	var ribFilterObj *LogicalRouterResourceVrfRibFilterObject

	var bgpObj *LogicalRouterResourceVrfBgpObject

	var routingTableObj *LogicalRouterResourceVrfRoutingTableObject

	var ospfObj *LogicalRouterResourceVrfOspfObject

	var ospfv3Obj *LogicalRouterResourceVrfOspfv3Object

	var ecmpObj *LogicalRouterResourceVrfEcmpObject

	var multicastObj *LogicalRouterResourceVrfMulticastObject

	var ripObj *LogicalRouterResourceVrfRipObject
	return map[string]attr.Type{
		"name":      types.StringType,
		"interface": types.ListType{},
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"rib_filter": types.ObjectType{
			AttrTypes: ribFilterObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"routing_table": types.ObjectType{
			AttrTypes: routingTableObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfObject) AncestorName() string {
	return "vrf"
}

func (o LogicalRouterResourceVrfObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static":       types.Int64Type,
		"static_ipv6":  types.Int64Type,
		"ospf_inter":   types.Int64Type,
		"ospf_intra":   types.Int64Type,
		"ospf_ext":     types.Int64Type,
		"ospfv3_inter": types.Int64Type,
		"ospfv3_intra": types.Int64Type,
		"ospfv3_ext":   types.Int64Type,
		"bgp_internal": types.Int64Type,
		"bgp_external": types.Int64Type,
		"bgp_local":    types.Int64Type,
		"rip":          types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o LogicalRouterResourceVrfAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfRibFilterIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfRibFilterIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterObject) AncestorName() string {
	return "rib-filter"
}

func (o LogicalRouterResourceVrfRibFilterObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterResourceVrfRibFilterIpv4StaticObject

	var bgpObj *LogicalRouterResourceVrfRibFilterIpv4BgpObject

	var ospfObj *LogicalRouterResourceVrfRibFilterIpv4OspfObject

	var ripObj *LogicalRouterResourceVrfRibFilterIpv4RipObject
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfRibFilterIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfRibFilterIpv4StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfRibFilterIpv4BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4OspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterResourceVrfRibFilterIpv4OspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv4RipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterResourceVrfRibFilterIpv4RipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Object) AttributeTypes() map[string]attr.Type {

	var staticObj *LogicalRouterResourceVrfRibFilterIpv6StaticObject

	var bgpObj *LogicalRouterResourceVrfRibFilterIpv6BgpObject

	var ospfv3Obj *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object
	return map[string]attr.Type{
		"static": types.ObjectType{
			AttrTypes: staticObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfRibFilterIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6StaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfRibFilterIpv6StaticObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6BgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfRibFilterIpv6BgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"route_map": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpObject) AttributeTypes() map[string]attr.Type {

	var medObj *LogicalRouterResourceVrfBgpMedObject

	var gracefulRestartObj *LogicalRouterResourceVrfBgpGracefulRestartObject

	var globalBfdObj *LogicalRouterResourceVrfBgpGlobalBfdObject

	var redistributionProfileObj *LogicalRouterResourceVrfBgpRedistributionProfileObject

	var advertiseNetworkObj *LogicalRouterResourceVrfBgpAdvertiseNetworkObject

	return map[string]attr.Type{
		"enable":                         types.BoolType,
		"router_id":                      types.StringType,
		"local_as":                       types.StringType,
		"install_route":                  types.BoolType,
		"enforce_first_as":               types.BoolType,
		"fast_external_failover":         types.BoolType,
		"ecmp_multi_as":                  types.BoolType,
		"default_local_preference":       types.Int64Type,
		"graceful_shutdown":              types.BoolType,
		"always_advertise_network_route": types.BoolType,
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"redistribution_profile": types.ObjectType{
			AttrTypes: redistributionProfileObj.AttributeTypes(),
		},
		"advertise_network": types.ObjectType{
			AttrTypes: advertiseNetworkObj.AttributeTypes(),
		},
		"peer_group":       types.ListType{},
		"aggregate_routes": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfBgpObject) AncestorName() string {
	return "bgp"
}

func (o LogicalRouterResourceVrfBgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpMedObject) AncestorName() string {
	return "med"
}

func (o LogicalRouterResourceVrfBgpMedObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"stale_route_time":      types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"local_restart_time":    types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfBgpGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfBgpGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileObject) AncestorName() string {
	return "redistribution-profile"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkObject) AncestorName() string {
	return "advertise-network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"network": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
		"backdoor":  types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"network": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":    types.StringType,
		"unicast": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) AncestorName() string {
	return "network"
}

func (o LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfBgpPeerGroupTypeObject

	var addressFamilyObj *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject

	var filteringProfileObj *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject

	var connectionOptionsObj *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject

	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"peer": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o LogicalRouterResourceVrfBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject

	var ebgpObj *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.Int64Type,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var inheritObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject

	var localAddressObj *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"passive":                           types.BoolType,
		"peer_as":                           types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"inherit": types.ObjectType{
			AttrTypes: inheritObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) AttributeTypes() map[string]attr.Type {

	var yesObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject

	var noObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject
	return map[string]attr.Type{
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) AncestorName() string {
	return "inherit"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) AncestorName() string {
	return "yes"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) AttributeTypes() map[string]attr.Type {

	var addressFamilyObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject

	var filteringProfileObj *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	return map[string]attr.Type{
		"address_family": types.ObjectType{
			AttrTypes: addressFamilyObj.AttributeTypes(),
		},
		"filtering_profile": types.ObjectType{
			AttrTypes: filteringProfileObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) AncestorName() string {
	return "no"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) AncestorName() string {
	return "address-family"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ipv4": types.StringType,
		"ipv6": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) AncestorName() string {
	return "filtering-profile"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"timers":         types.StringType,
		"multihop":       types.StringType,
		"authentication": types.StringType,
		"dampening":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject
	return map[string]attr.Type{
		"name":         types.StringType,
		"description":  types.StringType,
		"enable":       types.BoolType,
		"summary_only": types.BoolType,
		"as_set":       types.BoolType,
		"same_med":     types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesObject) AncestorName() string {
	return "aggregate-routes"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) AttributeTypes() map[string]attr.Type {

	var ipv4Obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object

	var ipv6Obj *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object
	return map[string]attr.Type{
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"summary_prefix": types.StringType,
		"suppress_map":   types.StringType,
		"attribute_map":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableObject) AttributeTypes() map[string]attr.Type {

	var ipObj *LogicalRouterResourceVrfRoutingTableIpObject

	var ipv6Obj *LogicalRouterResourceVrfRoutingTableIpv6Object
	return map[string]attr.Type{
		"ip": types.ObjectType{
			AttrTypes: ipObj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableObject) AncestorName() string {
	return "routing-table"
}

func (o LogicalRouterResourceVrfRoutingTableObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static_route": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpObject) AncestorName() string {
	return "ip"
}

func (o LogicalRouterResourceVrfRoutingTableIpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject

	var bfdObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject

	var pathMonitorObj *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ip_address": types.StringType,
		"next_lr":    types.StringType,
		"fqdn":       types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":               types.BoolType,
		"failure_condition":    types.StringType,
		"hold_time":            types.Int64Type,
		"monitor_destinations": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"static_route": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject

	var bfdObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject

	var pathMonitorObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	return map[string]attr.Type{
		"name":                    types.StringType,
		"destination":             types.StringType,
		"interface":               types.StringType,
		"administrative_distance": types.Int64Type,
		"metric":                  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"path_monitor": types.ObjectType{
			AttrTypes: pathMonitorObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	var discardObj *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject

	return map[string]attr.Type{
		"discard": types.ObjectType{
			AttrTypes: discardObj.AttributeTypes(),
		},
		"ipv6_address": types.StringType,
		"fqdn":         types.StringType,
		"next_lr":      types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) AncestorName() string {
	return "discard"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":               types.BoolType,
		"failure_condition":    types.StringType,
		"hold_time":            types.Int64Type,
		"monitor_destinations": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) AncestorName() string {
	return "path-monitor"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":        types.StringType,
		"enable":      types.BoolType,
		"source":      types.StringType,
		"destination": types.StringType,
		"interval":    types.Int64Type,
		"count":       types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) AncestorName() string {
	return "monitor-destinations"
}

func (o LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfOspfGlobalBfdObject

	var gracefulRestartObj *LogicalRouterResourceVrfOspfGracefulRestartObject

	return map[string]attr.Type{
		"router_id":              types.StringType,
		"enable":                 types.BoolType,
		"rfc1583":                types.BoolType,
		"spf_timer":              types.StringType,
		"global_if_timer":        types.StringType,
		"redistribution_profile": types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfObject) AncestorName() string {
	return "ospf"
}

func (o LogicalRouterResourceVrfOspfObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfOspfAreaTypeObject

	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range":        types.ListType{},
		"interface":    types.ListType{},
		"virtual_link": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfAreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterResourceVrfOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterResourceVrfOspfAreaTypeNormalObject

	var stubObj *LogicalRouterResourceVrfOspfAreaTypeStubObject

	var nssaObj *LogicalRouterResourceVrfOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range":       types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterResourceVrfOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"neighbor": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3Object) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfOspfv3GlobalBfdObject

	var gracefulRestartObj *LogicalRouterResourceVrfOspfv3GracefulRestartObject

	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"router_id":               types.StringType,
		"disable_transit_traffic": types.BoolType,
		"spf_timer":               types.StringType,
		"global_if_timer":         types.StringType,
		"redistribution_profile":  types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"area": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o LogicalRouterResourceVrfOspfv3Object) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"strict_lsa_checking":       types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o LogicalRouterResourceVrfOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *LogicalRouterResourceVrfOspfv3AreaTypeObject

	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range":        types.ListType{},
		"interface":    types.ListType{},
		"virtual_link": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o LogicalRouterResourceVrfOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject

	var stubObj *LogicalRouterResourceVrfOspfv3AreaTypeStubObject

	var nssaObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject
	return map[string]attr.Type{
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject

	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
		"default_route_metric": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultInformationOriginateObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject

	var abrObj *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject
	return map[string]attr.Type{
		"no_summary": types.BoolType,
		"default_information_originate": types.ObjectType{
			AttrTypes: defaultInformationOriginateObj.AttributeTypes(),
		},
		"abr": types.ObjectType{
			AttrTypes: abrObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric":      types.Int64Type,
		"metric_type": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) AncestorName() string {
	return "default-information-originate"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_list":          types.StringType,
		"export_list":          types.StringType,
		"inbound_filter_list":  types.StringType,
		"outbound_filter_list": types.StringType,
		"nssa_ext_range":       types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) AncestorName() string {
	return "abr"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"advertise": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o LogicalRouterResourceVrfOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject

	var bfdObj *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mtu_ignore":     types.BoolType,
		"passive":        types.BoolType,
		"priority":       types.Int64Type,
		"metric":         types.Int64Type,
		"instance_id":    types.Int64Type,
		"authentication": types.StringType,
		"timing":         types.StringType,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"neighbor": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"neighbor_id":     types.StringType,
		"transit_area_id": types.StringType,
		"enable":          types.BoolType,
		"instance_id":     types.Int64Type,
		"timing":          types.StringType,
		"authentication":  types.StringType,
	}
}

func (o LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *LogicalRouterResourceVrfEcmpAlgorithmObject
	return map[string]attr.Type{
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"symmetric_return":   types.BoolType,
		"strict_source_path": types.BoolType,
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o LogicalRouterResourceVrfEcmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var ipModuloObj *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject

	var ipHashObj *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject

	var weightedRoundRobinObj *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject

	var balancedRoundRobinObj *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject
	return map[string]attr.Type{
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
		"hash_seed": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastObject) AttributeTypes() map[string]attr.Type {

	var pimObj *LogicalRouterResourceVrfMulticastPimObject

	var igmpObj *LogicalRouterResourceVrfMulticastIgmpObject

	var msdpObj *LogicalRouterResourceVrfMulticastMsdpObject
	return map[string]attr.Type{
		"enable":       types.BoolType,
		"static_route": types.ListType{},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"msdp": types.ObjectType{
			AttrTypes: msdpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastObject) AncestorName() string {
	return "multicast"
}

func (o LogicalRouterResourceVrfMulticastObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) AttributeTypes() map[string]attr.Type {

	var nexthopObj *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"destination": types.StringType,
		"interface":   types.StringType,
		"preference":  types.Int64Type,
		"nexthop": types.ObjectType{
			AttrTypes: nexthopObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastStaticRouteObject) AncestorName() string {
	return "static-route"
}

func (o LogicalRouterResourceVrfMulticastStaticRouteObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip_address": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) AncestorName() string {
	return "nexthop"
}

func (o LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimObject) AttributeTypes() map[string]attr.Type {

	var ssmAddressSpaceObj *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject

	var rpObj *LogicalRouterResourceVrfMulticastPimRpObject

	return map[string]attr.Type{
		"enable":            types.BoolType,
		"rpf_lookup_mode":   types.StringType,
		"route_ageout_time": types.Int64Type,
		"if_timer_global":   types.StringType,
		"group_permission":  types.StringType,
		"ssm_address_space": types.ObjectType{
			AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
		},
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{},
		"interface":     types.ListType{},
	}
}

func (o LogicalRouterResourceVrfMulticastPimObject) AncestorName() string {
	return "pim"
}

func (o LogicalRouterResourceVrfMulticastPimObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"group_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpObject) AttributeTypes() map[string]attr.Type {

	var localRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpObject

	return map[string]attr.Type{
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
		"external_rp": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpObject) AncestorName() string {
	return "rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var staticRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject

	var candidateRpObj *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject
	return map[string]attr.Type{
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":  types.StringType,
		"address":    types.StringType,
		"override":   types.BoolType,
		"group_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface":              types.StringType,
		"address":                types.StringType,
		"priority":               types.Int64Type,
		"advertisement_interval": types.Int64Type,
		"group_list":             types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"group_list": types.StringType,
		"override":   types.BoolType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o LogicalRouterResourceVrfMulticastPimRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o LogicalRouterResourceVrfMulticastPimSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":            types.StringType,
		"description":     types.StringType,
		"dr_priority":     types.Int64Type,
		"send_bsm":        types.BoolType,
		"if_timer":        types.StringType,
		"neighbor_filter": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastPimInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfMulticastPimInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastIgmpObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *LogicalRouterResourceVrfMulticastIgmpDynamicObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"static": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpObject) AncestorName() string {
	return "igmp"
}

func (o LogicalRouterResourceVrfMulticastIgmpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                  types.StringType,
		"version":               types.StringType,
		"robustness":            types.StringType,
		"group_filter":          types.StringType,
		"max_groups":            types.StringType,
		"max_sources":           types.StringType,
		"query_profile":         types.StringType,
		"router_alert_policing": types.BoolType,
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) AncestorName() string {
	return "interface"
}

func (o LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"interface":      types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastIgmpStaticObject) AncestorName() string {
	return "static"
}

func (o LogicalRouterResourceVrfMulticastIgmpStaticObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastMsdpObject) AttributeTypes() map[string]attr.Type {

	var originatorIdObj *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"global_timer":          types.StringType,
		"global_authentication": types.StringType,
		"originator_id": types.ObjectType{
			AttrTypes: originatorIdObj.AttributeTypes(),
		},
		"peer": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpObject) AncestorName() string {
	return "msdp"
}

func (o LogicalRouterResourceVrfMulticastMsdpObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) AncestorName() string {
	return "originator-id"
}

func (o LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) AttributeTypes() map[string]attr.Type {

	var localAddressObj *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject

	var peerAddressObj *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject
	return map[string]attr.Type{
		"name":               types.StringType,
		"enable":             types.BoolType,
		"peer_as":            types.StringType,
		"authentication":     types.StringType,
		"max_sa":             types.Int64Type,
		"inbound_sa_filter":  types.StringType,
		"outbound_sa_filter": types.StringType,
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerObject) AncestorName() string {
	return "peer"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipObject) AttributeTypes() map[string]attr.Type {

	var globalBfdObj *LogicalRouterResourceVrfRipGlobalBfdObject

	var globalInboundDistributeListObj *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject

	var globalOutboundDistributeListObj *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject

	return map[string]attr.Type{
		"enable":                        types.BoolType,
		"default_information_originate": types.BoolType,
		"global_timer":                  types.StringType,
		"auth_profile":                  types.StringType,
		"redistribution_profile":        types.StringType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"global_inbound_distribute_list": types.ObjectType{
			AttrTypes: globalInboundDistributeListObj.AttributeTypes(),
		},
		"global_outbound_distribute_list": types.ObjectType{
			AttrTypes: globalOutboundDistributeListObj.AttributeTypes(),
		},
		"interfaces": types.ListType{},
	}
}

func (o LogicalRouterResourceVrfRipObject) AncestorName() string {
	return "rip"
}

func (o LogicalRouterResourceVrfRipObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o LogicalRouterResourceVrfRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) AncestorName() string {
	return "global-inbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) AncestorName() string {
	return "global-outbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *LogicalRouterResourceVrfRipInterfacesBfdObject

	var interfaceInboundDistributeListObj *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject

	var interfaceOutboundDistributeListObj *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"mode":           types.StringType,
		"split_horizon":  types.StringType,
		"authentication": types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
		"interface_inbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceInboundDistributeListObj.AttributeTypes(),
		},
		"interface_outbound_distribute_list": types.ObjectType{
			AttrTypes: interfaceOutboundDistributeListObj.AttributeTypes(),
		},
	}
}

func (o LogicalRouterResourceVrfRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o LogicalRouterResourceVrfRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o LogicalRouterResourceVrfRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) AncestorName() string {
	return "interface-inbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) EntryName() *string {
	return nil
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"access_list": types.StringType,
		"metric":      types.Int64Type,
	}
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) AncestorName() string {
	return "interface-outbound-distribute-list"
}

func (o LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) EntryName() *string {
	return nil
}

func (o *LogicalRouterResourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_tf_entries []LogicalRouterResourceVrfObject
	var vrf_pango_entries []logical_router.Vrf
	{
		d := o.Vrf.ElementsAs(ctx, &vrf_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range vrf_tf_entries {
			var entry *logical_router.Vrf
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_pango_entries = append(vrf_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Vrf = vrf_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var administrativeDistances_entry *logical_router.VrfAdminDists
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(logical_router.VrfAdminDists)
		}
		// ModelOrObject: Object
		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, append(ancestors, o), &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_entry *logical_router.VrfRibFilter
	if o.RibFilter != nil {
		if *obj != nil && (*obj).RibFilter != nil {
			ribFilter_entry = (*obj).RibFilter
		} else {
			ribFilter_entry = new(logical_router.VrfRibFilter)
		}
		// ModelOrObject: Object
		diags.Append(o.RibFilter.CopyToPango(ctx, append(ancestors, o), &ribFilter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfBgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *logical_router.VrfRoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(logical_router.VrfRoutingTable)
		}
		// ModelOrObject: Object
		diags.Append(o.RoutingTable.CopyToPango(ctx, append(ancestors, o), &routingTable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfOspf)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospf.CopyToPango(ctx, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfOspfv3)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospfv3.CopyToPango(ctx, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *logical_router.VrfEcmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(logical_router.VrfEcmp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ecmp.CopyToPango(ctx, append(ancestors, o), &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *logical_router.VrfMulticast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(logical_router.VrfMulticast)
		}
		// ModelOrObject: Object
		diags.Append(o.Multicast.CopyToPango(ctx, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRip)
		}
		// ModelOrObject: Object
		diags.Append(o.Rip.CopyToPango(ctx, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.Vrf)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).RibFilter = ribFilter_entry
	(*obj).Bgp = bgp_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Multicast = multicast_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInter_value := o.OspfInter.ValueInt64Pointer()
	ospfIntra_value := o.OspfIntra.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Inter_value := o.Ospfv3Inter.ValueInt64Pointer()
	ospfv3Intra_value := o.Ospfv3Intra.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	bgpInternal_value := o.BgpInternal.ValueInt64Pointer()
	bgpExternal_value := o.BgpExternal.ValueInt64Pointer()
	bgpLocal_value := o.BgpLocal.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfAdminDists)
	}
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInter = ospfInter_value
	(*obj).OspfIntra = ospfIntra_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Inter = ospfv3Inter_value
	(*obj).Ospfv3Intra = ospfv3Intra_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).BgpInternal = bgpInternal_value
	(*obj).BgpExternal = bgpExternal_value
	(*obj).BgpLocal = bgpLocal_value
	(*obj).Rip = rip_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfRibFilterIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfRibFilterIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRibFilterIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRibFilterIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilter)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv4Static
	if o.Static != nil {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv4Static)
		}
		// ModelOrObject: Object
		diags.Append(o.Static.CopyToPango(ctx, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv4Bgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv4Bgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *logical_router.VrfRibFilterIpv4Ospf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(logical_router.VrfRibFilterIpv4Ospf)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospf.CopyToPango(ctx, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_entry *logical_router.VrfRibFilterIpv4Rip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(logical_router.VrfRibFilterIpv4Rip)
		}
		// ModelOrObject: Object
		diags.Append(o.Rip.CopyToPango(ctx, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Rip = rip_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Ospf)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv4Rip)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_entry *logical_router.VrfRibFilterIpv6Static
	if o.Static != nil {
		if *obj != nil && (*obj).Static != nil {
			static_entry = (*obj).Static
		} else {
			static_entry = new(logical_router.VrfRibFilterIpv6Static)
		}
		// ModelOrObject: Object
		diags.Append(o.Static.CopyToPango(ctx, append(ancestors, o), &static_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *logical_router.VrfRibFilterIpv6Bgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(logical_router.VrfRibFilterIpv6Bgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Bgp.CopyToPango(ctx, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *logical_router.VrfRibFilterIpv6Ospfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(logical_router.VrfRibFilterIpv6Ospfv3)
		}
		// ModelOrObject: Object
		diags.Append(o.Ospfv3.CopyToPango(ctx, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6)
	}
	(*obj).Static = static_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Static)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Bgp)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeMap_value := o.RouteMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRibFilterIpv6Ospfv3)
	}
	(*obj).RouteMap = routeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	fastExternalFailover_value := o.FastExternalFailover.ValueBoolPointer()
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	gracefulShutdown_value := o.GracefulShutdown.ValueBoolPointer()
	alwaysAdvertiseNetworkRoute_value := o.AlwaysAdvertiseNetworkRoute.ValueBoolPointer()
	var med_entry *logical_router.VrfBgpMed
	if o.Med != nil {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(logical_router.VrfBgpMed)
		}
		// ModelOrObject: Object
		diags.Append(o.Med.CopyToPango(ctx, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfBgpGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfBgpGracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_entry *logical_router.VrfBgpGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfBgpGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_entry *logical_router.VrfBgpRedistributionProfile
	if o.RedistributionProfile != nil {
		if *obj != nil && (*obj).RedistributionProfile != nil {
			redistributionProfile_entry = (*obj).RedistributionProfile
		} else {
			redistributionProfile_entry = new(logical_router.VrfBgpRedistributionProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.RedistributionProfile.CopyToPango(ctx, append(ancestors, o), &redistributionProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_entry *logical_router.VrfBgpAdvertiseNetwork
	if o.AdvertiseNetwork != nil {
		if *obj != nil && (*obj).AdvertiseNetwork != nil {
			advertiseNetwork_entry = (*obj).AdvertiseNetwork
		} else {
			advertiseNetwork_entry = new(logical_router.VrfBgpAdvertiseNetwork)
		}
		// ModelOrObject: Object
		diags.Append(o.AdvertiseNetwork.CopyToPango(ctx, append(ancestors, o), &advertiseNetwork_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerGroup_tf_entries []LogicalRouterResourceVrfBgpPeerGroupObject
	var peerGroup_pango_entries []logical_router.VrfBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *logical_router.VrfBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var aggregateRoutes_tf_entries []LogicalRouterResourceVrfBgpAggregateRoutesObject
	var aggregateRoutes_pango_entries []logical_router.VrfBgpAggregateRoutes
	{
		d := o.AggregateRoutes.ElementsAs(ctx, &aggregateRoutes_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range aggregateRoutes_tf_entries {
			var entry *logical_router.VrfBgpAggregateRoutes
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_pango_entries = append(aggregateRoutes_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgp)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).LocalAs = localAs_value
	(*obj).InstallRoute = installRoute_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).FastExternalFailover = fastExternalFailover_value
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulShutdown = gracefulShutdown_value
	(*obj).AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	(*obj).Med = med_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RedistributionProfile = redistributionProfile_entry
	(*obj).AdvertiseNetwork = advertiseNetwork_entry
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).AggregateRoutes = aggregateRoutes_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpMedObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpRedistributionProfileIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpRedistributionProfileIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpRedistributionProfileIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpRedistributionProfileIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfile)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv4)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpRedistributionProfileIpv6)
	}
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAdvertiseNetworkIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAdvertiseNetworkIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetwork)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv4Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv4Network
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()
	backdoor_value := o.Backdoor.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv4Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value
	(*obj).Backdoor = backdoor_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject
	var network_pango_entries []logical_router.VrfBgpAdvertiseNetworkIpv6Network
	{
		d := o.Network.ElementsAs(ctx, &network_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range network_tf_entries {
			var entry *logical_router.VrfBgpAdvertiseNetworkIpv6Network
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			network_pango_entries = append(network_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6)
	}
	(*obj).Network = network_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAdvertiseNetworkIpv6Network)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Unicast = unicast_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpPeerGroupType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpPeerGroupType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_entry *logical_router.VrfBgpPeerGroupAddressFamily
	if o.AddressFamily != nil {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupAddressFamily)
		}
		// ModelOrObject: Object
		diags.Append(o.AddressFamily.CopyToPango(ctx, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupFilteringProfile
	if o.FilteringProfile != nil {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupFilteringProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.FilteringProfile.CopyToPango(ctx, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupConnectionOptions)
		}
		// ModelOrObject: Object
		diags.Append(o.ConnectionOptions.CopyToPango(ctx, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterResourceVrfBgpPeerGroupPeerObject
	var peer_pango_entries []logical_router.VrfBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Type = type_entry
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *logical_router.VrfBgpPeerGroupTypeIbgp
	if o.Ibgp != nil {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(logical_router.VrfBgpPeerGroupTypeIbgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ibgp.CopyToPango(ctx, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *logical_router.VrfBgpPeerGroupTypeEbgp
	if o.Ebgp != nil {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(logical_router.VrfBgpPeerGroupTypeEbgp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ebgp.CopyToPango(ctx, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeIbgp)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupTypeEbgp)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	var inherit_entry *logical_router.VrfBgpPeerGroupPeerInherit
	if o.Inherit != nil {
		if *obj != nil && (*obj).Inherit != nil {
			inherit_entry = (*obj).Inherit
		} else {
			inherit_entry = new(logical_router.VrfBgpPeerGroupPeerInherit)
		}
		// ModelOrObject: Object
		diags.Append(o.Inherit.CopyToPango(ctx, append(ancestors, o), &inherit_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *logical_router.VrfBgpPeerGroupPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalAddress.CopyToPango(ctx, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfBgpPeerGroupPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.PeerAddress.CopyToPango(ctx, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *logical_router.VrfBgpPeerGroupPeerConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
		}
		// ModelOrObject: Object
		diags.Append(o.ConnectionOptions.CopyToPango(ctx, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfBgpPeerGroupPeerBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfBgpPeerGroupPeerBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).Inherit = inherit_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_entry *logical_router.VrfBgpPeerGroupPeerInheritYes
	if o.Yes != nil {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
		}
		// ModelOrObject: Object
		diags.Append(o.Yes.CopyToPango(ctx, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_entry *logical_router.VrfBgpPeerGroupPeerInheritNo
	if o.No != nil {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
		}
		// ModelOrObject: Object
		diags.Append(o.No.CopyToPango(ctx, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInherit)
	}
	(*obj).Yes = yes_entry
	(*obj).No = no_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritYes)
	}

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_entry *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily
	if o.AddressFamily != nil {
		if *obj != nil && (*obj).AddressFamily != nil {
			addressFamily_entry = (*obj).AddressFamily
		} else {
			addressFamily_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
		}
		// ModelOrObject: Object
		diags.Append(o.AddressFamily.CopyToPango(ctx, append(ancestors, o), &addressFamily_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_entry *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile
	if o.FilteringProfile != nil {
		if *obj != nil && (*obj).FilteringProfile != nil {
			filteringProfile_entry = (*obj).FilteringProfile
		} else {
			filteringProfile_entry = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
		}
		// ModelOrObject: Object
		diags.Append(o.FilteringProfile.CopyToPango(ctx, append(ancestors, o), &filteringProfile_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNo)
	}
	(*obj).AddressFamily = addressFamily_entry
	(*obj).FilteringProfile = filteringProfile_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipv4_value := o.Ipv4.ValueStringPointer()
	ipv6_value := o.Ipv6.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile)
	}
	(*obj).Ipv4 = ipv4_value
	(*obj).Ipv6 = ipv6_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	timers_value := o.Timers.ValueStringPointer()
	multihop_value := o.Multihop.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	dampening_value := o.Dampening.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Timers = timers_value
	(*obj).Multihop = multihop_value
	(*obj).Authentication = authentication_value
	(*obj).Dampening = dampening_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summaryOnly_value := o.SummaryOnly.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	sameMed_value := o.SameMed.ValueBoolPointer()
	var type_entry *logical_router.VrfBgpAggregateRoutesType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfBgpAggregateRoutesType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutes)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Enable = enable_value
	(*obj).SummaryOnly = summaryOnly_value
	(*obj).AsSet = asSet_value
	(*obj).SameMed = sameMed_value
	(*obj).Type = type_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *logical_router.VrfBgpAggregateRoutesTypeIpv4
	if o.Ipv4 != nil {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv4.CopyToPango(ctx, append(ancestors, o), &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfBgpAggregateRoutesTypeIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesType)
	}
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv4)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	summaryPrefix_value := o.SummaryPrefix.ValueStringPointer()
	suppressMap_value := o.SuppressMap.ValueStringPointer()
	attributeMap_value := o.AttributeMap.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfBgpAggregateRoutesTypeIpv6)
	}
	(*obj).SummaryPrefix = summaryPrefix_value
	(*obj).SuppressMap = suppressMap_value
	(*obj).AttributeMap = attributeMap_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *logical_router.VrfRoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(logical_router.VrfRoutingTableIp)
		}
		// ModelOrObject: Object
		diags.Append(o.Ip.CopyToPango(ctx, append(ancestors, o), &ip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *logical_router.VrfRoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(logical_router.VrfRoutingTableIpv6)
		}
		// ModelOrObject: Object
		diags.Append(o.Ipv6.CopyToPango(ctx, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpStaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
		}
		// ModelOrObject: Object
		diags.Append(o.PathMonitor.CopyToPango(ctx, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
		}
		// ModelOrObject: Object
		diags.Append(o.Discard.CopyToPango(ctx, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).NextLr = nextLr_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfRoutingTableIpv6StaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
		}
		// ModelOrObject: Object
		diags.Append(o.PathMonitor.CopyToPango(ctx, append(ancestors, o), &pathMonitor_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
		}
		// ModelOrObject: Object
		diags.Append(o.Discard.CopyToPango(ctx, append(ancestors, o), &discard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextLr_value := o.NextLr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextLr = nextLr_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routerId_value := o.RouterId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfGracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterResourceVrfOspfAreaObject
	var area_pango_entries []logical_router.VrfOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfArea
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspf)
	}
	(*obj).RouterId = routerId_value
	(*obj).Enable = enable_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfAreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfAreaType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterResourceVrfOspfAreaRangeObject
	var range_pango_entries []logical_router.VrfOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterResourceVrfOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfAreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfAreaTypeNormal)
		}
		// ModelOrObject: Object
		diags.Append(o.Normal.CopyToPango(ctx, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfAreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfAreaTypeStub)
		}
		// ModelOrObject: Object
		diags.Append(o.Stub.CopyToPango(ctx, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfAreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfAreaTypeNssa)
		}
		// ModelOrObject: Object
		diags.Append(o.Nssa.CopyToPango(ctx, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfAreaTypeNormalAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNormalAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfAreaTypeStubAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeStubAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate
	if o.DefaultInformationOriginate != nil {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
		}
		// ModelOrObject: Object
		diags.Append(o.DefaultInformationOriginate.CopyToPango(ctx, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfAreaTypeNssaAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfAreaTypeNssaAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfAreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfAreaInterfaceLinkType)
		}
		// ModelOrObject: Object
		diags.Append(o.LinkType.CopyToPango(ctx, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfAreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
		}
		// ModelOrObject: Object
		diags.Append(o.Broadcast.CopyToPango(ctx, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
		}
		// ModelOrObject: Object
		diags.Append(o.P2p.CopyToPango(ctx, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
		}
		// ModelOrObject: Object
		diags.Append(o.P2mp.CopyToPango(ctx, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfOspfAreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfAreaVirtualLinkBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3Object) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	spfTimer_value := o.SpfTimer.ValueStringPointer()
	globalIfTimer_value := o.GlobalIfTimer.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfOspfv3GlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfOspfv3GlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *logical_router.VrfOspfv3GracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(logical_router.VrfOspfv3GracefulRestart)
		}
		// ModelOrObject: Object
		diags.Append(o.GracefulRestart.CopyToPango(ctx, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []LogicalRouterResourceVrfOspfv3AreaObject
	var area_pango_entries []logical_router.VrfOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *logical_router.VrfOspfv3Area
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3)
	}
	(*obj).Enable = enable_value
	(*obj).RouterId = routerId_value
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).SpfTimer = spfTimer_value
	(*obj).GlobalIfTimer = globalIfTimer_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	strictLsaChecking_value := o.StrictLsaChecking.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).StrictLSAChecking = strictLsaChecking_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *logical_router.VrfOspfv3AreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(logical_router.VrfOspfv3AreaType)
		}
		// ModelOrObject: Object
		diags.Append(o.Type.CopyToPango(ctx, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []LogicalRouterResourceVrfOspfv3AreaRangeObject
	var range_pango_entries []logical_router.VrfOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *logical_router.VrfOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceObject
	var interface_pango_entries []logical_router.VrfOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []logical_router.VrfOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *logical_router.VrfOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *logical_router.VrfOspfv3AreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(logical_router.VrfOspfv3AreaTypeNormal)
		}
		// ModelOrObject: Object
		diags.Append(o.Normal.CopyToPango(ctx, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *logical_router.VrfOspfv3AreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(logical_router.VrfOspfv3AreaTypeStub)
		}
		// ModelOrObject: Object
		diags.Append(o.Stub.CopyToPango(ctx, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *logical_router.VrfOspfv3AreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(logical_router.VrfOspfv3AreaTypeNssa)
		}
		// ModelOrObject: Object
		diags.Append(o.Nssa.CopyToPango(ctx, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_entry *logical_router.VrfOspfv3AreaTypeNormalAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormal)
	}
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNormalAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var abr_entry *logical_router.VrfOspfv3AreaTypeStubAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeStubAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStub)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).Abr = abr_entry
	(*obj).DefaultRouteMetric = defaultRouteMetric_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeStubAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	noSummary_value := o.NoSummary.ValueBoolPointer()
	var defaultInformationOriginate_entry *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate
	if o.DefaultInformationOriginate != nil {
		if *obj != nil && (*obj).DefaultInformationOriginate != nil {
			defaultInformationOriginate_entry = (*obj).DefaultInformationOriginate
		} else {
			defaultInformationOriginate_entry = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
		}
		// ModelOrObject: Object
		diags.Append(o.DefaultInformationOriginate.CopyToPango(ctx, append(ancestors, o), &defaultInformationOriginate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_entry *logical_router.VrfOspfv3AreaTypeNssaAbr
	if o.Abr != nil {
		if *obj != nil && (*obj).Abr != nil {
			abr_entry = (*obj).Abr
		} else {
			abr_entry = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
		}
		// ModelOrObject: Object
		diags.Append(o.Abr.CopyToPango(ctx, append(ancestors, o), &abr_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssa)
	}
	(*obj).NoSummary = noSummary_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_entry
	(*obj).Abr = abr_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	metricType_value := o.MetricType.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate)
	}
	(*obj).Metric = metric_value
	(*obj).MetricType = metricType_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importList_value := o.ImportList.ValueStringPointer()
	exportList_value := o.ExportList.ValueStringPointer()
	inboundFilterList_value := o.InboundFilterList.ValueStringPointer()
	outboundFilterList_value := o.OutboundFilterList.ValueStringPointer()
	var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
	var nssaExtRange_pango_entries []logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbr)
	}
	(*obj).ImportList = importList_value
	(*obj).ExportList = exportList_value
	(*obj).InboundFilterList = inboundFilterList_value
	(*obj).OutboundFilterList = outboundFilterList_value
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	advertise_value := o.Advertise.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mtuIgnore_value := o.MtuIgnore.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	timing_value := o.Timing.ValueStringPointer()
	var linkType_entry *logical_router.VrfOspfv3AreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
		}
		// ModelOrObject: Object
		diags.Append(o.LinkType.CopyToPango(ctx, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *logical_router.VrfOspfv3AreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfOspfv3AreaInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).MtuIgnore = mtuIgnore_value
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).Metric = metric_value
	(*obj).InstanceId = instanceId_value
	(*obj).Authentication = authentication_value
	(*obj).Timing = timing_value
	(*obj).LinkType = linkType_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		// ModelOrObject: Object
		diags.Append(o.Broadcast.CopyToPango(ctx, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
		}
		// ModelOrObject: Object
		diags.Append(o.P2p.CopyToPango(ctx, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
		}
		// ModelOrObject: Object
		diags.Append(o.P2mp.CopyToPango(ctx, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
	var neighbor_pango_entries []logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp)
	}
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	timing_value := o.Timing.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Timing = timing_value
	(*obj).Authentication = authentication_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	var algorithm_entry *logical_router.VrfEcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(logical_router.VrfEcmpAlgorithm)
		}
		// ModelOrObject: Object
		diags.Append(o.Algorithm.CopyToPango(ctx, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmp)
	}
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).Algorithm = algorithm_entry

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_entry *logical_router.VrfEcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(logical_router.VrfEcmpAlgorithmIpModulo)
		}
		// ModelOrObject: Object
		diags.Append(o.IpModulo.CopyToPango(ctx, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *logical_router.VrfEcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(logical_router.VrfEcmpAlgorithmIpHash)
		}
		// ModelOrObject: Object
		diags.Append(o.IpHash.CopyToPango(ctx, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
		}
		// ModelOrObject: Object
		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_entry *logical_router.VrfEcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
		}
		// ModelOrObject: Object
		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithm)
	}
	(*obj).IpModulo = ipModulo_entry
	(*obj).IpHash = ipHash_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmIpHash)
	}
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(logical_router.VrfEcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *LogicalRouterResourceVrfMulticastObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var staticRoute_tf_entries []LogicalRouterResourceVrfMulticastStaticRouteObject
	var staticRoute_pango_entries []logical_router.VrfMulticastStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *logical_router.VrfMulticastStaticRoute
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}
	var pim_entry *logical_router.VrfMulticastPim
	if o.Pim != nil {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(logical_router.VrfMulticastPim)
		}
		// ModelOrObject: Object
		diags.Append(o.Pim.CopyToPango(ctx, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *logical_router.VrfMulticastIgmp
	if o.Igmp != nil {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(logical_router.VrfMulticastIgmp)
		}
		// ModelOrObject: Object
		diags.Append(o.Igmp.CopyToPango(ctx, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_entry *logical_router.VrfMulticastMsdp
	if o.Msdp != nil {
		if *obj != nil && (*obj).Msdp != nil {
			msdp_entry = (*obj).Msdp
		} else {
			msdp_entry = new(logical_router.VrfMulticastMsdp)
		}
		// ModelOrObject: Object
		diags.Append(o.Msdp.CopyToPango(ctx, append(ancestors, o), &msdp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticast)
	}
	(*obj).Enable = enable_value
	(*obj).StaticRoute = staticRoute_pango_entries
	(*obj).Pim = pim_entry
	(*obj).Igmp = igmp_entry
	(*obj).Msdp = msdp_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	preference_value := o.Preference.ValueInt64Pointer()
	var nexthop_entry *logical_router.VrfMulticastStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(logical_router.VrfMulticastStaticRouteNexthop)
		}
		// ModelOrObject: Object
		diags.Append(o.Nexthop.CopyToPango(ctx, append(ancestors, o), &nexthop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Preference = preference_value
	(*obj).Nexthop = nexthop_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastStaticRouteNexthop)
	}
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	rpfLookupMode_value := o.RpfLookupMode.ValueStringPointer()
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	ifTimerGlobal_value := o.IfTimerGlobal.ValueStringPointer()
	groupPermission_value := o.GroupPermission.ValueStringPointer()
	var ssmAddressSpace_entry *logical_router.VrfMulticastPimSsmAddressSpace
	if o.SsmAddressSpace != nil {
		if *obj != nil && (*obj).SsmAddressSpace != nil {
			ssmAddressSpace_entry = (*obj).SsmAddressSpace
		} else {
			ssmAddressSpace_entry = new(logical_router.VrfMulticastPimSsmAddressSpace)
		}
		// ModelOrObject: Object
		diags.Append(o.SsmAddressSpace.CopyToPango(ctx, append(ancestors, o), &ssmAddressSpace_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_entry *logical_router.VrfMulticastPimRp
	if o.Rp != nil {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(logical_router.VrfMulticastPimRp)
		}
		// ModelOrObject: Object
		diags.Append(o.Rp.CopyToPango(ctx, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []LogicalRouterResourceVrfMulticastPimSptThresholdObject
	var sptThreshold_pango_entries []logical_router.VrfMulticastPimSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *logical_router.VrfMulticastPimSptThreshold
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var interface_tf_entries []LogicalRouterResourceVrfMulticastPimInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastPimInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastPimInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPim)
	}
	(*obj).Enable = enable_value
	(*obj).RpfLookupMode = rpfLookupMode_value
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).IfTimerGlobal = ifTimerGlobal_value
	(*obj).GroupPermission = groupPermission_value
	(*obj).SsmAddressSpace = ssmAddressSpace_entry
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSsmAddressSpace)
	}
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localRp_entry *logical_router.VrfMulticastPimRpLocalRp
	if o.LocalRp != nil {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(logical_router.VrfMulticastPimRpLocalRp)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalRp.CopyToPango(ctx, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var externalRp_tf_entries []LogicalRouterResourceVrfMulticastPimRpExternalRpObject
	var externalRp_pango_entries []logical_router.VrfMulticastPimRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *logical_router.VrfMulticastPimRpExternalRp
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRp)
	}
	(*obj).LocalRp = localRp_entry
	(*obj).ExternalRp = externalRp_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_entry *logical_router.VrfMulticastPimRpLocalRpStaticRp
	if o.StaticRp != nil {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
		}
		// ModelOrObject: Object
		diags.Append(o.StaticRp.CopyToPango(ctx, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_entry *logical_router.VrfMulticastPimRpLocalRpCandidateRp
	if o.CandidateRp != nil {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
		}
		// ModelOrObject: Object
		diags.Append(o.CandidateRp.CopyToPango(ctx, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRp)
	}
	(*obj).StaticRp = staticRp_entry
	(*obj).CandidateRp = candidateRp_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpStaticRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Override = override_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	address_value := o.Address.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	groupList_value := o.GroupList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpLocalRpCandidateRp)
	}
	(*obj).Interface = interface_value
	(*obj).Address = address_value
	(*obj).Priority = priority_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupList = groupList_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupList_value := o.GroupList.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupList = groupList_value
	(*obj).Override = override_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	sendBsm_value := o.SendBsm.ValueBoolPointer()
	ifTimer_value := o.IfTimer.ValueStringPointer()
	neighborFilter_value := o.NeighborFilter.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastPimInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).DrPriority = drPriority_value
	(*obj).SendBsm = sendBsm_value
	(*obj).IfTimer = ifTimer_value
	(*obj).NeighborFilter = neighborFilter_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var dynamic_entry *logical_router.VrfMulticastIgmpDynamic
	if o.Dynamic != nil {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(logical_router.VrfMulticastIgmpDynamic)
		}
		// ModelOrObject: Object
		diags.Append(o.Dynamic.CopyToPango(ctx, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var static_tf_entries []LogicalRouterResourceVrfMulticastIgmpStaticObject
	var static_pango_entries []logical_router.VrfMulticastIgmpStatic
	{
		d := o.Static.ElementsAs(ctx, &static_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range static_tf_entries {
			var entry *logical_router.VrfMulticastIgmpStatic
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			static_pango_entries = append(static_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Dynamic = dynamic_entry
	(*obj).Static = static_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject
	var interface_pango_entries []logical_router.VrfMulticastIgmpDynamicInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *logical_router.VrfMulticastIgmpDynamicInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamic)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	version_value := o.Version.ValueStringPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	groupFilter_value := o.GroupFilter.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	queryProfile_value := o.QueryProfile.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpDynamicInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Version = version_value
	(*obj).Robustness = robustness_value
	(*obj).GroupFilter = groupFilter_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).QueryProfile = queryProfile_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastIgmpStatic)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_value
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	globalAuthentication_value := o.GlobalAuthentication.ValueStringPointer()
	var originatorId_entry *logical_router.VrfMulticastMsdpOriginatorId
	if o.OriginatorId != nil {
		if *obj != nil && (*obj).OriginatorId != nil {
			originatorId_entry = (*obj).OriginatorId
		} else {
			originatorId_entry = new(logical_router.VrfMulticastMsdpOriginatorId)
		}
		// ModelOrObject: Object
		diags.Append(o.OriginatorId.CopyToPango(ctx, append(ancestors, o), &originatorId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []LogicalRouterResourceVrfMulticastMsdpPeerObject
	var peer_pango_entries []logical_router.VrfMulticastMsdpPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *logical_router.VrfMulticastMsdpPeer
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdp)
	}
	(*obj).Enable = enable_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).GlobalAuthentication = globalAuthentication_value
	(*obj).OriginatorId = originatorId_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpOriginatorId)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	maxSa_value := o.MaxSa.ValueInt64Pointer()
	inboundSaFilter_value := o.InboundSaFilter.ValueStringPointer()
	outboundSaFilter_value := o.OutboundSaFilter.ValueStringPointer()
	var localAddress_entry *logical_router.VrfMulticastMsdpPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.LocalAddress.CopyToPango(ctx, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *logical_router.VrfMulticastMsdpPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
		}
		// ModelOrObject: Object
		diags.Append(o.PeerAddress.CopyToPango(ctx, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).Authentication = authentication_value
	(*obj).MaxSa = maxSa_value
	(*obj).InboundSaFilter = inboundSaFilter_value
	(*obj).OutboundSaFilter = outboundSaFilter_value
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfMulticastMsdpPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *LogicalRouterResourceVrfRipObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	defaultInformationOriginate_value := o.DefaultInformationOriginate.ValueBoolPointer()
	globalTimer_value := o.GlobalTimer.ValueStringPointer()
	authProfile_value := o.AuthProfile.ValueStringPointer()
	redistributionProfile_value := o.RedistributionProfile.ValueStringPointer()
	var globalBfd_entry *logical_router.VrfRipGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(logical_router.VrfRipGlobalBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalBfd.CopyToPango(ctx, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_entry *logical_router.VrfRipGlobalInboundDistributeList
	if o.GlobalInboundDistributeList != nil {
		if *obj != nil && (*obj).GlobalInboundDistributeList != nil {
			globalInboundDistributeList_entry = (*obj).GlobalInboundDistributeList
		} else {
			globalInboundDistributeList_entry = new(logical_router.VrfRipGlobalInboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalInboundDistributeList.CopyToPango(ctx, append(ancestors, o), &globalInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_entry *logical_router.VrfRipGlobalOutboundDistributeList
	if o.GlobalOutboundDistributeList != nil {
		if *obj != nil && (*obj).GlobalOutboundDistributeList != nil {
			globalOutboundDistributeList_entry = (*obj).GlobalOutboundDistributeList
		} else {
			globalOutboundDistributeList_entry = new(logical_router.VrfRipGlobalOutboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.GlobalOutboundDistributeList.CopyToPango(ctx, append(ancestors, o), &globalOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []LogicalRouterResourceVrfRipInterfacesObject
	var interfaces_pango_entries []logical_router.VrfRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *logical_router.VrfRipInterface
			diags.Append(elt.CopyToPango(ctx, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRip)
	}
	(*obj).Enable = enable_value
	(*obj).DefaultInformationOriginate = defaultInformationOriginate_value
	(*obj).GlobalTimer = globalTimer_value
	(*obj).AuthProfile = authProfile_value
	(*obj).RedistributionProfile = redistributionProfile_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GlobalInboundDistributeList = globalInboundDistributeList_entry
	(*obj).GlobalOutboundDistributeList = globalOutboundDistributeList_entry
	(*obj).Interface = interfaces_pango_entries

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalInboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipGlobalOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	mode_value := o.Mode.ValueStringPointer()
	splitHorizon_value := o.SplitHorizon.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *logical_router.VrfRipInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(logical_router.VrfRipInterfaceBfd)
		}
		// ModelOrObject: Object
		diags.Append(o.Bfd.CopyToPango(ctx, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceInboundDistributeList
	if o.InterfaceInboundDistributeList != nil {
		if *obj != nil && (*obj).InterfaceInboundDistributeList != nil {
			interfaceInboundDistributeList_entry = (*obj).InterfaceInboundDistributeList
		} else {
			interfaceInboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.InterfaceInboundDistributeList.CopyToPango(ctx, append(ancestors, o), &interfaceInboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_entry *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList
	if o.InterfaceOutboundDistributeList != nil {
		if *obj != nil && (*obj).InterfaceOutboundDistributeList != nil {
			interfaceOutboundDistributeList_entry = (*obj).InterfaceOutboundDistributeList
		} else {
			interfaceOutboundDistributeList_entry = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
		}
		// ModelOrObject: Object
		diags.Append(o.InterfaceOutboundDistributeList.CopyToPango(ctx, append(ancestors, o), &interfaceOutboundDistributeList_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Mode = mode_value
	(*obj).SplitHorizon = splitHorizon_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).InterfaceInboundDistributeList = interfaceInboundDistributeList_entry
	(*obj).InterfaceOutboundDistributeList = interfaceOutboundDistributeList_entry

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceInboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}
func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessList_value := o.AccessList.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(logical_router.VrfRipInterfaceInterfaceOutboundDistributeList)
	}
	(*obj).AccessList = accessList_value
	(*obj).Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var vrf_list types.List
	{
		var vrf_tf_entries []LogicalRouterResourceVrfObject
		for _, elt := range obj.Vrf {
			entry := LogicalRouterResourceVrfObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			vrf_tf_entries = append(vrf_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("vrf")
		vrf_list, list_diags = types.ListValueFrom(ctx, schemaType, vrf_tf_entries)
		diags.Append(list_diags...)
	}

	o.Name = types.StringValue(obj.Name)
	o.Vrf = vrf_list

	return diags
}

func (o *LogicalRouterResourceVrfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.Vrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_object *LogicalRouterResourceVrfAdministrativeDistancesObject
	if obj.AdminDists != nil {
		administrativeDistances_object = new(LogicalRouterResourceVrfAdministrativeDistancesObject)
		diags.Append(administrativeDistances_object.CopyFromPango(ctx, append(ancestors, o), obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ribFilter_object *LogicalRouterResourceVrfRibFilterObject
	if obj.RibFilter != nil {
		ribFilter_object = new(LogicalRouterResourceVrfRibFilterObject)
		diags.Append(ribFilter_object.CopyFromPango(ctx, append(ancestors, o), obj.RibFilter, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterResourceVrfBgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterResourceVrfBgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *LogicalRouterResourceVrfRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(LogicalRouterResourceVrfRoutingTableObject)
		diags.Append(routingTable_object.CopyFromPango(ctx, append(ancestors, o), obj.RoutingTable, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *LogicalRouterResourceVrfOspfObject
	if obj.Ospf != nil {
		ospf_object = new(LogicalRouterResourceVrfOspfObject)
		diags.Append(ospf_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *LogicalRouterResourceVrfOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(LogicalRouterResourceVrfOspfv3Object)
		diags.Append(ospfv3_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_object *LogicalRouterResourceVrfEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(LogicalRouterResourceVrfEcmpObject)
		diags.Append(ecmp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *LogicalRouterResourceVrfMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(LogicalRouterResourceVrfMulticastObject)
		diags.Append(multicast_object.CopyFromPango(ctx, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *LogicalRouterResourceVrfRipObject
	if obj.Rip != nil {
		rip_object = new(LogicalRouterResourceVrfRipObject)
		diags.Append(rip_object.CopyFromPango(ctx, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_list
	o.AdministrativeDistances = administrativeDistances_object
	o.RibFilter = ribFilter_object
	o.Bgp = bgp_object
	o.RoutingTable = routingTable_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.Ecmp = ecmp_object
	o.Multicast = multicast_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterResourceVrfAdministrativeDistancesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfAdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ospfInter_value types.Int64
	if obj.OspfInter != nil {
		ospfInter_value = types.Int64Value(*obj.OspfInter)
	}
	var ospfIntra_value types.Int64
	if obj.OspfIntra != nil {
		ospfIntra_value = types.Int64Value(*obj.OspfIntra)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Inter_value types.Int64
	if obj.Ospfv3Inter != nil {
		ospfv3Inter_value = types.Int64Value(*obj.Ospfv3Inter)
	}
	var ospfv3Intra_value types.Int64
	if obj.Ospfv3Intra != nil {
		ospfv3Intra_value = types.Int64Value(*obj.Ospfv3Intra)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var bgpInternal_value types.Int64
	if obj.BgpInternal != nil {
		bgpInternal_value = types.Int64Value(*obj.BgpInternal)
	}
	var bgpExternal_value types.Int64
	if obj.BgpExternal != nil {
		bgpExternal_value = types.Int64Value(*obj.BgpExternal)
	}
	var bgpLocal_value types.Int64
	if obj.BgpLocal != nil {
		bgpLocal_value = types.Int64Value(*obj.BgpLocal)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value
	o.OspfInter = ospfInter_value
	o.OspfIntra = ospfIntra_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Inter = ospfv3Inter_value
	o.Ospfv3Intra = ospfv3Intra_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.BgpInternal = bgpInternal_value
	o.BgpExternal = bgpExternal_value
	o.BgpLocal = bgpLocal_value
	o.Rip = rip_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterResourceVrfRibFilterIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterResourceVrfRibFilterIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterResourceVrfRibFilterIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterResourceVrfRibFilterIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_object *LogicalRouterResourceVrfRibFilterIpv4StaticObject
	if obj.Static != nil {
		static_object = new(LogicalRouterResourceVrfRibFilterIpv4StaticObject)
		diags.Append(static_object.CopyFromPango(ctx, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterResourceVrfRibFilterIpv4BgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterResourceVrfRibFilterIpv4BgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *LogicalRouterResourceVrfRibFilterIpv4OspfObject
	if obj.Ospf != nil {
		ospf_object = new(LogicalRouterResourceVrfRibFilterIpv4OspfObject)
		diags.Append(ospf_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rip_object *LogicalRouterResourceVrfRibFilterIpv4RipObject
	if obj.Rip != nil {
		rip_object = new(LogicalRouterResourceVrfRibFilterIpv4RipObject)
		diags.Append(rip_object.CopyFromPango(ctx, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Rip = rip_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4StaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4BgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4OspfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Ospf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv4RipObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv4Rip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_object *LogicalRouterResourceVrfRibFilterIpv6StaticObject
	if obj.Static != nil {
		static_object = new(LogicalRouterResourceVrfRibFilterIpv6StaticObject)
		diags.Append(static_object.CopyFromPango(ctx, append(ancestors, o), obj.Static, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *LogicalRouterResourceVrfRibFilterIpv6BgpObject
	if obj.Bgp != nil {
		bgp_object = new(LogicalRouterResourceVrfRibFilterIpv6BgpObject)
		diags.Append(bgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object)
		diags.Append(ospfv3_object.CopyFromPango(ctx, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Static = static_object
	o.Bgp = bgp_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6StaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Static, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6BgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Bgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRibFilterIpv6Ospfv3Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRibFilterIpv6Ospfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var routeMap_value types.String
	if obj.RouteMap != nil {
		routeMap_value = types.StringValue(*obj.RouteMap)
	}
	o.RouteMap = routeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []LogicalRouterResourceVrfBgpPeerGroupObject
		for _, elt := range obj.PeerGroup {
			entry := LogicalRouterResourceVrfBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRoutes_list types.List
	{
		var aggregateRoutes_tf_entries []LogicalRouterResourceVrfBgpAggregateRoutesObject
		for _, elt := range obj.AggregateRoutes {
			entry := LogicalRouterResourceVrfBgpAggregateRoutesObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			aggregateRoutes_tf_entries = append(aggregateRoutes_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("aggregate_routes")
		aggregateRoutes_list, list_diags = types.ListValueFrom(ctx, schemaType, aggregateRoutes_tf_entries)
		diags.Append(list_diags...)
	}
	var med_object *LogicalRouterResourceVrfBgpMedObject
	if obj.Med != nil {
		med_object = new(LogicalRouterResourceVrfBgpMedObject)
		diags.Append(med_object.CopyFromPango(ctx, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterResourceVrfBgpGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterResourceVrfBgpGracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *LogicalRouterResourceVrfBgpGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterResourceVrfBgpGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistributionProfile_object *LogicalRouterResourceVrfBgpRedistributionProfileObject
	if obj.RedistributionProfile != nil {
		redistributionProfile_object = new(LogicalRouterResourceVrfBgpRedistributionProfileObject)
		diags.Append(redistributionProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.RedistributionProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertiseNetwork_object *LogicalRouterResourceVrfBgpAdvertiseNetworkObject
	if obj.AdvertiseNetwork != nil {
		advertiseNetwork_object = new(LogicalRouterResourceVrfBgpAdvertiseNetworkObject)
		diags.Append(advertiseNetwork_object.CopyFromPango(ctx, append(ancestors, o), obj.AdvertiseNetwork, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var fastExternalFailover_value types.Bool
	if obj.FastExternalFailover != nil {
		fastExternalFailover_value = types.BoolValue(*obj.FastExternalFailover)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var gracefulShutdown_value types.Bool
	if obj.GracefulShutdown != nil {
		gracefulShutdown_value = types.BoolValue(*obj.GracefulShutdown)
	}
	var alwaysAdvertiseNetworkRoute_value types.Bool
	if obj.AlwaysAdvertiseNetworkRoute != nil {
		alwaysAdvertiseNetworkRoute_value = types.BoolValue(*obj.AlwaysAdvertiseNetworkRoute)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.LocalAs = localAs_value
	o.InstallRoute = installRoute_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.FastExternalFailover = fastExternalFailover_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulShutdown = gracefulShutdown_value
	o.AlwaysAdvertiseNetworkRoute = alwaysAdvertiseNetworkRoute_value
	o.Med = med_object
	o.GracefulRestart = gracefulRestart_object
	o.GlobalBfd = globalBfd_object
	o.RedistributionProfile = redistributionProfile_object
	o.AdvertiseNetwork = advertiseNetwork_object
	o.PeerGroup = peerGroup_list
	o.AggregateRoutes = aggregateRoutes_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpMedObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpGracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	o.Enable = enable_value
	o.StaleRouteTime = staleRouteTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.LocalRestartTime = localRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpRedistributionProfileIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpRedistributionProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.String
	if obj.Unicast != nil {
		unicast_value = types.StringValue(*obj.Unicast)
	}
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetwork, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject
		for _, elt := range obj.Network {
			entry := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			network_tf_entries = append(network_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv4NetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv4Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	var backdoor_value types.Bool
	if obj.Backdoor != nil {
		backdoor_value = types.BoolValue(*obj.Backdoor)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value
	o.Multicast = multicast_value
	o.Backdoor = backdoor_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var network_list types.List
	{
		var network_tf_entries []LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject
		for _, elt := range obj.Network {
			entry := LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			network_tf_entries = append(network_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("network")
		network_list, list_diags = types.ListValueFrom(ctx, schemaType, network_tf_entries)
		diags.Append(list_diags...)
	}

	o.Network = network_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpAdvertiseNetworkIpv6NetworkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAdvertiseNetworkIpv6Network, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	o.Name = types.StringValue(obj.Name)
	o.Unicast = unicast_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterResourceVrfBgpPeerGroupPeerObject
		for _, elt := range obj.Peer {
			entry := LogicalRouterResourceVrfBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterResourceVrfBgpPeerGroupTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterResourceVrfBgpPeerGroupTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var addressFamily_object *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject
	if obj.AddressFamily != nil {
		addressFamily_object = new(LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject)
		diags.Append(addressFamily_object.CopyFromPango(ctx, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_object *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject
	if obj.FilteringProfile != nil {
		filteringProfile_object = new(LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject)
		diags.Append(filteringProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject)
		diags.Append(connectionOptions_object.CopyFromPango(ctx, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Type = type_object
	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object
	o.ConnectionOptions = connectionOptions_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_object *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject
	if obj.Ibgp != nil {
		ibgp_object = new(LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject)
		diags.Append(ibgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_object *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject
	if obj.Ebgp != nil {
		ebgp_object = new(LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject)
		diags.Append(ebgp_object.CopyFromPango(ctx, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupAddressFamilyObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupFilteringProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupConnectionOptionsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var inherit_object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject
	if obj.Inherit != nil {
		inherit_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject)
		diags.Append(inherit_object.CopyFromPango(ctx, append(ancestors, o), obj.Inherit, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject)
		diags.Append(localAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject)
		diags.Append(peerAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject)
		diags.Append(connectionOptions_object.CopyFromPango(ctx, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.PeerAs = peerAs_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.Inherit = inherit_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInherit, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var yes_object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject
	if obj.Yes != nil {
		yes_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject)
		diags.Append(yes_object.CopyFromPango(ctx, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var no_object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject
	if obj.No != nil {
		no_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject)
		diags.Append(no_object.CopyFromPango(ctx, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Yes = yes_object
	o.No = no_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritYesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressFamily_object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject
	if obj.AddressFamily != nil {
		addressFamily_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject)
		diags.Append(addressFamily_object.CopyFromPango(ctx, append(ancestors, o), obj.AddressFamily, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var filteringProfile_object *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject
	if obj.FilteringProfile != nil {
		filteringProfile_object = new(LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject)
		diags.Append(filteringProfile_object.CopyFromPango(ctx, append(ancestors, o), obj.FilteringProfile, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.AddressFamily = addressFamily_object
	o.FilteringProfile = filteringProfile_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoAddressFamilyObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoAddressFamily, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerInheritNoFilteringProfileObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerInheritNoFilteringProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_value types.String
	if obj.Ipv4 != nil {
		ipv4_value = types.StringValue(*obj.Ipv4)
	}
	var ipv6_value types.String
	if obj.Ipv6 != nil {
		ipv6_value = types.StringValue(*obj.Ipv6)
	}
	o.Ipv4 = ipv4_value
	o.Ipv6 = ipv6_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var timers_value types.String
	if obj.Timers != nil {
		timers_value = types.StringValue(*obj.Timers)
	}
	var multihop_value types.String
	if obj.Multihop != nil {
		multihop_value = types.StringValue(*obj.Multihop)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Timers = timers_value
	o.Multihop = multihop_value
	o.Authentication = authentication_value
	o.Dampening = dampening_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summaryOnly_value types.Bool
	if obj.SummaryOnly != nil {
		summaryOnly_value = types.BoolValue(*obj.SummaryOnly)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	var sameMed_value types.Bool
	if obj.SameMed != nil {
		sameMed_value = types.BoolValue(*obj.SameMed)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Enable = enable_value
	o.SummaryOnly = summaryOnly_value
	o.AsSet = asSet_value
	o.SameMed = sameMed_value
	o.Type = type_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_object *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object
	if obj.Ipv4 != nil {
		ipv4_object = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object)
		diags.Append(ipv4_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv4Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfBgpAggregateRoutesTypeIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfBgpAggregateRoutesTypeIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var summaryPrefix_value types.String
	if obj.SummaryPrefix != nil {
		summaryPrefix_value = types.StringValue(*obj.SummaryPrefix)
	}
	var suppressMap_value types.String
	if obj.SuppressMap != nil {
		suppressMap_value = types.StringValue(*obj.SuppressMap)
	}
	var attributeMap_value types.String
	if obj.AttributeMap != nil {
		attributeMap_value = types.StringValue(*obj.AttributeMap)
	}
	o.SummaryPrefix = summaryPrefix_value
	o.SuppressMap = suppressMap_value
	o.AttributeMap = attributeMap_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *LogicalRouterResourceVrfRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(LogicalRouterResourceVrfRoutingTableIpObject)
		diags.Append(ip_object.CopyFromPango(ctx, append(ancestors, o), obj.Ip, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *LogicalRouterResourceVrfRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(LogicalRouterResourceVrfRoutingTableIpv6Object)
		diags.Append(ipv6_object.CopyFromPango(ctx, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfRoutingTableIpStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject)
		diags.Append(pathMonitor_object.CopyFromPango(ctx, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_object *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject)
		diags.Append(discard_object.CopyFromPango(ctx, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.NextLr = nextLr_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			entry := LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpStaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject)
		diags.Append(pathMonitor_object.CopyFromPango(ctx, append(ancestors, o), obj.PathMonitor, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_object *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject)
		diags.Append(discard_object.CopyFromPango(ctx, append(ancestors, o), obj.Discard, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextLr_value types.String
	if obj.NextLr != nil {
		nextLr_value = types.StringValue(*obj.NextLr)
	}
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.Fqdn = fqdn_value
	o.NextLr = nextLr_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteNexthopDiscard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRouteBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			entry := LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *LogicalRouterResourceVrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterResourceVrfOspfAreaObject
		for _, elt := range obj.Area {
			entry := LogicalRouterResourceVrfOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterResourceVrfOspfGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterResourceVrfOspfGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterResourceVrfOspfGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterResourceVrfOspfGracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.RouterId = routerId_value
	o.Enable = enable_value
	o.Rfc1583 = rfc1583_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfGracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterResourceVrfOspfAreaRangeObject
		for _, elt := range obj.Range {
			entry := LogicalRouterResourceVrfOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterResourceVrfOspfAreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			entry := LogicalRouterResourceVrfOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterResourceVrfOspfAreaTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterResourceVrfOspfAreaTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *LogicalRouterResourceVrfOspfAreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(LogicalRouterResourceVrfOspfAreaTypeNormalObject)
		diags.Append(normal_object.CopyFromPango(ctx, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *LogicalRouterResourceVrfOspfAreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(LogicalRouterResourceVrfOspfAreaTypeStubObject)
		diags.Append(stub_object.CopyFromPango(ctx, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *LogicalRouterResourceVrfOspfAreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(LogicalRouterResourceVrfOspfAreaTypeNssaObject)
		diags.Append(nssa_object.CopyFromPango(ctx, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfAreaTypeStubAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeStubAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultInformationOriginate_object *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_object = new(LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject)
		diags.Append(defaultInformationOriginate_object.CopyFromPango(ctx, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_object *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			entry := LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var linkType_object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject)
		diags.Append(linkType_object.CopyFromPango(ctx, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfOspfAreaInterfaceBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject)
		diags.Append(broadcast_object.CopyFromPango(ctx, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject)
		diags.Append(p2p_object.CopyFromPango(ctx, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject)
		diags.Append(p2mp_object.CopyFromPango(ctx, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject
		for _, elt := range obj.Neighbor {
			entry := LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3Object) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []LogicalRouterResourceVrfOspfv3AreaObject
		for _, elt := range obj.Area {
			entry := LogicalRouterResourceVrfOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterResourceVrfOspfv3GlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterResourceVrfOspfv3GlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *LogicalRouterResourceVrfOspfv3GracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(LogicalRouterResourceVrfOspfv3GracefulRestartObject)
		diags.Append(gracefulRestart_object.CopyFromPango(ctx, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var spfTimer_value types.String
	if obj.SpfTimer != nil {
		spfTimer_value = types.StringValue(*obj.SpfTimer)
	}
	var globalIfTimer_value types.String
	if obj.GlobalIfTimer != nil {
		globalIfTimer_value = types.StringValue(*obj.GlobalIfTimer)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.RouterId = routerId_value
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.SpfTimer = spfTimer_value
	o.GlobalIfTimer = globalIfTimer_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.Area = area_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var strictLsaChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLsaChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.StrictLsaChecking = strictLsaChecking_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []LogicalRouterResourceVrfOspfv3AreaRangeObject
		for _, elt := range obj.Range {
			entry := LogicalRouterResourceVrfOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			entry := LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *LogicalRouterResourceVrfOspfv3AreaTypeObject
	if obj.Type != nil {
		type_object = new(LogicalRouterResourceVrfOspfv3AreaTypeObject)
		diags.Append(type_object.CopyFromPango(ctx, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(LogicalRouterResourceVrfOspfv3AreaTypeNormalObject)
		diags.Append(normal_object.CopyFromPango(ctx, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *LogicalRouterResourceVrfOspfv3AreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(LogicalRouterResourceVrfOspfv3AreaTypeStubObject)
		diags.Append(stub_object.CopyFromPango(ctx, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaObject)
		diags.Append(nssa_object.CopyFromPango(ctx, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNormalAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNormalAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var abr_object *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	o.NoSummary = noSummary_value
	o.Abr = abr_object
	o.DefaultRouteMetric = defaultRouteMetric_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeStubAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeStubAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultInformationOriginate_object *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_object = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject)
		diags.Append(defaultInformationOriginate_object.CopyFromPango(ctx, append(ancestors, o), obj.DefaultInformationOriginate, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var abr_object *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject
	if obj.Abr != nil {
		abr_object = new(LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject)
		diags.Append(abr_object.CopyFromPango(ctx, append(ancestors, o), obj.Abr, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var noSummary_value types.Bool
	if obj.NoSummary != nil {
		noSummary_value = types.BoolValue(*obj.NoSummary)
	}
	o.NoSummary = noSummary_value
	o.DefaultInformationOriginate = defaultInformationOriginate_object
	o.Abr = abr_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaDefaultInformationOriginateObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaDefaultInformationOriginate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var metricType_value types.String
	if obj.MetricType != nil {
		metricType_value = types.StringValue(*obj.MetricType)
	}
	o.Metric = metric_value
	o.MetricType = metricType_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			entry := LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var importList_value types.String
	if obj.ImportList != nil {
		importList_value = types.StringValue(*obj.ImportList)
	}
	var exportList_value types.String
	if obj.ExportList != nil {
		exportList_value = types.StringValue(*obj.ExportList)
	}
	var inboundFilterList_value types.String
	if obj.InboundFilterList != nil {
		inboundFilterList_value = types.StringValue(*obj.InboundFilterList)
	}
	var outboundFilterList_value types.String
	if obj.OutboundFilterList != nil {
		outboundFilterList_value = types.StringValue(*obj.OutboundFilterList)
	}
	o.ImportList = importList_value
	o.ExportList = exportList_value
	o.InboundFilterList = inboundFilterList_value
	o.OutboundFilterList = outboundFilterList_value
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaTypeNssaAbrNssaExtRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaTypeNssaAbrNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_value types.Bool
	if obj.Advertise != nil {
		advertise_value = types.BoolValue(*obj.Advertise)
	}
	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var linkType_object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject)
		diags.Append(linkType_object.CopyFromPango(ctx, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mtuIgnore_value types.Bool
	if obj.MtuIgnore != nil {
		mtuIgnore_value = types.BoolValue(*obj.MtuIgnore)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.MtuIgnore = mtuIgnore_value
	o.Passive = passive_value
	o.Priority = priority_value
	o.Metric = metric_value
	o.InstanceId = instanceId_value
	o.Authentication = authentication_value
	o.Timing = timing_value
	o.LinkType = linkType_object
	o.Bfd = bfd_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject)
		diags.Append(broadcast_object.CopyFromPango(ctx, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject)
		diags.Append(p2p_object.CopyFromPango(ctx, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject)
		diags.Append(p2mp_object.CopyFromPango(ctx, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject
		for _, elt := range obj.Neighbor {
			entry := LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	o.Neighbor = neighbor_list

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceLinkTypeP2mpNeighborObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceLinkTypeP2mpNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var timing_value types.String
	if obj.Timing != nil {
		timing_value = types.StringValue(*obj.Timing)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Timing = timing_value
	o.Authentication = authentication_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *LogicalRouterResourceVrfEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(LogicalRouterResourceVrfEcmpAlgorithmObject)
		diags.Append(algorithm_object.CopyFromPango(ctx, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.SymmetricReturn = symmetricReturn_value
	o.StrictSourcePath = strictSourcePath_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipModulo_object *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject)
		diags.Append(ipModulo_object.CopyFromPango(ctx, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(LogicalRouterResourceVrfEcmpAlgorithmIpHashObject)
		diags.Append(ipHash_object.CopyFromPango(ctx, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_object *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject)
		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var balancedRoundRobin_object *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject)
		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.IpModulo = ipModulo_object
	o.IpHash = ipHash_object
	o.WeightedRoundRobin = weightedRoundRobin_object
	o.BalancedRoundRobin = balancedRoundRobin_object

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value
	o.HashSeed = hashSeed_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *LogicalRouterResourceVrfEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfEcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *LogicalRouterResourceVrfMulticastObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []LogicalRouterResourceVrfMulticastStaticRouteObject
		for _, elt := range obj.StaticRoute {
			entry := LogicalRouterResourceVrfMulticastStaticRouteObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}
	var pim_object *LogicalRouterResourceVrfMulticastPimObject
	if obj.Pim != nil {
		pim_object = new(LogicalRouterResourceVrfMulticastPimObject)
		diags.Append(pim_object.CopyFromPango(ctx, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_object *LogicalRouterResourceVrfMulticastIgmpObject
	if obj.Igmp != nil {
		igmp_object = new(LogicalRouterResourceVrfMulticastIgmpObject)
		diags.Append(igmp_object.CopyFromPango(ctx, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var msdp_object *LogicalRouterResourceVrfMulticastMsdpObject
	if obj.Msdp != nil {
		msdp_object = new(LogicalRouterResourceVrfMulticastMsdpObject)
		diags.Append(msdp_object.CopyFromPango(ctx, append(ancestors, o), obj.Msdp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.StaticRoute = staticRoute_list
	o.Pim = pim_object
	o.Igmp = igmp_object
	o.Msdp = msdp_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(LogicalRouterResourceVrfMulticastStaticRouteNexthopObject)
		diags.Append(nexthop_object.CopyFromPango(ctx, append(ancestors, o), obj.Nexthop, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var preference_value types.Int64
	if obj.Preference != nil {
		preference_value = types.Int64Value(*obj.Preference)
	}
	o.Name = types.StringValue(obj.Name)
	o.Destination = destination_value
	o.Interface = interface_value
	o.Preference = preference_value
	o.Nexthop = nexthop_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastStaticRouteNexthopObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastStaticRouteNexthop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.IpAddress = ipAddress_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []LogicalRouterResourceVrfMulticastPimSptThresholdObject
		for _, elt := range obj.SptThreshold {
			entry := LogicalRouterResourceVrfMulticastPimSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfMulticastPimInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfMulticastPimInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var ssmAddressSpace_object *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject
	if obj.SsmAddressSpace != nil {
		ssmAddressSpace_object = new(LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject)
		diags.Append(ssmAddressSpace_object.CopyFromPango(ctx, append(ancestors, o), obj.SsmAddressSpace, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var rp_object *LogicalRouterResourceVrfMulticastPimRpObject
	if obj.Rp != nil {
		rp_object = new(LogicalRouterResourceVrfMulticastPimRpObject)
		diags.Append(rp_object.CopyFromPango(ctx, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rpfLookupMode_value types.String
	if obj.RpfLookupMode != nil {
		rpfLookupMode_value = types.StringValue(*obj.RpfLookupMode)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	var ifTimerGlobal_value types.String
	if obj.IfTimerGlobal != nil {
		ifTimerGlobal_value = types.StringValue(*obj.IfTimerGlobal)
	}
	var groupPermission_value types.String
	if obj.GroupPermission != nil {
		groupPermission_value = types.StringValue(*obj.GroupPermission)
	}
	o.Enable = enable_value
	o.RpfLookupMode = rpfLookupMode_value
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.IfTimerGlobal = ifTimerGlobal_value
	o.GroupPermission = groupPermission_value
	o.SsmAddressSpace = ssmAddressSpace_object
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimSsmAddressSpaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []LogicalRouterResourceVrfMulticastPimRpExternalRpObject
		for _, elt := range obj.ExternalRp {
			entry := LogicalRouterResourceVrfMulticastPimRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_tf_entries = append(externalRp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}
	var localRp_object *LogicalRouterResourceVrfMulticastPimRpLocalRpObject
	if obj.LocalRp != nil {
		localRp_object = new(LogicalRouterResourceVrfMulticastPimRpLocalRpObject)
		diags.Append(localRp_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.LocalRp = localRp_object
	o.ExternalRp = externalRp_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRp_object *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject
	if obj.StaticRp != nil {
		staticRp_object = new(LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject)
		diags.Append(staticRp_object.CopyFromPango(ctx, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var candidateRp_object *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject
	if obj.CandidateRp != nil {
		candidateRp_object = new(LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject)
		diags.Append(candidateRp_object.CopyFromPango(ctx, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	o.StaticRp = staticRp_object
	o.CandidateRp = candidateRp_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Override = override_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	o.Interface = interface_value
	o.Address = address_value
	o.Priority = priority_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupList = groupList_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimRpExternalRpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupList_value types.String
	if obj.GroupList != nil {
		groupList_value = types.StringValue(*obj.GroupList)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupList = groupList_value
	o.Override = override_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimSptThresholdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastPimInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastPimInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var sendBsm_value types.Bool
	if obj.SendBsm != nil {
		sendBsm_value = types.BoolValue(*obj.SendBsm)
	}
	var ifTimer_value types.String
	if obj.IfTimer != nil {
		ifTimer_value = types.StringValue(*obj.IfTimer)
	}
	var neighborFilter_value types.String
	if obj.NeighborFilter != nil {
		neighborFilter_value = types.StringValue(*obj.NeighborFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.DrPriority = drPriority_value
	o.SendBsm = sendBsm_value
	o.IfTimer = ifTimer_value
	o.NeighborFilter = neighborFilter_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var static_list types.List
	{
		var static_tf_entries []LogicalRouterResourceVrfMulticastIgmpStaticObject
		for _, elt := range obj.Static {
			entry := LogicalRouterResourceVrfMulticastIgmpStaticObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			static_tf_entries = append(static_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static")
		static_list, list_diags = types.ListValueFrom(ctx, schemaType, static_tf_entries)
		diags.Append(list_diags...)
	}
	var dynamic_object *LogicalRouterResourceVrfMulticastIgmpDynamicObject
	if obj.Dynamic != nil {
		dynamic_object = new(LogicalRouterResourceVrfMulticastIgmpDynamicObject)
		diags.Append(dynamic_object.CopyFromPango(ctx, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Dynamic = dynamic_object
	o.Static = static_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpDynamicInterfaceObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpDynamicInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var groupFilter_value types.String
	if obj.GroupFilter != nil {
		groupFilter_value = types.StringValue(*obj.GroupFilter)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var queryProfile_value types.String
	if obj.QueryProfile != nil {
		queryProfile_value = types.StringValue(*obj.QueryProfile)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Name = types.StringValue(obj.Name)
	o.Version = version_value
	o.Robustness = robustness_value
	o.GroupFilter = groupFilter_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.QueryProfile = queryProfile_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastIgmpStaticObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastIgmpStatic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_value
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []LogicalRouterResourceVrfMulticastMsdpPeerObject
		for _, elt := range obj.Peer {
			entry := LogicalRouterResourceVrfMulticastMsdpPeerObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var originatorId_object *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject
	if obj.OriginatorId != nil {
		originatorId_object = new(LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject)
		diags.Append(originatorId_object.CopyFromPango(ctx, append(ancestors, o), obj.OriginatorId, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var globalAuthentication_value types.String
	if obj.GlobalAuthentication != nil {
		globalAuthentication_value = types.StringValue(*obj.GlobalAuthentication)
	}
	o.Enable = enable_value
	o.GlobalTimer = globalTimer_value
	o.GlobalAuthentication = globalAuthentication_value
	o.OriginatorId = originatorId_object
	o.Peer = peer_list

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpOriginatorIdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpOriginatorId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var localAddress_object *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject)
		diags.Append(localAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject)
		diags.Append(peerAddress_object.CopyFromPango(ctx, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var maxSa_value types.Int64
	if obj.MaxSa != nil {
		maxSa_value = types.Int64Value(*obj.MaxSa)
	}
	var inboundSaFilter_value types.String
	if obj.InboundSaFilter != nil {
		inboundSaFilter_value = types.StringValue(*obj.InboundSaFilter)
	}
	var outboundSaFilter_value types.String
	if obj.OutboundSaFilter != nil {
		outboundSaFilter_value = types.StringValue(*obj.OutboundSaFilter)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.Authentication = authentication_value
	o.MaxSa = maxSa_value
	o.InboundSaFilter = inboundSaFilter_value
	o.OutboundSaFilter = outboundSaFilter_value
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerLocalAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *LogicalRouterResourceVrfMulticastMsdpPeerPeerAddressObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfMulticastMsdpPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *LogicalRouterResourceVrfRipObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []LogicalRouterResourceVrfRipInterfacesObject
		for _, elt := range obj.Interface {
			entry := LogicalRouterResourceVrfRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			diags.Append(entry.CopyFromPango(ctx, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *LogicalRouterResourceVrfRipGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(LogicalRouterResourceVrfRipGlobalBfdObject)
		diags.Append(globalBfd_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalInboundDistributeList_object *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject
	if obj.GlobalInboundDistributeList != nil {
		globalInboundDistributeList_object = new(LogicalRouterResourceVrfRipGlobalInboundDistributeListObject)
		diags.Append(globalInboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalOutboundDistributeList_object *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject
	if obj.GlobalOutboundDistributeList != nil {
		globalOutboundDistributeList_object = new(LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject)
		diags.Append(globalOutboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.GlobalOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var defaultInformationOriginate_value types.Bool
	if obj.DefaultInformationOriginate != nil {
		defaultInformationOriginate_value = types.BoolValue(*obj.DefaultInformationOriginate)
	}
	var globalTimer_value types.String
	if obj.GlobalTimer != nil {
		globalTimer_value = types.StringValue(*obj.GlobalTimer)
	}
	var authProfile_value types.String
	if obj.AuthProfile != nil {
		authProfile_value = types.StringValue(*obj.AuthProfile)
	}
	var redistributionProfile_value types.String
	if obj.RedistributionProfile != nil {
		redistributionProfile_value = types.StringValue(*obj.RedistributionProfile)
	}
	o.Enable = enable_value
	o.DefaultInformationOriginate = defaultInformationOriginate_value
	o.GlobalTimer = globalTimer_value
	o.AuthProfile = authProfile_value
	o.RedistributionProfile = redistributionProfile_value
	o.GlobalBfd = globalBfd_object
	o.GlobalInboundDistributeList = globalInboundDistributeList_object
	o.GlobalOutboundDistributeList = globalOutboundDistributeList_object
	o.Interfaces = interfaces_list

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalInboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterResourceVrfRipGlobalOutboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipGlobalOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	o.AccessList = accessList_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *LogicalRouterResourceVrfRipInterfacesBfdObject
	if obj.Bfd != nil {
		bfd_object = new(LogicalRouterResourceVrfRipInterfacesBfdObject)
		diags.Append(bfd_object.CopyFromPango(ctx, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceInboundDistributeList_object *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject
	if obj.InterfaceInboundDistributeList != nil {
		interfaceInboundDistributeList_object = new(LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject)
		diags.Append(interfaceInboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.InterfaceInboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaceOutboundDistributeList_object *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject
	if obj.InterfaceOutboundDistributeList != nil {
		interfaceOutboundDistributeList_object = new(LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject)
		diags.Append(interfaceOutboundDistributeList_object.CopyFromPango(ctx, append(ancestors, o), obj.InterfaceOutboundDistributeList, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var splitHorizon_value types.String
	if obj.SplitHorizon != nil {
		splitHorizon_value = types.StringValue(*obj.SplitHorizon)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Mode = mode_value
	o.SplitHorizon = splitHorizon_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.InterfaceInboundDistributeList = interfaceInboundDistributeList_object
	o.InterfaceOutboundDistributeList = interfaceOutboundDistributeList_object

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesBfdObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceInboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceInboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceVrfRipInterfacesInterfaceOutboundDistributeListObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *logical_router.VrfRipInterfaceInterfaceOutboundDistributeList, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var accessList_value types.String
	if obj.AccessList != nil {
		accessList_value = types.StringValue(*obj.AccessList)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.AccessList = accessList_value
	o.Metric = metric_value

	return diags
}

func (o *LogicalRouterResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (r *LogicalRouterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *logical_router.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := r.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *LogicalRouterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *LogicalRouterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := r.manager.Read(ctx, location, components, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := r.manager.Update(ctx, location, components, obj, obj.Name)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *LogicalRouterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state LogicalRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_logical_router_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location logical_router.Location

	{
		var terraformLocation LogicalRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Vsys.IsNull() {
			location.Vsys = &logical_router.VsysLocation{}
			var innerLocation LogicalRouterVsysLocation
			resp.Diagnostics.Append(terraformLocation.Vsys.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Vsys.NgfwDevice = innerLocation.NgfwDevice.ValueString()
			location.Vsys.Vsys = innerLocation.Name.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &logical_router.TemplateLocation{}
			var innerLocation LogicalRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &logical_router.TemplateStackLocation{}
			var innerLocation LogicalRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = r.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type LogicalRouterImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o LogicalRouterImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *LogicalRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}
	var location_object *LogicalRouterLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *LogicalRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func LogicalRouterImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := LogicalRouterImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *LogicalRouterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj LogicalRouterImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type LogicalRouterVsysLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
	Name       types.String `tfsdk:"name"`
}
type LogicalRouterTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type LogicalRouterTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type LogicalRouterLocation struct {
	Vsys          types.Object `tfsdk:"vsys"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func LogicalRouterLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"vsys": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Virtual System",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "The Virtual System name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("vsys"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o LogicalRouterVsysLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
		Name:       o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterVsysLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
		Name       *string `json:"name,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o LogicalRouterTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o LogicalRouterTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o LogicalRouterLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Vsys          *LogicalRouterVsysLocation          `json:"vsys,omitempty"`
		Template      *LogicalRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *LogicalRouterTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var vsys_object *LogicalRouterVsysLocation
	{
		diags := o.Vsys.As(context.TODO(), &vsys_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal vsys into JSON document", diags.Errors())
		}
	}
	var template_object *LogicalRouterTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *LogicalRouterTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Vsys:          vsys_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *LogicalRouterLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Vsys          *LogicalRouterVsysLocation          `json:"vsys,omitempty"`
		Template      *LogicalRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *LogicalRouterTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var vsys_object types.Object
	{
		var diags_tmp diag.Diagnostics
		vsys_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Vsys.AttributeTypes(), shadow.Vsys)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into vsys", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Vsys = vsys_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *LogicalRouterVsysLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
		"name":        types.StringType,
	}
}
func (o *LogicalRouterTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *LogicalRouterTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *LogicalRouterLocation) AttributeTypes() map[string]attr.Type {
	var vsysObj LogicalRouterVsysLocation
	var templateObj LogicalRouterTemplateLocation
	var templateStackObj LogicalRouterTemplateStackLocation
	return map[string]attr.Type{
		"vsys": types.ObjectType{
			AttrTypes: vsysObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
