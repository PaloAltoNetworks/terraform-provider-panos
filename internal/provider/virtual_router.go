package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/virtual_router"

	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &VirtualRouterDataSource{}
	_ datasource.DataSourceWithConfigure = &VirtualRouterDataSource{}
)

func NewVirtualRouterDataSource() datasource.DataSource {
	return &VirtualRouterDataSource{}
}

type VirtualRouterDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}

type VirtualRouterDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type VirtualRouterDataSourceModel struct {
	Location                VirtualRouterLocation                                 `tfsdk:"location"`
	Name                    types.String                                          `tfsdk:"name"`
	Interfaces              types.List                                            `tfsdk:"interfaces"`
	Multicast               *VirtualRouterDataSourceMulticastObject               `tfsdk:"multicast"`
	Protocol                *VirtualRouterDataSourceProtocolObject                `tfsdk:"protocol"`
	RoutingTable            *VirtualRouterDataSourceRoutingTableObject            `tfsdk:"routing_table"`
	AdministrativeDistances *VirtualRouterDataSourceAdministrativeDistancesObject `tfsdk:"administrative_distances"`
	Ecmp                    *VirtualRouterDataSourceEcmpObject                    `tfsdk:"ecmp"`
}
type VirtualRouterDataSourceMulticastObject struct {
	Rp              *VirtualRouterDataSourceMulticastRpObject `tfsdk:"rp"`
	SptThreshold    types.List                                `tfsdk:"spt_threshold"`
	SsmAddressSpace types.List                                `tfsdk:"ssm_address_space"`
	Enable          types.Bool                                `tfsdk:"enable"`
	InterfaceGroup  types.List                                `tfsdk:"interface_group"`
	RouteAgeoutTime types.Int64                               `tfsdk:"route_ageout_time"`
}
type VirtualRouterDataSourceMulticastSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type VirtualRouterDataSourceMulticastSsmAddressSpaceObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupObject struct {
	Name            types.String                                                         `tfsdk:"name"`
	Igmp            *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject            `tfsdk:"igmp"`
	Pim             *VirtualRouterDataSourceMulticastInterfaceGroupPimObject             `tfsdk:"pim"`
	Description     types.String                                                         `tfsdk:"description"`
	Interface       types.List                                                           `tfsdk:"interface"`
	GroupPermission *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject `tfsdk:"group_permission"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject struct {
	SourceSpecificMulticast types.List `tfsdk:"source_specific_multicast"`
	AnySourceMulticast      types.List `tfsdk:"any_source_multicast"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject struct {
	Name          types.String `tfsdk:"name"`
	SourceAddress types.String `tfsdk:"source_address"`
	Included      types.Bool   `tfsdk:"included"`
	GroupAddress  types.String `tfsdk:"group_address"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject struct {
	MaxQueryResponseTime    types.Float64 `tfsdk:"max_query_response_time"`
	LastMemberQueryInterval types.Float64 `tfsdk:"last_member_query_interval"`
	Robustness              types.String  `tfsdk:"robustness"`
	MaxGroups               types.String  `tfsdk:"max_groups"`
	RouterAlertPolicing     types.Bool    `tfsdk:"router_alert_policing"`
	Enable                  types.Bool    `tfsdk:"enable"`
	Version                 types.String  `tfsdk:"version"`
	QueryInterval           types.Int64   `tfsdk:"query_interval"`
	ImmediateLeave          types.Bool    `tfsdk:"immediate_leave"`
	MaxSources              types.String  `tfsdk:"max_sources"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupPimObject struct {
	HelloInterval     types.Int64 `tfsdk:"hello_interval"`
	JoinPruneInterval types.Int64 `tfsdk:"join_prune_interval"`
	DrPriority        types.Int64 `tfsdk:"dr_priority"`
	BsrBorder         types.Bool  `tfsdk:"bsr_border"`
	AllowedNeighbors  types.List  `tfsdk:"allowed_neighbors"`
	Enable            types.Bool  `tfsdk:"enable"`
	AssertInterval    types.Int64 `tfsdk:"assert_interval"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceMulticastRpObject struct {
	ExternalRp types.List                                       `tfsdk:"external_rp"`
	LocalRp    *VirtualRouterDataSourceMulticastRpLocalRpObject `tfsdk:"local_rp"`
}
type VirtualRouterDataSourceMulticastRpExternalRpObject struct {
	Name           types.String `tfsdk:"name"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterDataSourceMulticastRpLocalRpObject struct {
	CandidateRp *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject `tfsdk:"candidate_rp"`
	StaticRp    *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject    `tfsdk:"static_rp"`
}
type VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject struct {
	Interface             types.String `tfsdk:"interface"`
	Priority              types.Int64  `tfsdk:"priority"`
	Address               types.String `tfsdk:"address"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupAddresses        types.List   `tfsdk:"group_addresses"`
}
type VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject struct {
	Address        types.String `tfsdk:"address"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Interface      types.String `tfsdk:"interface"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterDataSourceProtocolObject struct {
	Ospfv3            *VirtualRouterDataSourceProtocolOspfv3Object `tfsdk:"ospfv3"`
	RedistProfile     types.List                                   `tfsdk:"redist_profile"`
	RedistProfileIpv6 types.List                                   `tfsdk:"redist_profile_ipv6"`
	Rip               *VirtualRouterDataSourceProtocolRipObject    `tfsdk:"rip"`
	Bgp               *VirtualRouterDataSourceProtocolBgpObject    `tfsdk:"bgp"`
	Ospf              *VirtualRouterDataSourceProtocolOspfObject   `tfsdk:"ospf"`
}
type VirtualRouterDataSourceProtocolBgpObject struct {
	DampeningProfile        types.List                                              `tfsdk:"dampening_profile"`
	InstallRoute            types.Bool                                              `tfsdk:"install_route"`
	Policy                  *VirtualRouterDataSourceProtocolBgpPolicyObject         `tfsdk:"policy"`
	RedistRules             types.List                                              `tfsdk:"redist_rules"`
	RouterId                types.String                                            `tfsdk:"router_id"`
	RoutingOptions          *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject `tfsdk:"routing_options"`
	AllowRedistDefaultRoute types.Bool                                              `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                              `tfsdk:"auth_profile"`
	GlobalBfd               *VirtualRouterDataSourceProtocolBgpGlobalBfdObject      `tfsdk:"global_bfd"`
	LocalAs                 types.String                                            `tfsdk:"local_as"`
	EcmpMultiAs             types.Bool                                              `tfsdk:"ecmp_multi_as"`
	Enable                  types.Bool                                              `tfsdk:"enable"`
	PeerGroup               types.List                                              `tfsdk:"peer_group"`
	RejectDefaultRoute      types.Bool                                              `tfsdk:"reject_default_route"`
	EnforceFirstAs          types.Bool                                              `tfsdk:"enforce_first_as"`
}
type VirtualRouterDataSourceProtocolBgpDampeningProfileObject struct {
	Name                     types.String  `tfsdk:"name"`
	Reuse                    types.Float64 `tfsdk:"reuse"`
	MaxHoldTime              types.Int64   `tfsdk:"max_hold_time"`
	DecayHalfLifeReachable   types.Int64   `tfsdk:"decay_half_life_reachable"`
	DecayHalfLifeUnreachable types.Int64   `tfsdk:"decay_half_life_unreachable"`
	Enable                   types.Bool    `tfsdk:"enable"`
	Cutoff                   types.Float64 `tfsdk:"cutoff"`
}
type VirtualRouterDataSourceProtocolBgpPolicyObject struct {
	Aggregation              *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject              `tfsdk:"aggregation"`
	ConditionalAdvertisement *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject `tfsdk:"conditional_advertisement"`
	Export                   *VirtualRouterDataSourceProtocolBgpPolicyExportObject                   `tfsdk:"export"`
	Import                   *VirtualRouterDataSourceProtocolBgpPolicyImportObject                   `tfsdk:"import"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationObject struct {
	Address types.List `tfsdk:"address"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject struct {
	Name                     types.String                                                                              `tfsdk:"name"`
	Prefix                   types.String                                                                              `tfsdk:"prefix"`
	Enable                   types.Bool                                                                                `tfsdk:"enable"`
	Summary                  types.Bool                                                                                `tfsdk:"summary"`
	AsSet                    types.Bool                                                                                `tfsdk:"as_set"`
	AggregateRouteAttributes *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject `tfsdk:"aggregate_route_attributes"`
	SuppressFilters          types.List                                                                                `tfsdk:"suppress_filters"`
	AdvertiseFilters         types.List                                                                                `tfsdk:"advertise_filters"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject struct {
	AsPathLimit       types.Int64                                                                                                `tfsdk:"as_path_limit"`
	LocalPreference   types.Int64                                                                                                `tfsdk:"local_preference"`
	Weight            types.Int64                                                                                                `tfsdk:"weight"`
	Origin            types.String                                                                                               `tfsdk:"origin"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject `tfsdk:"extended_community"`
	Med               types.Int64                                                                                                `tfsdk:"med"`
	Nexthop           types.String                                                                                               `tfsdk:"nexthop"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject            `tfsdk:"as_path"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject struct {
	Remove  *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject `tfsdk:"remove"`
	Prepend types.Int64                                                                                           `tfsdk:"prepend"`
	None    *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject   `tfsdk:"none"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject struct {
	None        *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                                `tfsdk:"remove_regex"`
	Append      types.List                                                                                                  `tfsdk:"append"`
	Overwrite   types.List                                                                                                  `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject struct {
	Overwrite   types.List                                                                                                          `tfsdk:"overwrite"`
	None        *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                                        `tfsdk:"remove_regex"`
	Append      types.List                                                                                                          `tfsdk:"append"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject struct {
	Name   types.String                                                                          `tfsdk:"name"`
	Enable types.Bool                                                                            `tfsdk:"enable"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject struct {
	Nexthop           types.List                                                                                             `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                             `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                           `tfsdk:"route_table"`
	Med               types.Int64                                                                                            `tfsdk:"med"`
	AddressPrefix     types.List                                                                                             `tfsdk:"address_prefix"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject struct {
	Name   types.String                                                                           `tfsdk:"name"`
	Enable types.Bool                                                                             `tfsdk:"enable"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject struct {
	Med               types.Int64                                                                                             `tfsdk:"med"`
	AddressPrefix     types.List                                                                                              `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                                              `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                              `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                            `tfsdk:"route_table"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject struct {
	Policy types.List `tfsdk:"policy"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject struct {
	Name             types.String `tfsdk:"name"`
	NonExistFilters  types.List   `tfsdk:"non_exist_filters"`
	AdvertiseFilters types.List   `tfsdk:"advertise_filters"`
	Enable           types.Bool   `tfsdk:"enable"`
	UsedBy           types.List   `tfsdk:"used_by"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject struct {
	Name   types.String                                                                                      `tfsdk:"name"`
	Enable types.Bool                                                                                        `tfsdk:"enable"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject struct {
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                                       `tfsdk:"route_table"`
	Med               types.Int64                                                                                                        `tfsdk:"med"`
	AddressPrefix     types.List                                                                                                         `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                                                         `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                                         `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject         `tfsdk:"community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject struct {
	Name   types.String                                                                                       `tfsdk:"name"`
	Enable types.Bool                                                                                         `tfsdk:"enable"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject struct {
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                                        `tfsdk:"route_table"`
	Med               types.Int64                                                                                                         `tfsdk:"med"`
	AddressPrefix     types.List                                                                                                          `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                                                          `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                                          `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject         `tfsdk:"community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject struct {
	Name   types.String                                                     `tfsdk:"name"`
	Enable types.Bool                                                       `tfsdk:"enable"`
	UsedBy types.List                                                       `tfsdk:"used_by"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject  `tfsdk:"match"`
	Action *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject struct {
	Med               types.Int64                                                                      `tfsdk:"med"`
	AddressPrefix     types.List                                                                       `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                       `tfsdk:"nexthop"`
	FromPeer          types.List                                                                       `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                     `tfsdk:"route_table"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject struct {
	Deny  *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject  `tfsdk:"deny"`
	Allow *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject struct {
	Update *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject `tfsdk:"update"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject struct {
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject `tfsdk:"extended_community"`
	LocalPreference   types.Int64                                                                                  `tfsdk:"local_preference"`
	Med               types.Int64                                                                                  `tfsdk:"med"`
	Nexthop           types.String                                                                                 `tfsdk:"nexthop"`
	Origin            types.String                                                                                 `tfsdk:"origin"`
	AsPathLimit       types.Int64                                                                                  `tfsdk:"as_path_limit"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject         `tfsdk:"community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject struct {
	None             *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject   `tfsdk:"none"`
	Remove           *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject `tfsdk:"remove"`
	Prepend          types.Int64                                                                             `tfsdk:"prepend"`
	RemoveAndPrepend types.Int64                                                                             `tfsdk:"remove_and_prepend"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject struct {
	None        *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                  `tfsdk:"remove_regex"`
	Append      types.List                                                                                    `tfsdk:"append"`
	Overwrite   types.List                                                                                    `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject struct {
	Append      types.List                                                                                            `tfsdk:"append"`
	Overwrite   types.List                                                                                            `tfsdk:"overwrite"`
	None        *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                          `tfsdk:"remove_regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject struct {
	Name   types.String                                                     `tfsdk:"name"`
	Match  *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject  `tfsdk:"match"`
	Action *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject `tfsdk:"action"`
	Enable types.Bool                                                       `tfsdk:"enable"`
	UsedBy types.List                                                       `tfsdk:"used_by"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject struct {
	Deny  *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject  `tfsdk:"deny"`
	Allow *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject struct {
	Dampening types.String                                                                `tfsdk:"dampening"`
	Update    *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject `tfsdk:"update"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject struct {
	Community         *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject         `tfsdk:"community"`
	Med               types.Int64                                                                                  `tfsdk:"med"`
	Nexthop           types.String                                                                                 `tfsdk:"nexthop"`
	Origin            types.String                                                                                 `tfsdk:"origin"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject            `tfsdk:"as_path"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject `tfsdk:"extended_community"`
	LocalPreference   types.Int64                                                                                  `tfsdk:"local_preference"`
	Weight            types.Int64                                                                                  `tfsdk:"weight"`
	AsPathLimit       types.Int64                                                                                  `tfsdk:"as_path_limit"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject struct {
	None   *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject   `tfsdk:"none"`
	Remove *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject `tfsdk:"remove"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                          `tfsdk:"remove_regex"`
	Append      types.List                                                                                            `tfsdk:"append"`
	Overwrite   types.List                                                                                            `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject struct {
	None        *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                  `tfsdk:"remove_regex"`
	Append      types.List                                                                                    `tfsdk:"append"`
	Overwrite   types.List                                                                                    `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject struct {
	Community         *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                     `tfsdk:"route_table"`
	Med               types.Int64                                                                      `tfsdk:"med"`
	AddressPrefix     types.List                                                                       `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                       `tfsdk:"nexthop"`
	FromPeer          types.List                                                                       `tfsdk:"from_peer"`
	AsPath            *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject            `tfsdk:"as_path"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpRedistRulesObject struct {
	Name                    types.String `tfsdk:"name"`
	Enable                  types.Bool   `tfsdk:"enable"`
	SetMed                  types.Int64  `tfsdk:"set_med"`
	SetLocalPreference      types.Int64  `tfsdk:"set_local_preference"`
	SetAsPathLimit          types.Int64  `tfsdk:"set_as_path_limit"`
	AddressFamilyIdentifier types.String `tfsdk:"address_family_identifier"`
	SetOrigin               types.String `tfsdk:"set_origin"`
	Metric                  types.Int64  `tfsdk:"metric"`
	SetCommunity            types.List   `tfsdk:"set_community"`
	SetExtendedCommunity    types.List   `tfsdk:"set_extended_community"`
	RouteTable              types.String `tfsdk:"route_table"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsObject struct {
	Med                    *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject             `tfsdk:"med"`
	ReflectorClusterId     types.String                                                           `tfsdk:"reflector_cluster_id"`
	Aggregate              *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject       `tfsdk:"aggregate"`
	AsFormat               types.String                                                           `tfsdk:"as_format"`
	ConfederationMemberAs  types.String                                                           `tfsdk:"confederation_member_as"`
	DefaultLocalPreference types.Int64                                                            `tfsdk:"default_local_preference"`
	GracefulRestart        *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject `tfsdk:"graceful_restart"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject struct {
	AggregateMed types.Bool `tfsdk:"aggregate_med"`
}
type VirtualRouterDataSourceProtocolBgpAuthProfileObject struct {
	Name   types.String `tfsdk:"name"`
	Secret types.String `tfsdk:"secret"`
}
type VirtualRouterDataSourceProtocolBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupObject struct {
	Name                    types.String                                           `tfsdk:"name"`
	AggregatedConfedAsPath  types.Bool                                             `tfsdk:"aggregated_confed_as_path"`
	SoftResetWithStoredInfo types.Bool                                             `tfsdk:"soft_reset_with_stored_info"`
	Type                    *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject `tfsdk:"type"`
	Peer                    types.List                                             `tfsdk:"peer"`
	Enable                  types.Bool                                             `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject struct {
	Ibgp       *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject       `tfsdk:"ibgp"`
	EbgpConfed *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject `tfsdk:"ebgp_confed"`
	IbgpConfed *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject `tfsdk:"ibgp_confed"`
	Ebgp       *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject       `tfsdk:"ebgp"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject struct {
	ImportNexthop   types.String `tfsdk:"import_nexthop"`
	ExportNexthop   types.String `tfsdk:"export_nexthop"`
	RemovePrivateAs types.Bool   `tfsdk:"remove_private_as"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject struct {
	Name                              types.String                                                                            `tfsdk:"name"`
	SubsequentAddressFamilyIdentifier *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject `tfsdk:"subsequent_address_family_identifier"`
	LocalAddress                      *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject                      `tfsdk:"local_address"`
	PeerAs                            types.String                                                                            `tfsdk:"peer_as"`
	EnableMpBgp                       types.Bool                                                                              `tfsdk:"enable_mp_bgp"`
	AddressFamilyIdentifier           types.String                                                                            `tfsdk:"address_family_identifier"`
	EnableSenderSideLoopDetection     types.Bool                                                                              `tfsdk:"enable_sender_side_loop_detection"`
	ReflectorClient                   types.String                                                                            `tfsdk:"reflector_client"`
	MaxPrefixes                       types.String                                                                            `tfsdk:"max_prefixes"`
	ConnectionOptions                 *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject                 `tfsdk:"connection_options"`
	Enable                            types.Bool                                                                              `tfsdk:"enable"`
	PeeringType                       types.String                                                                            `tfsdk:"peering_type"`
	PeerAddress                       *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject                       `tfsdk:"peer_address"`
	Bfd                               *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject                               `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject struct {
	Unicast   types.Bool `tfsdk:"unicast"`
	Multicast types.Bool `tfsdk:"multicast"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject struct {
	Authentication        types.String                                                                                 `tfsdk:"authentication"`
	MinRouteAdvInterval   types.Int64                                                                                  `tfsdk:"min_route_adv_interval"`
	Multihop              types.Int64                                                                                  `tfsdk:"multihop"`
	OpenDelayTime         types.Int64                                                                                  `tfsdk:"open_delay_time"`
	HoldTime              types.String                                                                                 `tfsdk:"hold_time"`
	IncomingBgpConnection *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject `tfsdk:"incoming_bgp_connection"`
	KeepAliveInterval     types.String                                                                                 `tfsdk:"keep_alive_interval"`
	IdleHoldTime          types.Int64                                                                                  `tfsdk:"idle_hold_time"`
	OutgoingBgpConnection *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject `tfsdk:"outgoing_bgp_connection"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject struct {
	RemotePort types.Int64 `tfsdk:"remote_port"`
	Allow      types.Bool  `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject struct {
	Allow     types.Bool  `tfsdk:"allow"`
	LocalPort types.Int64 `tfsdk:"local_port"`
}
type VirtualRouterDataSourceProtocolOspfObject struct {
	AllowRedistDefaultRoute types.Bool                                                `tfsdk:"allow_redist_default_route"`
	Area                    types.List                                                `tfsdk:"area"`
	AuthProfile             types.List                                                `tfsdk:"auth_profile"`
	Enable                  types.Bool                                                `tfsdk:"enable"`
	ExportRules             types.List                                                `tfsdk:"export_rules"`
	GlobalBfd               *VirtualRouterDataSourceProtocolOspfGlobalBfdObject       `tfsdk:"global_bfd"`
	RejectDefaultRoute      types.Bool                                                `tfsdk:"reject_default_route"`
	Rfc1583                 types.Bool                                                `tfsdk:"rfc1583"`
	RouterId                types.String                                              `tfsdk:"router_id"`
	Timers                  *VirtualRouterDataSourceProtocolOspfTimersObject          `tfsdk:"timers"`
	GracefulRestart         *VirtualRouterDataSourceProtocolOspfGracefulRestartObject `tfsdk:"graceful_restart"`
}
type VirtualRouterDataSourceProtocolOspfGracefulRestartObject struct {
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
	Enable                 types.Bool  `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolOspfAreaObject struct {
	Name        types.String                                       `tfsdk:"name"`
	Range       types.List                                         `tfsdk:"range"`
	Interface   types.List                                         `tfsdk:"interface"`
	VirtualLink types.List                                         `tfsdk:"virtual_link"`
	Type        *VirtualRouterDataSourceProtocolOspfAreaTypeObject `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeObject struct {
	Nssa   *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject   `tfsdk:"nssa"`
	Normal *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject `tfsdk:"normal"`
	Stub   *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject   `tfsdk:"stub"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubObject struct {
	AcceptSummary types.Bool                                                         `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject `tfsdk:"default_route"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject struct {
	Advertise *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject `tfsdk:"advertise"`
	Disable   *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject   `tfsdk:"disable"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject struct {
	DefaultRoute  *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject `tfsdk:"default_route"`
	NssaExtRange  types.List                                                         `tfsdk:"nssa_ext_range"`
	AcceptSummary types.Bool                                                         `tfsdk:"accept_summary"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject struct {
	Advertise *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject `tfsdk:"advertise"`
	Disable   *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject   `tfsdk:"disable"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject struct {
	Name      types.String                                                                `tfsdk:"name"`
	Advertise *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaRangeObject struct {
	Name      types.String                                                 `tfsdk:"name"`
	Suppress  *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject  `tfsdk:"suppress"`
	Advertise *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceObject struct {
	Name               types.String                                                    `tfsdk:"name"`
	Metric             types.Int64                                                     `tfsdk:"metric"`
	HelloInterval      types.Int64                                                     `tfsdk:"hello_interval"`
	DeadCounts         types.Int64                                                     `tfsdk:"dead_counts"`
	TransitDelay       types.Int64                                                     `tfsdk:"transit_delay"`
	Authentication     types.String                                                    `tfsdk:"authentication"`
	Neighbor           types.List                                                      `tfsdk:"neighbor"`
	Bfd                *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject      `tfsdk:"bfd"`
	Passive            types.Bool                                                      `tfsdk:"passive"`
	Priority           types.Int64                                                     `tfsdk:"priority"`
	RetransmitInterval types.Int64                                                     `tfsdk:"retransmit_interval"`
	GrDelay            types.Int64                                                     `tfsdk:"gr_delay"`
	LinkType           *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Enable             types.Bool                                                      `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject struct {
	Broadcast *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject struct {
	Name               types.String                                                 `tfsdk:"name"`
	NeighborId         types.String                                                 `tfsdk:"neighbor_id"`
	DeadCounts         types.Int64                                                  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64                                                  `tfsdk:"retransmit_interval"`
	Authentication     types.String                                                 `tfsdk:"authentication"`
	Bfd                *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject `tfsdk:"bfd"`
	TransitAreaId      types.String                                                 `tfsdk:"transit_area_id"`
	Enable             types.Bool                                                   `tfsdk:"enable"`
	HelloInterval      types.Int64                                                  `tfsdk:"hello_interval"`
	TransitDelay       types.Int64                                                  `tfsdk:"transit_delay"`
}
type VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterDataSourceProtocolOspfExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfTimersObject struct {
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
}
type VirtualRouterDataSourceProtocolOspfv3Object struct {
	Enable                  types.Bool                                                  `tfsdk:"enable"`
	ExportRules             types.List                                                  `tfsdk:"export_rules"`
	GracefulRestart         *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject `tfsdk:"graceful_restart"`
	Timers                  *VirtualRouterDataSourceProtocolOspfv3TimersObject          `tfsdk:"timers"`
	Area                    types.List                                                  `tfsdk:"area"`
	DisableTransitTraffic   types.Bool                                                  `tfsdk:"disable_transit_traffic"`
	GlobalBfd               *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject       `tfsdk:"global_bfd"`
	RejectDefaultRoute      types.Bool                                                  `tfsdk:"reject_default_route"`
	RouterId                types.String                                                `tfsdk:"router_id"`
	AllowRedistDefaultRoute types.Bool                                                  `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                                  `tfsdk:"auth_profile"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaObject struct {
	Name           types.String                                         `tfsdk:"name"`
	Authentication types.String                                         `tfsdk:"authentication"`
	Type           *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject `tfsdk:"type"`
	Range          types.List                                           `tfsdk:"range"`
	Interface      types.List                                           `tfsdk:"interface"`
	VirtualLink    types.List                                           `tfsdk:"virtual_link"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeObject struct {
	Nssa   *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject   `tfsdk:"nssa"`
	Normal *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject `tfsdk:"normal"`
	Stub   *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject   `tfsdk:"stub"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject struct {
	AcceptSummary types.Bool                                                           `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject `tfsdk:"default_route"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject struct {
	Disable   *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject struct {
	DefaultRoute  *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject `tfsdk:"default_route"`
	NssaExtRange  types.List                                                           `tfsdk:"nssa_ext_range"`
	AcceptSummary types.Bool                                                           `tfsdk:"accept_summary"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject struct {
	Disable   *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject struct {
	Name      types.String                                                                  `tfsdk:"name"`
	Advertise *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeObject struct {
	Name      types.String                                                   `tfsdk:"name"`
	Advertise *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject struct {
	Name               types.String                                                      `tfsdk:"name"`
	RetransmitInterval types.Int64                                                       `tfsdk:"retransmit_interval"`
	Authentication     types.String                                                      `tfsdk:"authentication"`
	Bfd                *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject      `tfsdk:"bfd"`
	Passive            types.Bool                                                        `tfsdk:"passive"`
	Metric             types.Int64                                                       `tfsdk:"metric"`
	LinkType           *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Priority           types.Int64                                                       `tfsdk:"priority"`
	DeadCounts         types.Int64                                                       `tfsdk:"dead_counts"`
	HelloInterval      types.Int64                                                       `tfsdk:"hello_interval"`
	GrDelay            types.Int64                                                       `tfsdk:"gr_delay"`
	TransitDelay       types.Int64                                                       `tfsdk:"transit_delay"`
	Neighbor           types.List                                                        `tfsdk:"neighbor"`
	Enable             types.Bool                                                        `tfsdk:"enable"`
	InstanceId         types.Int64                                                       `tfsdk:"instance_id"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject struct {
	Name               types.String                                                   `tfsdk:"name"`
	RetransmitInterval types.Int64                                                    `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64                                                    `tfsdk:"transit_delay"`
	Authentication     types.String                                                   `tfsdk:"authentication"`
	NeighborId         types.String                                                   `tfsdk:"neighbor_id"`
	HelloInterval      types.Int64                                                    `tfsdk:"hello_interval"`
	InstanceId         types.Int64                                                    `tfsdk:"instance_id"`
	DeadCounts         types.Int64                                                    `tfsdk:"dead_counts"`
	Bfd                *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject `tfsdk:"bfd"`
	TransitAreaId      types.String                                                   `tfsdk:"transit_area_id"`
	Enable             types.Bool                                                     `tfsdk:"enable"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfv3ExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject struct {
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
}
type VirtualRouterDataSourceProtocolOspfv3TimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileObject struct {
	Name types.String                                               `tfsdk:"name"`
	Spi  types.String                                               `tfsdk:"spi"`
	Esp  *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject `tfsdk:"esp"`
	Ah   *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject  `tfsdk:"ah"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject struct {
	Authentication *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject `tfsdk:"authentication"`
	Encryption     *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject     `tfsdk:"encryption"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject struct {
	Sha256 *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object `tfsdk:"sha256"`
	Sha384 *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object `tfsdk:"sha384"`
	Sha512 *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object `tfsdk:"sha512"`
	None   *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject   `tfsdk:"none"`
	Md5    *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object    `tfsdk:"md5"`
	Sha1   *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object   `tfsdk:"sha1"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject struct {
	Md5    *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object    `tfsdk:"md5"`
	Sha1   *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object   `tfsdk:"sha1"`
	Sha256 *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object `tfsdk:"sha256"`
	Sha384 *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object `tfsdk:"sha384"`
	Sha512 *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object `tfsdk:"sha512"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolRedistProfileObject struct {
	Name     types.String                                              `tfsdk:"name"`
	Priority types.Int64                                               `tfsdk:"priority"`
	Filter   *VirtualRouterDataSourceProtocolRedistProfileFilterObject `tfsdk:"filter"`
	Action   *VirtualRouterDataSourceProtocolRedistProfileActionObject `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterObject struct {
	Interface   types.List                                                    `tfsdk:"interface"`
	Destination types.List                                                    `tfsdk:"destination"`
	Nexthop     types.List                                                    `tfsdk:"nexthop"`
	Ospf        *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject `tfsdk:"ospf"`
	Bgp         *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject  `tfsdk:"bgp"`
	Type        types.List                                                    `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject struct {
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
	PathType types.List `tfsdk:"path_type"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolRedistProfileActionObject struct {
	NoRedist *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject `tfsdk:"no_redist"`
	Redist   *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject   `tfsdk:"redist"`
}
type VirtualRouterDataSourceProtocolRedistProfileActionRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6Object struct {
	Name     types.String                                                  `tfsdk:"name"`
	Priority types.Int64                                                   `tfsdk:"priority"`
	Filter   *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject `tfsdk:"filter"`
	Action   *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject struct {
	Interface   types.List                                                          `tfsdk:"interface"`
	Destination types.List                                                          `tfsdk:"destination"`
	Nexthop     types.List                                                          `tfsdk:"nexthop"`
	Ospfv3      *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object `tfsdk:"ospfv3"`
	Bgp         *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject    `tfsdk:"bgp"`
	Type        types.List                                                          `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object struct {
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
	PathType types.List `tfsdk:"path_type"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject struct {
	NoRedist *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject `tfsdk:"no_redist"`
	Redist   *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject   `tfsdk:"redist"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject struct {
}
type VirtualRouterDataSourceProtocolRipObject struct {
	AllowRedistDefaultRoute types.Bool                                         `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                         `tfsdk:"auth_profile"`
	Enable                  types.Bool                                         `tfsdk:"enable"`
	ExportRules             types.List                                         `tfsdk:"export_rules"`
	GlobalBfd               *VirtualRouterDataSourceProtocolRipGlobalBfdObject `tfsdk:"global_bfd"`
	Interfaces              types.List                                         `tfsdk:"interfaces"`
	RejectDefaultRoute      types.Bool                                         `tfsdk:"reject_default_route"`
	Timers                  *VirtualRouterDataSourceProtocolRipTimersObject    `tfsdk:"timers"`
}
type VirtualRouterDataSourceProtocolRipTimersObject struct {
	IntervalSeconds types.Int64 `tfsdk:"interval_seconds"`
	UpdateIntervals types.Int64 `tfsdk:"update_intervals"`
	DeleteIntervals types.Int64 `tfsdk:"delete_intervals"`
	ExpireIntervals types.Int64 `tfsdk:"expire_intervals"`
}
type VirtualRouterDataSourceProtocolRipAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterDataSourceProtocolRipAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterDataSourceProtocolRipExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Metric types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolRipInterfacesObject struct {
	Name           types.String                                                    `tfsdk:"name"`
	Mode           types.String                                                    `tfsdk:"mode"`
	DefaultRoute   *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject `tfsdk:"default_route"`
	Bfd            *VirtualRouterDataSourceProtocolRipInterfacesBfdObject          `tfsdk:"bfd"`
	Enable         types.Bool                                                      `tfsdk:"enable"`
	Authentication types.String                                                    `tfsdk:"authentication"`
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject struct {
	Disable   *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceRoutingTableObject struct {
	Ipv6 *VirtualRouterDataSourceRoutingTableIpv6Object `tfsdk:"ipv6"`
	Ip   *VirtualRouterDataSourceRoutingTableIpObject   `tfsdk:"ip"`
}
type VirtualRouterDataSourceRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteObject struct {
	Name                   types.String                                                       `tfsdk:"name"`
	Metric                 types.Int64                                                        `tfsdk:"metric"`
	Nexthop                *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject     `tfsdk:"nexthop"`
	RouteTable             *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject  `tfsdk:"route_table"`
	Bfd                    *VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject `tfsdk:"path_monitor"`
	Destination            types.String                                                       `tfsdk:"destination"`
	Interface              types.String                                                       `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                        `tfsdk:"administrative_distance"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
	Enable      types.Bool   `tfsdk:"enable"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject struct {
	Receive   *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject `tfsdk:"receive"`
	Discard   *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject `tfsdk:"discard"`
	IpAddress types.String                                                          `tfsdk:"ip_address"`
	Fqdn      types.String                                                          `tfsdk:"fqdn"`
	NextVr    types.String                                                          `tfsdk:"next_vr"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject struct {
	Both      *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject      `tfsdk:"both"`
	NoInstall *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject `tfsdk:"no_install"`
	Unicast   *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject   `tfsdk:"unicast"`
	Multicast *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject `tfsdk:"multicast"`
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject struct {
}
type VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String                                                         `tfsdk:"name"`
	Metric                 types.Int64                                                          `tfsdk:"metric"`
	Bfd                    *VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject         `tfsdk:"bfd"`
	AdministrativeDistance types.Int64                                                          `tfsdk:"administrative_distance"`
	Interface              types.String                                                         `tfsdk:"interface"`
	Nexthop                *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject     `tfsdk:"nexthop"`
	Option                 *VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject      `tfsdk:"option"`
	RouteTable             *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject  `tfsdk:"route_table"`
	PathMonitor            *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject `tfsdk:"path_monitor"`
	Destination            types.String                                                         `tfsdk:"destination"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject struct {
	Receive     *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject `tfsdk:"receive"`
	Discard     *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject `tfsdk:"discard"`
	Ipv6Address types.String                                                            `tfsdk:"ipv6_address"`
	NextVr      types.String                                                            `tfsdk:"next_vr"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject struct {
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject struct {
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject struct {
	Unicast   *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject   `tfsdk:"unicast"`
	NoInstall *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject `tfsdk:"no_install"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject struct {
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject struct {
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
	Enable      types.Bool   `tfsdk:"enable"`
}
type VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceAdministrativeDistancesObject struct {
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Static     types.Int64 `tfsdk:"static"`
	Rip        types.Int64 `tfsdk:"rip"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
	Ebgp       types.Int64 `tfsdk:"ebgp"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
}
type VirtualRouterDataSourceEcmpObject struct {
	StrictSourcePath types.Bool                                  `tfsdk:"strict_source_path"`
	SymmetricReturn  types.Bool                                  `tfsdk:"symmetric_return"`
	Algorithm        *VirtualRouterDataSourceEcmpAlgorithmObject `tfsdk:"algorithm"`
	Enable           types.Bool                                  `tfsdk:"enable"`
	MaxPaths         types.Int64                                 `tfsdk:"max_paths"`
}
type VirtualRouterDataSourceEcmpAlgorithmObject struct {
	WeightedRoundRobin *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
	BalancedRoundRobin *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
	IpHash             *VirtualRouterDataSourceEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	IpModulo           *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
}
type VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterDataSourceEcmpAlgorithmIpHashObject struct {
	HashSeed types.Int64 `tfsdk:"hash_seed"`
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
}
type VirtualRouterDataSourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}

func (o *VirtualRouterDataSourceModel) CopyToPango(ctx context.Context, obj **virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ecmp_entry *virtual_router.Ecmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}

		diags.Append(o.Ecmp.CopyToPango(ctx, &ecmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaces_pango_entries := make([]string, 0)
	diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var multicast_entry *virtual_router.Multicast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.Multicast)
		}

		diags.Append(o.Multicast.CopyToPango(ctx, &multicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *virtual_router.RoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(virtual_router.RoutingTable)
		}

		diags.Append(o.RoutingTable.CopyToPango(ctx, &routingTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_entry *virtual_router.AdminDists
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(virtual_router.AdminDists)
		}

		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, &administrativeDistances_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ecmp = ecmp_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).Multicast = multicast_entry
	(*obj).Protocol = protocol_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).AdminDists = administrativeDistances_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolObject) CopyToPango(ctx context.Context, obj **virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ospf_entry *virtual_router.ProtocolOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistProfile_tf_entries []VirtualRouterDataSourceProtocolRedistProfileObject
	var redistProfile_pango_entries []virtual_router.ProtocolRedistProfile
	{
		d := o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfile_tf_entries {
			var entry *virtual_router.ProtocolRedistProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistProfile_pango_entries = append(redistProfile_pango_entries, *entry)
		}
	}
	var redistProfileIpv6_tf_entries []VirtualRouterDataSourceProtocolRedistProfileIpv6Object
	var redistProfileIpv6_pango_entries []virtual_router.ProtocolRedistProfileIpv6
	{
		d := o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfileIpv6_tf_entries {
			var entry *virtual_router.ProtocolRedistProfileIpv6
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistProfileIpv6_pango_entries = append(redistProfileIpv6_pango_entries, *entry)
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}

		diags.Append(o.Rip.CopyToPango(ctx, &rip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).RedistProfile = redistProfile_pango_entries
	(*obj).RedistProfileIpv6 = redistProfileIpv6_pango_entries
	(*obj).Rip = rip_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolBgpAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolBgpAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolBgpGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolBgpGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localAs_value := o.LocalAs.ValueStringPointer()
	var redistRules_tf_entries []VirtualRouterDataSourceProtocolBgpRedistRulesObject
	var redistRules_pango_entries []virtual_router.ProtocolBgpRedistRules
	{
		d := o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistRules_tf_entries {
			var entry *virtual_router.ProtocolBgpRedistRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistRules_pango_entries = append(redistRules_pango_entries, *entry)
		}
	}
	routerId_value := o.RouterId.ValueStringPointer()
	var routingOptions_entry *virtual_router.ProtocolBgpRoutingOptions
	if o.RoutingOptions != nil {
		if *obj != nil && (*obj).RoutingOptions != nil {
			routingOptions_entry = (*obj).RoutingOptions
		} else {
			routingOptions_entry = new(virtual_router.ProtocolBgpRoutingOptions)
		}

		diags.Append(o.RoutingOptions.CopyToPango(ctx, &routingOptions_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var peerGroup_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupObject
	var peerGroup_pango_entries []virtual_router.ProtocolBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	var dampeningProfile_tf_entries []VirtualRouterDataSourceProtocolBgpDampeningProfileObject
	var dampeningProfile_pango_entries []virtual_router.ProtocolBgpDampeningProfile
	{
		d := o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range dampeningProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpDampeningProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			dampeningProfile_pango_entries = append(dampeningProfile_pango_entries, *entry)
		}
	}
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	var policy_entry *virtual_router.ProtocolBgpPolicy
	if o.Policy != nil {
		if *obj != nil && (*obj).Policy != nil {
			policy_entry = (*obj).Policy
		} else {
			policy_entry = new(virtual_router.ProtocolBgpPolicy)
		}

		diags.Append(o.Policy.CopyToPango(ctx, &policy_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).LocalAs = localAs_value
	(*obj).RedistRules = redistRules_pango_entries
	(*obj).RouterId = routerId_value
	(*obj).RoutingOptions = routingOptions_entry
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).Enable = enable_value
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).DampeningProfile = dampeningProfile_pango_entries
	(*obj).InstallRoute = installRoute_value
	(*obj).Policy = policy_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRedistRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	setAsPathLimit_value := o.SetAsPathLimit.ValueInt64Pointer()
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	setMed_value := o.SetMed.ValueInt64Pointer()
	setLocalPreference_value := o.SetLocalPreference.ValueInt64Pointer()
	setExtendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.SetExtendedCommunity.ElementsAs(ctx, &setExtendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	setOrigin_value := o.SetOrigin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	setCommunity_pango_entries := make([]string, 0)
	diags.Append(o.SetCommunity.ElementsAs(ctx, &setCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRedistRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SetAsPathLimit = setAsPathLimit_value
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).Enable = enable_value
	(*obj).SetMed = setMed_value
	(*obj).SetLocalPreference = setLocalPreference_value
	(*obj).SetExtendedCommunity = setExtendedCommunity_pango_entries
	(*obj).RouteTable = routeTable_value
	(*obj).SetOrigin = setOrigin_value
	(*obj).Metric = metric_value
	(*obj).SetCommunity = setCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	confederationMemberAs_value := o.ConfederationMemberAs.ValueStringPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	var gracefulRestart_entry *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_entry *virtual_router.ProtocolBgpRoutingOptionsMed
	if o.Med != nil {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(virtual_router.ProtocolBgpRoutingOptionsMed)
		}

		diags.Append(o.Med.CopyToPango(ctx, &med_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	reflectorClusterId_value := o.ReflectorClusterId.ValueStringPointer()
	var aggregate_entry *virtual_router.ProtocolBgpRoutingOptionsAggregate
	if o.Aggregate != nil {
		if *obj != nil && (*obj).Aggregate != nil {
			aggregate_entry = (*obj).Aggregate
		} else {
			aggregate_entry = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
		}

		diags.Append(o.Aggregate.CopyToPango(ctx, &aggregate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	asFormat_value := o.AsFormat.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptions)
	}
	(*obj).ConfederationMemberAs = confederationMemberAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Med = med_entry
	(*obj).ReflectorClusterId = reflectorClusterId_value
	(*obj).Aggregate = aggregate_entry
	(*obj).AsFormat = asFormat_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
	}
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).Enable = enable_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsMed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsAggregate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	aggregateMed_value := o.AggregateMed.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
	}
	(*obj).AggregateMed = aggregateMed_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	secret_value := o.Secret.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Secret = secret_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	aggregatedConfedAsPath_value := o.AggregatedConfedAsPath.ValueBoolPointer()
	softResetWithStoredInfo_value := o.SoftResetWithStoredInfo.ValueBoolPointer()
	var type_entry *virtual_router.ProtocolBgpPeerGroupType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolBgpPeerGroupType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
	var peer_pango_entries []virtual_router.ProtocolBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AggregatedConfedAsPath = aggregatedConfedAsPath_value
	(*obj).SoftResetWithStoredInfo = softResetWithStoredInfo_value
	(*obj).Type = type_entry
	(*obj).Peer = peer_pango_entries
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgp
	if o.Ibgp != nil {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
		}

		diags.Append(o.Ibgp.CopyToPango(ctx, &ibgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed
	if o.EbgpConfed != nil {
		if *obj != nil && (*obj).EbgpConfed != nil {
			ebgpConfed_entry = (*obj).EbgpConfed
		} else {
			ebgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
		}

		diags.Append(o.EbgpConfed.CopyToPango(ctx, &ebgpConfed_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed
	if o.IbgpConfed != nil {
		if *obj != nil && (*obj).IbgpConfed != nil {
			ibgpConfed_entry = (*obj).IbgpConfed
		} else {
			ibgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
		}

		diags.Append(o.IbgpConfed.CopyToPango(ctx, &ibgpConfed_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgp
	if o.Ebgp != nil {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
		}

		diags.Append(o.Ebgp.CopyToPango(ctx, &ebgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).EbgpConfed = ebgpConfed_entry
	(*obj).IbgpConfed = ibgpConfed_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	importNexthop_value := o.ImportNexthop.ValueStringPointer()
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()
	removePrivateAs_value := o.RemovePrivateAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
	}
	(*obj).ImportNexthop = importNexthop_value
	(*obj).ExportNexthop = exportNexthop_value
	(*obj).RemovePrivateAs = removePrivateAs_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_entry *virtual_router.ProtocolBgpPeerGroupPeerBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	peeringType_value := o.PeeringType.ValueStringPointer()
	var peerAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	reflectorClient_value := o.ReflectorClient.ValueStringPointer()
	maxPrefixes_value := o.MaxPrefixes.ValueStringPointer()
	var subsequentAddressFamilyIdentifier_entry *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier
	if o.SubsequentAddressFamilyIdentifier != nil {
		if *obj != nil && (*obj).SubsequentAddressFamilyIdentifier != nil {
			subsequentAddressFamilyIdentifier_entry = (*obj).SubsequentAddressFamilyIdentifier
		} else {
			subsequentAddressFamilyIdentifier_entry = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
		}

		diags.Append(o.SubsequentAddressFamilyIdentifier.CopyToPango(ctx, &subsequentAddressFamilyIdentifier_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableMpBgp_value := o.EnableMpBgp.ValueBoolPointer()
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	var connectionOptions_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
		}

		diags.Append(o.ConnectionOptions.CopyToPango(ctx, &connectionOptions_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Bfd = bfd_entry
	(*obj).Enable = enable_value
	(*obj).PeeringType = peeringType_value
	(*obj).PeerAddress = peerAddress_entry
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).ReflectorClient = reflectorClient_value
	(*obj).MaxPrefixes = maxPrefixes_value
	(*obj).SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAs = peerAs_value
	(*obj).EnableMpBgp = enableMpBgp_value
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).ConnectionOptions = connectionOptions_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
	}
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	minRouteAdvInterval_value := o.MinRouteAdvInterval.ValueInt64Pointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	openDelayTime_value := o.OpenDelayTime.ValueInt64Pointer()
	holdTime_value := o.HoldTime.ValueStringPointer()
	var incomingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection
	if o.IncomingBgpConnection != nil {
		if *obj != nil && (*obj).IncomingBgpConnection != nil {
			incomingBgpConnection_entry = (*obj).IncomingBgpConnection
		} else {
			incomingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
		}

		diags.Append(o.IncomingBgpConnection.CopyToPango(ctx, &incomingBgpConnection_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	keepAliveInterval_value := o.KeepAliveInterval.ValueStringPointer()
	idleHoldTime_value := o.IdleHoldTime.ValueInt64Pointer()
	var outgoingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection
	if o.OutgoingBgpConnection != nil {
		if *obj != nil && (*obj).OutgoingBgpConnection != nil {
			outgoingBgpConnection_entry = (*obj).OutgoingBgpConnection
		} else {
			outgoingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
		}

		diags.Append(o.OutgoingBgpConnection.CopyToPango(ctx, &outgoingBgpConnection_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Authentication = authentication_value
	(*obj).MinRouteAdvInterval = minRouteAdvInterval_value
	(*obj).Multihop = multihop_value
	(*obj).OpenDelayTime = openDelayTime_value
	(*obj).HoldTime = holdTime_value
	(*obj).IncomingBgpConnection = incomingBgpConnection_entry
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).IdleHoldTime = idleHoldTime_value
	(*obj).OutgoingBgpConnection = outgoingBgpConnection_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
	}
	(*obj).LocalPort = localPort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var import_entry *virtual_router.ProtocolBgpPolicyImport
	if o.Import != nil {
		if *obj != nil && (*obj).Import != nil {
			import_entry = (*obj).Import
		} else {
			import_entry = new(virtual_router.ProtocolBgpPolicyImport)
		}

		diags.Append(o.Import.CopyToPango(ctx, &import_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var aggregation_entry *virtual_router.ProtocolBgpPolicyAggregation
	if o.Aggregation != nil {
		if *obj != nil && (*obj).Aggregation != nil {
			aggregation_entry = (*obj).Aggregation
		} else {
			aggregation_entry = new(virtual_router.ProtocolBgpPolicyAggregation)
		}

		diags.Append(o.Aggregation.CopyToPango(ctx, &aggregation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var conditionalAdvertisement_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisement
	if o.ConditionalAdvertisement != nil {
		if *obj != nil && (*obj).ConditionalAdvertisement != nil {
			conditionalAdvertisement_entry = (*obj).ConditionalAdvertisement
		} else {
			conditionalAdvertisement_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
		}

		diags.Append(o.ConditionalAdvertisement.CopyToPango(ctx, &conditionalAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_entry *virtual_router.ProtocolBgpPolicyExport
	if o.Export != nil {
		if *obj != nil && (*obj).Export != nil {
			export_entry = (*obj).Export
		} else {
			export_entry = new(virtual_router.ProtocolBgpPolicyExport)
		}

		diags.Append(o.Export.CopyToPango(ctx, &export_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicy)
	}
	(*obj).Import = import_entry
	(*obj).Aggregation = aggregation_entry
	(*obj).ConditionalAdvertisement = conditionalAdvertisement_entry
	(*obj).Export = export_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
	var address_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddress
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregation)
	}
	(*obj).Address = address_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppressFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
	var suppressFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
	{
		d := o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suppressFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suppressFilters_pango_entries = append(suppressFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}
	prefix_value := o.Prefix.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summary_value := o.Summary.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	var aggregateRouteAttributes_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes
	if o.AggregateRouteAttributes != nil {
		if *obj != nil && (*obj).AggregateRouteAttributes != nil {
			aggregateRouteAttributes_entry = (*obj).AggregateRouteAttributes
		} else {
			aggregateRouteAttributes_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
		}

		diags.Append(o.AggregateRouteAttributes.CopyToPango(ctx, &aggregateRouteAttributes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SuppressFilters = suppressFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries
	(*obj).Prefix = prefix_value
	(*obj).Enable = enable_value
	(*obj).Summary = summary_value
	(*obj).AsSet = asSet_value
	(*obj).AggregateRouteAttributes = aggregateRouteAttributes_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
	}
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).AsPath = asPath_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry
	(*obj).Prepend = prepend_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
	}
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
	}
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
	}
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
	}
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	var policy_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
	{
		d := o.Policy.ElementsAs(ctx, &policy_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range policy_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			policy_pango_entries = append(policy_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
	}
	(*obj).Policy = policy_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var nonExistFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
	var nonExistFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
	{
		d := o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nonExistFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nonExistFilters_pango_entries = append(nonExistFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).NonExistFilters = nonExistFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Match = match_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
	}
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
	}
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyExportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var match_entry *virtual_router.ProtocolBgpPolicyExportRulesMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyExportRulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyExportRulesActionDeny
	if o.Deny != nil {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
		}

		diags.Append(o.Deny.CopyToPango(ctx, &deny_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate
	if o.Update != nil {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
		}

		diags.Append(o.Update.CopyToPango(ctx, &update_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
	}
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
	}
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()
	removeAndPrepend_value := o.RemoveAndPrepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry
	(*obj).Prepend = prepend_value
	(*obj).RemoveAndPrepend = removeAndPrepend_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
	}
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyImportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var match_entry *virtual_router.ProtocolBgpPolicyImportRulesMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyImportRulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
	}
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyImportRulesActionDeny
	if o.Deny != nil {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
		}

		diags.Append(o.Deny.CopyToPango(ctx, &deny_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dampening_value := o.Dampening.ValueStringPointer()
	var update_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate
	if o.Update != nil {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
		}

		diags.Append(o.Update.CopyToPango(ctx, &update_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
	}
	(*obj).Dampening = dampening_value
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
	}
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).Community = community_entry
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
	}
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpDampeningProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	cutoff_value := o.Cutoff.ValueFloat64Pointer()
	reuse_value := o.Reuse.ValueFloat64Pointer()
	maxHoldTime_value := o.MaxHoldTime.ValueInt64Pointer()
	decayHalfLifeReachable_value := o.DecayHalfLifeReachable.ValueInt64Pointer()
	decayHalfLifeUnreachable_value := o.DecayHalfLifeUnreachable.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpDampeningProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Cutoff = cutoff_value
	(*obj).Reuse = reuse_value
	(*obj).MaxHoldTime = maxHoldTime_value
	(*obj).DecayHalfLifeReachable = decayHalfLifeReachable_value
	(*obj).DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gracefulRestart_entry *virtual_router.ProtocolOspfGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfGracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []VirtualRouterDataSourceProtocolOspfAreaObject
	var area_pango_entries []virtual_router.ProtocolOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfArea
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolOspfTimers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfTimers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Timers = timers_entry
	(*obj).RouterId = routerId_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfArea, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *virtual_router.ProtocolOspfAreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfAreaType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterDataSourceProtocolOspfAreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfAreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfAreaTypeNormal)
		}

		diags.Append(o.Normal.CopyToPango(ctx, &normal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfAreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfAreaTypeStub)
		}

		diags.Append(o.Stub.CopyToPango(ctx, &stub_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfAreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfAreaTypeNssa)
		}

		diags.Append(o.Nssa.CopyToPango(ctx, &nssa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStub)
	}
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).AcceptSummary = acceptSummary_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfAreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfAreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfAreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
		}

		diags.Append(o.LinkType.CopyToPango(ctx, &linkType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Enable = enable_value
	(*obj).Priority = priority_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var p2mp_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
		}

		diags.Append(o.P2mp.CopyToPango(ctx, &p2mp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var broadcast_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
		}

		diags.Append(o.Broadcast.CopyToPango(ctx, &broadcast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
		}

		diags.Append(o.P2p.CopyToPango(ctx, &p2p_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
	}
	(*obj).P2mp = p2mp_entry
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	neighborId_value := o.NeighborId.ValueStringPointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	var bfd_entry *virtual_router.ProtocolOspfAreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).NeighborId = neighborId_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Bfd = bfd_entry
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).HelloInterval = helloInterval_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolOspfAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfTimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfTimers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaObject
	var area_pango_entries []virtual_router.ProtocolOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfv3Area
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfv3ExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfv3ExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfv3ExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfv3GracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfv3GracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_entry *virtual_router.ProtocolOspfv3Timers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfv3Timers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfv3AuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfv3AuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfv3GlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfv3GlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).Area = area_pango_entries
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Timers = timers_entry
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	spi_value := o.Spi.ValueStringPointer()
	var esp_entry *virtual_router.ProtocolOspfv3AuthProfileEsp
	if o.Esp != nil {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
		}

		diags.Append(o.Esp.CopyToPango(ctx, &esp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_entry *virtual_router.ProtocolOspfv3AuthProfileAh
	if o.Ah != nil {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(virtual_router.ProtocolOspfv3AuthProfileAh)
		}

		diags.Append(o.Ah.CopyToPango(ctx, &ah_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Spi = spi_value
	(*obj).Esp = esp_entry
	(*obj).Ah = ah_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *virtual_router.ProtocolOspfv3AuthProfileEspEncryption
	if o.Encryption != nil {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
		}

		diags.Append(o.Encryption.CopyToPango(ctx, &encryption_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileAhMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAh)
	}
	(*obj).Sha512 = sha512_entry
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3GlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3Area, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *virtual_router.ProtocolOspfv3AreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfv3AreaType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries
	(*obj).Authentication = authentication_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	neighborId_value := o.NeighborId.ValueStringPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).NeighborId = neighborId_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Bfd = bfd_entry
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).DeadCounts = deadCounts_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfv3AreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
		}

		diags.Append(o.Normal.CopyToPango(ctx, &normal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfv3AreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfv3AreaTypeStub)
		}

		diags.Append(o.Stub.CopyToPango(ctx, &stub_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfv3AreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
		}

		diags.Append(o.Nssa.CopyToPango(ctx, &nssa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
		}

		diags.Append(o.LinkType.CopyToPango(ctx, &linkType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	priority_value := o.Priority.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).LinkType = linkType_entry
	(*obj).Priority = priority_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).GrDelay = grDelay_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
		}

		diags.Append(o.Broadcast.CopyToPango(ctx, &broadcast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
		}

		diags.Append(o.P2p.CopyToPango(ctx, &p2p_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
		}

		diags.Append(o.P2mp.CopyToPango(ctx, &p2mp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3ExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3ExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3GracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3Timers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Timers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileFilter
	if o.Filter != nil {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileFilter)
		}

		diags.Append(o.Filter.CopyToPango(ctx, &filter_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	type_pango_entries := make([]string, 0)
	diags.Append(o.Type.ElementsAs(ctx, &type_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	destination_pango_entries := make([]string, 0)
	diags.Append(o.Destination.ElementsAs(ctx, &destination_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var ospf_entry *virtual_router.ProtocolRedistProfileFilterOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolRedistProfileFilterOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileFilterBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileFilterBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospf = ospf_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilterOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	pathType_pango_entries := make([]string, 0)
	diags.Append(o.PathType.ElementsAs(ctx, &pathType_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	area_pango_entries := make([]string, 0)
	diags.Append(o.Area.ElementsAs(ctx, &area_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterOspf)
	}
	(*obj).Tag = tag_pango_entries
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	community_pango_entries := make([]string, 0)
	diags.Append(o.Community.ElementsAs(ctx, &community_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	extendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &extendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileActionNoRedist
	if o.NoRedist != nil {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileActionNoRedist)
		}

		diags.Append(o.NoRedist.CopyToPango(ctx, &noRedist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileActionRedist
	if o.Redist != nil {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileActionRedist)
		}

		diags.Append(o.Redist.CopyToPango(ctx, &redist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileAction)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *virtual_router.ProtocolRedistProfileIpv6Action
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileIpv6Action)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileIpv6Filter
	if o.Filter != nil {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileIpv6Filter)
		}

		diags.Append(o.Filter.CopyToPango(ctx, &filter_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_entry
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6Filter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	type_pango_entries := make([]string, 0)
	diags.Append(o.Type.ElementsAs(ctx, &type_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	destination_pango_entries := make([]string, 0)
	diags.Append(o.Destination.ElementsAs(ctx, &destination_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var ospfv3_entry *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileIpv6FilterBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Filter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	area_pango_entries := make([]string, 0)
	diags.Append(o.Area.ElementsAs(ctx, &area_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	pathType_pango_entries := make([]string, 0)
	diags.Append(o.PathType.ElementsAs(ctx, &pathType_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
	}
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries
	(*obj).PathType = pathType_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6FilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	community_pango_entries := make([]string, 0)
	diags.Append(o.Community.ElementsAs(ctx, &community_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	extendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &extendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6Action, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist
	if o.NoRedist != nil {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
		}

		diags.Append(o.NoRedist.CopyToPango(ctx, &noRedist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileIpv6ActionRedist
	if o.Redist != nil {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
		}

		diags.Append(o.Redist.CopyToPango(ctx, &redist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Action)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6ActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolRipExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolRipExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolRipExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolRipGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolRipGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []VirtualRouterDataSourceProtocolRipInterfacesObject
	var interfaces_pango_entries []virtual_router.ProtocolRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.ProtocolRipInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolRipTimers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolRipTimers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolRipAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Timers = timers_entry
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipTimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	intervalSeconds_value := o.IntervalSeconds.ValueInt64Pointer()
	updateIntervals_value := o.UpdateIntervals.ValueInt64Pointer()
	deleteIntervals_value := o.DeleteIntervals.ValueInt64Pointer()
	expireIntervals_value := o.ExpireIntervals.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipTimers)
	}
	(*obj).IntervalSeconds = intervalSeconds_value
	(*obj).UpdateIntervals = updateIntervals_value
	(*obj).DeleteIntervals = deleteIntervals_value
	(*obj).ExpireIntervals = expireIntervals_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolRipAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	mode_value := o.Mode.ValueStringPointer()
	var defaultRoute_entry *virtual_router.ProtocolRipInterfaceDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolRipInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolRipInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	authentication_value := o.Authentication.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Mode = mode_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).Bfd = bfd_entry
	(*obj).Enable = enable_value
	(*obj).Authentication = authentication_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolRipInterfaceDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv6_entry *virtual_router.RoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(virtual_router.RoutingTableIpv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *virtual_router.RoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(virtual_router.RoutingTableIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTable)
	}
	(*obj).Ipv6 = ipv6_entry
	(*obj).Ip = ip_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []virtual_router.RoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *virtual_router.RoutingTableIpStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(virtual_router.RoutingTableIpStaticRouteNexthop)
		}

		diags.Append(o.Nexthop.CopyToPango(ctx, &nexthop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_entry *virtual_router.RoutingTableIpStaticRouteRouteTable
	if o.RouteTable != nil {
		if *obj != nil && (*obj).RouteTable != nil {
			routeTable_entry = (*obj).RouteTable
		} else {
			routeTable_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTable)
		}

		diags.Append(o.RouteTable.CopyToPango(ctx, &routeTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.RoutingTableIpStaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.RoutingTableIpStaticRouteBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *virtual_router.RoutingTableIpStaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(virtual_router.RoutingTableIpStaticRoutePathMonitor)
		}

		diags.Append(o.PathMonitor.CopyToPango(ctx, &pathMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).RouteTable = routeTable_entry
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_entry *virtual_router.RoutingTableIpStaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(virtual_router.RoutingTableIpStaticRouteNexthopDiscard)
		}

		diags.Append(o.Discard.CopyToPango(ctx, &discard_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()
	var receive_entry *virtual_router.RoutingTableIpStaticRouteNexthopReceive
	if o.Receive != nil {
		if *obj != nil && (*obj).Receive != nil {
			receive_entry = (*obj).Receive
		} else {
			receive_entry = new(virtual_router.RoutingTableIpStaticRouteNexthopReceive)
		}

		diags.Append(o.Receive.CopyToPango(ctx, &receive_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthop)
	}
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).Fqdn = fqdn_value
	(*obj).NextVr = nextVr_value
	(*obj).Receive = receive_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthopReceive)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *virtual_router.RoutingTableIpStaticRouteRouteTableUnicast
	if o.Unicast != nil {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableUnicast)
		}

		diags.Append(o.Unicast.CopyToPango(ctx, &unicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *virtual_router.RoutingTableIpStaticRouteRouteTableMulticast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableMulticast)
		}

		diags.Append(o.Multicast.CopyToPango(ctx, &multicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *virtual_router.RoutingTableIpStaticRouteRouteTableBoth
	if o.Both != nil {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableBoth)
		}

		diags.Append(o.Both.CopyToPango(ctx, &both_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_entry *virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall
	if o.NoInstall != nil {
		if *obj != nil && (*obj).NoInstall != nil {
			noInstall_entry = (*obj).NoInstall
		} else {
			noInstall_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall)
		}

		diags.Append(o.NoInstall.CopyToPango(ctx, &noInstall_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTable)
	}
	(*obj).Unicast = unicast_entry
	(*obj).Multicast = multicast_entry
	(*obj).Both = both_entry
	(*obj).NoInstall = noInstall_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableUnicast)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableMulticast)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableBoth)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []virtual_router.RoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	var nexthop_entry *virtual_router.RoutingTableIpv6StaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthop)
		}

		diags.Append(o.Nexthop.CopyToPango(ctx, &nexthop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var option_entry *virtual_router.RoutingTableIpv6StaticRouteOption
	if o.Option != nil {
		if *obj != nil && (*obj).Option != nil {
			option_entry = (*obj).Option
		} else {
			option_entry = new(virtual_router.RoutingTableIpv6StaticRouteOption)
		}

		diags.Append(o.Option.CopyToPango(ctx, &option_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTable
	if o.RouteTable != nil {
		if *obj != nil && (*obj).RouteTable != nil {
			routeTable_entry = (*obj).RouteTable
		} else {
			routeTable_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTable)
		}

		diags.Append(o.RouteTable.CopyToPango(ctx, &routeTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *virtual_router.RoutingTableIpv6StaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitor)
		}

		diags.Append(o.PathMonitor.CopyToPango(ctx, &pathMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var bfd_entry *virtual_router.RoutingTableIpv6StaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.RoutingTableIpv6StaticRouteBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Option = option_entry
	(*obj).RouteTable = routeTable_entry
	(*obj).PathMonitor = pathMonitor_entry
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	nextVr_value := o.NextVr.ValueStringPointer()
	var receive_entry *virtual_router.RoutingTableIpv6StaticRouteNexthopReceive
	if o.Receive != nil {
		if *obj != nil && (*obj).Receive != nil {
			receive_entry = (*obj).Receive
		} else {
			receive_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthopReceive)
		}

		diags.Append(o.Receive.CopyToPango(ctx, &receive_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_entry *virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard)
		}

		diags.Append(o.Discard.CopyToPango(ctx, &discard_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).NextVr = nextVr_value
	(*obj).Receive = receive_entry
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthopReceive)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteOption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteOption)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast
	if o.Unicast != nil {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast)
		}

		diags.Append(o.Unicast.CopyToPango(ctx, &unicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall
	if o.NoInstall != nil {
		if *obj != nil && (*obj).NoInstall != nil {
			noInstall_entry = (*obj).NoInstall
		} else {
			noInstall_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall)
		}

		diags.Append(o.NoInstall.CopyToPango(ctx, &noInstall_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTable)
	}
	(*obj).Unicast = unicast_entry
	(*obj).NoInstall = noInstall_entry

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall)
	}

	return diags
}
func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, obj **virtual_router.AdminDists, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	static_value := o.Static.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ebgp_value := o.Ebgp.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdminDists)
	}
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Static = static_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Ibgp = ibgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).Rip = rip_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).Ebgp = ebgp_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpObject) CopyToPango(ctx context.Context, obj **virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}

		diags.Append(o.Algorithm.CopyToPango(ctx, &algorithm_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).SymmetricReturn = symmetricReturn_value
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).StrictSourcePath = strictSourcePath_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}

		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, &balancedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}

		diags.Append(o.IpHash.CopyToPango(ctx, &ipHash_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}

		diags.Append(o.IpModulo.CopyToPango(ctx, &ipModulo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}

		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, &weightedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry
	(*obj).IpHash = ipHash_entry
	(*obj).IpModulo = ipModulo_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	hashSeed_value := o.HashSeed.ValueInt64Pointer()
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).HashSeed = hashSeed_value
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.Multicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_tf_entries []VirtualRouterDataSourceMulticastSptThresholdObject
	var sptThreshold_pango_entries []virtual_router.MulticastSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *virtual_router.MulticastSptThreshold
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var ssmAddressSpace_tf_entries []VirtualRouterDataSourceMulticastSsmAddressSpaceObject
	var ssmAddressSpace_pango_entries []virtual_router.MulticastSsmAddressSpace
	{
		d := o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ssmAddressSpace_tf_entries {
			var entry *virtual_router.MulticastSsmAddressSpace
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ssmAddressSpace_pango_entries = append(ssmAddressSpace_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var interfaceGroup_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupObject
	var interfaceGroup_pango_entries []virtual_router.MulticastInterfaceGroup
	{
		d := o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaceGroup_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroup
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaceGroup_pango_entries = append(interfaceGroup_pango_entries, *entry)
		}
	}
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	var rp_entry *virtual_router.MulticastRp
	if o.Rp != nil {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(virtual_router.MulticastRp)
		}

		diags.Append(o.Rp.CopyToPango(ctx, &rp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Multicast)
	}
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).SsmAddressSpace = ssmAddressSpace_pango_entries
	(*obj).Enable = enable_value
	(*obj).InterfaceGroup = interfaceGroup_pango_entries
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).Rp = rp_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var groupPermission_entry *virtual_router.MulticastInterfaceGroupGroupPermission
	if o.GroupPermission != nil {
		if *obj != nil && (*obj).GroupPermission != nil {
			groupPermission_entry = (*obj).GroupPermission
		} else {
			groupPermission_entry = new(virtual_router.MulticastInterfaceGroupGroupPermission)
		}

		diags.Append(o.GroupPermission.CopyToPango(ctx, &groupPermission_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *virtual_router.MulticastInterfaceGroupIgmp
	if o.Igmp != nil {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(virtual_router.MulticastInterfaceGroupIgmp)
		}

		diags.Append(o.Igmp.CopyToPango(ctx, &igmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pim_entry *virtual_router.MulticastInterfaceGroupPim
	if o.Pim != nil {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(virtual_router.MulticastInterfaceGroupPim)
		}

		diags.Append(o.Pim.CopyToPango(ctx, &pim_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).GroupPermission = groupPermission_entry
	(*obj).Igmp = igmp_entry
	(*obj).Pim = pim_entry
	(*obj).Description = description_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupPim, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	assertInterval_value := o.AssertInterval.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	joinPruneInterval_value := o.JoinPruneInterval.ValueInt64Pointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	bsrBorder_value := o.BsrBorder.ValueBoolPointer()
	var allowedNeighbors_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
	var allowedNeighbors_pango_entries []virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
	{
		d := o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range allowedNeighbors_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			allowedNeighbors_pango_entries = append(allowedNeighbors_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPim)
	}
	(*obj).AssertInterval = assertInterval_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).JoinPruneInterval = joinPruneInterval_value
	(*obj).DrPriority = drPriority_value
	(*obj).BsrBorder = bsrBorder_value
	(*obj).AllowedNeighbors = allowedNeighbors_pango_entries
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPimAllowedNeighbors)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermission, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
	var anySourceMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
	{
		d := o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range anySourceMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			anySourceMulticast_pango_entries = append(anySourceMulticast_pango_entries, *entry)
		}
	}
	var sourceSpecificMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	var sourceSpecificMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
	{
		d := o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sourceSpecificMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sourceSpecificMulticast_pango_entries = append(sourceSpecificMulticast_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermission)
	}
	(*obj).AnySourceMulticast = anySourceMulticast_pango_entries
	(*obj).SourceSpecificMulticast = sourceSpecificMulticast_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()
	groupAddress_value := o.GroupAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SourceAddress = sourceAddress_value
	(*obj).Included = included_value
	(*obj).GroupAddress = groupAddress_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupIgmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	immediateLeave_value := o.ImmediateLeave.ValueBoolPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	version_value := o.Version.ValueStringPointer()
	queryInterval_value := o.QueryInterval.ValueInt64Pointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxQueryResponseTime_value := o.MaxQueryResponseTime.ValueFloat64Pointer()
	lastMemberQueryInterval_value := o.LastMemberQueryInterval.ValueFloat64Pointer()
	robustness_value := o.Robustness.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupIgmp)
	}
	(*obj).ImmediateLeave = immediateLeave_value
	(*obj).MaxSources = maxSources_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value
	(*obj).Enable = enable_value
	(*obj).Version = version_value
	(*obj).QueryInterval = queryInterval_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxQueryResponseTime = maxQueryResponseTime_value
	(*obj).LastMemberQueryInterval = lastMemberQueryInterval_value
	(*obj).Robustness = robustness_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_tf_entries []VirtualRouterDataSourceMulticastRpExternalRpObject
	var externalRp_pango_entries []virtual_router.MulticastRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *virtual_router.MulticastRpExternalRp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}
	var localRp_entry *virtual_router.MulticastRpLocalRp
	if o.LocalRp != nil {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(virtual_router.MulticastRpLocalRp)
		}

		diags.Append(o.LocalRp.CopyToPango(ctx, &localRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRp)
	}
	(*obj).ExternalRp = externalRp_pango_entries
	(*obj).LocalRp = localRp_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpExternalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_entry *virtual_router.MulticastRpLocalRpCandidateRp
	if o.CandidateRp != nil {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(virtual_router.MulticastRpLocalRpCandidateRp)
		}

		diags.Append(o.CandidateRp.CopyToPango(ctx, &candidateRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_entry *virtual_router.MulticastRpLocalRpStaticRp
	if o.StaticRp != nil {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(virtual_router.MulticastRpLocalRpStaticRp)
		}

		diags.Append(o.StaticRp.CopyToPango(ctx, &staticRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRp)
	}
	(*obj).CandidateRp = candidateRp_entry
	(*obj).StaticRp = staticRp_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRpCandidateRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_value := o.Interface.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	address_value := o.Address.ValueStringPointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpCandidateRp)
	}
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Priority = priority_value
	(*obj).Address = address_value
	(*obj).AdvertisementInterval = advertisementInterval_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRpStaticRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_value := o.Interface.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpStaticRp)
	}
	(*obj).Address = address_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastSptThresholdObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastSptThreshold, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastSsmAddressSpace, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSsmAddressSpace)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceModel) CopyFromPango(ctx context.Context, obj *virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics
		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var administrativeDistances_object *VirtualRouterDataSourceAdministrativeDistancesObject
	if obj.AdminDists != nil {
		administrativeDistances_object = new(VirtualRouterDataSourceAdministrativeDistancesObject)

		diags.Append(administrativeDistances_object.CopyFromPango(ctx, obj.AdminDists, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_object *VirtualRouterDataSourceEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(VirtualRouterDataSourceEcmpObject)

		diags.Append(ecmp_object.CopyFromPango(ctx, obj.Ecmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *VirtualRouterDataSourceMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(VirtualRouterDataSourceMulticastObject)

		diags.Append(multicast_object.CopyFromPango(ctx, obj.Multicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_object *VirtualRouterDataSourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(VirtualRouterDataSourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *VirtualRouterDataSourceRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(VirtualRouterDataSourceRoutingTableObject)

		diags.Append(routingTable_object.CopyFromPango(ctx, obj.RoutingTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.AdministrativeDistances = administrativeDistances_object
	o.Ecmp = ecmp_object
	o.Interfaces = interfaces_list
	o.Multicast = multicast_object
	o.Protocol = protocol_object
	o.RoutingTable = routingTable_object

	return diags
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, obj *virtual_router.AdminDists, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	o.Ospfv3Ext = ospfv3Ext_value
	o.Rip = rip_value
	o.StaticIpv6 = staticIpv6_value
	o.Ebgp = ebgp_value
	o.Ibgp = ibgp_value
	o.OspfExt = ospfExt_value
	o.OspfInt = ospfInt_value
	o.Ospfv3Int = ospfv3Int_value
	o.Static = static_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *VirtualRouterDataSourceEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(VirtualRouterDataSourceEcmpAlgorithmObject)

		diags.Append(algorithm_object.CopyFromPango(ctx, obj.Algorithm, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.StrictSourcePath = strictSourcePath_value
	o.SymmetricReturn = symmetricReturn_value
	o.Algorithm = algorithm_object

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_object *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject)

		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, obj.BalancedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *VirtualRouterDataSourceEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(VirtualRouterDataSourceEcmpAlgorithmIpHashObject)

		diags.Append(ipHash_object.CopyFromPango(ctx, obj.IpHash, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_object *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(VirtualRouterDataSourceEcmpAlgorithmIpModuloObject)

		diags.Append(ipModulo_object.CopyFromPango(ctx, obj.IpModulo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_object *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject)

		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, obj.WeightedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpHash = ipHash_object
	o.IpModulo = ipModulo_object
	o.WeightedRoundRobin = weightedRoundRobin_object

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	o.HashSeed = hashSeed_value
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.Multicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ssmAddressSpace_list types.List
	{
		var ssmAddressSpace_tf_entries []VirtualRouterDataSourceMulticastSsmAddressSpaceObject
		for _, elt := range obj.SsmAddressSpace {
			var entry VirtualRouterDataSourceMulticastSsmAddressSpaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ssmAddressSpace_tf_entries = append(ssmAddressSpace_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssm_address_space")
		ssmAddressSpace_list, list_diags = types.ListValueFrom(ctx, schemaType, ssmAddressSpace_tf_entries)
		diags.Append(list_diags...)
	}
	var interfaceGroup_list types.List
	{
		var interfaceGroup_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupObject
		for _, elt := range obj.InterfaceGroup {
			var entry VirtualRouterDataSourceMulticastInterfaceGroupObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaceGroup_tf_entries = append(interfaceGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface_group")
		interfaceGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaceGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []VirtualRouterDataSourceMulticastSptThresholdObject
		for _, elt := range obj.SptThreshold {
			var entry VirtualRouterDataSourceMulticastSptThresholdObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var rp_object *VirtualRouterDataSourceMulticastRpObject
	if obj.Rp != nil {
		rp_object = new(VirtualRouterDataSourceMulticastRpObject)

		diags.Append(rp_object.CopyFromPango(ctx, obj.Rp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	o.SsmAddressSpace = ssmAddressSpace_list
	o.Enable = enable_value
	o.InterfaceGroup = interfaceGroup_list
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []VirtualRouterDataSourceMulticastRpExternalRpObject
		for _, elt := range obj.ExternalRp {
			var entry VirtualRouterDataSourceMulticastRpExternalRpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			externalRp_tf_entries = append(externalRp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}
	var localRp_object *VirtualRouterDataSourceMulticastRpLocalRpObject
	if obj.LocalRp != nil {
		localRp_object = new(VirtualRouterDataSourceMulticastRpLocalRpObject)

		diags.Append(localRp_object.CopyFromPango(ctx, obj.LocalRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.LocalRp = localRp_object
	o.ExternalRp = externalRp_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpExternalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddresses = groupAddresses_list
	o.Override = override_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_object *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject
	if obj.CandidateRp != nil {
		candidateRp_object = new(VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject)

		diags.Append(candidateRp_object.CopyFromPango(ctx, obj.CandidateRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_object *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject
	if obj.StaticRp != nil {
		staticRp_object = new(VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject)

		diags.Append(staticRp_object.CopyFromPango(ctx, obj.StaticRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.CandidateRp = candidateRp_object
	o.StaticRp = staticRp_object

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRpCandidateRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Address = address_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Priority = priority_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRpStaticRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Address = address_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Override = override_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastSptThresholdObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastSptThreshold, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastSsmAddressSpace, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var igmp_object *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject
	if obj.Igmp != nil {
		igmp_object = new(VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject)

		diags.Append(igmp_object.CopyFromPango(ctx, obj.Igmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pim_object *VirtualRouterDataSourceMulticastInterfaceGroupPimObject
	if obj.Pim != nil {
		pim_object = new(VirtualRouterDataSourceMulticastInterfaceGroupPimObject)

		diags.Append(pim_object.CopyFromPango(ctx, obj.Pim, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var groupPermission_object *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject
	if obj.GroupPermission != nil {
		groupPermission_object = new(VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject)

		diags.Append(groupPermission_object.CopyFromPango(ctx, obj.GroupPermission, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Igmp = igmp_object
	o.Pim = pim_object
	o.Description = description_value
	o.Interface = interface_list
	o.GroupPermission = groupPermission_object

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermission, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_list types.List
	{
		var anySourceMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
		for _, elt := range obj.AnySourceMulticast {
			var entry VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			anySourceMulticast_tf_entries = append(anySourceMulticast_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("any_source_multicast")
		anySourceMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, anySourceMulticast_tf_entries)
		diags.Append(list_diags...)
	}
	var sourceSpecificMulticast_list types.List
	{
		var sourceSpecificMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
		for _, elt := range obj.SourceSpecificMulticast {
			var entry VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sourceSpecificMulticast_tf_entries = append(sourceSpecificMulticast_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("source_specific_multicast")
		sourceSpecificMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, sourceSpecificMulticast_tf_entries)
		diags.Append(list_diags...)
	}

	o.AnySourceMulticast = anySourceMulticast_list
	o.SourceSpecificMulticast = sourceSpecificMulticast_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupIgmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var immediateLeave_value types.Bool
	if obj.ImmediateLeave != nil {
		immediateLeave_value = types.BoolValue(*obj.ImmediateLeave)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var queryInterval_value types.Int64
	if obj.QueryInterval != nil {
		queryInterval_value = types.Int64Value(*obj.QueryInterval)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxQueryResponseTime_value types.Float64
	if obj.MaxQueryResponseTime != nil {
		maxQueryResponseTime_value = types.Float64Value(*obj.MaxQueryResponseTime)
	}
	var lastMemberQueryInterval_value types.Float64
	if obj.LastMemberQueryInterval != nil {
		lastMemberQueryInterval_value = types.Float64Value(*obj.LastMemberQueryInterval)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	o.ImmediateLeave = immediateLeave_value
	o.MaxSources = maxSources_value
	o.RouterAlertPolicing = routerAlertPolicing_value
	o.Enable = enable_value
	o.Version = version_value
	o.QueryInterval = queryInterval_value
	o.MaxGroups = maxGroups_value
	o.MaxQueryResponseTime = maxQueryResponseTime_value
	o.LastMemberQueryInterval = lastMemberQueryInterval_value
	o.Robustness = robustness_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupPim, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var allowedNeighbors_list types.List
	{
		var allowedNeighbors_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
		for _, elt := range obj.AllowedNeighbors {
			var entry VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			allowedNeighbors_tf_entries = append(allowedNeighbors_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("allowed_neighbors")
		allowedNeighbors_list, list_diags = types.ListValueFrom(ctx, schemaType, allowedNeighbors_tf_entries)
		diags.Append(list_diags...)
	}

	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var bsrBorder_value types.Bool
	if obj.BsrBorder != nil {
		bsrBorder_value = types.BoolValue(*obj.BsrBorder)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var assertInterval_value types.Int64
	if obj.AssertInterval != nil {
		assertInterval_value = types.Int64Value(*obj.AssertInterval)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var joinPruneInterval_value types.Int64
	if obj.JoinPruneInterval != nil {
		joinPruneInterval_value = types.Int64Value(*obj.JoinPruneInterval)
	}
	o.DrPriority = drPriority_value
	o.BsrBorder = bsrBorder_value
	o.AllowedNeighbors = allowedNeighbors_list
	o.Enable = enable_value
	o.AssertInterval = assertInterval_value
	o.HelloInterval = helloInterval_value
	o.JoinPruneInterval = joinPruneInterval_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolObject) CopyFromPango(ctx context.Context, obj *virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistProfile_list types.List
	{
		var redistProfile_tf_entries []VirtualRouterDataSourceProtocolRedistProfileObject
		for _, elt := range obj.RedistProfile {
			var entry VirtualRouterDataSourceProtocolRedistProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistProfile_tf_entries = append(redistProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile")
		redistProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var redistProfileIpv6_list types.List
	{
		var redistProfileIpv6_tf_entries []VirtualRouterDataSourceProtocolRedistProfileIpv6Object
		for _, elt := range obj.RedistProfileIpv6 {
			var entry VirtualRouterDataSourceProtocolRedistProfileIpv6Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistProfileIpv6_tf_entries = append(redistProfileIpv6_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile_ipv6")
		redistProfileIpv6_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfileIpv6_tf_entries)
		diags.Append(list_diags...)
	}
	var rip_object *VirtualRouterDataSourceProtocolRipObject
	if obj.Rip != nil {
		rip_object = new(VirtualRouterDataSourceProtocolRipObject)

		diags.Append(rip_object.CopyFromPango(ctx, obj.Rip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterDataSourceProtocolBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterDataSourceProtocolBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *VirtualRouterDataSourceProtocolOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterDataSourceProtocolOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *VirtualRouterDataSourceProtocolOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterDataSourceProtocolOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.RedistProfile = redistProfile_list
	o.RedistProfileIpv6 = redistProfileIpv6_list
	o.Rip = rip_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistRules_list types.List
	{
		var redistRules_tf_entries []VirtualRouterDataSourceProtocolBgpRedistRulesObject
		for _, elt := range obj.RedistRules {
			var entry VirtualRouterDataSourceProtocolBgpRedistRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistRules_tf_entries = append(redistRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_rules")
		redistRules_list, list_diags = types.ListValueFrom(ctx, schemaType, redistRules_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolBgpAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterDataSourceProtocolBgpAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupObject
		for _, elt := range obj.PeerGroup {
			var entry VirtualRouterDataSourceProtocolBgpPeerGroupObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var dampeningProfile_list types.List
	{
		var dampeningProfile_tf_entries []VirtualRouterDataSourceProtocolBgpDampeningProfileObject
		for _, elt := range obj.DampeningProfile {
			var entry VirtualRouterDataSourceProtocolBgpDampeningProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			dampeningProfile_tf_entries = append(dampeningProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("dampening_profile")
		dampeningProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, dampeningProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var routingOptions_object *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject
	if obj.RoutingOptions != nil {
		routingOptions_object = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsObject)

		diags.Append(routingOptions_object.CopyFromPango(ctx, obj.RoutingOptions, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *VirtualRouterDataSourceProtocolBgpGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterDataSourceProtocolBgpGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var policy_object *VirtualRouterDataSourceProtocolBgpPolicyObject
	if obj.Policy != nil {
		policy_object = new(VirtualRouterDataSourceProtocolBgpPolicyObject)

		diags.Append(policy_object.CopyFromPango(ctx, obj.Policy, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	o.RedistRules = redistRules_list
	o.RouterId = routerId_value
	o.RoutingOptions = routingOptions_object
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.GlobalBfd = globalBfd_object
	o.LocalAs = localAs_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.Enable = enable_value
	o.PeerGroup = peerGroup_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.DampeningProfile = dampeningProfile_list
	o.InstallRoute = installRoute_value
	o.Policy = policy_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregate_object *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject
	if obj.Aggregate != nil {
		aggregate_object = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject)

		diags.Append(aggregate_object.CopyFromPango(ctx, obj.Aggregate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_object *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject
	if obj.Med != nil {
		med_object = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject)

		diags.Append(med_object.CopyFromPango(ctx, obj.Med, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var reflectorClusterId_value types.String
	if obj.ReflectorClusterId != nil {
		reflectorClusterId_value = types.StringValue(*obj.ReflectorClusterId)
	}
	var asFormat_value types.String
	if obj.AsFormat != nil {
		asFormat_value = types.StringValue(*obj.AsFormat)
	}
	var confederationMemberAs_value types.String
	if obj.ConfederationMemberAs != nil {
		confederationMemberAs_value = types.StringValue(*obj.ConfederationMemberAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	o.ReflectorClusterId = reflectorClusterId_value
	o.Aggregate = aggregate_object
	o.AsFormat = asFormat_value
	o.ConfederationMemberAs = confederationMemberAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulRestart = gracefulRestart_object
	o.Med = med_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsAggregate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregateMed_value types.Bool
	if obj.AggregateMed != nil {
		aggregateMed_value = types.BoolValue(*obj.AggregateMed)
	}
	o.AggregateMed = aggregateMed_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	o.Enable = enable_value
	o.LocalRestartTime = localRestartTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.StaleRouteTime = staleRouteTime_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsMed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var secret_value types.String
	if obj.Secret != nil {
		secret_value = types.StringValue(*obj.Secret)
	}
	o.Name = types.StringValue(obj.Name)
	o.Secret = secret_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRedistRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var setExtendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		setExtendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.SetExtendedCommunity)
		diags.Append(list_diags...)
	}
	var setCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		setCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.SetCommunity)
		diags.Append(list_diags...)
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var setOrigin_value types.String
	if obj.SetOrigin != nil {
		setOrigin_value = types.StringValue(*obj.SetOrigin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var setAsPathLimit_value types.Int64
	if obj.SetAsPathLimit != nil {
		setAsPathLimit_value = types.Int64Value(*obj.SetAsPathLimit)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var setMed_value types.Int64
	if obj.SetMed != nil {
		setMed_value = types.Int64Value(*obj.SetMed)
	}
	var setLocalPreference_value types.Int64
	if obj.SetLocalPreference != nil {
		setLocalPreference_value = types.Int64Value(*obj.SetLocalPreference)
	}
	o.Name = types.StringValue(obj.Name)
	o.SetExtendedCommunity = setExtendedCommunity_list
	o.RouteTable = routeTable_value
	o.SetOrigin = setOrigin_value
	o.Metric = metric_value
	o.SetCommunity = setCommunity_list
	o.SetAsPathLimit = setAsPathLimit_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.Enable = enable_value
	o.SetMed = setMed_value
	o.SetLocalPreference = setLocalPreference_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
		for _, elt := range obj.Peer {
			var entry VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var aggregatedConfedAsPath_value types.Bool
	if obj.AggregatedConfedAsPath != nil {
		aggregatedConfedAsPath_value = types.BoolValue(*obj.AggregatedConfedAsPath)
	}
	var softResetWithStoredInfo_value types.Bool
	if obj.SoftResetWithStoredInfo != nil {
		softResetWithStoredInfo_value = types.BoolValue(*obj.SoftResetWithStoredInfo)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.AggregatedConfedAsPath = aggregatedConfedAsPath_value
	o.SoftResetWithStoredInfo = softResetWithStoredInfo_value
	o.Type = type_object
	o.Peer = peer_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ebgpConfed_object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject
	if obj.EbgpConfed != nil {
		ebgpConfed_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject)

		diags.Append(ebgpConfed_object.CopyFromPango(ctx, obj.EbgpConfed, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject
	if obj.IbgpConfed != nil {
		ibgpConfed_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject)

		diags.Append(ibgpConfed_object.CopyFromPango(ctx, obj.IbgpConfed, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject
	if obj.Ebgp != nil {
		ebgp_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject)

		diags.Append(ebgp_object.CopyFromPango(ctx, obj.Ebgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgp_object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject
	if obj.Ibgp != nil {
		ibgp_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject)

		diags.Append(ibgp_object.CopyFromPango(ctx, obj.Ibgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.EbgpConfed = ebgpConfed_object
	o.IbgpConfed = ibgpConfed_object
	o.Ebgp = ebgp_object
	o.Ibgp = ibgp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var importNexthop_value types.String
	if obj.ImportNexthop != nil {
		importNexthop_value = types.StringValue(*obj.ImportNexthop)
	}
	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	var removePrivateAs_value types.Bool
	if obj.RemovePrivateAs != nil {
		removePrivateAs_value = types.BoolValue(*obj.RemovePrivateAs)
	}
	o.ImportNexthop = importNexthop_value
	o.ExportNexthop = exportNexthop_value
	o.RemovePrivateAs = removePrivateAs_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var subsequentAddressFamilyIdentifier_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
	if obj.SubsequentAddressFamilyIdentifier != nil {
		subsequentAddressFamilyIdentifier_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject)

		diags.Append(subsequentAddressFamilyIdentifier_object.CopyFromPango(ctx, obj.SubsequentAddressFamilyIdentifier, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject)

		diags.Append(connectionOptions_object.CopyFromPango(ctx, obj.ConnectionOptions, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.String
	if obj.MaxPrefixes != nil {
		maxPrefixes_value = types.StringValue(*obj.MaxPrefixes)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableMpBgp_value types.Bool
	if obj.EnableMpBgp != nil {
		enableMpBgp_value = types.BoolValue(*obj.EnableMpBgp)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	var reflectorClient_value types.String
	if obj.ReflectorClient != nil {
		reflectorClient_value = types.StringValue(*obj.ReflectorClient)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peeringType_value types.String
	if obj.PeeringType != nil {
		peeringType_value = types.StringValue(*obj.PeeringType)
	}
	o.Name = types.StringValue(obj.Name)
	o.MaxPrefixes = maxPrefixes_value
	o.SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_object
	o.LocalAddress = localAddress_object
	o.PeerAs = peerAs_value
	o.EnableMpBgp = enableMpBgp_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.ReflectorClient = reflectorClient_value
	o.ConnectionOptions = connectionOptions_object
	o.Enable = enable_value
	o.PeeringType = peeringType_value
	o.PeerAddress = peerAddress_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	o.Unicast = unicast_value
	o.Multicast = multicast_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var incomingBgpConnection_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
	if obj.IncomingBgpConnection != nil {
		incomingBgpConnection_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject)

		diags.Append(incomingBgpConnection_object.CopyFromPango(ctx, obj.IncomingBgpConnection, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var outgoingBgpConnection_object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	if obj.OutgoingBgpConnection != nil {
		outgoingBgpConnection_object = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject)

		diags.Append(outgoingBgpConnection_object.CopyFromPango(ctx, obj.OutgoingBgpConnection, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var minRouteAdvInterval_value types.Int64
	if obj.MinRouteAdvInterval != nil {
		minRouteAdvInterval_value = types.Int64Value(*obj.MinRouteAdvInterval)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var openDelayTime_value types.Int64
	if obj.OpenDelayTime != nil {
		openDelayTime_value = types.Int64Value(*obj.OpenDelayTime)
	}
	var holdTime_value types.String
	if obj.HoldTime != nil {
		holdTime_value = types.StringValue(*obj.HoldTime)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var idleHoldTime_value types.Int64
	if obj.IdleHoldTime != nil {
		idleHoldTime_value = types.Int64Value(*obj.IdleHoldTime)
	}
	var keepAliveInterval_value types.String
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.StringValue(*obj.KeepAliveInterval)
	}
	o.MinRouteAdvInterval = minRouteAdvInterval_value
	o.Multihop = multihop_value
	o.OpenDelayTime = openDelayTime_value
	o.HoldTime = holdTime_value
	o.IncomingBgpConnection = incomingBgpConnection_object
	o.Authentication = authentication_value
	o.IdleHoldTime = idleHoldTime_value
	o.OutgoingBgpConnection = outgoingBgpConnection_object
	o.KeepAliveInterval = keepAliveInterval_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	o.Allow = allow_value
	o.RemotePort = remotePort_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.LocalPort = localPort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpDampeningProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var decayHalfLifeReachable_value types.Int64
	if obj.DecayHalfLifeReachable != nil {
		decayHalfLifeReachable_value = types.Int64Value(*obj.DecayHalfLifeReachable)
	}
	var decayHalfLifeUnreachable_value types.Int64
	if obj.DecayHalfLifeUnreachable != nil {
		decayHalfLifeUnreachable_value = types.Int64Value(*obj.DecayHalfLifeUnreachable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var cutoff_value types.Float64
	if obj.Cutoff != nil {
		cutoff_value = types.Float64Value(*obj.Cutoff)
	}
	var reuse_value types.Float64
	if obj.Reuse != nil {
		reuse_value = types.Float64Value(*obj.Reuse)
	}
	var maxHoldTime_value types.Int64
	if obj.MaxHoldTime != nil {
		maxHoldTime_value = types.Int64Value(*obj.MaxHoldTime)
	}
	o.Name = types.StringValue(obj.Name)
	o.DecayHalfLifeReachable = decayHalfLifeReachable_value
	o.DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value
	o.Enable = enable_value
	o.Cutoff = cutoff_value
	o.Reuse = reuse_value
	o.MaxHoldTime = maxHoldTime_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var conditionalAdvertisement_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject
	if obj.ConditionalAdvertisement != nil {
		conditionalAdvertisement_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject)

		diags.Append(conditionalAdvertisement_object.CopyFromPango(ctx, obj.ConditionalAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_object *VirtualRouterDataSourceProtocolBgpPolicyExportObject
	if obj.Export != nil {
		export_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportObject)

		diags.Append(export_object.CopyFromPango(ctx, obj.Export, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var import_object *VirtualRouterDataSourceProtocolBgpPolicyImportObject
	if obj.Import != nil {
		import_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportObject)

		diags.Append(import_object.CopyFromPango(ctx, obj.Import, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var aggregation_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject
	if obj.Aggregation != nil {
		aggregation_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationObject)

		diags.Append(aggregation_object.CopyFromPango(ctx, obj.Aggregation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.ConditionalAdvertisement = conditionalAdvertisement_object
	o.Export = export_object
	o.Import = import_object
	o.Aggregation = aggregation_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
		for _, elt := range obj.Address {
			var entry VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	o.Address = address_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
		for _, elt := range obj.AdvertiseFilters {
			var entry VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var suppressFilters_list types.List
	{
		var suppressFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
		for _, elt := range obj.SuppressFilters {
			var entry VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suppressFilters_tf_entries = append(suppressFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suppress_filters")
		suppressFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, suppressFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRouteAttributes_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
	if obj.AggregateRouteAttributes != nil {
		aggregateRouteAttributes_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject)

		diags.Append(aggregateRouteAttributes_object.CopyFromPango(ctx, obj.AggregateRouteAttributes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summary_value types.Bool
	if obj.Summary != nil {
		summary_value = types.BoolValue(*obj.Summary)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	o.Name = types.StringValue(obj.Name)
	o.AdvertiseFilters = advertiseFilters_list
	o.Prefix = prefix_value
	o.Enable = enable_value
	o.Summary = summary_value
	o.AsSet = asSet_value
	o.AggregateRouteAttributes = aggregateRouteAttributes_object
	o.SuppressFilters = suppressFilters_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.Overwrite = overwrite_list
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object
	o.RemoveAll = removeAll_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_list types.List
	{
		var policy_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
		for _, elt := range obj.Policy {
			var entry VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			policy_tf_entries = append(policy_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("policy")
		policy_list, list_diags = types.ListValueFrom(ctx, schemaType, policy_tf_entries)
		diags.Append(list_diags...)
	}

	o.Policy = policy_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nonExistFilters_list types.List
	{
		var nonExistFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
		for _, elt := range obj.NonExistFilters {
			var entry VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nonExistFilters_tf_entries = append(nonExistFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("non_exist_filters")
		nonExistFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, nonExistFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
		for _, elt := range obj.AdvertiseFilters {
			var entry VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.NonExistFilters = nonExistFilters_list
	o.AdvertiseFilters = advertiseFilters_list
	o.Enable = enable_value
	o.UsedBy = usedBy_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Match = match_object
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
		for _, elt := range obj.Rules {
			var entry VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject
	if obj.Deny != nil {
		deny_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject)

		diags.Append(deny_object.CopyFromPango(ctx, obj.Deny, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	if obj.Update != nil {
		update_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject)

		diags.Append(update_object.CopyFromPango(ctx, obj.Update, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Update = update_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	var removeAndPrepend_value types.Int64
	if obj.RemoveAndPrepend != nil {
		removeAndPrepend_value = types.Int64Value(*obj.RemoveAndPrepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value
	o.RemoveAndPrepend = removeAndPrepend_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
		for _, elt := range obj.Rules {
			var entry VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}
	var match_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject
	if obj.Deny != nil {
		deny_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject)

		diags.Append(deny_object.CopyFromPango(ctx, obj.Deny, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	if obj.Update != nil {
		update_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject)

		diags.Append(update_object.CopyFromPango(ctx, obj.Update, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Dampening = dampening_value
	o.Update = update_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.ExtendedCommunity = extendedCommunity_object
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.Origin = origin_value
	o.Community = community_object
	o.Med = med_value
	o.Nexthop = nexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var remove_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Remove = remove_object
	o.None = none_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object
	o.RemoveAll = removeAll_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterDataSourceProtocolOspfAreaObject
		for _, elt := range obj.Area {
			var entry VirtualRouterDataSourceProtocolOspfAreaObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterDataSourceProtocolOspfAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterDataSourceProtocolOspfExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *VirtualRouterDataSourceProtocolOspfGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterDataSourceProtocolOspfGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterDataSourceProtocolOspfTimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterDataSourceProtocolOspfTimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *VirtualRouterDataSourceProtocolOspfGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterDataSourceProtocolOspfGracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Rfc1583 = rfc1583_value
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.RouterId = routerId_value
	o.Timers = timers_object
	o.GracefulRestart = gracefulRestart_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfArea, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterDataSourceProtocolOspfAreaRangeObject
		for _, elt := range obj.Range {
			var entry VirtualRouterDataSourceProtocolOspfAreaRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterDataSourceProtocolOspfAreaInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			var entry VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterDataSourceProtocolOspfAreaTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject)

		diags.Append(normal_object.CopyFromPango(ctx, obj.Normal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubObject)

		diags.Append(stub_object.CopyFromPango(ctx, obj.Stub, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject)

		diags.Append(nssa_object.CopyFromPango(ctx, obj.Nssa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			var entry VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}
	var defaultRoute_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject
		for _, elt := range obj.Neighbor {
			var entry VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var linkType_object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject)

		diags.Append(linkType_object.CopyFromPango(ctx, obj.LinkType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.RetransmitInterval = retransmitInterval_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Enable = enable_value
	o.Metric = metric_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object
	o.Passive = passive_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var p2mp_object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject)

		diags.Append(p2mp_object.CopyFromPango(ctx, obj.P2mp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var broadcast_object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject)

		diags.Append(broadcast_object.CopyFromPango(ctx, obj.Broadcast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject)

		diags.Append(p2p_object.CopyFromPango(ctx, obj.P2p, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.P2mp = p2mp_object
	o.Broadcast = broadcast_object
	o.P2p = p2p_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.HelloInterval = helloInterval_value
	o.TransitDelay = transitDelay_value
	o.Bfd = bfd_object
	o.NeighborId = neighborId_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.Authentication = authentication_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
		for _, elt := range obj.Md5 {
			var entry VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			md5_tf_entries = append(md5_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfTimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	o.StrictLSAChecking = strictLSAChecking_value
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaObject
		for _, elt := range obj.Area {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfv3ExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterDataSourceProtocolOspfv3ExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfv3AuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterDataSourceProtocolOspfv3AuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var gracefulRestart_object *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterDataSourceProtocolOspfv3TimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterDataSourceProtocolOspfv3TimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.Area = area_list
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GracefulRestart = gracefulRestart_object
	o.Timers = timers_object
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.GlobalBfd = globalBfd_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var esp_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject
	if obj.Esp != nil {
		esp_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject)

		diags.Append(esp_object.CopyFromPango(ctx, obj.Esp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject
	if obj.Ah != nil {
		ah_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject)

		diags.Append(ah_object.CopyFromPango(ctx, obj.Ah, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var spi_value types.String
	if obj.Spi != nil {
		spi_value = types.StringValue(*obj.Spi)
	}
	o.Name = types.StringValue(obj.Name)
	o.Spi = spi_value
	o.Esp = esp_object
	o.Ah = ah_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject
	if obj.Encryption != nil {
		encryption_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject)

		diags.Append(encryption_object.CopyFromPango(ctx, obj.Encryption, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
	if obj.Md5 != nil {
		md5_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.None = none_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object
	if obj.Md5 != nil {
		md5_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3GlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3GracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3Timers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3Area, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaRangeObject
		for _, elt := range obj.Range {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject
		for _, elt := range obj.Neighbor {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var bfd_object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var linkType_object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject)

		diags.Append(linkType_object.CopyFromPango(ctx, obj.LinkType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Neighbor = neighbor_list
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.Passive = passive_value
	o.Metric = metric_value
	o.RetransmitInterval = retransmitInterval_value
	o.Priority = priority_value
	o.DeadCounts = deadCounts_value
	o.LinkType = linkType_object
	o.HelloInterval = helloInterval_value
	o.GrDelay = grDelay_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject)

		diags.Append(broadcast_object.CopyFromPango(ctx, obj.Broadcast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject)

		diags.Append(p2p_object.CopyFromPango(ctx, obj.P2p, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject)

		diags.Append(p2mp_object.CopyFromPango(ctx, obj.P2mp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.NeighborId = neighborId_value
	o.HelloInterval = helloInterval_value
	o.InstanceId = instanceId_value
	o.DeadCounts = deadCounts_value
	o.Bfd = bfd_object
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject)

		diags.Append(normal_object.CopyFromPango(ctx, obj.Normal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject)

		diags.Append(stub_object.CopyFromPango(ctx, obj.Stub, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject)

		diags.Append(nssa_object.CopyFromPango(ctx, obj.Nssa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			var entry VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}
	var defaultRoute_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Type = type_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3ExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var filter_object *VirtualRouterDataSourceProtocolRedistProfileFilterObject
	if obj.Filter != nil {
		filter_object = new(VirtualRouterDataSourceProtocolRedistProfileFilterObject)

		diags.Append(filter_object.CopyFromPango(ctx, obj.Filter, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterDataSourceProtocolRedistProfileActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterDataSourceProtocolRedistProfileActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics
		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Type)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics
		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var ospf_object *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospf = ospf_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilterOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics
		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PathType)
		diags.Append(list_diags...)
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics
		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Area)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics
		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Community)
		diags.Append(list_diags...)
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExtendedCommunity)
		diags.Append(list_diags...)
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_object *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject
	if obj.NoRedist != nil {
		noRedist_object = new(VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject)

		diags.Append(noRedist_object.CopyFromPango(ctx, obj.NoRedist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_object *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject
	if obj.Redist != nil {
		redist_object = new(VirtualRouterDataSourceProtocolRedistProfileActionRedistObject)

		diags.Append(redist_object.CopyFromPango(ctx, obj.Redist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var filter_object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject
	if obj.Filter != nil {
		filter_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject)

		diags.Append(filter_object.CopyFromPango(ctx, obj.Filter, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6Filter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics
		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Type)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics
		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var ospfv3_object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object
	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var list_diags diag.Diagnostics
		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Area)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics
		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PathType)
		diags.Append(list_diags...)
	}

	o.Area = area_list
	o.Tag = tag_list
	o.PathType = pathType_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6FilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics
		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Community)
		diags.Append(list_diags...)
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExtendedCommunity)
		diags.Append(list_diags...)
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6Action, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject
	if obj.NoRedist != nil {
		noRedist_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject)

		diags.Append(noRedist_object.CopyFromPango(ctx, obj.NoRedist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject
	if obj.Redist != nil {
		redist_object = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject)

		diags.Append(redist_object.CopyFromPango(ctx, obj.Redist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6ActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterDataSourceProtocolRipInterfacesObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterDataSourceProtocolRipInterfacesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterDataSourceProtocolRipAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolRipExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterDataSourceProtocolRipExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *VirtualRouterDataSourceProtocolRipGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterDataSourceProtocolRipGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterDataSourceProtocolRipTimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterDataSourceProtocolRipTimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.GlobalBfd = globalBfd_object
	o.Interfaces = interfaces_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Timers = timers_object
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterDataSourceProtocolRipInterfacesBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceProtocolRipInterfacesBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	o.Name = types.StringValue(obj.Name)
	o.DefaultRoute = defaultRoute_object
	o.Bfd = bfd_object
	o.Enable = enable_value
	o.Authentication = authentication_value
	o.Mode = mode_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipTimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var deleteIntervals_value types.Int64
	if obj.DeleteIntervals != nil {
		deleteIntervals_value = types.Int64Value(*obj.DeleteIntervals)
	}
	var expireIntervals_value types.Int64
	if obj.ExpireIntervals != nil {
		expireIntervals_value = types.Int64Value(*obj.ExpireIntervals)
	}
	var intervalSeconds_value types.Int64
	if obj.IntervalSeconds != nil {
		intervalSeconds_value = types.Int64Value(*obj.IntervalSeconds)
	}
	var updateIntervals_value types.Int64
	if obj.UpdateIntervals != nil {
		updateIntervals_value = types.Int64Value(*obj.UpdateIntervals)
	}
	o.DeleteIntervals = deleteIntervals_value
	o.ExpireIntervals = expireIntervals_value
	o.IntervalSeconds = intervalSeconds_value
	o.UpdateIntervals = updateIntervals_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
		for _, elt := range obj.Md5 {
			var entry VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			md5_tf_entries = append(md5_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *VirtualRouterDataSourceRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(VirtualRouterDataSourceRoutingTableIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *VirtualRouterDataSourceRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(VirtualRouterDataSourceRoutingTableIpv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRouteObject
		for _, elt := range obj.StaticRoute {
			var entry VirtualRouterDataSourceRoutingTableIpStaticRouteObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nexthop_object *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject)

		diags.Append(nexthop_object.CopyFromPango(ctx, obj.Nexthop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_object *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject
	if obj.RouteTable != nil {
		routeTable_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject)

		diags.Append(routeTable_object.CopyFromPango(ctx, obj.RouteTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject)

		diags.Append(pathMonitor_object.CopyFromPango(ctx, obj.PathMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.RouteTable = routeTable_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object
	o.Destination = destination_value
	o.Interface = interface_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var receive_object *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject
	if obj.Receive != nil {
		receive_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject)

		diags.Append(receive_object.CopyFromPango(ctx, obj.Receive, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_object *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject)

		diags.Append(discard_object.CopyFromPango(ctx, obj.Discard, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	o.Receive = receive_object
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.Fqdn = fqdn_value
	o.NextVr = nextVr_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_object *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject
	if obj.Unicast != nil {
		unicast_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject)

		diags.Append(unicast_object.CopyFromPango(ctx, obj.Unicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject)

		diags.Append(multicast_object.CopyFromPango(ctx, obj.Multicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_object *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject
	if obj.Both != nil {
		both_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject)

		diags.Append(both_object.CopyFromPango(ctx, obj.Both, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_object *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject
	if obj.NoInstall != nil {
		noInstall_object = new(VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject)

		diags.Append(noInstall_object.CopyFromPango(ctx, obj.NoInstall, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Unicast = unicast_object
	o.Multicast = multicast_object
	o.Both = both_object
	o.NoInstall = noInstall_object

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			var entry VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject
		for _, elt := range obj.StaticRoute {
			var entry VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject)

		diags.Append(nexthop_object.CopyFromPango(ctx, obj.Nexthop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var option_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject
	if obj.Option != nil {
		option_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject)

		diags.Append(option_object.CopyFromPango(ctx, obj.Option, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject
	if obj.RouteTable != nil {
		routeTable_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject)

		diags.Append(routeTable_object.CopyFromPango(ctx, obj.RouteTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject)

		diags.Append(pathMonitor_object.CopyFromPango(ctx, obj.PathMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.Bfd = bfd_object
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object
	o.Option = option_object
	o.RouteTable = routeTable_object
	o.PathMonitor = pathMonitor_object
	o.Destination = destination_value
	o.Interface = interface_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var receive_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject
	if obj.Receive != nil {
		receive_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject)

		diags.Append(receive_object.CopyFromPango(ctx, obj.Receive, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject)

		diags.Append(discard_object.CopyFromPango(ctx, obj.Discard, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	o.Receive = receive_object
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.NextVr = nextVr_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteOption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject
	if obj.Unicast != nil {
		unicast_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject)

		diags.Append(unicast_object.CopyFromPango(ctx, obj.Unicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_object *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject
	if obj.NoInstall != nil {
		noInstall_object = new(VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject)

		diags.Append(noInstall_object.CopyFromPango(ctx, obj.NoInstall, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Unicast = unicast_object
	o.NoInstall = noInstall_object

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			var entry VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value

	return diags
}

func VirtualRouterDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": VirtualRouterDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"protocol": VirtualRouterDataSourceProtocolSchema(),

			"routing_table": VirtualRouterDataSourceRoutingTableSchema(),

			"administrative_distances": VirtualRouterDataSourceAdministrativeDistancesSchema(),

			"ecmp": VirtualRouterDataSourceEcmpSchema(),

			"interfaces": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"multicast": VirtualRouterDataSourceMulticastSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": VirtualRouterDataSourceProtocolBgpSchema(),

			"ospf": VirtualRouterDataSourceProtocolOspfSchema(),

			"ospfv3": VirtualRouterDataSourceProtocolOspfv3Schema(),

			"redist_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRedistProfileSchema(),
			},

			"redist_profile_ipv6": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRedistProfileIpv6Schema(),
			},

			"rip": VirtualRouterDataSourceProtocolRipSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterDataSourceProtocolRedistProfileFilterSchema(),

			"action": VirtualRouterDataSourceProtocolRedistProfileActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ospf": VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema(),

			"bgp": VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema(),

			"type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"path_type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"redist": VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema(),

			"no_redist": VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"action": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema(),

			"priority": dsschema.Int64Attribute{
				Description: "priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"destination": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospfv3": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema(),

			"bgp": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema(),

			"type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"path_type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no_redist": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema(),

			"redist": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipAuthProfileSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipExportRulesSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolRipGlobalBfdSchema(),

			"interfaces": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipInterfacesSchema(),
			},

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterDataSourceProtocolRipTimersSchema(),

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema(),

			"bfd": VirtualRouterDataSourceProtocolRipInterfacesBfdSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route via RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipTimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"delete_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route expiration to its deletion",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"expire_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route last updated to its expiration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval_seconds": dsschema.Int64Attribute{
				Description: "timer interval value in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"update_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route advertisement (RIP response packet)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"md5": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": dsschema.BoolAttribute{
				Description: "prefer to use this key when sending packet",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enforce_first_as": dsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpDampeningProfileSchema(),
			},

			"install_route": dsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"policy": VirtualRouterDataSourceProtocolBgpPolicySchema(),

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to BGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpAuthProfileSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolBgpGlobalBfdSchema(),

			"local_as": dsschema.StringAttribute{
				Description: "local AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redist_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpRedistRulesSchema(),
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"routing_options": VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema(),

			"ecmp_multi_as": dsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPeerGroupSchema(),
			},

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from BGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRedistRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"route_table": dsschema.StringAttribute{
				Description: "select destination SAFI for redistribution",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_origin": dsschema.StringAttribute{
				Description: "add the ORIGIN path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"set_extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"address_family_identifier": dsschema.StringAttribute{
				Description: "select redistribution profile type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_med": dsschema.Int64Attribute{
				Description: "add the MULTI_EXIT_DISC path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_local_preference": dsschema.Int64Attribute{
				Description: "add the LOCAL_PREF path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_as_path_limit": dsschema.Int64Attribute{
				Description: "add the AS_PATHLIMIT path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRedistRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregate": VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema(),

			"as_format": dsschema.StringAttribute{
				Description: "AS format",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"confederation_member_as": dsschema.StringAttribute{
				Description: "confederation requires member-AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": dsschema.Int64Attribute{
				Description: "default local preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"graceful_restart": VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema(),

			"med": VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema(),

			"reflector_cluster_id": dsschema.StringAttribute{
				Description: "route reflector cluster ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregate_med": dsschema.BoolAttribute{
				Description: "aggregate route only if they have same MED attributes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": dsschema.Int64Attribute{
				Description: "local restart time to advertise to peer (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_peer_restart_time": dsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": dsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"deterministic_med_comparison": dsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"always_compare_med": dsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"secret": dsschema.StringAttribute{
				Description: "shared secret for the TCP MD5 authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"aggregated_confed_as_path": dsschema.BoolAttribute{
				Description: "the peers understand aggregated confederation AS path",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"soft_reset_with_stored_info": dsschema.BoolAttribute{
				Description: "soft reset with stored info",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ibgp": VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema(),

			"ebgp_confed": VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema(),

			"ibgp_confed": VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema(),

			"ebgp": VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"import_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remove_private_as": dsschema.BoolAttribute{
				Description: "remove private AS when exporting route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peering_type": dsschema.StringAttribute{
				Description: "peering type that affects NOPEER community value handling",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_address": VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema(),

			"bfd": VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema(),

			"local_address": VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema(),

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_mp_bgp": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_family_identifier": dsschema.StringAttribute{
				Description: "select AFI for this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reflector_client": dsschema.StringAttribute{
				Description: "this peer is reflector client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_prefixes": dsschema.StringAttribute{
				Description: "maximum of prefixes to receive from peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"subsequent_address_family_identifier": VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema(),

			"connection_options": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"outgoing_bgp_connection": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema(),

			"keep_alive_interval": dsschema.StringAttribute{
				Description: "keep-alive interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"idle_hold_time": dsschema.Int64Attribute{
				Description: "idle hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.Int64Attribute{
				Description: "IP TTL value used for sending BGP packet. set to 0 means eBGP use 2, iBGP use 255",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"open_delay_time": dsschema.Int64Attribute{
				Description: "open delay time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.StringAttribute{
				Description: "hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"incoming_bgp_connection": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema(),

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_route_adv_interval": dsschema.Int64Attribute{
				Description: "Minimum Route Advertisement Interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "use specific local port for outgoing BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remote_port": dsschema.Int64Attribute{
				Description: "restrict remote port for incoming BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "bgp peer FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpDampeningProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cutoff": dsschema.Float64Attribute{
				Description: "cutoff threshold value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reuse": dsschema.Float64Attribute{
				Description: "reuse threshold value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_hold_time": dsschema.Int64Attribute{
				Description: "maximum of hold-down time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decay_half_life_reachable": dsschema.Int64Attribute{
				Description: "Decay half-life while reachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decay_half_life_unreachable": dsschema.Int64Attribute{
				Description: "Decay half-life while unreachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpDampeningProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregation": VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema(),

			"conditional_advertisement": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema(),

			"export": VirtualRouterDataSourceProtocolBgpPolicyExportSchema(),

			"import": VirtualRouterDataSourceProtocolBgpPolicyImportSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enable aggregation for this prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary": dsschema.BoolAttribute{
				Description: "summarize route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": dsschema.BoolAttribute{
				Description: "generate AS-set attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregate_route_attributes": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema(),

			"suppress_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema(),
			},

			"advertise_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema(),
			},

			"prefix": dsschema.StringAttribute{
				Description: "aggregating address prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema(),

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema(),

			"remove": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema(),

			"prepend": dsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"policy": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this policy",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"non_exist_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema(),
			},

			"advertise_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema(),

			"action": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"deny": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema(),

			"allow": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"update": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema(),

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema(),

			"prepend": dsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remove_and_prepend": dsschema.Int64Attribute{
				Description: "remove matched AS path(s), and prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema(),

			"action": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema(),

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"deny": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema(),

			"allow": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"dampening": dsschema.StringAttribute{
				Description: "route flap dampening profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"update": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema(),

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema(),

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAuthProfileSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfExportRulesSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolOspfGlobalBfdSchema(),

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": dsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaSchema(),
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterDataSourceProtocolOspfTimersSchema(),

			"graceful_restart": VirtualRouterDataSourceProtocolOspfGracefulRestartSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": dsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"new_tag": dsschema.StringAttribute{
				Description: "new tag value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolOspfAreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema(),

			"stub": VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema(),

			"nssa": VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"default_route": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema(),

			"accept_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": dsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema(),

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema(),

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema(),

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"md5": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": dsschema.BoolAttribute{
				Description: "use this key when sending packet",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfTimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lsa_interval": dsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": dsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_l_s_a_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema(),

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaSchema(),
			},

			"disable_transit_traffic": dsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema(),
			},

			"graceful_restart": VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema(),

			"timers": VirtualRouterDataSourceProtocolOspfv3TimersSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3TimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lsa_interval": dsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": dsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3TimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema(),

			"stub": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema(),

			"nssa": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"type": dsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema(),

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema(),

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": dsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": dsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"new_tag": dsschema.StringAttribute{
				Description: "new tag value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"strict_l_s_a_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"spi": dsschema.StringAttribute{
				Description: "SPI for both inbound and outbound SA, hex format xxxxxxxx.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"esp": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema(),

			"ah": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"authentication": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema(),

			"encryption": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"sha512": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema(),

			"none": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema(),

			"md5": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema(),

			"sha1": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema(),

			"sha256": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema(),

			"sha384": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: 3des: 6, aes128: 4, aes192: 6, aes256: 8",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"sha1": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema(),

			"sha256": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema(),

			"sha384": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema(),

			"sha512": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema(),

			"md5": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": VirtualRouterDataSourceRoutingTableIpSchema(),

			"ipv6": VirtualRouterDataSourceRoutingTableIpv6Schema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorSchema(),

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopSchema(),

			"route_table": VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"receive": VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveSchema(),

			"discard": VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardSchema(),

			"ip_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": dsschema.StringAttribute{
				Description: "Next hop virtual router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopReceiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"multicast": VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastSchema(),

			"both": VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothSchema(),

			"no_install": VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallSchema(),

			"unicast": VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableUnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteRouteTableNoInstallSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpStaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"static_route": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"administrative_distance": dsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdSchema(),

			"route_table": VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableSchema(),

			"path_monitor": VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorSchema(),

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopSchema(),

			"option": VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"receive": VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveSchema(),

			"discard": VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": dsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": dsschema.StringAttribute{
				Description: "Next hop virtual router",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopReceiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteOptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema(),

			"no_install": VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": dsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"monitor_destinations": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source": dsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": dsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": dsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"count": dsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceAdministrativeDistancesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ebgp": dsschema.Int64Attribute{
				Description: "administrative distance used for eBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ibgp": dsschema.Int64Attribute{
				Description: "administrative distance used for iBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPF external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": dsschema.Int64Attribute{
				Description: "administrative distance used for RIP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": dsschema.Int64Attribute{
				Description: "administrative distance used for ipv6 static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_int": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPF internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_int": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static": dsschema.Int64Attribute{
				Description: "administrative distance used for static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": VirtualRouterDataSourceEcmpAlgorithmSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": dsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": dsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": dsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip_modulo": VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema(),

			"weighted_round_robin": VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema(),

			"balanced_round_robin": VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_hash": VirtualRouterDataSourceEcmpAlgorithmIpHashSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpHashSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"hash_seed": dsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"src_only": dsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": dsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupSchema(),
			},

			"route_ageout_time": dsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rp": VirtualRouterDataSourceMulticastRpSchema(),

			"spt_threshold": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastSptThresholdSchema(),
			},

			"ssm_address_space": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastSsmAddressSpaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"external_rp": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastRpExternalRpSchema(),
			},

			"local_rp": VirtualRouterDataSourceMulticastRpLocalRpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpExternalRpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"candidate_rp": VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema(),

			"static_rp": VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": dsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address": dsschema.StringAttribute{
				Description: "local RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSptThresholdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSsmAddressSpaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_permission": VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema(),

			"igmp": VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema(),

			"pim": VirtualRouterDataSourceMulticastInterfaceGroupPimSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"any_source_multicast": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema(),
			},

			"source_specific_multicast": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": dsschema.StringAttribute{
				Description: "source-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"immediate_leave": dsschema.BoolAttribute{
				Description: "leave group immediately when a leave message is received",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sources": dsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": dsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"version": dsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"query_interval": dsschema.Int64Attribute{
				Description: "interval between group/source specific query messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_groups": dsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_query_response_time": dsschema.Float64Attribute{
				Description: "maximum query response time for general group membership queries in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"last_member_query_interval": dsschema.Float64Attribute{
				Description: "interval between group/source specific query messages (including those sent in response of leave group messages)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": dsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupPimSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bsr_border": dsschema.BoolAttribute{
				Description: "interface is bootstrap border",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allowed_neighbors": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"assert_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Assert messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Hello messages, in seconds, a value of 0 represents an 'infinite' interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"join_prune_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Join/Prune messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": dsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

// Metadata returns the data source type name.
func (d *VirtualRouterDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

// Schema defines the schema for this data source.
func (d *VirtualRouterDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = VirtualRouterDataSourceSchema()
}

// Configure prepares the struct.
func (d *VirtualRouterDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := virtual_router.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, virtual_router.NewService(d.client), specifier, virtual_router.SpecMatches)
}

func (o *VirtualRouterDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state VirtualRouterDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location virtual_router.Location

	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &virtual_router.TemplateStackLocation{

			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
		}
	}
	if savestate.Location.Ngfw != nil {
		location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &virtual_router.TemplateLocation{

			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &VirtualRouterResource{}
	_ resource.ResourceWithConfigure   = &VirtualRouterResource{}
	_ resource.ResourceWithImportState = &VirtualRouterResource{}
)

func NewVirtualRouterResource() resource.Resource {
	if _, found := resourceFuncMap["panos_virtual_router"]; !found {
		resourceFuncMap["panos_virtual_router"] = resourceFuncs{
			CreateImportId: VirtualRouterImportStateCreator,
		}
	}
	return &VirtualRouterResource{}
}

type VirtualRouterResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}

func VirtualRouterResourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

type VirtualRouterResourceModel struct {
	Location                VirtualRouterLocation                               `tfsdk:"location"`
	Name                    types.String                                        `tfsdk:"name"`
	Protocol                *VirtualRouterResourceProtocolObject                `tfsdk:"protocol"`
	RoutingTable            *VirtualRouterResourceRoutingTableObject            `tfsdk:"routing_table"`
	AdministrativeDistances *VirtualRouterResourceAdministrativeDistancesObject `tfsdk:"administrative_distances"`
	Ecmp                    *VirtualRouterResourceEcmpObject                    `tfsdk:"ecmp"`
	Interfaces              types.List                                          `tfsdk:"interfaces"`
	Multicast               *VirtualRouterResourceMulticastObject               `tfsdk:"multicast"`
}
type VirtualRouterResourceProtocolObject struct {
	RedistProfileIpv6 types.List                                 `tfsdk:"redist_profile_ipv6"`
	Rip               *VirtualRouterResourceProtocolRipObject    `tfsdk:"rip"`
	Bgp               *VirtualRouterResourceProtocolBgpObject    `tfsdk:"bgp"`
	Ospf              *VirtualRouterResourceProtocolOspfObject   `tfsdk:"ospf"`
	Ospfv3            *VirtualRouterResourceProtocolOspfv3Object `tfsdk:"ospfv3"`
	RedistProfile     types.List                                 `tfsdk:"redist_profile"`
}
type VirtualRouterResourceProtocolOspfObject struct {
	GracefulRestart         *VirtualRouterResourceProtocolOspfGracefulRestartObject `tfsdk:"graceful_restart"`
	GlobalBfd               *VirtualRouterResourceProtocolOspfGlobalBfdObject       `tfsdk:"global_bfd"`
	RejectDefaultRoute      types.Bool                                              `tfsdk:"reject_default_route"`
	Rfc1583                 types.Bool                                              `tfsdk:"rfc1583"`
	AllowRedistDefaultRoute types.Bool                                              `tfsdk:"allow_redist_default_route"`
	Area                    types.List                                              `tfsdk:"area"`
	AuthProfile             types.List                                              `tfsdk:"auth_profile"`
	Enable                  types.Bool                                              `tfsdk:"enable"`
	ExportRules             types.List                                              `tfsdk:"export_rules"`
	RouterId                types.String                                            `tfsdk:"router_id"`
	Timers                  *VirtualRouterResourceProtocolOspfTimersObject          `tfsdk:"timers"`
}
type VirtualRouterResourceProtocolOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterResourceProtocolOspfAreaObject struct {
	Name        types.String                                     `tfsdk:"name"`
	Type        *VirtualRouterResourceProtocolOspfAreaTypeObject `tfsdk:"type"`
	Range       types.List                                       `tfsdk:"range"`
	Interface   types.List                                       `tfsdk:"interface"`
	VirtualLink types.List                                       `tfsdk:"virtual_link"`
}
type VirtualRouterResourceProtocolOspfAreaTypeObject struct {
	Normal *VirtualRouterResourceProtocolOspfAreaTypeNormalObject `tfsdk:"normal"`
	Stub   *VirtualRouterResourceProtocolOspfAreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *VirtualRouterResourceProtocolOspfAreaTypeNssaObject   `tfsdk:"nssa"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNormalObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeStubObject struct {
	AcceptSummary types.Bool                                                       `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject `tfsdk:"default_route"`
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject struct {
	Advertise *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject `tfsdk:"advertise"`
	Disable   *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject   `tfsdk:"disable"`
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaObject struct {
	AcceptSummary types.Bool                                                       `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject `tfsdk:"default_route"`
	NssaExtRange  types.List                                                       `tfsdk:"nssa_ext_range"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject struct {
	Disable   *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject struct {
	Name      types.String                                                              `tfsdk:"name"`
	Advertise *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfAreaRangeObject struct {
	Name      types.String                                               `tfsdk:"name"`
	Advertise *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfAreaRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceObject struct {
	Name               types.String                                                  `tfsdk:"name"`
	Enable             types.Bool                                                    `tfsdk:"enable"`
	Priority           types.Int64                                                   `tfsdk:"priority"`
	RetransmitInterval types.Int64                                                   `tfsdk:"retransmit_interval"`
	GrDelay            types.Int64                                                   `tfsdk:"gr_delay"`
	LinkType           *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	Passive            types.Bool                                                    `tfsdk:"passive"`
	Metric             types.Int64                                                   `tfsdk:"metric"`
	HelloInterval      types.Int64                                                   `tfsdk:"hello_interval"`
	DeadCounts         types.Int64                                                   `tfsdk:"dead_counts"`
	TransitDelay       types.Int64                                                   `tfsdk:"transit_delay"`
	Authentication     types.String                                                  `tfsdk:"authentication"`
	Neighbor           types.List                                                    `tfsdk:"neighbor"`
	Bfd                *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject struct {
	Broadcast *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfAreaVirtualLinkObject struct {
	Name               types.String                                               `tfsdk:"name"`
	Bfd                *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject `tfsdk:"bfd"`
	TransitAreaId      types.String                                               `tfsdk:"transit_area_id"`
	Enable             types.Bool                                                 `tfsdk:"enable"`
	HelloInterval      types.Int64                                                `tfsdk:"hello_interval"`
	TransitDelay       types.Int64                                                `tfsdk:"transit_delay"`
	NeighborId         types.String                                               `tfsdk:"neighbor_id"`
	DeadCounts         types.Int64                                                `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64                                                `tfsdk:"retransmit_interval"`
	Authentication     types.String                                               `tfsdk:"authentication"`
}
type VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterResourceProtocolOspfAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Preferred types.Bool   `tfsdk:"preferred"`
	Key       types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
	NewPathType types.String `tfsdk:"new_path_type"`
}
type VirtualRouterResourceProtocolOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfTimersObject struct {
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
}
type VirtualRouterResourceProtocolOspfv3Object struct {
	AllowRedistDefaultRoute types.Bool                                                `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                                `tfsdk:"auth_profile"`
	GlobalBfd               *VirtualRouterResourceProtocolOspfv3GlobalBfdObject       `tfsdk:"global_bfd"`
	RejectDefaultRoute      types.Bool                                                `tfsdk:"reject_default_route"`
	RouterId                types.String                                              `tfsdk:"router_id"`
	Area                    types.List                                                `tfsdk:"area"`
	DisableTransitTraffic   types.Bool                                                `tfsdk:"disable_transit_traffic"`
	Enable                  types.Bool                                                `tfsdk:"enable"`
	ExportRules             types.List                                                `tfsdk:"export_rules"`
	GracefulRestart         *VirtualRouterResourceProtocolOspfv3GracefulRestartObject `tfsdk:"graceful_restart"`
	Timers                  *VirtualRouterResourceProtocolOspfv3TimersObject          `tfsdk:"timers"`
}
type VirtualRouterResourceProtocolOspfv3AreaObject struct {
	Name           types.String                                       `tfsdk:"name"`
	Type           *VirtualRouterResourceProtocolOspfv3AreaTypeObject `tfsdk:"type"`
	Range          types.List                                         `tfsdk:"range"`
	Interface      types.List                                         `tfsdk:"interface"`
	VirtualLink    types.List                                         `tfsdk:"virtual_link"`
	Authentication types.String                                       `tfsdk:"authentication"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeObject struct {
	Normal *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject `tfsdk:"normal"`
	Stub   *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject   `tfsdk:"stub"`
	Nssa   *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject   `tfsdk:"nssa"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubObject struct {
	AcceptSummary types.Bool                                                         `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject `tfsdk:"default_route"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject struct {
	Disable   *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject struct {
	AcceptSummary types.Bool                                                         `tfsdk:"accept_summary"`
	DefaultRoute  *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject `tfsdk:"default_route"`
	NssaExtRange  types.List                                                         `tfsdk:"nssa_ext_range"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject struct {
	Name      types.String                                                                `tfsdk:"name"`
	Advertise *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject struct {
	Disable   *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterResourceProtocolOspfv3AreaRangeObject struct {
	Name      types.String                                                 `tfsdk:"name"`
	Advertise *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject `tfsdk:"advertise"`
	Suppress  *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject  `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceObject struct {
	Name               types.String                                                    `tfsdk:"name"`
	Priority           types.Int64                                                     `tfsdk:"priority"`
	DeadCounts         types.Int64                                                     `tfsdk:"dead_counts"`
	LinkType           *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject `tfsdk:"link_type"`
	HelloInterval      types.Int64                                                     `tfsdk:"hello_interval"`
	GrDelay            types.Int64                                                     `tfsdk:"gr_delay"`
	Enable             types.Bool                                                      `tfsdk:"enable"`
	InstanceId         types.Int64                                                     `tfsdk:"instance_id"`
	TransitDelay       types.Int64                                                     `tfsdk:"transit_delay"`
	Neighbor           types.List                                                      `tfsdk:"neighbor"`
	Passive            types.Bool                                                      `tfsdk:"passive"`
	Metric             types.Int64                                                     `tfsdk:"metric"`
	RetransmitInterval types.Int64                                                     `tfsdk:"retransmit_interval"`
	Authentication     types.String                                                    `tfsdk:"authentication"`
	Bfd                *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject      `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject `tfsdk:"broadcast"`
	P2p       *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject       `tfsdk:"p2p"`
	P2mp      *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject      `tfsdk:"p2mp"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject struct {
	Name               types.String                                                 `tfsdk:"name"`
	TransitAreaId      types.String                                                 `tfsdk:"transit_area_id"`
	Enable             types.Bool                                                   `tfsdk:"enable"`
	InstanceId         types.Int64                                                  `tfsdk:"instance_id"`
	DeadCounts         types.Int64                                                  `tfsdk:"dead_counts"`
	Bfd                *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject `tfsdk:"bfd"`
	NeighborId         types.String                                                 `tfsdk:"neighbor_id"`
	HelloInterval      types.Int64                                                  `tfsdk:"hello_interval"`
	RetransmitInterval types.Int64                                                  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64                                                  `tfsdk:"transit_delay"`
	Authentication     types.String                                                 `tfsdk:"authentication"`
}
type VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfv3ExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterResourceProtocolOspfv3TimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileObject struct {
	Name types.String                                             `tfsdk:"name"`
	Spi  types.String                                             `tfsdk:"spi"`
	Ah   *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject  `tfsdk:"ah"`
	Esp  *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject `tfsdk:"esp"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspObject struct {
	Authentication *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject `tfsdk:"authentication"`
	Encryption     *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject     `tfsdk:"encryption"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject struct {
	Sha1   *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object   `tfsdk:"sha1"`
	Sha256 *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object `tfsdk:"sha256"`
	Sha384 *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object `tfsdk:"sha384"`
	Sha512 *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object `tfsdk:"sha512"`
	None   *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject   `tfsdk:"none"`
	Md5    *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object    `tfsdk:"md5"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject struct {
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject struct {
	Key       types.String `tfsdk:"key"`
	Algorithm types.String `tfsdk:"algorithm"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhObject struct {
	Md5    *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object    `tfsdk:"md5"`
	Sha1   *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object   `tfsdk:"sha1"`
	Sha256 *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object `tfsdk:"sha256"`
	Sha384 *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object `tfsdk:"sha384"`
	Sha512 *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object `tfsdk:"sha512"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolRedistProfileObject struct {
	Name     types.String                                            `tfsdk:"name"`
	Action   *VirtualRouterResourceProtocolRedistProfileActionObject `tfsdk:"action"`
	Priority types.Int64                                             `tfsdk:"priority"`
	Filter   *VirtualRouterResourceProtocolRedistProfileFilterObject `tfsdk:"filter"`
}
type VirtualRouterResourceProtocolRedistProfileFilterObject struct {
	Destination types.List                                                  `tfsdk:"destination"`
	Nexthop     types.List                                                  `tfsdk:"nexthop"`
	Ospf        *VirtualRouterResourceProtocolRedistProfileFilterOspfObject `tfsdk:"ospf"`
	Bgp         *VirtualRouterResourceProtocolRedistProfileFilterBgpObject  `tfsdk:"bgp"`
	Type        types.List                                                  `tfsdk:"type"`
	Interface   types.List                                                  `tfsdk:"interface"`
}
type VirtualRouterResourceProtocolRedistProfileFilterOspfObject struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterResourceProtocolRedistProfileFilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolRedistProfileActionObject struct {
	NoRedist *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject `tfsdk:"no_redist"`
	Redist   *VirtualRouterResourceProtocolRedistProfileActionRedistObject   `tfsdk:"redist"`
}
type VirtualRouterResourceProtocolRedistProfileActionNoRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileActionRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileIpv6Object struct {
	Name     types.String                                                `tfsdk:"name"`
	Priority types.Int64                                                 `tfsdk:"priority"`
	Filter   *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject `tfsdk:"filter"`
	Action   *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject `tfsdk:"action"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterObject struct {
	Interface   types.List                                                        `tfsdk:"interface"`
	Destination types.List                                                        `tfsdk:"destination"`
	Nexthop     types.List                                                        `tfsdk:"nexthop"`
	Ospfv3      *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object `tfsdk:"ospfv3"`
	Bgp         *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject    `tfsdk:"bgp"`
	Type        types.List                                                        `tfsdk:"type"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionObject struct {
	NoRedist *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject `tfsdk:"no_redist"`
	Redist   *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject   `tfsdk:"redist"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject struct {
}
type VirtualRouterResourceProtocolRipObject struct {
	GlobalBfd               *VirtualRouterResourceProtocolRipGlobalBfdObject `tfsdk:"global_bfd"`
	Interfaces              types.List                                       `tfsdk:"interfaces"`
	RejectDefaultRoute      types.Bool                                       `tfsdk:"reject_default_route"`
	Timers                  *VirtualRouterResourceProtocolRipTimersObject    `tfsdk:"timers"`
	AllowRedistDefaultRoute types.Bool                                       `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                       `tfsdk:"auth_profile"`
	Enable                  types.Bool                                       `tfsdk:"enable"`
	ExportRules             types.List                                       `tfsdk:"export_rules"`
}
type VirtualRouterResourceProtocolRipAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterResourceProtocolRipAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Preferred types.Bool   `tfsdk:"preferred"`
	Key       types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolRipExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Metric types.Int64  `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolRipInterfacesObject struct {
	Name           types.String                                                  `tfsdk:"name"`
	Enable         types.Bool                                                    `tfsdk:"enable"`
	Authentication types.String                                                  `tfsdk:"authentication"`
	Mode           types.String                                                  `tfsdk:"mode"`
	DefaultRoute   *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject `tfsdk:"default_route"`
	Bfd            *VirtualRouterResourceProtocolRipInterfacesBfdObject          `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject struct {
	Disable   *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject   `tfsdk:"disable"`
	Advertise *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolRipTimersObject struct {
	DeleteIntervals types.Int64 `tfsdk:"delete_intervals"`
	ExpireIntervals types.Int64 `tfsdk:"expire_intervals"`
	IntervalSeconds types.Int64 `tfsdk:"interval_seconds"`
	UpdateIntervals types.Int64 `tfsdk:"update_intervals"`
}
type VirtualRouterResourceProtocolBgpObject struct {
	DampeningProfile        types.List                                            `tfsdk:"dampening_profile"`
	InstallRoute            types.Bool                                            `tfsdk:"install_route"`
	Policy                  *VirtualRouterResourceProtocolBgpPolicyObject         `tfsdk:"policy"`
	AllowRedistDefaultRoute types.Bool                                            `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List                                            `tfsdk:"auth_profile"`
	GlobalBfd               *VirtualRouterResourceProtocolBgpGlobalBfdObject      `tfsdk:"global_bfd"`
	LocalAs                 types.String                                          `tfsdk:"local_as"`
	RedistRules             types.List                                            `tfsdk:"redist_rules"`
	RouterId                types.String                                          `tfsdk:"router_id"`
	RoutingOptions          *VirtualRouterResourceProtocolBgpRoutingOptionsObject `tfsdk:"routing_options"`
	EcmpMultiAs             types.Bool                                            `tfsdk:"ecmp_multi_as"`
	Enable                  types.Bool                                            `tfsdk:"enable"`
	PeerGroup               types.List                                            `tfsdk:"peer_group"`
	RejectDefaultRoute      types.Bool                                            `tfsdk:"reject_default_route"`
	EnforceFirstAs          types.Bool                                            `tfsdk:"enforce_first_as"`
}
type VirtualRouterResourceProtocolBgpPolicyObject struct {
	Aggregation              *VirtualRouterResourceProtocolBgpPolicyAggregationObject              `tfsdk:"aggregation"`
	ConditionalAdvertisement *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject `tfsdk:"conditional_advertisement"`
	Export                   *VirtualRouterResourceProtocolBgpPolicyExportObject                   `tfsdk:"export"`
	Import                   *VirtualRouterResourceProtocolBgpPolicyImportObject                   `tfsdk:"import"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject struct {
	Policy types.List `tfsdk:"policy"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject struct {
	Name             types.String `tfsdk:"name"`
	UsedBy           types.List   `tfsdk:"used_by"`
	NonExistFilters  types.List   `tfsdk:"non_exist_filters"`
	AdvertiseFilters types.List   `tfsdk:"advertise_filters"`
	Enable           types.Bool   `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject struct {
	Name   types.String                                                                                    `tfsdk:"name"`
	Enable types.Bool                                                                                      `tfsdk:"enable"`
	Match  *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject struct {
	Nexthop           types.List                                                                                                       `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                                       `tfsdk:"from_peer"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                                     `tfsdk:"route_table"`
	Med               types.Int64                                                                                                      `tfsdk:"med"`
	AddressPrefix     types.List                                                                                                       `tfsdk:"address_prefix"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject struct {
	Name   types.String                                                                                     `tfsdk:"name"`
	Enable types.Bool                                                                                       `tfsdk:"enable"`
	Match  *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject struct {
	AsPath            *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                                      `tfsdk:"route_table"`
	Med               types.Int64                                                                                                       `tfsdk:"med"`
	AddressPrefix     types.List                                                                                                        `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                                                        `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                                        `tfsdk:"from_peer"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesObject struct {
	Name   types.String                                                   `tfsdk:"name"`
	Enable types.Bool                                                     `tfsdk:"enable"`
	UsedBy types.List                                                     `tfsdk:"used_by"`
	Match  *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject  `tfsdk:"match"`
	Action *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject `tfsdk:"action"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject struct {
	Med               types.Int64                                                                    `tfsdk:"med"`
	AddressPrefix     types.List                                                                     `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                     `tfsdk:"nexthop"`
	FromPeer          types.List                                                                     `tfsdk:"from_peer"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                   `tfsdk:"route_table"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject struct {
	Deny  *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject  `tfsdk:"deny"`
	Allow *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject struct {
	Update *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject `tfsdk:"update"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject struct {
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject `tfsdk:"extended_community"`
	LocalPreference   types.Int64                                                                                `tfsdk:"local_preference"`
	Med               types.Int64                                                                                `tfsdk:"med"`
	Nexthop           types.String                                                                               `tfsdk:"nexthop"`
	Origin            types.String                                                                               `tfsdk:"origin"`
	AsPathLimit       types.Int64                                                                                `tfsdk:"as_path_limit"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject         `tfsdk:"community"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject struct {
	None        *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                `tfsdk:"remove_regex"`
	Append      types.List                                                                                  `tfsdk:"append"`
	Overwrite   types.List                                                                                  `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                        `tfsdk:"remove_regex"`
	Append      types.List                                                                                          `tfsdk:"append"`
	Overwrite   types.List                                                                                          `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject struct {
	None             *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject   `tfsdk:"none"`
	Remove           *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject `tfsdk:"remove"`
	Prepend          types.Int64                                                                           `tfsdk:"prepend"`
	RemoveAndPrepend types.Int64                                                                           `tfsdk:"remove_and_prepend"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesObject struct {
	Name   types.String                                                   `tfsdk:"name"`
	Match  *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject  `tfsdk:"match"`
	Action *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject `tfsdk:"action"`
	Enable types.Bool                                                     `tfsdk:"enable"`
	UsedBy types.List                                                     `tfsdk:"used_by"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject struct {
	AsPath            *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                   `tfsdk:"route_table"`
	Med               types.Int64                                                                    `tfsdk:"med"`
	AddressPrefix     types.List                                                                     `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                     `tfsdk:"nexthop"`
	FromPeer          types.List                                                                     `tfsdk:"from_peer"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject struct {
	Deny  *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject  `tfsdk:"deny"`
	Allow *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject struct {
	Dampening types.String                                                              `tfsdk:"dampening"`
	Update    *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject `tfsdk:"update"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject struct {
	Med               types.Int64                                                                                `tfsdk:"med"`
	Nexthop           types.String                                                                               `tfsdk:"nexthop"`
	Origin            types.String                                                                               `tfsdk:"origin"`
	Community         *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject         `tfsdk:"community"`
	LocalPreference   types.Int64                                                                                `tfsdk:"local_preference"`
	Weight            types.Int64                                                                                `tfsdk:"weight"`
	AsPathLimit       types.Int64                                                                                `tfsdk:"as_path_limit"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject            `tfsdk:"as_path"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject struct {
	None   *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject   `tfsdk:"none"`
	Remove *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject `tfsdk:"remove"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject struct {
	Append      types.List                                                                                          `tfsdk:"append"`
	Overwrite   types.List                                                                                          `tfsdk:"overwrite"`
	None        *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                        `tfsdk:"remove_regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject struct {
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                `tfsdk:"remove_regex"`
	Append      types.List                                                                                  `tfsdk:"append"`
	Overwrite   types.List                                                                                  `tfsdk:"overwrite"`
	None        *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject      `tfsdk:"none"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationObject struct {
	Address types.List `tfsdk:"address"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject struct {
	Name                     types.String                                                                            `tfsdk:"name"`
	AdvertiseFilters         types.List                                                                              `tfsdk:"advertise_filters"`
	Prefix                   types.String                                                                            `tfsdk:"prefix"`
	Enable                   types.Bool                                                                              `tfsdk:"enable"`
	Summary                  types.Bool                                                                              `tfsdk:"summary"`
	AsSet                    types.Bool                                                                              `tfsdk:"as_set"`
	AggregateRouteAttributes *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject `tfsdk:"aggregate_route_attributes"`
	SuppressFilters          types.List                                                                              `tfsdk:"suppress_filters"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject struct {
	Name   types.String                                                                        `tfsdk:"name"`
	Match  *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject `tfsdk:"match"`
	Enable types.Bool                                                                          `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject struct {
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                         `tfsdk:"route_table"`
	Med               types.Int64                                                                                          `tfsdk:"med"`
	AddressPrefix     types.List                                                                                           `tfsdk:"address_prefix"`
	Nexthop           types.List                                                                                           `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                           `tfsdk:"from_peer"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject         `tfsdk:"community"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject struct {
	Name   types.String                                                                         `tfsdk:"name"`
	Enable types.Bool                                                                           `tfsdk:"enable"`
	Match  *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject struct {
	Nexthop           types.List                                                                                            `tfsdk:"nexthop"`
	FromPeer          types.List                                                                                            `tfsdk:"from_peer"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject `tfsdk:"extended_community"`
	RouteTable        types.String                                                                                          `tfsdk:"route_table"`
	Med               types.Int64                                                                                           `tfsdk:"med"`
	AddressPrefix     types.List                                                                                            `tfsdk:"address_prefix"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject struct {
	Med               types.Int64                                                                                              `tfsdk:"med"`
	Nexthop           types.String                                                                                             `tfsdk:"nexthop"`
	AsPath            *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject            `tfsdk:"as_path"`
	Community         *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject         `tfsdk:"community"`
	ExtendedCommunity *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject `tfsdk:"extended_community"`
	LocalPreference   types.Int64                                                                                              `tfsdk:"local_preference"`
	Weight            types.Int64                                                                                              `tfsdk:"weight"`
	Origin            types.String                                                                                             `tfsdk:"origin"`
	AsPathLimit       types.Int64                                                                                              `tfsdk:"as_path_limit"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject struct {
	None        *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                              `tfsdk:"remove_regex"`
	Append      types.List                                                                                                `tfsdk:"append"`
	Overwrite   types.List                                                                                                `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject struct {
	None        *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject      `tfsdk:"none"`
	RemoveAll   *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject `tfsdk:"remove_all"`
	RemoveRegex types.String                                                                                                      `tfsdk:"remove_regex"`
	Append      types.List                                                                                                        `tfsdk:"append"`
	Overwrite   types.List                                                                                                        `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject struct {
	Prepend types.Int64                                                                                         `tfsdk:"prepend"`
	None    *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject   `tfsdk:"none"`
	Remove  *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject `tfsdk:"remove"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject struct {
}
type VirtualRouterResourceProtocolBgpDampeningProfileObject struct {
	Name                     types.String  `tfsdk:"name"`
	MaxHoldTime              types.Int64   `tfsdk:"max_hold_time"`
	DecayHalfLifeReachable   types.Int64   `tfsdk:"decay_half_life_reachable"`
	DecayHalfLifeUnreachable types.Int64   `tfsdk:"decay_half_life_unreachable"`
	Enable                   types.Bool    `tfsdk:"enable"`
	Cutoff                   types.Float64 `tfsdk:"cutoff"`
	Reuse                    types.Float64 `tfsdk:"reuse"`
}
type VirtualRouterResourceProtocolBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolBgpRedistRulesObject struct {
	Name                    types.String `tfsdk:"name"`
	Metric                  types.Int64  `tfsdk:"metric"`
	SetCommunity            types.List   `tfsdk:"set_community"`
	SetExtendedCommunity    types.List   `tfsdk:"set_extended_community"`
	RouteTable              types.String `tfsdk:"route_table"`
	SetOrigin               types.String `tfsdk:"set_origin"`
	SetMed                  types.Int64  `tfsdk:"set_med"`
	SetLocalPreference      types.Int64  `tfsdk:"set_local_preference"`
	SetAsPathLimit          types.Int64  `tfsdk:"set_as_path_limit"`
	AddressFamilyIdentifier types.String `tfsdk:"address_family_identifier"`
	Enable                  types.Bool   `tfsdk:"enable"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsObject struct {
	Aggregate              *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject       `tfsdk:"aggregate"`
	AsFormat               types.String                                                         `tfsdk:"as_format"`
	ConfederationMemberAs  types.String                                                         `tfsdk:"confederation_member_as"`
	DefaultLocalPreference types.Int64                                                          `tfsdk:"default_local_preference"`
	GracefulRestart        *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject `tfsdk:"graceful_restart"`
	Med                    *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject             `tfsdk:"med"`
	ReflectorClusterId     types.String                                                         `tfsdk:"reflector_cluster_id"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject struct {
	AggregateMed types.Bool `tfsdk:"aggregate_med"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type VirtualRouterResourceProtocolBgpAuthProfileObject struct {
	Name   types.String `tfsdk:"name"`
	Secret types.String `tfsdk:"secret"`
}
type VirtualRouterResourceProtocolBgpPeerGroupObject struct {
	Name                    types.String                                         `tfsdk:"name"`
	Type                    *VirtualRouterResourceProtocolBgpPeerGroupTypeObject `tfsdk:"type"`
	Peer                    types.List                                           `tfsdk:"peer"`
	Enable                  types.Bool                                           `tfsdk:"enable"`
	AggregatedConfedAsPath  types.Bool                                           `tfsdk:"aggregated_confed_as_path"`
	SoftResetWithStoredInfo types.Bool                                           `tfsdk:"soft_reset_with_stored_info"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeObject struct {
	Ibgp       *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject       `tfsdk:"ibgp"`
	EbgpConfed *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject `tfsdk:"ebgp_confed"`
	IbgpConfed *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject `tfsdk:"ibgp_confed"`
	Ebgp       *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject       `tfsdk:"ebgp"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject struct {
	ImportNexthop   types.String `tfsdk:"import_nexthop"`
	ExportNexthop   types.String `tfsdk:"export_nexthop"`
	RemovePrivateAs types.Bool   `tfsdk:"remove_private_as"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerObject struct {
	Name                              types.String                                                                          `tfsdk:"name"`
	Enable                            types.Bool                                                                            `tfsdk:"enable"`
	PeeringType                       types.String                                                                          `tfsdk:"peering_type"`
	PeerAddress                       *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject                       `tfsdk:"peer_address"`
	Bfd                               *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject                               `tfsdk:"bfd"`
	MaxPrefixes                       types.String                                                                          `tfsdk:"max_prefixes"`
	SubsequentAddressFamilyIdentifier *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject `tfsdk:"subsequent_address_family_identifier"`
	LocalAddress                      *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject                      `tfsdk:"local_address"`
	PeerAs                            types.String                                                                          `tfsdk:"peer_as"`
	EnableMpBgp                       types.Bool                                                                            `tfsdk:"enable_mp_bgp"`
	AddressFamilyIdentifier           types.String                                                                          `tfsdk:"address_family_identifier"`
	EnableSenderSideLoopDetection     types.Bool                                                                            `tfsdk:"enable_sender_side_loop_detection"`
	ReflectorClient                   types.String                                                                          `tfsdk:"reflector_client"`
	ConnectionOptions                 *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject                 `tfsdk:"connection_options"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject struct {
	Unicast   types.Bool `tfsdk:"unicast"`
	Multicast types.Bool `tfsdk:"multicast"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject struct {
	Authentication        types.String                                                                               `tfsdk:"authentication"`
	MinRouteAdvInterval   types.Int64                                                                                `tfsdk:"min_route_adv_interval"`
	Multihop              types.Int64                                                                                `tfsdk:"multihop"`
	OpenDelayTime         types.Int64                                                                                `tfsdk:"open_delay_time"`
	HoldTime              types.String                                                                               `tfsdk:"hold_time"`
	IncomingBgpConnection *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject `tfsdk:"incoming_bgp_connection"`
	KeepAliveInterval     types.String                                                                               `tfsdk:"keep_alive_interval"`
	IdleHoldTime          types.Int64                                                                                `tfsdk:"idle_hold_time"`
	OutgoingBgpConnection *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject `tfsdk:"outgoing_bgp_connection"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject struct {
	LocalPort types.Int64 `tfsdk:"local_port"`
	Allow     types.Bool  `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject struct {
	RemotePort types.Int64 `tfsdk:"remote_port"`
	Allow      types.Bool  `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceRoutingTableObject struct {
	Ip   *VirtualRouterResourceRoutingTableIpObject   `tfsdk:"ip"`
	Ipv6 *VirtualRouterResourceRoutingTableIpv6Object `tfsdk:"ipv6"`
}
type VirtualRouterResourceRoutingTableIpObject struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type VirtualRouterResourceRoutingTableIpStaticRouteObject struct {
	Name                   types.String                                                     `tfsdk:"name"`
	PathMonitor            *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject `tfsdk:"path_monitor"`
	Destination            types.String                                                     `tfsdk:"destination"`
	Interface              types.String                                                     `tfsdk:"interface"`
	AdministrativeDistance types.Int64                                                      `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                      `tfsdk:"metric"`
	Nexthop                *VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject     `tfsdk:"nexthop"`
	RouteTable             *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject  `tfsdk:"route_table"`
	Bfd                    *VirtualRouterResourceRoutingTableIpStaticRouteBfdObject         `tfsdk:"bfd"`
}
type VirtualRouterResourceRoutingTableIpStaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject struct {
	Enable              types.Bool   `tfsdk:"enable"`
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
}
type VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Enable      types.Bool   `tfsdk:"enable"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
}
type VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject struct {
	NextVr    types.String                                                        `tfsdk:"next_vr"`
	Receive   *VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject `tfsdk:"receive"`
	Discard   *VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject `tfsdk:"discard"`
	IpAddress types.String                                                        `tfsdk:"ip_address"`
	Fqdn      types.String                                                        `tfsdk:"fqdn"`
}
type VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject struct {
}
type VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject struct {
}
type VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject struct {
	Unicast   *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject   `tfsdk:"unicast"`
	Multicast *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject `tfsdk:"multicast"`
	Both      *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject      `tfsdk:"both"`
	NoInstall *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject `tfsdk:"no_install"`
}
type VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject struct {
}
type VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject struct {
}
type VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject struct {
}
type VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject struct {
}
type VirtualRouterResourceRoutingTableIpv6Object struct {
	StaticRoute types.List `tfsdk:"static_route"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteObject struct {
	Name                   types.String                                                       `tfsdk:"name"`
	AdministrativeDistance types.Int64                                                        `tfsdk:"administrative_distance"`
	Metric                 types.Int64                                                        `tfsdk:"metric"`
	Bfd                    *VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject         `tfsdk:"bfd"`
	PathMonitor            *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject `tfsdk:"path_monitor"`
	Destination            types.String                                                       `tfsdk:"destination"`
	Interface              types.String                                                       `tfsdk:"interface"`
	Nexthop                *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject     `tfsdk:"nexthop"`
	Option                 *VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject      `tfsdk:"option"`
	RouteTable             *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject  `tfsdk:"route_table"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject struct {
	Receive     *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject `tfsdk:"receive"`
	Discard     *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject `tfsdk:"discard"`
	Ipv6Address types.String                                                          `tfsdk:"ipv6_address"`
	NextVr      types.String                                                          `tfsdk:"next_vr"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject struct {
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject struct {
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject struct {
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject struct {
	Unicast   *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject   `tfsdk:"unicast"`
	NoInstall *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject `tfsdk:"no_install"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject struct {
}
type VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject struct {
}
type VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject struct {
	FailureCondition    types.String `tfsdk:"failure_condition"`
	HoldTime            types.Int64  `tfsdk:"hold_time"`
	MonitorDestinations types.List   `tfsdk:"monitor_destinations"`
	Enable              types.Bool   `tfsdk:"enable"`
}
type VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject struct {
	Name        types.String `tfsdk:"name"`
	Source      types.String `tfsdk:"source"`
	Destination types.String `tfsdk:"destination"`
	Interval    types.Int64  `tfsdk:"interval"`
	Count       types.Int64  `tfsdk:"count"`
	Enable      types.Bool   `tfsdk:"enable"`
}
type VirtualRouterResourceAdministrativeDistancesObject struct {
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Static     types.Int64 `tfsdk:"static"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
	Ebgp       types.Int64 `tfsdk:"ebgp"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
	Rip        types.Int64 `tfsdk:"rip"`
}
type VirtualRouterResourceEcmpObject struct {
	Algorithm        *VirtualRouterResourceEcmpAlgorithmObject `tfsdk:"algorithm"`
	Enable           types.Bool                                `tfsdk:"enable"`
	MaxPaths         types.Int64                               `tfsdk:"max_paths"`
	StrictSourcePath types.Bool                                `tfsdk:"strict_source_path"`
	SymmetricReturn  types.Bool                                `tfsdk:"symmetric_return"`
}
type VirtualRouterResourceEcmpAlgorithmObject struct {
	BalancedRoundRobin *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject `tfsdk:"balanced_round_robin"`
	IpHash             *VirtualRouterResourceEcmpAlgorithmIpHashObject             `tfsdk:"ip_hash"`
	IpModulo           *VirtualRouterResourceEcmpAlgorithmIpModuloObject           `tfsdk:"ip_modulo"`
	WeightedRoundRobin *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject `tfsdk:"weighted_round_robin"`
}
type VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterResourceEcmpAlgorithmIpHashObject struct {
	UsePort  types.Bool  `tfsdk:"use_port"`
	HashSeed types.Int64 `tfsdk:"hash_seed"`
	SrcOnly  types.Bool  `tfsdk:"src_only"`
}
type VirtualRouterResourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type VirtualRouterResourceMulticastObject struct {
	Enable          types.Bool                              `tfsdk:"enable"`
	InterfaceGroup  types.List                              `tfsdk:"interface_group"`
	RouteAgeoutTime types.Int64                             `tfsdk:"route_ageout_time"`
	Rp              *VirtualRouterResourceMulticastRpObject `tfsdk:"rp"`
	SptThreshold    types.List                              `tfsdk:"spt_threshold"`
	SsmAddressSpace types.List                              `tfsdk:"ssm_address_space"`
}
type VirtualRouterResourceMulticastSsmAddressSpaceObject struct {
	Name         types.String `tfsdk:"name"`
	Included     types.Bool   `tfsdk:"included"`
	GroupAddress types.String `tfsdk:"group_address"`
}
type VirtualRouterResourceMulticastInterfaceGroupObject struct {
	Name            types.String                                                       `tfsdk:"name"`
	Description     types.String                                                       `tfsdk:"description"`
	Interface       types.List                                                         `tfsdk:"interface"`
	GroupPermission *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject `tfsdk:"group_permission"`
	Igmp            *VirtualRouterResourceMulticastInterfaceGroupIgmpObject            `tfsdk:"igmp"`
	Pim             *VirtualRouterResourceMulticastInterfaceGroupPimObject             `tfsdk:"pim"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject struct {
	AnySourceMulticast      types.List `tfsdk:"any_source_multicast"`
	SourceSpecificMulticast types.List `tfsdk:"source_specific_multicast"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject struct {
	Name          types.String `tfsdk:"name"`
	SourceAddress types.String `tfsdk:"source_address"`
	Included      types.Bool   `tfsdk:"included"`
	GroupAddress  types.String `tfsdk:"group_address"`
}
type VirtualRouterResourceMulticastInterfaceGroupIgmpObject struct {
	QueryInterval           types.Int64   `tfsdk:"query_interval"`
	ImmediateLeave          types.Bool    `tfsdk:"immediate_leave"`
	MaxSources              types.String  `tfsdk:"max_sources"`
	RouterAlertPolicing     types.Bool    `tfsdk:"router_alert_policing"`
	Enable                  types.Bool    `tfsdk:"enable"`
	Version                 types.String  `tfsdk:"version"`
	Robustness              types.String  `tfsdk:"robustness"`
	MaxGroups               types.String  `tfsdk:"max_groups"`
	MaxQueryResponseTime    types.Float64 `tfsdk:"max_query_response_time"`
	LastMemberQueryInterval types.Float64 `tfsdk:"last_member_query_interval"`
}
type VirtualRouterResourceMulticastInterfaceGroupPimObject struct {
	BsrBorder         types.Bool  `tfsdk:"bsr_border"`
	AllowedNeighbors  types.List  `tfsdk:"allowed_neighbors"`
	Enable            types.Bool  `tfsdk:"enable"`
	AssertInterval    types.Int64 `tfsdk:"assert_interval"`
	HelloInterval     types.Int64 `tfsdk:"hello_interval"`
	JoinPruneInterval types.Int64 `tfsdk:"join_prune_interval"`
	DrPriority        types.Int64 `tfsdk:"dr_priority"`
}
type VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceMulticastRpObject struct {
	ExternalRp types.List                                     `tfsdk:"external_rp"`
	LocalRp    *VirtualRouterResourceMulticastRpLocalRpObject `tfsdk:"local_rp"`
}
type VirtualRouterResourceMulticastRpExternalRpObject struct {
	Name           types.String `tfsdk:"name"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterResourceMulticastRpLocalRpObject struct {
	CandidateRp *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject `tfsdk:"candidate_rp"`
	StaticRp    *VirtualRouterResourceMulticastRpLocalRpStaticRpObject    `tfsdk:"static_rp"`
}
type VirtualRouterResourceMulticastRpLocalRpCandidateRpObject struct {
	Address               types.String `tfsdk:"address"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupAddresses        types.List   `tfsdk:"group_addresses"`
	Interface             types.String `tfsdk:"interface"`
	Priority              types.Int64  `tfsdk:"priority"`
}
type VirtualRouterResourceMulticastRpLocalRpStaticRpObject struct {
	Address        types.String `tfsdk:"address"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Interface      types.String `tfsdk:"interface"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterResourceMulticastSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}

func (r *VirtualRouterResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

func (r *VirtualRouterResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func VirtualRouterResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": VirtualRouterResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"protocol": VirtualRouterResourceProtocolSchema(),

			"routing_table": VirtualRouterResourceRoutingTableSchema(),

			"administrative_distances": VirtualRouterResourceAdministrativeDistancesSchema(),

			"ecmp": VirtualRouterResourceEcmpSchema(),

			"interfaces": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"multicast": VirtualRouterResourceMulticastSchema(),
		},
	}
}

func (o *VirtualRouterResourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ospfv3": VirtualRouterResourceProtocolOspfv3Schema(),

			"redist_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRedistProfileSchema(),
			},

			"redist_profile_ipv6": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRedistProfileIpv6Schema(),
			},

			"rip": VirtualRouterResourceProtocolRipSchema(),

			"bgp": VirtualRouterResourceProtocolBgpSchema(),

			"ospf": VirtualRouterResourceProtocolOspfSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"graceful_restart": VirtualRouterResourceProtocolOspfGracefulRestartSchema(),

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaSchema(),
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAuthProfileSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfExportRulesSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolOspfGlobalBfdSchema(),

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": rsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterResourceProtocolOspfTimersSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": rsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},

			"new_tag": rsschema.StringAttribute{
				Description: "new tag value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema(),
			},

			"type": VirtualRouterResourceProtocolOspfAreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"gr_delay": rsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"link_type": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema(),

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema(),

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"bfd": VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema(),

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"nssa": VirtualRouterResourceProtocolOspfAreaTypeNssaSchema(),

			"normal": VirtualRouterResourceProtocolOspfAreaTypeNormalSchema(),

			"stub": VirtualRouterResourceProtocolOspfAreaTypeStubSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"type": rsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": rsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("password"),
						path.MatchRelative().AtParent().AtName("md5"),
					}...),
				},
			},

			"md5": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAuthProfileMd5Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": rsschema.BoolAttribute{
				Description: "use this key when sending packet",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfTimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lsa_interval": rsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": rsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},

			"strict_l_s_a_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"graceful_restart": VirtualRouterResourceProtocolOspfv3GracefulRestartSchema(),

			"timers": VirtualRouterResourceProtocolOspfv3TimersSchema(),

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaSchema(),
			},

			"disable_transit_traffic": rsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3ExportRulesSchema(),
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AuthProfileSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolOspfv3GlobalBfdSchema(),

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3ExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": rsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},

			"new_tag": rsschema.StringAttribute{
				Description: "new tag value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3ExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3GracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},

			"strict_l_s_a_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3TimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lsa_interval": rsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": rsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3TimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3TimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": VirtualRouterResourceProtocolOspfv3AreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema(),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"bfd": VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema(),

			"stub": VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema(),

			"nssa": VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema(),

			"disable": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
				path.MatchRelative().AtParent().AtName("normal"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"type": rsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("suppress"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"link_type": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema(),

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"gr_delay": rsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema(),

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"p2mp": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema(),

			"broadcast": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"spi": rsschema.StringAttribute{
				Description: "SPI for both inbound and outbound SA, hex format xxxxxxxx.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"esp": VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema(),

			"ah": VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"authentication": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema(),

			"encryption": VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"sha256": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema(),

			"sha384": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema(),

			"sha512": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema(),

			"none": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema(),

			"md5": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema(),

			"sha1": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: 3des: 6, aes128: 4, aes192: 6, aes256: 8",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"sha512": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema(),

			"md5": VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema(),

			"sha1": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema(),

			"sha256": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema(),

			"sha384": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3GlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "priority",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterResourceProtocolRedistProfileFilterSchema(),

			"action": VirtualRouterResourceProtocolRedistProfileActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospf": VirtualRouterResourceProtocolRedistProfileFilterOspfSchema(),

			"bgp": VirtualRouterResourceProtocolRedistProfileFilterBgpSchema(),

			"type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"path_type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no_redist": VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema(),

			"redist": VirtualRouterResourceProtocolRedistProfileActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "priority",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema(),

			"action": VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ospfv3": VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema(),

			"bgp": VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema(),

			"type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"path_type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no_redist": VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema(),

			"redist": VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipAuthProfileSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipExportRulesSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolRipGlobalBfdSchema(),

			"interfaces": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipInterfacesSchema(),
			},

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterResourceProtocolRipTimersSchema(),

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipTimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"expire_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route last updated to its expiration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(180),
			},

			"interval_seconds": rsschema.Int64Attribute{
				Description: "timer interval value in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"update_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route advertisement (RIP response packet)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"delete_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route expiration to its deletion",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": rsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("password"),
						path.MatchRelative().AtParent().AtName("md5"),
					}...),
				},
			},

			"md5": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipAuthProfileMd5Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": rsschema.BoolAttribute{
				Description: "prefer to use this key when sending packet",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema(),

			"bfd": VirtualRouterResourceProtocolRipInterfacesBfdSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("normal"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("disable"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route via RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enforce_first_as": rsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dampening_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpDampeningProfileSchema(),
			},

			"install_route": rsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"policy": VirtualRouterResourceProtocolBgpPolicySchema(),

			"routing_options": VirtualRouterResourceProtocolBgpRoutingOptionsSchema(),

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to BGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpAuthProfileSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolBgpGlobalBfdSchema(),

			"local_as": rsschema.StringAttribute{
				Description: "local AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"redist_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpRedistRulesSchema(),
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ecmp_multi_as": rsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPeerGroupSchema(),
			},

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from BGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpDampeningProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"cutoff": rsschema.Float64Attribute{
				Description: "cutoff threshold value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reuse": rsschema.Float64Attribute{
				Description: "reuse threshold value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_hold_time": rsschema.Int64Attribute{
				Description: "maximum of hold-down time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(900),
			},

			"decay_half_life_reachable": rsschema.Int64Attribute{
				Description: "Decay half-life while reachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(300),
			},

			"decay_half_life_unreachable": rsschema.Int64Attribute{
				Description: "Decay half-life while unreachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(900),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpDampeningProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"export": VirtualRouterResourceProtocolBgpPolicyExportSchema(),

			"import": VirtualRouterResourceProtocolBgpPolicyImportSchema(),

			"aggregation": VirtualRouterResourceProtocolBgpPolicyAggregationSchema(),

			"conditional_advertisement": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema(),
			},

			"prefix": rsschema.StringAttribute{
				Description: "aggregating address prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enable aggregation for this prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary": rsschema.BoolAttribute{
				Description: "summarize route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": rsschema.BoolAttribute{
				Description: "generate AS-set attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregate_route_attributes": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema(),

			"suppress_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema(),

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema(),

			"remove": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema(),

			"prepend": rsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,

				Validators: []validator.List{
					listvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("none"),
						path.MatchRelative().AtParent().AtName("remove_all"),
						path.MatchRelative().AtParent().AtName("remove_regex"),
						path.MatchRelative().AtParent().AtName("append"),
						path.MatchRelative().AtParent().AtName("overwrite"),
					}...),
				},
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"policy": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this policy",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"non_exist_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema(),
			},

			"advertise_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"extended_community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema(),

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema(),

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyExportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema(),

			"action": VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema(),

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"deny": VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema(),

			"allow": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"update": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"extended_community": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema(),

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema(),

			"prepend": rsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"remove_and_prepend": rsschema.Int64Attribute{
				Description: "remove matched AS path(s), and prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,

				Validators: []validator.List{
					listvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("remove_regex"),
						path.MatchRelative().AtParent().AtName("append"),
						path.MatchRelative().AtParent().AtName("overwrite"),
						path.MatchRelative().AtParent().AtName("none"),
						path.MatchRelative().AtParent().AtName("remove_all"),
					}...),
				},
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyImportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema(),

			"action": VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema(),

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"allow": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema(),

			"deny": VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"update": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema(),

			"dampening": rsschema.StringAttribute{
				Description: "route flap dampening profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"community": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema(),

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,

				Validators: []validator.List{
					listvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("remove_all"),
						path.MatchRelative().AtParent().AtName("remove_regex"),
						path.MatchRelative().AtParent().AtName("append"),
						path.MatchRelative().AtParent().AtName("overwrite"),
						path.MatchRelative().AtParent().AtName("none"),
					}...),
				},
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"as_format": rsschema.StringAttribute{
				Description: "AS format",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2-byte"),
			},

			"confederation_member_as": rsschema.StringAttribute{
				Description: "confederation requires member-AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": rsschema.Int64Attribute{
				Description: "default local preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},

			"graceful_restart": VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema(),

			"med": VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema(),

			"reflector_cluster_id": rsschema.StringAttribute{
				Description: "route reflector cluster ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregate": VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregate_med": rsschema.BoolAttribute{
				Description: "aggregate route only if they have same MED attributes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": rsschema.Int64Attribute{
				Description: "local restart time to advertise to peer (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"max_peer_restart_time": rsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"stale_route_time": rsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"always_compare_med": rsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": rsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"secret": rsschema.StringAttribute{
				Description: "shared secret for the TCP MD5 authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRedistRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"set_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"set_extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"route_table": rsschema.StringAttribute{
				Description: "select destination SAFI for redistribution",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"set_origin": rsschema.StringAttribute{
				Description: "add the ORIGIN path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("incomplete"),
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_local_preference": rsschema.Int64Attribute{
				Description: "add the LOCAL_PREF path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_as_path_limit": rsschema.Int64Attribute{
				Description: "add the AS_PATHLIMIT path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_family_identifier": rsschema.StringAttribute{
				Description: "select redistribution profile type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_med": rsschema.Int64Attribute{
				Description: "add the MULTI_EXIT_DISC path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRedistRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPeerGroupPeerSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregated_confed_as_path": rsschema.BoolAttribute{
				Description: "the peers understand aggregated confederation AS path",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"soft_reset_with_stored_info": rsschema.BoolAttribute{
				Description: "soft reset with stored info",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterResourceProtocolBgpPeerGroupTypeSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ibgp": VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema(),

			"ebgp_confed": VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema(),

			"ibgp_confed": VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema(),

			"ebgp": VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ebgp"),
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"remove_private_as": rsschema.BoolAttribute{
				Description: "remove private AS when exporting route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"import_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("resolve"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ebgp"),
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ebgp"),
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ebgp"),
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peering_type": rsschema.StringAttribute{
				Description: "peering type that affects NOPEER community value handling",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"peer_address": VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema(),

			"bfd": VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema(),

			"local_address": VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema(),

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_mp_bgp": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_family_identifier": rsschema.StringAttribute{
				Description: "select AFI for this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"enable_sender_side_loop_detection": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reflector_client": rsschema.StringAttribute{
				Description: "this peer is reflector client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("non-client"),
			},

			"max_prefixes": rsschema.StringAttribute{
				Description: "maximum of prefixes to receive from peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("5000"),
			},

			"subsequent_address_family_identifier": VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema(),

			"connection_options": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "bgp peer FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hold_time": rsschema.StringAttribute{
				Description: "hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("90"),
			},

			"incoming_bgp_connection": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema(),

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_route_adv_interval": rsschema.Int64Attribute{
				Description: "Minimum Route Advertisement Interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"multihop": rsschema.Int64Attribute{
				Description: "IP TTL value used for sending BGP packet. set to 0 means eBGP use 2, iBGP use 255",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"open_delay_time": rsschema.Int64Attribute{
				Description: "open delay time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"keep_alive_interval": rsschema.StringAttribute{
				Description: "keep-alive interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("30"),
			},

			"idle_hold_time": rsschema.Int64Attribute{
				Description: "idle hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(15),
			},

			"outgoing_bgp_connection": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "use specific local port for outgoing BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"allow": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"remote_port": rsschema.Int64Attribute{
				Description: "restrict remote port for incoming BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"allow": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": VirtualRouterResourceRoutingTableIpSchema(),

			"ipv6": VirtualRouterResourceRoutingTableIpv6Schema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpStaticRouteSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"nexthop": VirtualRouterResourceRoutingTableIpStaticRouteNexthopSchema(),

			"route_table": VirtualRouterResourceRoutingTableIpStaticRouteRouteTableSchema(),

			"bfd": VirtualRouterResourceRoutingTableIpStaticRouteBfdSchema(),

			"path_monitor": VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorSchema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("receive"),
						path.MatchRelative().AtParent().AtName("discard"),
						path.MatchRelative().AtParent().AtName("ip_address"),
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("next_vr"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "nexthop address FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": rsschema.StringAttribute{
				Description: "Next hop virtual router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"receive": VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveSchema(),

			"discard": VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardSchema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("receive"),
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ip_address"),
				path.MatchRelative().AtParent().AtName("fqdn"),
				path.MatchRelative().AtParent().AtName("next_vr"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteRouteTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"both": VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothSchema(),

			"no_install": VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallSchema(),

			"unicast": VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastSchema(),

			"multicast": VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastSchema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteRouteTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("multicast"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"static_route": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpv6StaticRouteSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"administrative_distance": rsschema.Int64Attribute{
				Description: "adminitrative distance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value (path cost)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"bfd": VirtualRouterResourceRoutingTableIpv6StaticRouteBfdSchema(),

			"path_monitor": VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorSchema(),

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopSchema(),

			"option": VirtualRouterResourceRoutingTableIpv6StaticRouteOptionSchema(),

			"route_table": VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableSchema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"receive": VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveSchema(),

			"discard": VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardSchema(),

			"ipv6_address": rsschema.StringAttribute{
				Description: "Next hop IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"next_vr": rsschema.StringAttribute{
				Description: "Next hop virtual router",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("next_vr"),
				path.MatchRelative().AtParent().AtName("receive"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("discard"),
				path.MatchRelative().AtParent().AtName("ipv6_address"),
				path.MatchRelative().AtParent().AtName("next_vr"),
				path.MatchRelative().AtParent().AtName("receive"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteOptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteOptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema(),

			"no_install": VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema(),
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("unicast"),
				path.MatchRelative().AtParent().AtName("no_install"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hold_time": rsschema.Int64Attribute{
				Description: "hold time (minutes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"monitor_destinations": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"failure_condition": rsschema.StringAttribute{
				Description: "failure condition",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("any"),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": rsschema.StringAttribute{
				Description: "Source IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"destination": rsschema.StringAttribute{
				Description: "Destination IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval": rsschema.Int64Attribute{
				Description: "ping interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(3),
			},

			"count": rsschema.Int64Attribute{
				Description: "ping count",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},
		},
	}
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceAdministrativeDistancesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ospf_ext": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPF external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_ext": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"rip": rsschema.Int64Attribute{
				Description: "administrative distance used for RIP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"static_ipv6": rsschema.Int64Attribute{
				Description: "administrative distance used for ipv6 static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"ebgp": rsschema.Int64Attribute{
				Description: "administrative distance used for eBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"ibgp": rsschema.Int64Attribute{
				Description: "administrative distance used for iBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"static": rsschema.Int64Attribute{
				Description: "administrative distance used for static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"ospf_int": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPF internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"ospfv3_int": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},
		},
	}
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"max_paths": rsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"strict_source_path": rsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": rsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"algorithm": VirtualRouterResourceEcmpAlgorithmSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"balanced_round_robin": VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_hash": VirtualRouterResourceEcmpAlgorithmIpHashSchema(),

			"ip_modulo": VirtualRouterResourceEcmpAlgorithmIpModuloSchema(),

			"weighted_round_robin": VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema(),
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpHashSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"hash_seed": rsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"src_only": rsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": rsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpModuloSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"spt_threshold": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastSptThresholdSchema(),
			},

			"ssm_address_space": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastSsmAddressSpaceSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupSchema(),
			},

			"route_ageout_time": rsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(210),
			},

			"rp": VirtualRouterResourceMulticastRpSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSsmAddressSpaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_permission": VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema(),

			"igmp": VirtualRouterResourceMulticastInterfaceGroupIgmpSchema(),

			"pim": VirtualRouterResourceMulticastInterfaceGroupPimSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"any_source_multicast": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema(),
			},

			"source_specific_multicast": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"source_address": rsschema.StringAttribute{
				Description: "source-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupIgmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"version": rsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("3"),
			},

			"query_interval": rsschema.Int64Attribute{
				Description: "interval between group/source specific query messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(125),
			},

			"immediate_leave": rsschema.BoolAttribute{
				Description: "leave group immediately when a leave message is received",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sources": rsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"router_alert_policing": rsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_query_response_time": rsschema.Float64Attribute{
				Description: "maximum query response time for general group membership queries in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"last_member_query_interval": rsschema.Float64Attribute{
				Description: "interval between group/source specific query messages (including those sent in response of leave group messages)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": rsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2"),
			},

			"max_groups": rsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupPimSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"assert_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Assert messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(177),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Hello messages, in seconds, a value of 0 represents an 'infinite' interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"join_prune_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Join/Prune messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"dr_priority": rsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"bsr_border": rsschema.BoolAttribute{
				Description: "interface is bootstrap border",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allowed_neighbors": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"external_rp": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastRpExternalRpSchema(),
			},

			"local_rp": VirtualRouterResourceMulticastRpLocalRpSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpExternalRpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"candidate_rp": VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema(),

			"static_rp": VirtualRouterResourceMulticastRpLocalRpStaticRpSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": rsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(192),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpStaticRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.StringAttribute{
				Description: "local RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSptThresholdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("0"),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *VirtualRouterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = VirtualRouterResourceSchema()
}

// </ResourceSchema>

func (r *VirtualRouterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := virtual_router.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, virtual_router.NewService(r.client), specifier, virtual_router.SpecMatches)
}

func (o *VirtualRouterResourceModel) CopyToPango(ctx context.Context, obj **virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var multicast_entry *virtual_router.Multicast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.Multicast)
		}

		diags.Append(o.Multicast.CopyToPango(ctx, &multicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if o.Protocol != nil {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}

		diags.Append(o.Protocol.CopyToPango(ctx, &protocol_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_entry *virtual_router.RoutingTable
	if o.RoutingTable != nil {
		if *obj != nil && (*obj).RoutingTable != nil {
			routingTable_entry = (*obj).RoutingTable
		} else {
			routingTable_entry = new(virtual_router.RoutingTable)
		}

		diags.Append(o.RoutingTable.CopyToPango(ctx, &routingTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_entry *virtual_router.AdminDists
	if o.AdministrativeDistances != nil {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(virtual_router.AdminDists)
		}

		diags.Append(o.AdministrativeDistances.CopyToPango(ctx, &administrativeDistances_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *virtual_router.Ecmp
	if o.Ecmp != nil {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}

		diags.Append(o.Ecmp.CopyToPango(ctx, &ecmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaces_pango_entries := make([]string, 0)
	diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Multicast = multicast_entry
	(*obj).Protocol = protocol_entry
	(*obj).RoutingTable = routingTable_entry
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Interface = interfaces_pango_entries

	return diags
}
func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, obj **virtual_router.AdminDists, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ebgp_value := o.Ebgp.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	static_value := o.Static.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdminDists)
	}
	(*obj).Ebgp = ebgp_value
	(*obj).Ibgp = ibgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).Rip = rip_value
	(*obj).StaticIpv6 = staticIpv6_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Static = static_value

	return diags
}
func (o *VirtualRouterResourceEcmpObject) CopyToPango(ctx context.Context, obj **virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if o.Algorithm != nil {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}

		diags.Append(o.Algorithm.CopyToPango(ctx, &algorithm_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).SymmetricReturn = symmetricReturn_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if o.BalancedRoundRobin != nil {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}

		diags.Append(o.BalancedRoundRobin.CopyToPango(ctx, &balancedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if o.IpHash != nil {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}

		diags.Append(o.IpHash.CopyToPango(ctx, &ipHash_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if o.IpModulo != nil {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}

		diags.Append(o.IpModulo.CopyToPango(ctx, &ipModulo_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if o.WeightedRoundRobin != nil {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}

		diags.Append(o.WeightedRoundRobin.CopyToPango(ctx, &weightedRoundRobin_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry
	(*obj).IpHash = ipHash_entry
	(*obj).IpModulo = ipModulo_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, obj **virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	usePort_value := o.UsePort.ValueBoolPointer()
	hashSeed_value := o.HashSeed.ValueInt64Pointer()
	srcOnly_value := o.SrcOnly.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).UsePort = usePort_value
	(*obj).HashSeed = hashSeed_value
	(*obj).SrcOnly = srcOnly_value

	return diags
}
func (o *VirtualRouterResourceMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.Multicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var interfaceGroup_tf_entries []VirtualRouterResourceMulticastInterfaceGroupObject
	var interfaceGroup_pango_entries []virtual_router.MulticastInterfaceGroup
	{
		d := o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaceGroup_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroup
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaceGroup_pango_entries = append(interfaceGroup_pango_entries, *entry)
		}
	}
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	var rp_entry *virtual_router.MulticastRp
	if o.Rp != nil {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(virtual_router.MulticastRp)
		}

		diags.Append(o.Rp.CopyToPango(ctx, &rp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []VirtualRouterResourceMulticastSptThresholdObject
	var sptThreshold_pango_entries []virtual_router.MulticastSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *virtual_router.MulticastSptThreshold
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var ssmAddressSpace_tf_entries []VirtualRouterResourceMulticastSsmAddressSpaceObject
	var ssmAddressSpace_pango_entries []virtual_router.MulticastSsmAddressSpace
	{
		d := o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ssmAddressSpace_tf_entries {
			var entry *virtual_router.MulticastSsmAddressSpace
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			ssmAddressSpace_pango_entries = append(ssmAddressSpace_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Multicast)
	}
	(*obj).Enable = enable_value
	(*obj).InterfaceGroup = interfaceGroup_pango_entries
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).SsmAddressSpace = ssmAddressSpace_pango_entries

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var pim_entry *virtual_router.MulticastInterfaceGroupPim
	if o.Pim != nil {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(virtual_router.MulticastInterfaceGroupPim)
		}

		diags.Append(o.Pim.CopyToPango(ctx, &pim_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	description_value := o.Description.ValueStringPointer()
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var groupPermission_entry *virtual_router.MulticastInterfaceGroupGroupPermission
	if o.GroupPermission != nil {
		if *obj != nil && (*obj).GroupPermission != nil {
			groupPermission_entry = (*obj).GroupPermission
		} else {
			groupPermission_entry = new(virtual_router.MulticastInterfaceGroupGroupPermission)
		}

		diags.Append(o.GroupPermission.CopyToPango(ctx, &groupPermission_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *virtual_router.MulticastInterfaceGroupIgmp
	if o.Igmp != nil {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(virtual_router.MulticastInterfaceGroupIgmp)
		}

		diags.Append(o.Igmp.CopyToPango(ctx, &igmp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Pim = pim_entry
	(*obj).Description = description_value
	(*obj).Interface = interface_pango_entries
	(*obj).GroupPermission = groupPermission_entry
	(*obj).Igmp = igmp_entry

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermission, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sourceSpecificMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	var sourceSpecificMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
	{
		d := o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sourceSpecificMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			sourceSpecificMulticast_pango_entries = append(sourceSpecificMulticast_pango_entries, *entry)
		}
	}
	var anySourceMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
	var anySourceMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
	{
		d := o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range anySourceMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			anySourceMulticast_pango_entries = append(anySourceMulticast_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermission)
	}
	(*obj).SourceSpecificMulticast = sourceSpecificMulticast_pango_entries
	(*obj).AnySourceMulticast = anySourceMulticast_pango_entries

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupIgmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	maxSources_value := o.MaxSources.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	version_value := o.Version.ValueStringPointer()
	queryInterval_value := o.QueryInterval.ValueInt64Pointer()
	immediateLeave_value := o.ImmediateLeave.ValueBoolPointer()
	maxQueryResponseTime_value := o.MaxQueryResponseTime.ValueFloat64Pointer()
	lastMemberQueryInterval_value := o.LastMemberQueryInterval.ValueFloat64Pointer()
	robustness_value := o.Robustness.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupIgmp)
	}
	(*obj).MaxSources = maxSources_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value
	(*obj).Enable = enable_value
	(*obj).Version = version_value
	(*obj).QueryInterval = queryInterval_value
	(*obj).ImmediateLeave = immediateLeave_value
	(*obj).MaxQueryResponseTime = maxQueryResponseTime_value
	(*obj).LastMemberQueryInterval = lastMemberQueryInterval_value
	(*obj).Robustness = robustness_value
	(*obj).MaxGroups = maxGroups_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupPim, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	bsrBorder_value := o.BsrBorder.ValueBoolPointer()
	var allowedNeighbors_tf_entries []VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
	var allowedNeighbors_pango_entries []virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
	{
		d := o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range allowedNeighbors_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			allowedNeighbors_pango_entries = append(allowedNeighbors_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	assertInterval_value := o.AssertInterval.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	joinPruneInterval_value := o.JoinPruneInterval.ValueInt64Pointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPim)
	}
	(*obj).BsrBorder = bsrBorder_value
	(*obj).AllowedNeighbors = allowedNeighbors_pango_entries
	(*obj).Enable = enable_value
	(*obj).AssertInterval = assertInterval_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).JoinPruneInterval = joinPruneInterval_value
	(*obj).DrPriority = drPriority_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPimAllowedNeighbors)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceMulticastRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_tf_entries []VirtualRouterResourceMulticastRpExternalRpObject
	var externalRp_pango_entries []virtual_router.MulticastRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *virtual_router.MulticastRpExternalRp
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}
	var localRp_entry *virtual_router.MulticastRpLocalRp
	if o.LocalRp != nil {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(virtual_router.MulticastRpLocalRp)
		}

		diags.Append(o.LocalRp.CopyToPango(ctx, &localRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRp)
	}
	(*obj).ExternalRp = externalRp_pango_entries
	(*obj).LocalRp = localRp_entry

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_entry *virtual_router.MulticastRpLocalRpCandidateRp
	if o.CandidateRp != nil {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(virtual_router.MulticastRpLocalRpCandidateRp)
		}

		diags.Append(o.CandidateRp.CopyToPango(ctx, &candidateRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_entry *virtual_router.MulticastRpLocalRpStaticRp
	if o.StaticRp != nil {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(virtual_router.MulticastRpLocalRpStaticRp)
		}

		diags.Append(o.StaticRp.CopyToPango(ctx, &staticRp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRp)
	}
	(*obj).CandidateRp = candidateRp_entry
	(*obj).StaticRp = staticRp_entry

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRpCandidateRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	address_value := o.Address.ValueStringPointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_value := o.Interface.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpCandidateRp)
	}
	(*obj).Priority = priority_value
	(*obj).Address = address_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpLocalRpStaticRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_value := o.Interface.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpStaticRp)
	}
	(*obj).Address = address_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterResourceMulticastRpExternalRpObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastRpExternalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddresses_pango_entries := make([]string, 0)
	diags.Append(o.GroupAddresses.ElementsAs(ctx, &groupAddresses_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterResourceMulticastSptThresholdObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastSptThreshold, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) CopyToPango(ctx context.Context, obj **virtual_router.MulticastSsmAddressSpace, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSsmAddressSpace)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceProtocolObject) CopyToPango(ctx context.Context, obj **virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistProfile_tf_entries []VirtualRouterResourceProtocolRedistProfileObject
	var redistProfile_pango_entries []virtual_router.ProtocolRedistProfile
	{
		d := o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfile_tf_entries {
			var entry *virtual_router.ProtocolRedistProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistProfile_pango_entries = append(redistProfile_pango_entries, *entry)
		}
	}
	var redistProfileIpv6_tf_entries []VirtualRouterResourceProtocolRedistProfileIpv6Object
	var redistProfileIpv6_pango_entries []virtual_router.ProtocolRedistProfileIpv6
	{
		d := o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfileIpv6_tf_entries {
			var entry *virtual_router.ProtocolRedistProfileIpv6
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistProfileIpv6_pango_entries = append(redistProfileIpv6_pango_entries, *entry)
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if o.Rip != nil {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}

		diags.Append(o.Rip.CopyToPango(ctx, &rip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *virtual_router.ProtocolOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).RedistProfile = redistProfile_pango_entries
	(*obj).RedistProfileIpv6 = redistProfileIpv6_pango_entries
	(*obj).Rip = rip_entry
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_tf_entries []VirtualRouterResourceProtocolRipAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolRipAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolRipExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolRipExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolRipExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolRipGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolRipGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []VirtualRouterResourceProtocolRipInterfacesObject
	var interfaces_pango_entries []virtual_router.ProtocolRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.ProtocolRipInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolRipTimers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolRipTimers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Timers = timers_entry
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipTimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	intervalSeconds_value := o.IntervalSeconds.ValueInt64Pointer()
	updateIntervals_value := o.UpdateIntervals.ValueInt64Pointer()
	deleteIntervals_value := o.DeleteIntervals.ValueInt64Pointer()
	expireIntervals_value := o.ExpireIntervals.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipTimers)
	}
	(*obj).IntervalSeconds = intervalSeconds_value
	(*obj).UpdateIntervals = updateIntervals_value
	(*obj).DeleteIntervals = deleteIntervals_value
	(*obj).ExpireIntervals = expireIntervals_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_tf_entries []VirtualRouterResourceProtocolRipAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolRipAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}
	password_value := o.Password.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Md5 = md5_pango_entries
	(*obj).Password = password_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_entry *virtual_router.ProtocolRipInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolRipInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	mode_value := o.Mode.ValueStringPointer()
	var defaultRoute_entry *virtual_router.ProtocolRipInterfaceDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Bfd = bfd_entry
	(*obj).Enable = enable_value
	(*obj).Authentication = authentication_value
	(*obj).Mode = mode_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolRipInterfaceDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRipInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	var dampeningProfile_tf_entries []VirtualRouterResourceProtocolBgpDampeningProfileObject
	var dampeningProfile_pango_entries []virtual_router.ProtocolBgpDampeningProfile
	{
		d := o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range dampeningProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpDampeningProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			dampeningProfile_pango_entries = append(dampeningProfile_pango_entries, *entry)
		}
	}
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	var policy_entry *virtual_router.ProtocolBgpPolicy
	if o.Policy != nil {
		if *obj != nil && (*obj).Policy != nil {
			policy_entry = (*obj).Policy
		} else {
			policy_entry = new(virtual_router.ProtocolBgpPolicy)
		}

		diags.Append(o.Policy.CopyToPango(ctx, &policy_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistRules_tf_entries []VirtualRouterResourceProtocolBgpRedistRulesObject
	var redistRules_pango_entries []virtual_router.ProtocolBgpRedistRules
	{
		d := o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistRules_tf_entries {
			var entry *virtual_router.ProtocolBgpRedistRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			redistRules_pango_entries = append(redistRules_pango_entries, *entry)
		}
	}
	routerId_value := o.RouterId.ValueStringPointer()
	var routingOptions_entry *virtual_router.ProtocolBgpRoutingOptions
	if o.RoutingOptions != nil {
		if *obj != nil && (*obj).RoutingOptions != nil {
			routingOptions_entry = (*obj).RoutingOptions
		} else {
			routingOptions_entry = new(virtual_router.ProtocolBgpRoutingOptions)
		}

		diags.Append(o.RoutingOptions.CopyToPango(ctx, &routingOptions_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterResourceProtocolBgpAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolBgpAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolBgpGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolBgpGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	localAs_value := o.LocalAs.ValueStringPointer()
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var peerGroup_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupObject
	var peerGroup_pango_entries []virtual_router.ProtocolBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).DampeningProfile = dampeningProfile_pango_entries
	(*obj).InstallRoute = installRoute_value
	(*obj).Policy = policy_entry
	(*obj).RedistRules = redistRules_pango_entries
	(*obj).RouterId = routerId_value
	(*obj).RoutingOptions = routingOptions_entry
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).LocalAs = localAs_value
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).Enable = enable_value
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregation_entry *virtual_router.ProtocolBgpPolicyAggregation
	if o.Aggregation != nil {
		if *obj != nil && (*obj).Aggregation != nil {
			aggregation_entry = (*obj).Aggregation
		} else {
			aggregation_entry = new(virtual_router.ProtocolBgpPolicyAggregation)
		}

		diags.Append(o.Aggregation.CopyToPango(ctx, &aggregation_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var conditionalAdvertisement_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisement
	if o.ConditionalAdvertisement != nil {
		if *obj != nil && (*obj).ConditionalAdvertisement != nil {
			conditionalAdvertisement_entry = (*obj).ConditionalAdvertisement
		} else {
			conditionalAdvertisement_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
		}

		diags.Append(o.ConditionalAdvertisement.CopyToPango(ctx, &conditionalAdvertisement_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_entry *virtual_router.ProtocolBgpPolicyExport
	if o.Export != nil {
		if *obj != nil && (*obj).Export != nil {
			export_entry = (*obj).Export
		} else {
			export_entry = new(virtual_router.ProtocolBgpPolicyExport)
		}

		diags.Append(o.Export.CopyToPango(ctx, &export_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var import_entry *virtual_router.ProtocolBgpPolicyImport
	if o.Import != nil {
		if *obj != nil && (*obj).Import != nil {
			import_entry = (*obj).Import
		} else {
			import_entry = new(virtual_router.ProtocolBgpPolicyImport)
		}

		diags.Append(o.Import.CopyToPango(ctx, &import_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicy)
	}
	(*obj).Aggregation = aggregation_entry
	(*obj).ConditionalAdvertisement = conditionalAdvertisement_entry
	(*obj).Export = export_entry
	(*obj).Import = import_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
	var address_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddress
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregation)
	}
	(*obj).Address = address_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppressFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
	var suppressFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
	{
		d := o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suppressFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			suppressFilters_pango_entries = append(suppressFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}
	prefix_value := o.Prefix.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summary_value := o.Summary.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	var aggregateRouteAttributes_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes
	if o.AggregateRouteAttributes != nil {
		if *obj != nil && (*obj).AggregateRouteAttributes != nil {
			aggregateRouteAttributes_entry = (*obj).AggregateRouteAttributes
		} else {
			aggregateRouteAttributes_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
		}

		diags.Append(o.AggregateRouteAttributes.CopyToPango(ctx, &aggregateRouteAttributes_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SuppressFilters = suppressFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries
	(*obj).Prefix = prefix_value
	(*obj).Enable = enable_value
	(*obj).Summary = summary_value
	(*obj).AsSet = asSet_value
	(*obj).AggregateRouteAttributes = aggregateRouteAttributes_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	prepend_value := o.Prepend.ValueInt64Pointer()
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
	}
	(*obj).Prepend = prepend_value
	(*obj).None = none_entry
	(*obj).Remove = remove_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Match = match_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
	}
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
	}
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	var policy_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
	{
		d := o.Policy.ElementsAs(ctx, &policy_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range policy_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			policy_pango_entries = append(policy_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
	}
	(*obj).Policy = policy_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var nonExistFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
	var nonExistFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
	{
		d := o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nonExistFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nonExistFilters_pango_entries = append(nonExistFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).NonExistFilters = nonExistFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
	}
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyExportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_entry *virtual_router.ProtocolBgpPolicyExportRulesMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyExportRulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Match = match_entry
	(*obj).Action = action_entry
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
	}
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyExportRulesActionDeny
	if o.Deny != nil {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
		}

		diags.Append(o.Deny.CopyToPango(ctx, &deny_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate
	if o.Update != nil {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
		}

		diags.Append(o.Update.CopyToPango(ctx, &update_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
	}
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var remove_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()
	removeAndPrepend_value := o.RemoveAndPrepend.ValueInt64Pointer()
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
	}
	(*obj).Remove = remove_entry
	(*obj).Prepend = prepend_value
	(*obj).RemoveAndPrepend = removeAndPrepend_value
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
	}
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyImportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *virtual_router.ProtocolBgpPolicyImportRulesAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	usedBy_pango_entries := make([]string, 0)
	diags.Append(o.UsedBy.ElementsAs(ctx, &usedBy_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var match_entry *virtual_router.ProtocolBgpPolicyImportRulesMatch
	if o.Match != nil {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
		}

		diags.Append(o.Match.CopyToPango(ctx, &match_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Action = action_entry
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyImportRulesActionDeny
	if o.Deny != nil {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
		}

		diags.Append(o.Deny.CopyToPango(ctx, &deny_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllow
	if o.Allow != nil {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
		}

		diags.Append(o.Allow.CopyToPango(ctx, &allow_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dampening_value := o.Dampening.ValueStringPointer()
	var update_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate
	if o.Update != nil {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
		}

		diags.Append(o.Update.CopyToPango(ctx, &update_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
	}
	(*obj).Dampening = dampening_value
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Weight = weight_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).Community = community_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var remove_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove
	if o.Remove != nil {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
		}

		diags.Append(o.Remove.CopyToPango(ctx, &remove_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
	}
	(*obj).Remove = remove_entry
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll
	if o.RemoveAll != nil {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
		}

		diags.Append(o.RemoveAll.CopyToPango(ctx, &removeAll_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	append_pango_entries := make([]string, 0)
	diags.Append(o.Append.ElementsAs(ctx, &append_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	overwrite_pango_entries := make([]string, 0)
	diags.Append(o.Overwrite.ElementsAs(ctx, &overwrite_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
	}
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	fromPeer_pango_entries := make([]string, 0)
	diags.Append(o.FromPeer.ElementsAs(ctx, &fromPeer_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath
	if o.AsPath != nil {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
		}

		diags.Append(o.AsPath.CopyToPango(ctx, &asPath_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity
	if o.Community != nil {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
		}

		diags.Append(o.Community.CopyToPango(ctx, &community_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity
	if o.ExtendedCommunity != nil {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
		}

		diags.Append(o.ExtendedCommunity.CopyToPango(ctx, &extendedCommunity_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpDampeningProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	reuse_value := o.Reuse.ValueFloat64Pointer()
	maxHoldTime_value := o.MaxHoldTime.ValueInt64Pointer()
	decayHalfLifeReachable_value := o.DecayHalfLifeReachable.ValueInt64Pointer()
	decayHalfLifeUnreachable_value := o.DecayHalfLifeUnreachable.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	cutoff_value := o.Cutoff.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpDampeningProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Reuse = reuse_value
	(*obj).MaxHoldTime = maxHoldTime_value
	(*obj).DecayHalfLifeReachable = decayHalfLifeReachable_value
	(*obj).DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value
	(*obj).Enable = enable_value
	(*obj).Cutoff = cutoff_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	secret_value := o.Secret.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Secret = secret_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRedistRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	setMed_value := o.SetMed.ValueInt64Pointer()
	setLocalPreference_value := o.SetLocalPreference.ValueInt64Pointer()
	setAsPathLimit_value := o.SetAsPathLimit.ValueInt64Pointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	setOrigin_value := o.SetOrigin.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	setCommunity_pango_entries := make([]string, 0)
	diags.Append(o.SetCommunity.ElementsAs(ctx, &setCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	setExtendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.SetExtendedCommunity.ElementsAs(ctx, &setExtendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRedistRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).Enable = enable_value
	(*obj).SetMed = setMed_value
	(*obj).SetLocalPreference = setLocalPreference_value
	(*obj).SetAsPathLimit = setAsPathLimit_value
	(*obj).RouteTable = routeTable_value
	(*obj).SetOrigin = setOrigin_value
	(*obj).Metric = metric_value
	(*obj).SetCommunity = setCommunity_pango_entries
	(*obj).SetExtendedCommunity = setExtendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	var gracefulRestart_entry *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_entry *virtual_router.ProtocolBgpRoutingOptionsMed
	if o.Med != nil {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(virtual_router.ProtocolBgpRoutingOptionsMed)
		}

		diags.Append(o.Med.CopyToPango(ctx, &med_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	reflectorClusterId_value := o.ReflectorClusterId.ValueStringPointer()
	var aggregate_entry *virtual_router.ProtocolBgpRoutingOptionsAggregate
	if o.Aggregate != nil {
		if *obj != nil && (*obj).Aggregate != nil {
			aggregate_entry = (*obj).Aggregate
		} else {
			aggregate_entry = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
		}

		diags.Append(o.Aggregate.CopyToPango(ctx, &aggregate_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	asFormat_value := o.AsFormat.ValueStringPointer()
	confederationMemberAs_value := o.ConfederationMemberAs.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptions)
	}
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Med = med_entry
	(*obj).ReflectorClusterId = reflectorClusterId_value
	(*obj).Aggregate = aggregate_entry
	(*obj).AsFormat = asFormat_value
	(*obj).ConfederationMemberAs = confederationMemberAs_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsAggregate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	aggregateMed_value := o.AggregateMed.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
	}
	(*obj).AggregateMed = aggregateMed_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
	}
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).StaleRouteTime = staleRouteTime_value
	(*obj).Enable = enable_value
	(*obj).LocalRestartTime = localRestartTime_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpRoutingOptionsMed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	aggregatedConfedAsPath_value := o.AggregatedConfedAsPath.ValueBoolPointer()
	softResetWithStoredInfo_value := o.SoftResetWithStoredInfo.ValueBoolPointer()
	var type_entry *virtual_router.ProtocolBgpPeerGroupType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolBgpPeerGroupType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupPeerObject
	var peer_pango_entries []virtual_router.ProtocolBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).AggregatedConfedAsPath = aggregatedConfedAsPath_value
	(*obj).SoftResetWithStoredInfo = softResetWithStoredInfo_value
	(*obj).Type = type_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	reflectorClient_value := o.ReflectorClient.ValueStringPointer()
	maxPrefixes_value := o.MaxPrefixes.ValueStringPointer()
	var subsequentAddressFamilyIdentifier_entry *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier
	if o.SubsequentAddressFamilyIdentifier != nil {
		if *obj != nil && (*obj).SubsequentAddressFamilyIdentifier != nil {
			subsequentAddressFamilyIdentifier_entry = (*obj).SubsequentAddressFamilyIdentifier
		} else {
			subsequentAddressFamilyIdentifier_entry = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
		}

		diags.Append(o.SubsequentAddressFamilyIdentifier.CopyToPango(ctx, &subsequentAddressFamilyIdentifier_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress
	if o.LocalAddress != nil {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
		}

		diags.Append(o.LocalAddress.CopyToPango(ctx, &localAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableMpBgp_value := o.EnableMpBgp.ValueBoolPointer()
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	var connectionOptions_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions
	if o.ConnectionOptions != nil {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
		}

		diags.Append(o.ConnectionOptions.CopyToPango(ctx, &connectionOptions_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	peeringType_value := o.PeeringType.ValueStringPointer()
	var peerAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress
	if o.PeerAddress != nil {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
		}

		diags.Append(o.PeerAddress.CopyToPango(ctx, &peerAddress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolBgpPeerGroupPeerBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).ReflectorClient = reflectorClient_value
	(*obj).MaxPrefixes = maxPrefixes_value
	(*obj).SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAs = peerAs_value
	(*obj).EnableMpBgp = enableMpBgp_value
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Enable = enable_value
	(*obj).PeeringType = peeringType_value
	(*obj).PeerAddress = peerAddress_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	multicast_value := o.Multicast.ValueBoolPointer()
	unicast_value := o.Unicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
	}
	(*obj).Multicast = multicast_value
	(*obj).Unicast = unicast_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	minRouteAdvInterval_value := o.MinRouteAdvInterval.ValueInt64Pointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	openDelayTime_value := o.OpenDelayTime.ValueInt64Pointer()
	holdTime_value := o.HoldTime.ValueStringPointer()
	var incomingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection
	if o.IncomingBgpConnection != nil {
		if *obj != nil && (*obj).IncomingBgpConnection != nil {
			incomingBgpConnection_entry = (*obj).IncomingBgpConnection
		} else {
			incomingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
		}

		diags.Append(o.IncomingBgpConnection.CopyToPango(ctx, &incomingBgpConnection_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	keepAliveInterval_value := o.KeepAliveInterval.ValueStringPointer()
	idleHoldTime_value := o.IdleHoldTime.ValueInt64Pointer()
	var outgoingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection
	if o.OutgoingBgpConnection != nil {
		if *obj != nil && (*obj).OutgoingBgpConnection != nil {
			outgoingBgpConnection_entry = (*obj).OutgoingBgpConnection
		} else {
			outgoingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
		}

		diags.Append(o.OutgoingBgpConnection.CopyToPango(ctx, &outgoingBgpConnection_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Authentication = authentication_value
	(*obj).MinRouteAdvInterval = minRouteAdvInterval_value
	(*obj).Multihop = multihop_value
	(*obj).OpenDelayTime = openDelayTime_value
	(*obj).HoldTime = holdTime_value
	(*obj).IncomingBgpConnection = incomingBgpConnection_entry
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).IdleHoldTime = idleHoldTime_value
	(*obj).OutgoingBgpConnection = outgoingBgpConnection_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
	}
	(*obj).LocalPort = localPort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupPeerBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ebgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed
	if o.EbgpConfed != nil {
		if *obj != nil && (*obj).EbgpConfed != nil {
			ebgpConfed_entry = (*obj).EbgpConfed
		} else {
			ebgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
		}

		diags.Append(o.EbgpConfed.CopyToPango(ctx, &ebgpConfed_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed
	if o.IbgpConfed != nil {
		if *obj != nil && (*obj).IbgpConfed != nil {
			ibgpConfed_entry = (*obj).IbgpConfed
		} else {
			ibgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
		}

		diags.Append(o.IbgpConfed.CopyToPango(ctx, &ibgpConfed_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgp
	if o.Ebgp != nil {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
		}

		diags.Append(o.Ebgp.CopyToPango(ctx, &ebgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgp_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgp
	if o.Ibgp != nil {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
		}

		diags.Append(o.Ibgp.CopyToPango(ctx, &ibgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupType)
	}
	(*obj).EbgpConfed = ebgpConfed_entry
	(*obj).IbgpConfed = ibgpConfed_entry
	(*obj).Ebgp = ebgp_entry
	(*obj).Ibgp = ibgp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	importNexthop_value := o.ImportNexthop.ValueStringPointer()
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()
	removePrivateAs_value := o.RemovePrivateAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
	}
	(*obj).ImportNexthop = importNexthop_value
	(*obj).ExportNexthop = exportNexthop_value
	(*obj).RemovePrivateAs = removePrivateAs_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gracefulRestart_entry *virtual_router.ProtocolOspfGracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfGracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var area_tf_entries []VirtualRouterResourceProtocolOspfAreaObject
	var area_pango_entries []virtual_router.ProtocolOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfArea
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolOspfExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfGlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfGlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolOspfTimers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfTimers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	routerId_value := o.RouterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Timers = timers_entry
	(*obj).RouterId = routerId_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGracefulRestart)
	}
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolOspfAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfArea, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}
	var type_entry *virtual_router.ProtocolOspfAreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfAreaType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterResourceProtocolOspfAreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfAreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfAreaTypeNormal)
		}

		diags.Append(o.Normal.CopyToPango(ctx, &normal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfAreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfAreaTypeStub)
		}

		diags.Append(o.Stub.CopyToPango(ctx, &stub_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfAreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfAreaTypeNssa)
		}

		diags.Append(o.Nssa.CopyToPango(ctx, &nssa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStub)
	}
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).AcceptSummary = acceptSummary_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var disable_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
	}
	(*obj).Advertise = advertise_entry
	(*obj).Disable = disable_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppress_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Suppress = suppress_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var neighbor_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfAreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfAreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	passive_value := o.Passive.ValueBoolPointer()
	priority_value := o.Priority.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfAreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
		}

		diags.Append(o.LinkType.CopyToPango(ctx, &linkType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry
	(*obj).Passive = passive_value
	(*obj).Priority = priority_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Enable = enable_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
		}

		diags.Append(o.Broadcast.CopyToPango(ctx, &broadcast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
		}

		diags.Append(o.P2p.CopyToPango(ctx, &p2p_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
		}

		diags.Append(o.P2mp.CopyToPango(ctx, &p2mp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	var bfd_entry *virtual_router.ProtocolOspfAreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).Authentication = authentication_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfAreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfTimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfTimers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterResourceProtocolOspfv3AuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfv3AuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AuthProfile
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfv3GlobalBfd
	if o.GlobalBfd != nil {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfv3GlobalBfd)
		}

		diags.Append(o.GlobalBfd.CopyToPango(ctx, &globalBfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var area_tf_entries []VirtualRouterResourceProtocolOspfv3AreaObject
	var area_pango_entries []virtual_router.ProtocolOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfv3Area
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolOspfv3ExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfv3ExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfv3ExportRules
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfv3GracefulRestart
	if o.GracefulRestart != nil {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfv3GracefulRestart)
		}

		diags.Append(o.GracefulRestart.CopyToPango(ctx, &gracefulRestart_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_entry *virtual_router.ProtocolOspfv3Timers
	if o.Timers != nil {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfv3Timers)
		}

		diags.Append(o.Timers.CopyToPango(ctx, &timers_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value
	(*obj).Area = area_pango_entries
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	spi_value := o.Spi.ValueStringPointer()
	var esp_entry *virtual_router.ProtocolOspfv3AuthProfileEsp
	if o.Esp != nil {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
		}

		diags.Append(o.Esp.CopyToPango(ctx, &esp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_entry *virtual_router.ProtocolOspfv3AuthProfileAh
	if o.Ah != nil {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(virtual_router.ProtocolOspfv3AuthProfileAh)
		}

		diags.Append(o.Ah.CopyToPango(ctx, &ah_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Spi = spi_value
	(*obj).Esp = esp_entry
	(*obj).Ah = ah_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileAhMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication
	if o.Authentication != nil {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
		}

		diags.Append(o.Authentication.CopyToPango(ctx, &authentication_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *virtual_router.ProtocolOspfv3AuthProfileEspEncryption
	if o.Encryption != nil {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
		}

		diags.Append(o.Encryption.CopyToPango(ctx, &encryption_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384
	if o.Sha384 != nil {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
		}

		diags.Append(o.Sha384.CopyToPango(ctx, &sha384_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512
	if o.Sha512 != nil {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
		}

		diags.Append(o.Sha512.CopyToPango(ctx, &sha512_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone
	if o.None != nil {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
		}

		diags.Append(o.None.CopyToPango(ctx, &none_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5
	if o.Md5 != nil {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
		}

		diags.Append(o.Md5.CopyToPango(ctx, &md5_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1
	if o.Sha1 != nil {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
		}

		diags.Append(o.Sha1.CopyToPango(ctx, &sha1_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256
	if o.Sha256 != nil {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
		}

		diags.Append(o.Sha256.CopyToPango(ctx, &sha256_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
	}
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).None = none_entry
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3GlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3GracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GracefulRestart)
	}
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3TimersObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3Timers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Timers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3Area, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *virtual_router.ProtocolOspfv3AreaType
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfv3AreaType)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterResourceProtocolOspfv3AreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaInterfaceBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	priority_value := o.Priority.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkType
	if o.LinkType != nil {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
		}

		diags.Append(o.LinkType.CopyToPango(ctx, &linkType_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	var neighbor_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry
	(*obj).Priority = priority_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).LinkType = linkType_entry
	(*obj).HelloInterval = helloInterval_value
	(*obj).GrDelay = grDelay_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Neighbor = neighbor_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast
	if o.Broadcast != nil {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
		}

		diags.Append(o.Broadcast.CopyToPango(ctx, &broadcast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p
	if o.P2p != nil {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
		}

		diags.Append(o.P2p.CopyToPango(ctx, &p2p_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp
	if o.P2mp != nil {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
		}

		diags.Append(o.P2mp.CopyToPango(ctx, &p2mp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	neighborId_value := o.NeighborId.ValueStringPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).NeighborId = neighborId_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).Bfd = bfd_entry
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfv3AreaTypeNormal
	if o.Normal != nil {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
		}

		diags.Append(o.Normal.CopyToPango(ctx, &normal_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfv3AreaTypeStub
	if o.Stub != nil {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfv3AreaTypeStub)
		}

		diags.Append(o.Stub.CopyToPango(ctx, &stub_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfv3AreaTypeNssa
	if o.Nssa != nil {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
		}

		diags.Append(o.Nssa.CopyToPango(ctx, &nssa_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute
	if o.DefaultRoute != nil {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
		}

		diags.Append(o.DefaultRoute.CopyToPango(ctx, &defaultRoute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
	}
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries
	(*obj).AcceptSummary = acceptSummary_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable
	if o.Disable != nil {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
		}

		diags.Append(o.Disable.CopyToPango(ctx, &disable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise
	if o.Advertise != nil {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
		}

		diags.Append(o.Advertise.CopyToPango(ctx, &advertise_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress
	if o.Suppress != nil {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
		}

		diags.Append(o.Suppress.CopyToPango(ctx, &suppress_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3AreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolOspfv3ExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3ExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var filter_entry *virtual_router.ProtocolRedistProfileFilter
	if o.Filter != nil {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileFilter)
		}

		diags.Append(o.Filter.CopyToPango(ctx, &filter_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileAction
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileAction)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry
	(*obj).Priority = priority_value

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	type_pango_entries := make([]string, 0)
	diags.Append(o.Type.ElementsAs(ctx, &type_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	destination_pango_entries := make([]string, 0)
	diags.Append(o.Destination.ElementsAs(ctx, &destination_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var ospf_entry *virtual_router.ProtocolRedistProfileFilterOspf
	if o.Ospf != nil {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolRedistProfileFilterOspf)
		}

		diags.Append(o.Ospf.CopyToPango(ctx, &ospf_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileFilterBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileFilterBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospf = ospf_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilterOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	area_pango_entries := make([]string, 0)
	diags.Append(o.Area.ElementsAs(ctx, &area_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	pathType_pango_entries := make([]string, 0)
	diags.Append(o.PathType.ElementsAs(ctx, &pathType_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterOspf)
	}
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries
	(*obj).PathType = pathType_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileFilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	community_pango_entries := make([]string, 0)
	diags.Append(o.Community.ElementsAs(ctx, &community_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	extendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &extendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileActionNoRedist
	if o.NoRedist != nil {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileActionNoRedist)
		}

		diags.Append(o.NoRedist.CopyToPango(ctx, &noRedist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileActionRedist
	if o.Redist != nil {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileActionRedist)
		}

		diags.Append(o.Redist.CopyToPango(ctx, &redist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileAction)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileIpv6Filter
	if o.Filter != nil {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileIpv6Filter)
		}

		diags.Append(o.Filter.CopyToPango(ctx, &filter_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileIpv6Action
	if o.Action != nil {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileIpv6Action)
		}

		diags.Append(o.Action.CopyToPango(ctx, &action_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6Filter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	destination_pango_entries := make([]string, 0)
	diags.Append(o.Destination.ElementsAs(ctx, &destination_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	nexthop_pango_entries := make([]string, 0)
	diags.Append(o.Nexthop.ElementsAs(ctx, &nexthop_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var ospfv3_entry *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3
	if o.Ospfv3 != nil {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
		}

		diags.Append(o.Ospfv3.CopyToPango(ctx, &ospfv3_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileIpv6FilterBgp
	if o.Bgp != nil {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
		}

		diags.Append(o.Bgp.CopyToPango(ctx, &bgp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	type_pango_entries := make([]string, 0)
	diags.Append(o.Type.ElementsAs(ctx, &type_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	interface_pango_entries := make([]string, 0)
	diags.Append(o.Interface.ElementsAs(ctx, &interface_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Filter)
	}
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Bgp = bgp_entry
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	pathType_pango_entries := make([]string, 0)
	diags.Append(o.PathType.ElementsAs(ctx, &pathType_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	area_pango_entries := make([]string, 0)
	diags.Append(o.Area.ElementsAs(ctx, &area_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	tag_pango_entries := make([]string, 0)
	diags.Append(o.Tag.ElementsAs(ctx, &tag_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
	}
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6FilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	community_pango_entries := make([]string, 0)
	diags.Append(o.Community.ElementsAs(ctx, &community_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	extendedCommunity_pango_entries := make([]string, 0)
	diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &extendedCommunity_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6Action, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var redist_entry *virtual_router.ProtocolRedistProfileIpv6ActionRedist
	if o.Redist != nil {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
		}

		diags.Append(o.Redist.CopyToPango(ctx, &redist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noRedist_entry *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist
	if o.NoRedist != nil {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
		}

		diags.Append(o.NoRedist.CopyToPango(ctx, &noRedist_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Action)
	}
	(*obj).Redist = redist_entry
	(*obj).NoRedist = noRedist_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) CopyToPango(ctx context.Context, obj **virtual_router.ProtocolRedistProfileIpv6ActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_entry *virtual_router.RoutingTableIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(virtual_router.RoutingTableIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *virtual_router.RoutingTableIpv6
	if o.Ipv6 != nil {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(virtual_router.RoutingTableIpv6)
		}

		diags.Append(o.Ipv6.CopyToPango(ctx, &ipv6_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTable)
	}
	(*obj).Ip = ip_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []VirtualRouterResourceRoutingTableIpStaticRouteObject
	var staticRoute_pango_entries []virtual_router.RoutingTableIpStaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoute
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIp)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_entry *virtual_router.RoutingTableIpStaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.RoutingTableIpStaticRouteBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *virtual_router.RoutingTableIpStaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(virtual_router.RoutingTableIpStaticRoutePathMonitor)
		}

		diags.Append(o.PathMonitor.CopyToPango(ctx, &pathMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var nexthop_entry *virtual_router.RoutingTableIpStaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(virtual_router.RoutingTableIpStaticRouteNexthop)
		}

		diags.Append(o.Nexthop.CopyToPango(ctx, &nexthop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_entry *virtual_router.RoutingTableIpStaticRouteRouteTable
	if o.RouteTable != nil {
		if *obj != nil && (*obj).RouteTable != nil {
			routeTable_entry = (*obj).RouteTable
		} else {
			routeTable_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTable)
		}

		diags.Append(o.RouteTable.CopyToPango(ctx, &routeTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Bfd = bfd_entry
	(*obj).PathMonitor = pathMonitor_entry
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Nexthop = nexthop_entry
	(*obj).RouteTable = routeTable_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	nextVr_value := o.NextVr.ValueStringPointer()
	var receive_entry *virtual_router.RoutingTableIpStaticRouteNexthopReceive
	if o.Receive != nil {
		if *obj != nil && (*obj).Receive != nil {
			receive_entry = (*obj).Receive
		} else {
			receive_entry = new(virtual_router.RoutingTableIpStaticRouteNexthopReceive)
		}

		diags.Append(o.Receive.CopyToPango(ctx, &receive_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_entry *virtual_router.RoutingTableIpStaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(virtual_router.RoutingTableIpStaticRouteNexthopDiscard)
		}

		diags.Append(o.Discard.CopyToPango(ctx, &discard_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipAddress_value := o.IpAddress.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthop)
	}
	(*obj).NextVr = nextVr_value
	(*obj).Receive = receive_entry
	(*obj).Discard = discard_entry
	(*obj).IpAddress = ipAddress_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthopReceive)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteNexthopDiscard)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *virtual_router.RoutingTableIpStaticRouteRouteTableUnicast
	if o.Unicast != nil {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableUnicast)
		}

		diags.Append(o.Unicast.CopyToPango(ctx, &unicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_entry *virtual_router.RoutingTableIpStaticRouteRouteTableMulticast
	if o.Multicast != nil {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableMulticast)
		}

		diags.Append(o.Multicast.CopyToPango(ctx, &multicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *virtual_router.RoutingTableIpStaticRouteRouteTableBoth
	if o.Both != nil {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableBoth)
		}

		diags.Append(o.Both.CopyToPango(ctx, &both_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_entry *virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall
	if o.NoInstall != nil {
		if *obj != nil && (*obj).NoInstall != nil {
			noInstall_entry = (*obj).NoInstall
		} else {
			noInstall_entry = new(virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall)
		}

		diags.Append(o.NoInstall.CopyToPango(ctx, &noInstall_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTable)
	}
	(*obj).Unicast = unicast_entry
	(*obj).Multicast = multicast_entry
	(*obj).Both = both_entry
	(*obj).NoInstall = noInstall_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableUnicast)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableMulticast)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableBoth)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRouteBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6Object) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRouteObject
	var staticRoute_pango_entries []virtual_router.RoutingTableIpv6StaticRoute
	{
		d := o.StaticRoute.ElementsAs(ctx, &staticRoute_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range staticRoute_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoute
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			staticRoute_pango_entries = append(staticRoute_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6)
	}
	(*obj).StaticRoute = staticRoute_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	administrativeDistance_value := o.AdministrativeDistance.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var bfd_entry *virtual_router.RoutingTableIpv6StaticRouteBfd
	if o.Bfd != nil {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.RoutingTableIpv6StaticRouteBfd)
		}

		diags.Append(o.Bfd.CopyToPango(ctx, &bfd_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	destination_value := o.Destination.ValueStringPointer()
	interface_value := o.Interface.ValueStringPointer()
	var nexthop_entry *virtual_router.RoutingTableIpv6StaticRouteNexthop
	if o.Nexthop != nil {
		if *obj != nil && (*obj).Nexthop != nil {
			nexthop_entry = (*obj).Nexthop
		} else {
			nexthop_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthop)
		}

		diags.Append(o.Nexthop.CopyToPango(ctx, &nexthop_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var option_entry *virtual_router.RoutingTableIpv6StaticRouteOption
	if o.Option != nil {
		if *obj != nil && (*obj).Option != nil {
			option_entry = (*obj).Option
		} else {
			option_entry = new(virtual_router.RoutingTableIpv6StaticRouteOption)
		}

		diags.Append(o.Option.CopyToPango(ctx, &option_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTable
	if o.RouteTable != nil {
		if *obj != nil && (*obj).RouteTable != nil {
			routeTable_entry = (*obj).RouteTable
		} else {
			routeTable_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTable)
		}

		diags.Append(o.RouteTable.CopyToPango(ctx, &routeTable_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_entry *virtual_router.RoutingTableIpv6StaticRoutePathMonitor
	if o.PathMonitor != nil {
		if *obj != nil && (*obj).PathMonitor != nil {
			pathMonitor_entry = (*obj).PathMonitor
		} else {
			pathMonitor_entry = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitor)
		}

		diags.Append(o.PathMonitor.CopyToPango(ctx, &pathMonitor_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoute)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AdminDist = administrativeDistance_value
	(*obj).Metric = metric_value
	(*obj).Bfd = bfd_entry
	(*obj).Destination = destination_value
	(*obj).Interface = interface_value
	(*obj).Nexthop = nexthop_entry
	(*obj).Option = option_entry
	(*obj).RouteTable = routeTable_entry
	(*obj).PathMonitor = pathMonitor_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast
	if o.Unicast != nil {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast)
		}

		diags.Append(o.Unicast.CopyToPango(ctx, &unicast_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_entry *virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall
	if o.NoInstall != nil {
		if *obj != nil && (*obj).NoInstall != nil {
			noInstall_entry = (*obj).NoInstall
		} else {
			noInstall_entry = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall)
		}

		diags.Append(o.NoInstall.CopyToPango(ctx, &noInstall_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTable)
	}
	(*obj).Unicast = unicast_entry
	(*obj).NoInstall = noInstall_entry

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	failureCondition_value := o.FailureCondition.ValueStringPointer()
	holdTime_value := o.HoldTime.ValueInt64Pointer()
	var monitorDestinations_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
	var monitorDestinations_pango_entries []virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
	{
		d := o.MonitorDestinations.ElementsAs(ctx, &monitorDestinations_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range monitorDestinations_tf_entries {
			var entry *virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations
			diags.Append(elt.CopyToPango(ctx, &entry, encrypted)...)
			if diags.HasError() {
				return diags
			}
			monitorDestinations_pango_entries = append(monitorDestinations_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitor)
	}
	(*obj).Enable = enable_value
	(*obj).FailureCondition = failureCondition_value
	(*obj).HoldTime = holdTime_value
	(*obj).MonitorDestinations = monitorDestinations_pango_entries

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	source_value := o.Source.ValueStringPointer()
	destination_value := o.Destination.ValueStringPointer()
	interval_value := o.Interval.ValueInt64Pointer()
	count_value := o.Count.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Source = source_value
	(*obj).Destination = destination_value
	(*obj).Interval = interval_value
	(*obj).Count = count_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var receive_entry *virtual_router.RoutingTableIpv6StaticRouteNexthopReceive
	if o.Receive != nil {
		if *obj != nil && (*obj).Receive != nil {
			receive_entry = (*obj).Receive
		} else {
			receive_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthopReceive)
		}

		diags.Append(o.Receive.CopyToPango(ctx, &receive_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_entry *virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard
	if o.Discard != nil {
		if *obj != nil && (*obj).Discard != nil {
			discard_entry = (*obj).Discard
		} else {
			discard_entry = new(virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard)
		}

		diags.Append(o.Discard.CopyToPango(ctx, &discard_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	nextVr_value := o.NextVr.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthop)
	}
	(*obj).Receive = receive_entry
	(*obj).Discard = discard_entry
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).NextVr = nextVr_value

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthopReceive)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteOption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteOption)
	}

	return diags
}
func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject) CopyToPango(ctx context.Context, obj **virtual_router.RoutingTableIpv6StaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.RoutingTableIpv6StaticRouteBfd)
	}
	(*obj).Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceModel) CopyFromPango(ctx context.Context, obj *virtual_router.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics
		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var protocol_object *VirtualRouterResourceProtocolObject
	if obj.Protocol != nil {
		protocol_object = new(VirtualRouterResourceProtocolObject)

		diags.Append(protocol_object.CopyFromPango(ctx, obj.Protocol, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingTable_object *VirtualRouterResourceRoutingTableObject
	if obj.RoutingTable != nil {
		routingTable_object = new(VirtualRouterResourceRoutingTableObject)

		diags.Append(routingTable_object.CopyFromPango(ctx, obj.RoutingTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var administrativeDistances_object *VirtualRouterResourceAdministrativeDistancesObject
	if obj.AdminDists != nil {
		administrativeDistances_object = new(VirtualRouterResourceAdministrativeDistancesObject)

		diags.Append(administrativeDistances_object.CopyFromPango(ctx, obj.AdminDists, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_object *VirtualRouterResourceEcmpObject
	if obj.Ecmp != nil {
		ecmp_object = new(VirtualRouterResourceEcmpObject)

		diags.Append(ecmp_object.CopyFromPango(ctx, obj.Ecmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *VirtualRouterResourceMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(VirtualRouterResourceMulticastObject)

		diags.Append(multicast_object.CopyFromPango(ctx, obj.Multicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Protocol = protocol_object
	o.RoutingTable = routingTable_object
	o.AdministrativeDistances = administrativeDistances_object
	o.Ecmp = ecmp_object
	o.Interfaces = interfaces_list
	o.Multicast = multicast_object

	return diags
}

func (o *VirtualRouterResourceMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.Multicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []VirtualRouterResourceMulticastSptThresholdObject
		for _, elt := range obj.SptThreshold {
			var entry VirtualRouterResourceMulticastSptThresholdObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var ssmAddressSpace_list types.List
	{
		var ssmAddressSpace_tf_entries []VirtualRouterResourceMulticastSsmAddressSpaceObject
		for _, elt := range obj.SsmAddressSpace {
			var entry VirtualRouterResourceMulticastSsmAddressSpaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			ssmAddressSpace_tf_entries = append(ssmAddressSpace_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssm_address_space")
		ssmAddressSpace_list, list_diags = types.ListValueFrom(ctx, schemaType, ssmAddressSpace_tf_entries)
		diags.Append(list_diags...)
	}
	var interfaceGroup_list types.List
	{
		var interfaceGroup_tf_entries []VirtualRouterResourceMulticastInterfaceGroupObject
		for _, elt := range obj.InterfaceGroup {
			var entry VirtualRouterResourceMulticastInterfaceGroupObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaceGroup_tf_entries = append(interfaceGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface_group")
		interfaceGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaceGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var rp_object *VirtualRouterResourceMulticastRpObject
	if obj.Rp != nil {
		rp_object = new(VirtualRouterResourceMulticastRpObject)

		diags.Append(rp_object.CopyFromPango(ctx, obj.Rp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	o.SptThreshold = sptThreshold_list
	o.SsmAddressSpace = ssmAddressSpace_list
	o.Enable = enable_value
	o.InterfaceGroup = interfaceGroup_list
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.Rp = rp_object

	return diags
}

func (o *VirtualRouterResourceMulticastRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []VirtualRouterResourceMulticastRpExternalRpObject
		for _, elt := range obj.ExternalRp {
			var entry VirtualRouterResourceMulticastRpExternalRpObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			externalRp_tf_entries = append(externalRp_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}
	var localRp_object *VirtualRouterResourceMulticastRpLocalRpObject
	if obj.LocalRp != nil {
		localRp_object = new(VirtualRouterResourceMulticastRpLocalRpObject)

		diags.Append(localRp_object.CopyFromPango(ctx, obj.LocalRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.ExternalRp = externalRp_list
	o.LocalRp = localRp_object

	return diags
}

func (o *VirtualRouterResourceMulticastRpExternalRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpExternalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddresses = groupAddresses_list
	o.Override = override_value

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_object *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject
	if obj.CandidateRp != nil {
		candidateRp_object = new(VirtualRouterResourceMulticastRpLocalRpCandidateRpObject)

		diags.Append(candidateRp_object.CopyFromPango(ctx, obj.CandidateRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_object *VirtualRouterResourceMulticastRpLocalRpStaticRpObject
	if obj.StaticRp != nil {
		staticRp_object = new(VirtualRouterResourceMulticastRpLocalRpStaticRpObject)

		diags.Append(staticRp_object.CopyFromPango(ctx, obj.StaticRp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.CandidateRp = candidateRp_object
	o.StaticRp = staticRp_object

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRpCandidateRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	o.Interface = interface_value
	o.Priority = priority_value
	o.Address = address_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupAddresses = groupAddresses_list

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastRpLocalRpStaticRp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics
		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.GroupAddresses)
		diags.Append(list_diags...)
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Address = address_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Override = override_value

	return diags
}

func (o *VirtualRouterResourceMulticastSptThresholdObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastSptThreshold, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastSsmAddressSpace, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var groupPermission_object *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject
	if obj.GroupPermission != nil {
		groupPermission_object = new(VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject)

		diags.Append(groupPermission_object.CopyFromPango(ctx, obj.GroupPermission, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_object *VirtualRouterResourceMulticastInterfaceGroupIgmpObject
	if obj.Igmp != nil {
		igmp_object = new(VirtualRouterResourceMulticastInterfaceGroupIgmpObject)

		diags.Append(igmp_object.CopyFromPango(ctx, obj.Igmp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pim_object *VirtualRouterResourceMulticastInterfaceGroupPimObject
	if obj.Pim != nil {
		pim_object = new(VirtualRouterResourceMulticastInterfaceGroupPimObject)

		diags.Append(pim_object.CopyFromPango(ctx, obj.Pim, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Interface = interface_list
	o.GroupPermission = groupPermission_object
	o.Igmp = igmp_object
	o.Pim = pim_object

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermission, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_list types.List
	{
		var anySourceMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
		for _, elt := range obj.AnySourceMulticast {
			var entry VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			anySourceMulticast_tf_entries = append(anySourceMulticast_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("any_source_multicast")
		anySourceMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, anySourceMulticast_tf_entries)
		diags.Append(list_diags...)
	}
	var sourceSpecificMulticast_list types.List
	{
		var sourceSpecificMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
		for _, elt := range obj.SourceSpecificMulticast {
			var entry VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			sourceSpecificMulticast_tf_entries = append(sourceSpecificMulticast_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("source_specific_multicast")
		sourceSpecificMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, sourceSpecificMulticast_tf_entries)
		diags.Append(list_diags...)
	}

	o.AnySourceMulticast = anySourceMulticast_list
	o.SourceSpecificMulticast = sourceSpecificMulticast_list

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.SourceAddress = sourceAddress_value
	o.Included = included_value
	o.GroupAddress = groupAddress_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupIgmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var maxQueryResponseTime_value types.Float64
	if obj.MaxQueryResponseTime != nil {
		maxQueryResponseTime_value = types.Float64Value(*obj.MaxQueryResponseTime)
	}
	var lastMemberQueryInterval_value types.Float64
	if obj.LastMemberQueryInterval != nil {
		lastMemberQueryInterval_value = types.Float64Value(*obj.LastMemberQueryInterval)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var queryInterval_value types.Int64
	if obj.QueryInterval != nil {
		queryInterval_value = types.Int64Value(*obj.QueryInterval)
	}
	var immediateLeave_value types.Bool
	if obj.ImmediateLeave != nil {
		immediateLeave_value = types.BoolValue(*obj.ImmediateLeave)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.MaxQueryResponseTime = maxQueryResponseTime_value
	o.LastMemberQueryInterval = lastMemberQueryInterval_value
	o.Robustness = robustness_value
	o.MaxGroups = maxGroups_value
	o.Enable = enable_value
	o.Version = version_value
	o.QueryInterval = queryInterval_value
	o.ImmediateLeave = immediateLeave_value
	o.MaxSources = maxSources_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupPim, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var allowedNeighbors_list types.List
	{
		var allowedNeighbors_tf_entries []VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
		for _, elt := range obj.AllowedNeighbors {
			var entry VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			allowedNeighbors_tf_entries = append(allowedNeighbors_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("allowed_neighbors")
		allowedNeighbors_list, list_diags = types.ListValueFrom(ctx, schemaType, allowedNeighbors_tf_entries)
		diags.Append(list_diags...)
	}

	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var joinPruneInterval_value types.Int64
	if obj.JoinPruneInterval != nil {
		joinPruneInterval_value = types.Int64Value(*obj.JoinPruneInterval)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var bsrBorder_value types.Bool
	if obj.BsrBorder != nil {
		bsrBorder_value = types.BoolValue(*obj.BsrBorder)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var assertInterval_value types.Int64
	if obj.AssertInterval != nil {
		assertInterval_value = types.Int64Value(*obj.AssertInterval)
	}
	o.HelloInterval = helloInterval_value
	o.JoinPruneInterval = joinPruneInterval_value
	o.DrPriority = drPriority_value
	o.BsrBorder = bsrBorder_value
	o.AllowedNeighbors = allowedNeighbors_list
	o.Enable = enable_value
	o.AssertInterval = assertInterval_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyFromPango(ctx context.Context, obj *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolObject) CopyFromPango(ctx context.Context, obj *virtual_router.Protocol, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistProfile_list types.List
	{
		var redistProfile_tf_entries []VirtualRouterResourceProtocolRedistProfileObject
		for _, elt := range obj.RedistProfile {
			var entry VirtualRouterResourceProtocolRedistProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistProfile_tf_entries = append(redistProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile")
		redistProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var redistProfileIpv6_list types.List
	{
		var redistProfileIpv6_tf_entries []VirtualRouterResourceProtocolRedistProfileIpv6Object
		for _, elt := range obj.RedistProfileIpv6 {
			var entry VirtualRouterResourceProtocolRedistProfileIpv6Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistProfileIpv6_tf_entries = append(redistProfileIpv6_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile_ipv6")
		redistProfileIpv6_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfileIpv6_tf_entries)
		diags.Append(list_diags...)
	}
	var rip_object *VirtualRouterResourceProtocolRipObject
	if obj.Rip != nil {
		rip_object = new(VirtualRouterResourceProtocolRipObject)

		diags.Append(rip_object.CopyFromPango(ctx, obj.Rip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterResourceProtocolBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterResourceProtocolBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *VirtualRouterResourceProtocolOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterResourceProtocolOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_object *VirtualRouterResourceProtocolOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterResourceProtocolOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.RedistProfile = redistProfile_list
	o.RedistProfileIpv6 = redistProfileIpv6_list
	o.Rip = rip_object
	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterResourceProtocolOspfAreaObject
		for _, elt := range obj.Area {
			var entry VirtualRouterResourceProtocolOspfAreaObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterResourceProtocolOspfAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolOspfExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterResourceProtocolOspfExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var gracefulRestart_object *VirtualRouterResourceProtocolOspfGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterResourceProtocolOspfGracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *VirtualRouterResourceProtocolOspfGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterResourceProtocolOspfGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterResourceProtocolOspfTimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterResourceProtocolOspfTimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.GracefulRestart = gracefulRestart_object
	o.GlobalBfd = globalBfd_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Rfc1583 = rfc1583_value
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.RouterId = routerId_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfArea, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterResourceProtocolOspfAreaInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			var entry VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterResourceProtocolOspfAreaRangeObject
		for _, elt := range obj.Range {
			var entry VirtualRouterResourceProtocolOspfAreaRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterResourceProtocolOspfAreaTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterResourceProtocolOspfAreaTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list
	o.Type = type_object
	o.Range = range_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject
		for _, elt := range obj.Neighbor {
			var entry VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var linkType_object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject)

		diags.Append(linkType_object.CopyFromPango(ctx, obj.LinkType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.RetransmitInterval = retransmitInterval_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Enable = enable_value
	o.Metric = metric_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object
	o.Passive = passive_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject)

		diags.Append(broadcast_object.CopyFromPango(ctx, obj.Broadcast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject)

		diags.Append(p2p_object.CopyFromPango(ctx, obj.P2p, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject)

		diags.Append(p2mp_object.CopyFromPango(ctx, obj.P2mp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	o.Name = types.StringValue(obj.Name)
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.Authentication = authentication_value
	o.NeighborId = neighborId_value
	o.Enable = enable_value
	o.HelloInterval = helloInterval_value
	o.TransitDelay = transitDelay_value
	o.Bfd = bfd_object
	o.TransitAreaId = transitAreaId_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssa_object *VirtualRouterResourceProtocolOspfAreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaObject)

		diags.Append(nssa_object.CopyFromPango(ctx, obj.Nssa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var normal_object *VirtualRouterResourceProtocolOspfAreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(VirtualRouterResourceProtocolOspfAreaTypeNormalObject)

		diags.Append(normal_object.CopyFromPango(ctx, obj.Normal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *VirtualRouterResourceProtocolOspfAreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(VirtualRouterResourceProtocolOspfAreaTypeStubObject)

		diags.Append(stub_object.CopyFromPango(ctx, obj.Stub, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Nssa = nssa_object
	o.Normal = normal_object
	o.Stub = stub_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			var entry VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}
	var defaultRoute_object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.NssaExtRange = nssaExtRange_list
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppress_object *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Suppress = suppress_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppress_object *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterResourceProtocolOspfAreaRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Suppress = suppress_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileMd5Object
		for _, elt := range obj.Md5 {
			var entry VirtualRouterResourceProtocolOspfAuthProfileMd5Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			md5_tf_entries = append(md5_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfTimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolOspfv3AuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterResourceProtocolOspfv3AuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolOspfv3ExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterResourceProtocolOspfv3ExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterResourceProtocolOspfv3AreaObject
		for _, elt := range obj.Area {
			var entry VirtualRouterResourceProtocolOspfv3AreaObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			area_tf_entries = append(area_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *VirtualRouterResourceProtocolOspfv3GlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterResourceProtocolOspfv3GlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_object *VirtualRouterResourceProtocolOspfv3GracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterResourceProtocolOspfv3GracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterResourceProtocolOspfv3TimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterResourceProtocolOspfv3TimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	o.GlobalBfd = globalBfd_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GracefulRestart = gracefulRestart_object
	o.Timers = timers_object
	o.Area = area_list
	o.DisableTransitTraffic = disableTransitTraffic_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3ExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3GracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3TimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3Timers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3Area, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterResourceProtocolOspfv3AreaRangeObject
		for _, elt := range obj.Range {
			var entry VirtualRouterResourceProtocolOspfv3AreaRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			range_tf_entries = append(range_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterResourceProtocolOspfv3AreaInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
		for _, elt := range obj.VirtualLink {
			var entry VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterResourceProtocolOspfv3AreaTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_object *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject
	if obj.Normal != nil {
		normal_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject)

		diags.Append(normal_object.CopyFromPango(ctx, obj.Normal, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_object *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject
	if obj.Stub != nil {
		stub_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubObject)

		diags.Append(stub_object.CopyFromPango(ctx, obj.Stub, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject
	if obj.Nssa != nil {
		nssa_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject)

		diags.Append(nssa_object.CopyFromPango(ctx, obj.Nssa, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNormal, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStub, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssa, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
		for _, elt := range obj.NssaExtRange {
			var entry VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}
	var defaultRoute_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRange, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_object *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_object *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject
	if obj.Suppress != nil {
		suppress_object = new(VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject)

		diags.Append(suppress_object.CopyFromPango(ctx, obj.Suppress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRangeAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaRangeSuppress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject
		for _, elt := range obj.Neighbor {
			var entry VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			neighbor_tf_entries = append(neighbor_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}
	var bfd_object *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var linkType_object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject
	if obj.LinkType != nil {
		linkType_object = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject)

		diags.Append(linkType_object.CopyFromPango(ctx, obj.LinkType, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Passive = passive_value
	o.Metric = metric_value
	o.RetransmitInterval = retransmitInterval_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object
	o.Priority = priority_value
	o.DeadCounts = deadCounts_value
	o.LinkType = linkType_object
	o.HelloInterval = helloInterval_value
	o.GrDelay = grDelay_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.TransitDelay = transitDelay_value
	o.Neighbor = neighbor_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
	if obj.Broadcast != nil {
		broadcast_object = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject)

		diags.Append(broadcast_object.CopyFromPango(ctx, obj.Broadcast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
	if obj.P2p != nil {
		p2p_object = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject)

		diags.Append(p2p_object.CopyFromPango(ctx, obj.P2p, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	if obj.P2mp != nil {
		p2mp_object = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject)

		diags.Append(p2mp_object.CopyFromPango(ctx, obj.P2mp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaVirtualLink, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Bfd = bfd_object
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.DeadCounts = deadCounts_value
	o.Authentication = authentication_value
	o.NeighborId = neighborId_value
	o.HelloInterval = helloInterval_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var esp_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject
	if obj.Esp != nil {
		esp_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspObject)

		diags.Append(esp_object.CopyFromPango(ctx, obj.Esp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject
	if obj.Ah != nil {
		ah_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhObject)

		diags.Append(ah_object.CopyFromPango(ctx, obj.Ah, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var spi_value types.String
	if obj.Spi != nil {
		spi_value = types.StringValue(*obj.Spi)
	}
	o.Name = types.StringValue(obj.Name)
	o.Spi = spi_value
	o.Esp = esp_object
	o.Ah = ah_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEsp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject
	if obj.Authentication != nil {
		authentication_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject)

		diags.Append(authentication_object.CopyFromPango(ctx, obj.Authentication, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject
	if obj.Encryption != nil {
		encryption_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject)

		diags.Append(encryption_object.CopyFromPango(ctx, obj.Encryption, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var sha384_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var md5_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
	if obj.Md5 != nil {
		md5_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.None = none_object
	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileEspEncryption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAh, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object
	if obj.Md5 != nil {
		md5_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object)

		diags.Append(md5_object.CopyFromPango(ctx, obj.Md5, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object
	if obj.Sha1 != nil {
		sha1_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object)

		diags.Append(sha1_object.CopyFromPango(ctx, obj.Sha1, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object
	if obj.Sha256 != nil {
		sha256_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object)

		diags.Append(sha256_object.CopyFromPango(ctx, obj.Sha256, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object
	if obj.Sha384 != nil {
		sha384_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object)

		diags.Append(sha384_object.CopyFromPango(ctx, obj.Sha384, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object
	if obj.Sha512 != nil {
		sha512_object = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object)

		diags.Append(sha512_object.CopyFromPango(ctx, obj.Sha512, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha1, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha256, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha384, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha512, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3AuthProfileAhMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolOspfv3GlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_object *VirtualRouterResourceProtocolRedistProfileActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterResourceProtocolRedistProfileActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var filter_object *VirtualRouterResourceProtocolRedistProfileFilterObject
	if obj.Filter != nil {
		filter_object = new(VirtualRouterResourceProtocolRedistProfileFilterObject)

		diags.Append(filter_object.CopyFromPango(ctx, obj.Filter, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Action = action_object
	o.Priority = priority_value
	o.Filter = filter_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics
		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Type)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics
		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var bgp_object *VirtualRouterResourceProtocolRedistProfileFilterBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterResourceProtocolRedistProfileFilterBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_object *VirtualRouterResourceProtocolRedistProfileFilterOspfObject
	if obj.Ospf != nil {
		ospf_object = new(VirtualRouterResourceProtocolRedistProfileFilterOspfObject)

		diags.Append(ospf_object.CopyFromPango(ctx, obj.Ospf, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospf = ospf_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilterOspf, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics
		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PathType)
		diags.Append(list_diags...)
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics
		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Area)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileFilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics
		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Community)
		diags.Append(list_diags...)
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExtendedCommunity)
		diags.Append(list_diags...)
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_object *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject
	if obj.NoRedist != nil {
		noRedist_object = new(VirtualRouterResourceProtocolRedistProfileActionNoRedistObject)

		diags.Append(noRedist_object.CopyFromPango(ctx, obj.NoRedist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_object *VirtualRouterResourceProtocolRedistProfileActionRedistObject
	if obj.Redist != nil {
		redist_object = new(VirtualRouterResourceProtocolRedistProfileActionRedistObject)

		diags.Append(redist_object.CopyFromPango(ctx, obj.Redist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var filter_object *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject
	if obj.Filter != nil {
		filter_object = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterObject)

		diags.Append(filter_object.CopyFromPango(ctx, obj.Filter, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6Action, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_object *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject
	if obj.NoRedist != nil {
		noRedist_object = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject)

		diags.Append(noRedist_object.CopyFromPango(ctx, obj.NoRedist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_object *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject
	if obj.Redist != nil {
		redist_object = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject)

		diags.Append(redist_object.CopyFromPango(ctx, obj.Redist, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6ActionRedist, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6Filter, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics
		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Type)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics
		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Interface)
		diags.Append(list_diags...)
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics
		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Destination)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var ospfv3_object *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object
	if obj.Ospfv3 != nil {
		ospfv3_object = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object)

		diags.Append(ospfv3_object.CopyFromPango(ctx, obj.Ospfv3, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_object *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject
	if obj.Bgp != nil {
		bgp_object = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject)

		diags.Append(bgp_object.CopyFromPango(ctx, obj.Bgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var list_diags diag.Diagnostics
		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Area)
		diags.Append(list_diags...)
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics
		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Tag)
		diags.Append(list_diags...)
	}
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics
		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.PathType)
		diags.Append(list_diags...)
	}

	o.Area = area_list
	o.Tag = tag_list
	o.PathType = pathType_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRedistProfileIpv6FilterBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics
		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Community)
		diags.Append(list_diags...)
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExtendedCommunity)
		diags.Append(list_diags...)
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterResourceProtocolRipObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRip, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolRipAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterResourceProtocolRipAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolRipExportRulesObject
		for _, elt := range obj.ExportRules {
			var entry VirtualRouterResourceProtocolRipExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			exportRules_tf_entries = append(exportRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterResourceProtocolRipInterfacesObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterResourceProtocolRipInterfacesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interfaces_tf_entries = append(interfaces_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}
	var globalBfd_object *VirtualRouterResourceProtocolRipGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterResourceProtocolRipGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var timers_object *VirtualRouterResourceProtocolRipTimersObject
	if obj.Timers != nil {
		timers_object = new(VirtualRouterResourceProtocolRipTimersObject)

		diags.Append(timers_object.CopyFromPango(ctx, obj.Timers, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.Interfaces = interfaces_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Timers = timers_object
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterResourceProtocolRipAuthProfileMd5Object
		for _, elt := range obj.Md5 {
			var entry VirtualRouterResourceProtocolRipAuthProfileMd5Object
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			md5_tf_entries = append(md5_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipAuthProfileMd5, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var defaultRoute_object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject
	if obj.DefaultRoute != nil {
		defaultRoute_object = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject)

		diags.Append(defaultRoute_object.CopyFromPango(ctx, obj.DefaultRoute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterResourceProtocolRipInterfacesBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolRipInterfacesBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Mode = mode_value
	o.DefaultRoute = defaultRoute_object
	o.Bfd = bfd_object
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject
	if obj.Disable != nil {
		disable_object = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject)

		diags.Append(disable_object.CopyFromPango(ctx, obj.Disable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	if obj.Advertise != nil {
		advertise_object = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject)

		diags.Append(advertise_object.CopyFromPango(ctx, obj.Advertise, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRouteDisable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipInterfaceBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipTimersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolRipTimers, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var updateIntervals_value types.Int64
	if obj.UpdateIntervals != nil {
		updateIntervals_value = types.Int64Value(*obj.UpdateIntervals)
	}
	var deleteIntervals_value types.Int64
	if obj.DeleteIntervals != nil {
		deleteIntervals_value = types.Int64Value(*obj.DeleteIntervals)
	}
	var expireIntervals_value types.Int64
	if obj.ExpireIntervals != nil {
		expireIntervals_value = types.Int64Value(*obj.ExpireIntervals)
	}
	var intervalSeconds_value types.Int64
	if obj.IntervalSeconds != nil {
		intervalSeconds_value = types.Int64Value(*obj.IntervalSeconds)
	}
	o.UpdateIntervals = updateIntervals_value
	o.DeleteIntervals = deleteIntervals_value
	o.ExpireIntervals = expireIntervals_value
	o.IntervalSeconds = intervalSeconds_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupObject
		for _, elt := range obj.PeerGroup {
			var entry VirtualRouterResourceProtocolBgpPeerGroupObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var dampeningProfile_list types.List
	{
		var dampeningProfile_tf_entries []VirtualRouterResourceProtocolBgpDampeningProfileObject
		for _, elt := range obj.DampeningProfile {
			var entry VirtualRouterResourceProtocolBgpDampeningProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			dampeningProfile_tf_entries = append(dampeningProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("dampening_profile")
		dampeningProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, dampeningProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var redistRules_list types.List
	{
		var redistRules_tf_entries []VirtualRouterResourceProtocolBgpRedistRulesObject
		for _, elt := range obj.RedistRules {
			var entry VirtualRouterResourceProtocolBgpRedistRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			redistRules_tf_entries = append(redistRules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_rules")
		redistRules_list, list_diags = types.ListValueFrom(ctx, schemaType, redistRules_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolBgpAuthProfileObject
		for _, elt := range obj.AuthProfile {
			var entry VirtualRouterResourceProtocolBgpAuthProfileObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			authProfile_tf_entries = append(authProfile_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var policy_object *VirtualRouterResourceProtocolBgpPolicyObject
	if obj.Policy != nil {
		policy_object = new(VirtualRouterResourceProtocolBgpPolicyObject)

		diags.Append(policy_object.CopyFromPango(ctx, obj.Policy, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routingOptions_object *VirtualRouterResourceProtocolBgpRoutingOptionsObject
	if obj.RoutingOptions != nil {
		routingOptions_object = new(VirtualRouterResourceProtocolBgpRoutingOptionsObject)

		diags.Append(routingOptions_object.CopyFromPango(ctx, obj.RoutingOptions, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var globalBfd_object *VirtualRouterResourceProtocolBgpGlobalBfdObject
	if obj.GlobalBfd != nil {
		globalBfd_object = new(VirtualRouterResourceProtocolBgpGlobalBfdObject)

		diags.Append(globalBfd_object.CopyFromPango(ctx, obj.GlobalBfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.EcmpMultiAs = ecmpMultiAs_value
	o.Enable = enable_value
	o.PeerGroup = peerGroup_list
	o.EnforceFirstAs = enforceFirstAs_value
	o.DampeningProfile = dampeningProfile_list
	o.InstallRoute = installRoute_value
	o.Policy = policy_object
	o.LocalAs = localAs_value
	o.RedistRules = redistRules_list
	o.RouterId = routerId_value
	o.RoutingOptions = routingOptions_object
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.GlobalBfd = globalBfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroup, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupPeerObject
		for _, elt := range obj.Peer {
			var entry VirtualRouterResourceProtocolBgpPeerGroupPeerObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			peer_tf_entries = append(peer_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}
	var type_object *VirtualRouterResourceProtocolBgpPeerGroupTypeObject
	if obj.Type != nil {
		type_object = new(VirtualRouterResourceProtocolBgpPeerGroupTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var aggregatedConfedAsPath_value types.Bool
	if obj.AggregatedConfedAsPath != nil {
		aggregatedConfedAsPath_value = types.BoolValue(*obj.AggregatedConfedAsPath)
	}
	var softResetWithStoredInfo_value types.Bool
	if obj.SoftResetWithStoredInfo != nil {
		softResetWithStoredInfo_value = types.BoolValue(*obj.SoftResetWithStoredInfo)
	}
	o.Name = types.StringValue(obj.Name)
	o.Type = type_object
	o.Peer = peer_list
	o.Enable = enable_value
	o.AggregatedConfedAsPath = aggregatedConfedAsPath_value
	o.SoftResetWithStoredInfo = softResetWithStoredInfo_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupType, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ebgpConfed_object *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject
	if obj.EbgpConfed != nil {
		ebgpConfed_object = new(VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject)

		diags.Append(ebgpConfed_object.CopyFromPango(ctx, obj.EbgpConfed, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_object *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject
	if obj.IbgpConfed != nil {
		ibgpConfed_object = new(VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject)

		diags.Append(ibgpConfed_object.CopyFromPango(ctx, obj.IbgpConfed, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_object *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject
	if obj.Ebgp != nil {
		ebgp_object = new(VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject)

		diags.Append(ebgp_object.CopyFromPango(ctx, obj.Ebgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgp_object *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject
	if obj.Ibgp != nil {
		ibgp_object = new(VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject)

		diags.Append(ibgp_object.CopyFromPango(ctx, obj.Ibgp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.EbgpConfed = ebgpConfed_object
	o.IbgpConfed = ibgpConfed_object
	o.Ebgp = ebgp_object
	o.Ibgp = ibgp_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var importNexthop_value types.String
	if obj.ImportNexthop != nil {
		importNexthop_value = types.StringValue(*obj.ImportNexthop)
	}
	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	var removePrivateAs_value types.Bool
	if obj.RemovePrivateAs != nil {
		removePrivateAs_value = types.BoolValue(*obj.RemovePrivateAs)
	}
	o.ImportNexthop = importNexthop_value
	o.ExportNexthop = exportNexthop_value
	o.RemovePrivateAs = removePrivateAs_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeer, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var subsequentAddressFamilyIdentifier_object *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
	if obj.SubsequentAddressFamilyIdentifier != nil {
		subsequentAddressFamilyIdentifier_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject)

		diags.Append(subsequentAddressFamilyIdentifier_object.CopyFromPango(ctx, obj.SubsequentAddressFamilyIdentifier, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_object *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject
	if obj.LocalAddress != nil {
		localAddress_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject)

		diags.Append(localAddress_object.CopyFromPango(ctx, obj.LocalAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject
	if obj.ConnectionOptions != nil {
		connectionOptions_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject)

		diags.Append(connectionOptions_object.CopyFromPango(ctx, obj.ConnectionOptions, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_object *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject
	if obj.PeerAddress != nil {
		peerAddress_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject)

		diags.Append(peerAddress_object.CopyFromPango(ctx, obj.PeerAddress, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableMpBgp_value types.Bool
	if obj.EnableMpBgp != nil {
		enableMpBgp_value = types.BoolValue(*obj.EnableMpBgp)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	var reflectorClient_value types.String
	if obj.ReflectorClient != nil {
		reflectorClient_value = types.StringValue(*obj.ReflectorClient)
	}
	var maxPrefixes_value types.String
	if obj.MaxPrefixes != nil {
		maxPrefixes_value = types.StringValue(*obj.MaxPrefixes)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peeringType_value types.String
	if obj.PeeringType != nil {
		peeringType_value = types.StringValue(*obj.PeeringType)
	}
	o.Name = types.StringValue(obj.Name)
	o.SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_object
	o.LocalAddress = localAddress_object
	o.PeerAs = peerAs_value
	o.EnableMpBgp = enableMpBgp_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.ReflectorClient = reflectorClient_value
	o.MaxPrefixes = maxPrefixes_value
	o.ConnectionOptions = connectionOptions_object
	o.Enable = enable_value
	o.PeeringType = peeringType_value
	o.PeerAddress = peerAddress_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	o.Unicast = unicast_value
	o.Multicast = multicast_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var incomingBgpConnection_object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
	if obj.IncomingBgpConnection != nil {
		incomingBgpConnection_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject)

		diags.Append(incomingBgpConnection_object.CopyFromPango(ctx, obj.IncomingBgpConnection, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var outgoingBgpConnection_object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	if obj.OutgoingBgpConnection != nil {
		outgoingBgpConnection_object = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject)

		diags.Append(outgoingBgpConnection_object.CopyFromPango(ctx, obj.OutgoingBgpConnection, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var minRouteAdvInterval_value types.Int64
	if obj.MinRouteAdvInterval != nil {
		minRouteAdvInterval_value = types.Int64Value(*obj.MinRouteAdvInterval)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var openDelayTime_value types.Int64
	if obj.OpenDelayTime != nil {
		openDelayTime_value = types.Int64Value(*obj.OpenDelayTime)
	}
	var holdTime_value types.String
	if obj.HoldTime != nil {
		holdTime_value = types.StringValue(*obj.HoldTime)
	}
	var keepAliveInterval_value types.String
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.StringValue(*obj.KeepAliveInterval)
	}
	var idleHoldTime_value types.Int64
	if obj.IdleHoldTime != nil {
		idleHoldTime_value = types.Int64Value(*obj.IdleHoldTime)
	}
	o.IncomingBgpConnection = incomingBgpConnection_object
	o.Authentication = authentication_value
	o.MinRouteAdvInterval = minRouteAdvInterval_value
	o.Multihop = multihop_value
	o.OpenDelayTime = openDelayTime_value
	o.HoldTime = holdTime_value
	o.KeepAliveInterval = keepAliveInterval_value
	o.IdleHoldTime = idleHoldTime_value
	o.OutgoingBgpConnection = outgoingBgpConnection_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.LocalPort = localPort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.RemotePort = remotePort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPeerGroupPeerBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpDampeningProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var cutoff_value types.Float64
	if obj.Cutoff != nil {
		cutoff_value = types.Float64Value(*obj.Cutoff)
	}
	var reuse_value types.Float64
	if obj.Reuse != nil {
		reuse_value = types.Float64Value(*obj.Reuse)
	}
	var maxHoldTime_value types.Int64
	if obj.MaxHoldTime != nil {
		maxHoldTime_value = types.Int64Value(*obj.MaxHoldTime)
	}
	var decayHalfLifeReachable_value types.Int64
	if obj.DecayHalfLifeReachable != nil {
		decayHalfLifeReachable_value = types.Int64Value(*obj.DecayHalfLifeReachable)
	}
	var decayHalfLifeUnreachable_value types.Int64
	if obj.DecayHalfLifeUnreachable != nil {
		decayHalfLifeUnreachable_value = types.Int64Value(*obj.DecayHalfLifeUnreachable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Cutoff = cutoff_value
	o.Reuse = reuse_value
	o.MaxHoldTime = maxHoldTime_value
	o.DecayHalfLifeReachable = decayHalfLifeReachable_value
	o.DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregation_object *VirtualRouterResourceProtocolBgpPolicyAggregationObject
	if obj.Aggregation != nil {
		aggregation_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationObject)

		diags.Append(aggregation_object.CopyFromPango(ctx, obj.Aggregation, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var conditionalAdvertisement_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject
	if obj.ConditionalAdvertisement != nil {
		conditionalAdvertisement_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject)

		diags.Append(conditionalAdvertisement_object.CopyFromPango(ctx, obj.ConditionalAdvertisement, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_object *VirtualRouterResourceProtocolBgpPolicyExportObject
	if obj.Export != nil {
		export_object = new(VirtualRouterResourceProtocolBgpPolicyExportObject)

		diags.Append(export_object.CopyFromPango(ctx, obj.Export, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var import_object *VirtualRouterResourceProtocolBgpPolicyImportObject
	if obj.Import != nil {
		import_object = new(VirtualRouterResourceProtocolBgpPolicyImportObject)

		diags.Append(import_object.CopyFromPango(ctx, obj.Import, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Aggregation = aggregation_object
	o.ConditionalAdvertisement = conditionalAdvertisement_object
	o.Export = export_object
	o.Import = import_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesObject
		for _, elt := range obj.Rules {
			var entry VirtualRouterResourceProtocolBgpPolicyExportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}
	var match_object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var allow_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var deny_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject
	if obj.Deny != nil {
		deny_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject)

		diags.Append(deny_object.CopyFromPango(ctx, obj.Deny, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Allow = allow_object
	o.Deny = deny_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	if obj.Update != nil {
		update_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject)

		diags.Append(update_object.CopyFromPango(ctx, obj.Update, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Update = update_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.ExtendedCommunity = extendedCommunity_object
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object
	o.RemoveAll = removeAll_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	var removeAndPrepend_value types.Int64
	if obj.RemoveAndPrepend != nil {
		removeAndPrepend_value = types.Int64Value(*obj.RemoveAndPrepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value
	o.RemoveAndPrepend = removeAndPrepend_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.Append = append_list
	o.Overwrite = overwrite_list
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImport, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesObject
		for _, elt := range obj.Rules {
			var entry VirtualRouterResourceProtocolBgpPolicyImportRulesObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			rules_tf_entries = append(rules_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}
	var match_object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject
	if obj.Action != nil {
		action_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject)

		diags.Append(action_object.CopyFromPango(ctx, obj.Action, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesAction, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject
	if obj.Deny != nil {
		deny_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject)

		diags.Append(deny_object.CopyFromPango(ctx, obj.Deny, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject
	if obj.Allow != nil {
		allow_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject)

		diags.Append(allow_object.CopyFromPango(ctx, obj.Allow, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionDeny, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllow, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	if obj.Update != nil {
		update_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject)

		diags.Append(update_object.CopyFromPango(ctx, obj.Update, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Update = update_object
	o.Dampening = dampening_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.LocalPreference = localPreference_value
	o.Weight = weight_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.None = none_object
	o.Remove = remove_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregation, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
		for _, elt := range obj.Address {
			var entry VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			address_tf_entries = append(address_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	o.Address = address_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddress, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
		for _, elt := range obj.AdvertiseFilters {
			var entry VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var suppressFilters_list types.List
	{
		var suppressFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
		for _, elt := range obj.SuppressFilters {
			var entry VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			suppressFilters_tf_entries = append(suppressFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suppress_filters")
		suppressFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, suppressFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var aggregateRouteAttributes_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
	if obj.AggregateRouteAttributes != nil {
		aggregateRouteAttributes_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject)

		diags.Append(aggregateRouteAttributes_object.CopyFromPango(ctx, obj.AggregateRouteAttributes, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summary_value types.Bool
	if obj.Summary != nil {
		summary_value = types.BoolValue(*obj.Summary)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	o.Name = types.StringValue(obj.Name)
	o.AdvertiseFilters = advertiseFilters_list
	o.Prefix = prefix_value
	o.Enable = enable_value
	o.Summary = summary_value
	o.AsSet = asSet_value
	o.AggregateRouteAttributes = aggregateRouteAttributes_object
	o.SuppressFilters = suppressFilters_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.Weight = weight_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.LocalPreference = localPreference_value
	o.Nexthop = nexthop_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.Med = med_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject
	if obj.Remove != nil {
		remove_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject)

		diags.Append(remove_object.CopyFromPango(ctx, obj.Remove, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemoveObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathRemove, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics
		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Append)
		diags.Append(list_diags...)
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics
		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Overwrite)
		diags.Append(list_diags...)
	}
	var none_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
	if obj.None != nil {
		none_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject)

		diags.Append(none_object.CopyFromPango(ctx, obj.None, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
	if obj.RemoveAll != nil {
		removeAll_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject)

		diags.Append(removeAll_object.CopyFromPango(ctx, obj.RemoveAll, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Match = match_object
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisement, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_list types.List
	{
		var policy_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
		for _, elt := range obj.Policy {
			var entry VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			policy_tf_entries = append(policy_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("policy")
		policy_list, list_diags = types.ListValueFrom(ctx, schemaType, policy_tf_entries)
		diags.Append(list_diags...)
	}

	o.Policy = policy_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics
		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.UsedBy)
		diags.Append(list_diags...)
	}
	var nonExistFilters_list types.List
	{
		var nonExistFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
		for _, elt := range obj.NonExistFilters {
			var entry VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			nonExistFilters_tf_entries = append(nonExistFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("non_exist_filters")
		nonExistFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, nonExistFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
		for _, elt := range obj.AdvertiseFilters {
			var entry VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.NonExistFilters = nonExistFilters_list
	o.AdvertiseFilters = advertiseFilters_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var match_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	if obj.Match != nil {
		match_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject)

		diags.Append(match_object.CopyFromPango(ctx, obj.Match, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
		for _, elt := range obj.AddressPrefix {
			var entry VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics
		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.Nexthop)
		diags.Append(list_diags...)
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics
		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.FromPeer)
		diags.Append(list_diags...)
	}
	var asPath_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
	if obj.AsPath != nil {
		asPath_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject)

		diags.Append(asPath_object.CopyFromPango(ctx, obj.AsPath, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
	if obj.Community != nil {
		community_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject)

		diags.Append(community_object.CopyFromPango(ctx, obj.Community, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	if obj.ExtendedCommunity != nil {
		extendedCommunity_object = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject)

		diags.Append(extendedCommunity_object.CopyFromPango(ctx, obj.ExtendedCommunity, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpAuthProfile, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var secret_value types.String
	if obj.Secret != nil {
		secret_value = types.StringValue(*obj.Secret)
	}
	o.Name = types.StringValue(obj.Name)
	o.Secret = secret_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpGlobalBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRedistRules, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var setCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		setCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.SetCommunity)
		diags.Append(list_diags...)
	}
	var setExtendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics
		setExtendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.SetExtendedCommunity)
		diags.Append(list_diags...)
	}

	var setOrigin_value types.String
	if obj.SetOrigin != nil {
		setOrigin_value = types.StringValue(*obj.SetOrigin)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var setMed_value types.Int64
	if obj.SetMed != nil {
		setMed_value = types.Int64Value(*obj.SetMed)
	}
	var setLocalPreference_value types.Int64
	if obj.SetLocalPreference != nil {
		setLocalPreference_value = types.Int64Value(*obj.SetLocalPreference)
	}
	var setAsPathLimit_value types.Int64
	if obj.SetAsPathLimit != nil {
		setAsPathLimit_value = types.Int64Value(*obj.SetAsPathLimit)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	o.Name = types.StringValue(obj.Name)
	o.SetOrigin = setOrigin_value
	o.Metric = metric_value
	o.SetCommunity = setCommunity_list
	o.SetExtendedCommunity = setExtendedCommunity_list
	o.RouteTable = routeTable_value
	o.Enable = enable_value
	o.SetMed = setMed_value
	o.SetLocalPreference = setLocalPreference_value
	o.SetAsPathLimit = setAsPathLimit_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptions, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var gracefulRestart_object *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject
	if obj.GracefulRestart != nil {
		gracefulRestart_object = new(VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject)

		diags.Append(gracefulRestart_object.CopyFromPango(ctx, obj.GracefulRestart, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_object *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject
	if obj.Med != nil {
		med_object = new(VirtualRouterResourceProtocolBgpRoutingOptionsMedObject)

		diags.Append(med_object.CopyFromPango(ctx, obj.Med, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var aggregate_object *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject
	if obj.Aggregate != nil {
		aggregate_object = new(VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject)

		diags.Append(aggregate_object.CopyFromPango(ctx, obj.Aggregate, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var reflectorClusterId_value types.String
	if obj.ReflectorClusterId != nil {
		reflectorClusterId_value = types.StringValue(*obj.ReflectorClusterId)
	}
	var asFormat_value types.String
	if obj.AsFormat != nil {
		asFormat_value = types.StringValue(*obj.AsFormat)
	}
	var confederationMemberAs_value types.String
	if obj.ConfederationMemberAs != nil {
		confederationMemberAs_value = types.StringValue(*obj.ConfederationMemberAs)
	}
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulRestart = gracefulRestart_object
	o.Med = med_object
	o.ReflectorClusterId = reflectorClusterId_value
	o.Aggregate = aggregate_object
	o.AsFormat = asFormat_value
	o.ConfederationMemberAs = confederationMemberAs_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	o.Enable = enable_value
	o.LocalRestartTime = localRestartTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.StaleRouteTime = staleRouteTime_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsMed, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) CopyFromPango(ctx context.Context, obj *virtual_router.ProtocolBgpRoutingOptionsAggregate, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregateMed_value types.Bool
	if obj.AggregateMed != nil {
		aggregateMed_value = types.BoolValue(*obj.AggregateMed)
	}
	o.AggregateMed = aggregateMed_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var ip_object *VirtualRouterResourceRoutingTableIpObject
	if obj.Ip != nil {
		ip_object = new(VirtualRouterResourceRoutingTableIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_object *VirtualRouterResourceRoutingTableIpv6Object
	if obj.Ipv6 != nil {
		ipv6_object = new(VirtualRouterResourceRoutingTableIpv6Object)

		diags.Append(ipv6_object.CopyFromPango(ctx, obj.Ipv6, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ip = ip_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []VirtualRouterResourceRoutingTableIpStaticRouteObject
		for _, elt := range obj.StaticRoute {
			var entry VirtualRouterResourceRoutingTableIpStaticRouteObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var routeTable_object *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject
	if obj.RouteTable != nil {
		routeTable_object = new(VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject)

		diags.Append(routeTable_object.CopyFromPango(ctx, obj.RouteTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_object *VirtualRouterResourceRoutingTableIpStaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceRoutingTableIpStaticRouteBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject)

		diags.Append(pathMonitor_object.CopyFromPango(ctx, obj.PathMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_object *VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject)

		diags.Append(nexthop_object.CopyFromPango(ctx, obj.Nexthop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.RouteTable = routeTable_object
	o.Bfd = bfd_object
	o.PathMonitor = pathMonitor_object
	o.Destination = destination_value
	o.Interface = interface_value
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Nexthop = nexthop_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			var entry VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var receive_object *VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject
	if obj.Receive != nil {
		receive_object = new(VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject)

		diags.Append(receive_object.CopyFromPango(ctx, obj.Receive, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var discard_object *VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject)

		diags.Append(discard_object.CopyFromPango(ctx, obj.Discard, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	o.Receive = receive_object
	o.Discard = discard_object
	o.IpAddress = ipAddress_value
	o.Fqdn = fqdn_value
	o.NextVr = nextVr_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopReceiveObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_object *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject
	if obj.Unicast != nil {
		unicast_object = new(VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject)

		diags.Append(unicast_object.CopyFromPango(ctx, obj.Unicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var multicast_object *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject
	if obj.Multicast != nil {
		multicast_object = new(VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject)

		diags.Append(multicast_object.CopyFromPango(ctx, obj.Multicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_object *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject
	if obj.Both != nil {
		both_object = new(VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject)

		diags.Append(both_object.CopyFromPango(ctx, obj.Both, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var noInstall_object *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject
	if obj.NoInstall != nil {
		noInstall_object = new(VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject)

		diags.Append(noInstall_object.CopyFromPango(ctx, obj.NoInstall, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Unicast = unicast_object
	o.Multicast = multicast_object
	o.Both = both_object
	o.NoInstall = noInstall_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableNoInstallObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableUnicastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableMulticastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableMulticast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpStaticRouteRouteTableBothObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpStaticRouteRouteTableBoth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6Object) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var staticRoute_list types.List
	{
		var staticRoute_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRouteObject
		for _, elt := range obj.StaticRoute {
			var entry VirtualRouterResourceRoutingTableIpv6StaticRouteObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			staticRoute_tf_entries = append(staticRoute_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("static_route")
		staticRoute_list, list_diags = types.ListValueFrom(ctx, schemaType, staticRoute_tf_entries)
		diags.Append(list_diags...)
	}

	o.StaticRoute = staticRoute_list

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var bfd_object *VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject
	if obj.Bfd != nil {
		bfd_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject)

		diags.Append(bfd_object.CopyFromPango(ctx, obj.Bfd, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_object *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject
	if obj.Nexthop != nil {
		nexthop_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject)

		diags.Append(nexthop_object.CopyFromPango(ctx, obj.Nexthop, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var option_object *VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject
	if obj.Option != nil {
		option_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject)

		diags.Append(option_object.CopyFromPango(ctx, obj.Option, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var routeTable_object *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject
	if obj.RouteTable != nil {
		routeTable_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject)

		diags.Append(routeTable_object.CopyFromPango(ctx, obj.RouteTable, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var pathMonitor_object *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject
	if obj.PathMonitor != nil {
		pathMonitor_object = new(VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject)

		diags.Append(pathMonitor_object.CopyFromPango(ctx, obj.PathMonitor, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistance_value types.Int64
	if obj.AdminDist != nil {
		administrativeDistance_value = types.Int64Value(*obj.AdminDist)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	o.Name = types.StringValue(obj.Name)
	o.AdministrativeDistance = administrativeDistance_value
	o.Metric = metric_value
	o.Bfd = bfd_object
	o.Destination = destination_value
	o.Interface = interface_value
	o.Nexthop = nexthop_object
	o.Option = option_object
	o.RouteTable = routeTable_object
	o.PathMonitor = pathMonitor_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteBfdObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteBfd, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthop, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var discard_object *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject
	if obj.Discard != nil {
		discard_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject)

		diags.Append(discard_object.CopyFromPango(ctx, obj.Discard, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var receive_object *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject
	if obj.Receive != nil {
		receive_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject)

		diags.Append(receive_object.CopyFromPango(ctx, obj.Receive, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var nextVr_value types.String
	if obj.NextVr != nil {
		nextVr_value = types.StringValue(*obj.NextVr)
	}
	o.Discard = discard_object
	o.Ipv6Address = ipv6Address_value
	o.NextVr = nextVr_value
	o.Receive = receive_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopReceiveObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthopReceive, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteNexthopDiscardObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteNexthopDiscard, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteOptionObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteOption, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTable, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var noInstall_object *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject
	if obj.NoInstall != nil {
		noInstall_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject)

		diags.Append(noInstall_object.CopyFromPango(ctx, obj.NoInstall, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var unicast_object *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject
	if obj.Unicast != nil {
		unicast_object = new(VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject)

		diags.Append(unicast_object.CopyFromPango(ctx, obj.Unicast, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoInstall = noInstall_object
	o.Unicast = unicast_object

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableUnicastObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTableUnicast, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRouteRouteTableNoInstallObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRouteRouteTableNoInstall, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutePathMonitor, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monitorDestinations_list types.List
	{
		var monitorDestinations_tf_entries []VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
		for _, elt := range obj.MonitorDestinations {
			var entry VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			monitorDestinations_tf_entries = append(monitorDestinations_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("monitor_destinations")
		monitorDestinations_list, list_diags = types.ListValueFrom(ctx, schemaType, monitorDestinations_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var failureCondition_value types.String
	if obj.FailureCondition != nil {
		failureCondition_value = types.StringValue(*obj.FailureCondition)
	}
	var holdTime_value types.Int64
	if obj.HoldTime != nil {
		holdTime_value = types.Int64Value(*obj.HoldTime)
	}
	o.Enable = enable_value
	o.FailureCondition = failureCondition_value
	o.HoldTime = holdTime_value
	o.MonitorDestinations = monitorDestinations_list

	return diags
}

func (o *VirtualRouterResourceRoutingTableIpv6StaticRoutePathMonitorMonitorDestinationsObject) CopyFromPango(ctx context.Context, obj *virtual_router.RoutingTableIpv6StaticRoutePathMonitorMonitorDestinations, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_value types.String
	if obj.Source != nil {
		source_value = types.StringValue(*obj.Source)
	}
	var destination_value types.String
	if obj.Destination != nil {
		destination_value = types.StringValue(*obj.Destination)
	}
	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	var count_value types.Int64
	if obj.Count != nil {
		count_value = types.Int64Value(*obj.Count)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Source = source_value
	o.Destination = destination_value
	o.Interval = interval_value
	o.Count = count_value
	o.Enable = enable_value

	return diags
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, obj *virtual_router.AdminDists, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	o.OspfInt = ospfInt_value
	o.Ospfv3Int = ospfv3Int_value
	o.Static = static_value
	o.Ebgp = ebgp_value
	o.Ibgp = ibgp_value
	o.OspfExt = ospfExt_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.Rip = rip_value
	o.StaticIpv6 = staticIpv6_value

	return diags
}

func (o *VirtualRouterResourceEcmpObject) CopyFromPango(ctx context.Context, obj *virtual_router.Ecmp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_object *VirtualRouterResourceEcmpAlgorithmObject
	if obj.Algorithm != nil {
		algorithm_object = new(VirtualRouterResourceEcmpAlgorithmObject)

		diags.Append(algorithm_object.CopyFromPango(ctx, obj.Algorithm, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	o.Algorithm = algorithm_object
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.StrictSourcePath = strictSourcePath_value
	o.SymmetricReturn = symmetricReturn_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithm, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_object *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject
	if obj.BalancedRoundRobin != nil {
		balancedRoundRobin_object = new(VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject)

		diags.Append(balancedRoundRobin_object.CopyFromPango(ctx, obj.BalancedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_object *VirtualRouterResourceEcmpAlgorithmIpHashObject
	if obj.IpHash != nil {
		ipHash_object = new(VirtualRouterResourceEcmpAlgorithmIpHashObject)

		diags.Append(ipHash_object.CopyFromPango(ctx, obj.IpHash, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_object *VirtualRouterResourceEcmpAlgorithmIpModuloObject
	if obj.IpModulo != nil {
		ipModulo_object = new(VirtualRouterResourceEcmpAlgorithmIpModuloObject)

		diags.Append(ipModulo_object.CopyFromPango(ctx, obj.IpModulo, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_object *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject
	if obj.WeightedRoundRobin != nil {
		weightedRoundRobin_object = new(VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject)

		diags.Append(weightedRoundRobin_object.CopyFromPango(ctx, obj.WeightedRoundRobin, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpHash = ipHash_object
	o.IpModulo = ipModulo_object
	o.WeightedRoundRobin = weightedRoundRobin_object

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpHash, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	o.HashSeed = hashSeed_value
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmIpModulo, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
		for _, elt := range obj.Interface {
			var entry VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
			entry_diags := entry.CopyFromPango(ctx, &elt, encrypted)
			diags.Append(entry_diags...)
			interface_tf_entries = append(interface_tf_entries, entry)
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (r *VirtualRouterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location virtual_router.Location

	if state.Location.Ngfw != nil {
		location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &virtual_router.TemplateLocation{

			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &virtual_router.TemplateStackLocation{

			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *virtual_router.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

func (o *VirtualRouterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location virtual_router.Location

	if savestate.Location.Ngfw != nil {
		location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: savestate.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.Template != nil {
		location.Template = &virtual_router.TemplateLocation{

			PanoramaDevice: savestate.Location.Template.PanoramaDevice.ValueString(),
			Template:       savestate.Location.Template.Name.ValueString(),
			NgfwDevice:     savestate.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if savestate.Location.TemplateStack != nil {
		location.TemplateStack = &virtual_router.TemplateStackLocation{

			NgfwDevice:     savestate.Location.TemplateStack.NgfwDevice.ValueString(),
			PanoramaDevice: savestate.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  savestate.Location.TemplateStack.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *VirtualRouterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location virtual_router.Location

	if state.Location.Template != nil {
		location.Template = &virtual_router.TemplateLocation{

			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &virtual_router.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Ngfw != nil {
		location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

func (r *VirtualRouterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location virtual_router.Location

	if state.Location.Ngfw != nil {
		location.Ngfw = &virtual_router.NgfwLocation{

			NgfwDevice: state.Location.Ngfw.NgfwDevice.ValueString(),
		}
	}
	if state.Location.Template != nil {
		location.Template = &virtual_router.TemplateLocation{

			PanoramaDevice: state.Location.Template.PanoramaDevice.ValueString(),
			Template:       state.Location.Template.Name.ValueString(),
			NgfwDevice:     state.Location.Template.NgfwDevice.ValueString(),
		}
	}
	if state.Location.TemplateStack != nil {
		location.TemplateStack = &virtual_router.TemplateStackLocation{

			PanoramaDevice: state.Location.TemplateStack.PanoramaDevice.ValueString(),
			TemplateStack:  state.Location.TemplateStack.Name.ValueString(),
			NgfwDevice:     state.Location.TemplateStack.NgfwDevice.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type VirtualRouterImportState struct {
	Location VirtualRouterLocation `json:"location"`
	Name     string                `json:"name"`
}

func VirtualRouterImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location VirtualRouterLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := VirtualRouterImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *VirtualRouterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj VirtualRouterImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type VirtualRouterNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterLocation struct {
	Ngfw          *VirtualRouterNgfwLocation          `tfsdk:"ngfw"`
	Template      *VirtualRouterTemplateLocation      `tfsdk:"template"`
	TemplateStack *VirtualRouterTemplateStackLocation `tfsdk:"template_stack"`
}

func VirtualRouterLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o VirtualRouterTemplateLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterTemplateStackLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
		NgfwDevice     *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterNgfwLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		NgfwDevice *string `json:"ngfw_device"`
	}{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Template      *VirtualRouterTemplateLocation      `json:"template"`
		TemplateStack *VirtualRouterTemplateStackLocation `json:"template_stack"`
		Ngfw          *VirtualRouterNgfwLocation          `json:"ngfw"`
	}{
		Template:      o.Template,
		TemplateStack: o.TemplateStack,
		Ngfw:          o.Ngfw,
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Template      *VirtualRouterTemplateLocation      `json:"template"`
		TemplateStack *VirtualRouterTemplateStackLocation `json:"template_stack"`
		Ngfw          *VirtualRouterNgfwLocation          `json:"ngfw"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Template = shadow.Template
	o.TemplateStack = shadow.TemplateStack
	o.Ngfw = shadow.Ngfw

	return nil
}
