package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/virtual_router"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &VirtualRouterDataSource{}
	_ datasource.DataSourceWithConfigure = &VirtualRouterDataSource{}
)

func NewVirtualRouterDataSource() datasource.DataSource {
	return &VirtualRouterDataSource{}
}

type VirtualRouterDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}

type VirtualRouterDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type VirtualRouterDataSourceModel struct {
	Location                types.Object `tfsdk:"location"`
	Name                    types.String `tfsdk:"name"`
	AdministrativeDistances types.Object `tfsdk:"administrative_distances"`
	Ecmp                    types.Object `tfsdk:"ecmp"`
	Interfaces              types.List   `tfsdk:"interfaces"`
	Multicast               types.Object `tfsdk:"multicast"`
	Protocol                types.Object `tfsdk:"protocol"`
}
type VirtualRouterDataSourceAdministrativeDistancesObject struct {
	Ebgp       types.Int64 `tfsdk:"ebgp"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Rip        types.Int64 `tfsdk:"rip"`
	Static     types.Int64 `tfsdk:"static"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
}
type VirtualRouterDataSourceEcmpObject struct {
	Algorithm        types.Object `tfsdk:"algorithm"`
	Enable           types.Bool   `tfsdk:"enable"`
	MaxPaths         types.Int64  `tfsdk:"max_paths"`
	StrictSourcePath types.Bool   `tfsdk:"strict_source_path"`
	SymmetricReturn  types.Bool   `tfsdk:"symmetric_return"`
}
type VirtualRouterDataSourceEcmpAlgorithmObject struct {
	BalancedRoundRobin types.Object `tfsdk:"balanced_round_robin"`
	IpHash             types.Object `tfsdk:"ip_hash"`
	IpModulo           types.Object `tfsdk:"ip_modulo"`
	WeightedRoundRobin types.Object `tfsdk:"weighted_round_robin"`
}
type VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterDataSourceEcmpAlgorithmIpHashObject struct {
	HashSeed types.Int64 `tfsdk:"hash_seed"`
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
}
type VirtualRouterDataSourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type VirtualRouterDataSourceMulticastObject struct {
	Enable          types.Bool   `tfsdk:"enable"`
	InterfaceGroup  types.List   `tfsdk:"interface_group"`
	RouteAgeoutTime types.Int64  `tfsdk:"route_ageout_time"`
	Rp              types.Object `tfsdk:"rp"`
	SptThreshold    types.List   `tfsdk:"spt_threshold"`
	SsmAddressSpace types.List   `tfsdk:"ssm_address_space"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupObject struct {
	Name            types.String `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	Interface       types.List   `tfsdk:"interface"`
	GroupPermission types.Object `tfsdk:"group_permission"`
	Igmp            types.Object `tfsdk:"igmp"`
	Pim             types.Object `tfsdk:"pim"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject struct {
	AnySourceMulticast      types.List `tfsdk:"any_source_multicast"`
	SourceSpecificMulticast types.List `tfsdk:"source_specific_multicast"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject struct {
	Name          types.String `tfsdk:"name"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
	Included      types.Bool   `tfsdk:"included"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject struct {
	Enable                  types.Bool    `tfsdk:"enable"`
	Version                 types.String  `tfsdk:"version"`
	MaxQueryResponseTime    types.Float64 `tfsdk:"max_query_response_time"`
	QueryInterval           types.Int64   `tfsdk:"query_interval"`
	LastMemberQueryInterval types.Float64 `tfsdk:"last_member_query_interval"`
	ImmediateLeave          types.Bool    `tfsdk:"immediate_leave"`
	Robustness              types.String  `tfsdk:"robustness"`
	MaxGroups               types.String  `tfsdk:"max_groups"`
	MaxSources              types.String  `tfsdk:"max_sources"`
	RouterAlertPolicing     types.Bool    `tfsdk:"router_alert_policing"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupPimObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	AssertInterval    types.Int64 `tfsdk:"assert_interval"`
	HelloInterval     types.Int64 `tfsdk:"hello_interval"`
	JoinPruneInterval types.Int64 `tfsdk:"join_prune_interval"`
	DrPriority        types.Int64 `tfsdk:"dr_priority"`
	BsrBorder         types.Bool  `tfsdk:"bsr_border"`
	AllowedNeighbors  types.List  `tfsdk:"allowed_neighbors"`
}
type VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceMulticastRpObject struct {
	ExternalRp types.List   `tfsdk:"external_rp"`
	LocalRp    types.Object `tfsdk:"local_rp"`
}
type VirtualRouterDataSourceMulticastRpExternalRpObject struct {
	Name           types.String `tfsdk:"name"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterDataSourceMulticastRpLocalRpObject struct {
	CandidateRp types.Object `tfsdk:"candidate_rp"`
	StaticRp    types.Object `tfsdk:"static_rp"`
}
type VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject struct {
	Address               types.String `tfsdk:"address"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupAddresses        types.List   `tfsdk:"group_addresses"`
	Interface             types.String `tfsdk:"interface"`
	Priority              types.Int64  `tfsdk:"priority"`
}
type VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject struct {
	Address        types.String `tfsdk:"address"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Interface      types.String `tfsdk:"interface"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterDataSourceMulticastSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type VirtualRouterDataSourceMulticastSsmAddressSpaceObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterDataSourceProtocolObject struct {
	Bgp               types.Object `tfsdk:"bgp"`
	Ospf              types.Object `tfsdk:"ospf"`
	Ospfv3            types.Object `tfsdk:"ospfv3"`
	RedistProfile     types.List   `tfsdk:"redist_profile"`
	RedistProfileIpv6 types.List   `tfsdk:"redist_profile_ipv6"`
	Rip               types.Object `tfsdk:"rip"`
}
type VirtualRouterDataSourceProtocolBgpObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	DampeningProfile        types.List   `tfsdk:"dampening_profile"`
	EcmpMultiAs             types.Bool   `tfsdk:"ecmp_multi_as"`
	Enable                  types.Bool   `tfsdk:"enable"`
	EnforceFirstAs          types.Bool   `tfsdk:"enforce_first_as"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	InstallRoute            types.Bool   `tfsdk:"install_route"`
	LocalAs                 types.String `tfsdk:"local_as"`
	PeerGroup               types.List   `tfsdk:"peer_group"`
	Policy                  types.Object `tfsdk:"policy"`
	RedistRules             types.List   `tfsdk:"redist_rules"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	RouterId                types.String `tfsdk:"router_id"`
	RoutingOptions          types.Object `tfsdk:"routing_options"`
}
type VirtualRouterDataSourceProtocolBgpAuthProfileObject struct {
	Name   types.String `tfsdk:"name"`
	Secret types.String `tfsdk:"secret"`
}
type VirtualRouterDataSourceProtocolBgpDampeningProfileObject struct {
	Name                     types.String  `tfsdk:"name"`
	Enable                   types.Bool    `tfsdk:"enable"`
	Cutoff                   types.Float64 `tfsdk:"cutoff"`
	Reuse                    types.Float64 `tfsdk:"reuse"`
	MaxHoldTime              types.Int64   `tfsdk:"max_hold_time"`
	DecayHalfLifeReachable   types.Int64   `tfsdk:"decay_half_life_reachable"`
	DecayHalfLifeUnreachable types.Int64   `tfsdk:"decay_half_life_unreachable"`
}
type VirtualRouterDataSourceProtocolBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupObject struct {
	Name                    types.String `tfsdk:"name"`
	Enable                  types.Bool   `tfsdk:"enable"`
	AggregatedConfedAsPath  types.Bool   `tfsdk:"aggregated_confed_as_path"`
	SoftResetWithStoredInfo types.Bool   `tfsdk:"soft_reset_with_stored_info"`
	Type                    types.Object `tfsdk:"type"`
	Peer                    types.List   `tfsdk:"peer"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject struct {
	Ibgp       types.Object `tfsdk:"ibgp"`
	EbgpConfed types.Object `tfsdk:"ebgp_confed"`
	IbgpConfed types.Object `tfsdk:"ibgp_confed"`
	Ebgp       types.Object `tfsdk:"ebgp"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject struct {
	ImportNexthop   types.String `tfsdk:"import_nexthop"`
	ExportNexthop   types.String `tfsdk:"export_nexthop"`
	RemovePrivateAs types.Bool   `tfsdk:"remove_private_as"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject struct {
	Name                              types.String `tfsdk:"name"`
	Enable                            types.Bool   `tfsdk:"enable"`
	PeerAs                            types.String `tfsdk:"peer_as"`
	EnableMpBgp                       types.Bool   `tfsdk:"enable_mp_bgp"`
	AddressFamilyIdentifier           types.String `tfsdk:"address_family_identifier"`
	EnableSenderSideLoopDetection     types.Bool   `tfsdk:"enable_sender_side_loop_detection"`
	ReflectorClient                   types.String `tfsdk:"reflector_client"`
	PeeringType                       types.String `tfsdk:"peering_type"`
	MaxPrefixes                       types.String `tfsdk:"max_prefixes"`
	SubsequentAddressFamilyIdentifier types.Object `tfsdk:"subsequent_address_family_identifier"`
	LocalAddress                      types.Object `tfsdk:"local_address"`
	PeerAddress                       types.Object `tfsdk:"peer_address"`
	ConnectionOptions                 types.Object `tfsdk:"connection_options"`
	Bfd                               types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject struct {
	Unicast   types.Bool `tfsdk:"unicast"`
	Multicast types.Bool `tfsdk:"multicast"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject struct {
	Authentication        types.String `tfsdk:"authentication"`
	KeepAliveInterval     types.String `tfsdk:"keep_alive_interval"`
	MinRouteAdvInterval   types.Int64  `tfsdk:"min_route_adv_interval"`
	Multihop              types.Int64  `tfsdk:"multihop"`
	OpenDelayTime         types.Int64  `tfsdk:"open_delay_time"`
	HoldTime              types.String `tfsdk:"hold_time"`
	IdleHoldTime          types.Int64  `tfsdk:"idle_hold_time"`
	IncomingBgpConnection types.Object `tfsdk:"incoming_bgp_connection"`
	OutgoingBgpConnection types.Object `tfsdk:"outgoing_bgp_connection"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject struct {
	RemotePort types.Int64 `tfsdk:"remote_port"`
	Allow      types.Bool  `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject struct {
	LocalPort types.Int64 `tfsdk:"local_port"`
	Allow     types.Bool  `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolBgpPolicyObject struct {
	Aggregation              types.Object `tfsdk:"aggregation"`
	ConditionalAdvertisement types.Object `tfsdk:"conditional_advertisement"`
	Export                   types.Object `tfsdk:"export"`
	Import                   types.Object `tfsdk:"import"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationObject struct {
	Address types.List `tfsdk:"address"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject struct {
	Name                     types.String `tfsdk:"name"`
	Prefix                   types.String `tfsdk:"prefix"`
	Enable                   types.Bool   `tfsdk:"enable"`
	Summary                  types.Bool   `tfsdk:"summary"`
	AsSet                    types.Bool   `tfsdk:"as_set"`
	AggregateRouteAttributes types.Object `tfsdk:"aggregate_route_attributes"`
	SuppressFilters          types.List   `tfsdk:"suppress_filters"`
	AdvertiseFilters         types.List   `tfsdk:"advertise_filters"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Weight            types.Int64  `tfsdk:"weight"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject struct {
	None    types.Object `tfsdk:"none"`
	Prepend types.Int64  `tfsdk:"prepend"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject struct {
	Policy types.List `tfsdk:"policy"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject struct {
	Name             types.String `tfsdk:"name"`
	Enable           types.Bool   `tfsdk:"enable"`
	UsedBy           types.List   `tfsdk:"used_by"`
	NonExistFilters  types.List   `tfsdk:"non_exist_filters"`
	AdvertiseFilters types.List   `tfsdk:"advertise_filters"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	UsedBy types.List   `tfsdk:"used_by"`
	Match  types.Object `tfsdk:"match"`
	Action types.Object `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject struct {
	Deny  types.Object `tfsdk:"deny"`
	Allow types.Object `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject struct {
	Update types.Object `tfsdk:"update"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject struct {
	None             types.Object `tfsdk:"none"`
	Remove           types.Object `tfsdk:"remove"`
	Prepend          types.Int64  `tfsdk:"prepend"`
	RemoveAndPrepend types.Int64  `tfsdk:"remove_and_prepend"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	UsedBy types.List   `tfsdk:"used_by"`
	Match  types.Object `tfsdk:"match"`
	Action types.Object `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject struct {
	Deny  types.Object `tfsdk:"deny"`
	Allow types.Object `tfsdk:"allow"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject struct {
	Dampening types.String `tfsdk:"dampening"`
	Update    types.Object `tfsdk:"update"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Weight            types.Int64  `tfsdk:"weight"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject struct {
	None   types.Object `tfsdk:"none"`
	Remove types.Object `tfsdk:"remove"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterDataSourceProtocolBgpRedistRulesObject struct {
	Name                    types.String `tfsdk:"name"`
	AddressFamilyIdentifier types.String `tfsdk:"address_family_identifier"`
	RouteTable              types.String `tfsdk:"route_table"`
	Enable                  types.Bool   `tfsdk:"enable"`
	SetOrigin               types.String `tfsdk:"set_origin"`
	SetMed                  types.Int64  `tfsdk:"set_med"`
	SetLocalPreference      types.Int64  `tfsdk:"set_local_preference"`
	SetAsPathLimit          types.Int64  `tfsdk:"set_as_path_limit"`
	Metric                  types.Int64  `tfsdk:"metric"`
	SetCommunity            types.List   `tfsdk:"set_community"`
	SetExtendedCommunity    types.List   `tfsdk:"set_extended_community"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsObject struct {
	Aggregate              types.Object `tfsdk:"aggregate"`
	AsFormat               types.String `tfsdk:"as_format"`
	ConfederationMemberAs  types.String `tfsdk:"confederation_member_as"`
	DefaultLocalPreference types.Int64  `tfsdk:"default_local_preference"`
	GracefulRestart        types.Object `tfsdk:"graceful_restart"`
	Med                    types.Object `tfsdk:"med"`
	ReflectorClusterId     types.String `tfsdk:"reflector_cluster_id"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject struct {
	AggregateMed types.Bool `tfsdk:"aggregate_med"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
}
type VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type VirtualRouterDataSourceProtocolOspfObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	Area                    types.List   `tfsdk:"area"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	GracefulRestart         types.Object `tfsdk:"graceful_restart"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	Rfc1583                 types.Bool   `tfsdk:"rfc1583"`
	RouterId                types.String `tfsdk:"router_id"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterDataSourceProtocolOspfAreaObject struct {
	Name        types.String `tfsdk:"name"`
	Type        types.Object `tfsdk:"type"`
	Range       types.List   `tfsdk:"range"`
	Interface   types.List   `tfsdk:"interface"`
	VirtualLink types.List   `tfsdk:"virtual_link"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
	NssaExtRange  types.List   `tfsdk:"nssa_ext_range"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceObject struct {
	Name               types.String `tfsdk:"name"`
	Enable             types.Bool   `tfsdk:"enable"`
	Passive            types.Bool   `tfsdk:"passive"`
	Metric             types.Int64  `tfsdk:"metric"`
	Priority           types.Int64  `tfsdk:"priority"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	GrDelay            types.Int64  `tfsdk:"gr_delay"`
	LinkType           types.Object `tfsdk:"link_type"`
	Neighbor           types.List   `tfsdk:"neighbor"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject struct {
	Name               types.String `tfsdk:"name"`
	NeighborId         types.String `tfsdk:"neighbor_id"`
	TransitAreaId      types.String `tfsdk:"transit_area_id"`
	Enable             types.Bool   `tfsdk:"enable"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterDataSourceProtocolOspfExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterDataSourceProtocolOspfTimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterDataSourceProtocolOspfv3Object struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	Area                    types.List   `tfsdk:"area"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	DisableTransitTraffic   types.Bool   `tfsdk:"disable_transit_traffic"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	GracefulRestart         types.Object `tfsdk:"graceful_restart"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	RouterId                types.String `tfsdk:"router_id"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
	NssaExtRange  types.List   `tfsdk:"nssa_ext_range"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject struct {
	Name               types.String `tfsdk:"name"`
	Enable             types.Bool   `tfsdk:"enable"`
	InstanceId         types.Int64  `tfsdk:"instance_id"`
	Passive            types.Bool   `tfsdk:"passive"`
	Metric             types.Int64  `tfsdk:"metric"`
	Priority           types.Int64  `tfsdk:"priority"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	GrDelay            types.Int64  `tfsdk:"gr_delay"`
	LinkType           types.Object `tfsdk:"link_type"`
	Neighbor           types.List   `tfsdk:"neighbor"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject struct {
	Name               types.String `tfsdk:"name"`
	NeighborId         types.String `tfsdk:"neighbor_id"`
	TransitAreaId      types.String `tfsdk:"transit_area_id"`
	Enable             types.Bool   `tfsdk:"enable"`
	InstanceId         types.Int64  `tfsdk:"instance_id"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileObject struct {
	Name types.String `tfsdk:"name"`
	Spi  types.String `tfsdk:"spi"`
	Esp  types.Object `tfsdk:"esp"`
	Ah   types.Object `tfsdk:"ah"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject struct {
	Authentication types.Object `tfsdk:"authentication"`
	Encryption     types.Object `tfsdk:"encryption"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
	None   types.Object `tfsdk:"none"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject struct {
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterDataSourceProtocolOspfv3ExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterDataSourceProtocolOspfv3TimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterDataSourceProtocolRedistProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
	Filter   types.Object `tfsdk:"filter"`
	Action   types.Object `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterObject struct {
	Type        types.List   `tfsdk:"type"`
	Interface   types.List   `tfsdk:"interface"`
	Destination types.List   `tfsdk:"destination"`
	Nexthop     types.List   `tfsdk:"nexthop"`
	Ospf        types.Object `tfsdk:"ospf"`
	Bgp         types.Object `tfsdk:"bgp"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolRedistProfileActionObject struct {
	NoRedist types.Object `tfsdk:"no_redist"`
	Redist   types.Object `tfsdk:"redist"`
}
type VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileActionRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6Object struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
	Filter   types.Object `tfsdk:"filter"`
	Action   types.Object `tfsdk:"action"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject struct {
	Type        types.List   `tfsdk:"type"`
	Interface   types.List   `tfsdk:"interface"`
	Destination types.List   `tfsdk:"destination"`
	Nexthop     types.List   `tfsdk:"nexthop"`
	Ospfv3      types.Object `tfsdk:"ospfv3"`
	Bgp         types.Object `tfsdk:"bgp"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject struct {
	NoRedist types.Object `tfsdk:"no_redist"`
	Redist   types.Object `tfsdk:"redist"`
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject struct {
}
type VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject struct {
}
type VirtualRouterDataSourceProtocolRipObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	Interfaces              types.List   `tfsdk:"interfaces"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterDataSourceProtocolRipAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterDataSourceProtocolRipAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterDataSourceProtocolRipExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Metric types.Int64  `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolRipInterfacesObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	Authentication types.String `tfsdk:"authentication"`
	Mode           types.String `tfsdk:"mode"`
	DefaultRoute   types.Object `tfsdk:"default_route"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject struct {
}
type VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterDataSourceProtocolRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterDataSourceProtocolRipTimersObject struct {
	DeleteIntervals types.Int64 `tfsdk:"delete_intervals"`
	ExpireIntervals types.Int64 `tfsdk:"expire_intervals"`
	IntervalSeconds types.Int64 `tfsdk:"interval_seconds"`
	UpdateIntervals types.Int64 `tfsdk:"update_intervals"`
}

func (o *VirtualRouterDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj VirtualRouterLocation

	var administrativeDistancesObj *VirtualRouterDataSourceAdministrativeDistancesObject

	var ecmpObj *VirtualRouterDataSourceEcmpObject

	var multicastObj *VirtualRouterDataSourceMulticastObject

	var protocolObj *VirtualRouterDataSourceProtocolObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.StringType,
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceModel) AncestorName() string {
	return ""
}

func (o VirtualRouterDataSourceModel) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ebgp":        types.Int64Type,
		"ibgp":        types.Int64Type,
		"ospf_ext":    types.Int64Type,
		"ospf_int":    types.Int64Type,
		"ospfv3_ext":  types.Int64Type,
		"ospfv3_int":  types.Int64Type,
		"rip":         types.Int64Type,
		"static":      types.Int64Type,
		"static_ipv6": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o VirtualRouterDataSourceAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *VirtualRouterDataSourceEcmpAlgorithmObject

	return map[string]attr.Type{
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"strict_source_path": types.BoolType,
		"symmetric_return":   types.BoolType,
	}
}

func (o VirtualRouterDataSourceEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o VirtualRouterDataSourceEcmpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var balancedRoundRobinObj *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject

	var ipHashObj *VirtualRouterDataSourceEcmpAlgorithmIpHashObject

	var ipModuloObj *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject

	var weightedRoundRobinObj *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject
	return map[string]attr.Type{
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o VirtualRouterDataSourceEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hash_seed": types.Int64Type,
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
	}
}

func (o VirtualRouterDataSourceEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o VirtualRouterDataSourceEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastObject) AttributeTypes() map[string]attr.Type {

	var interfaceGroupObj *VirtualRouterDataSourceMulticastInterfaceGroupObject

	var rpObj *VirtualRouterDataSourceMulticastRpObject

	var sptThresholdObj *VirtualRouterDataSourceMulticastSptThresholdObject

	var ssmAddressSpaceObj *VirtualRouterDataSourceMulticastSsmAddressSpaceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"interface_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceGroupObj.AttributeTypes(),
			},
		},
		"route_ageout_time": types.Int64Type,
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sptThresholdObj.AttributeTypes(),
			},
		},
		"ssm_address_space": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceMulticastObject) AncestorName() string {
	return "multicast"
}

func (o VirtualRouterDataSourceMulticastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) AttributeTypes() map[string]attr.Type {

	var groupPermissionObj *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject

	var igmpObj *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject

	var pimObj *VirtualRouterDataSourceMulticastInterfaceGroupPimObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"description": types.StringType,
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"group_permission": types.ObjectType{
			AttrTypes: groupPermissionObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupObject) AncestorName() string {
	return "interface-group"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) AttributeTypes() map[string]attr.Type {

	var anySourceMulticastObj *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject

	var sourceSpecificMulticastObj *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	return map[string]attr.Type{
		"any_source_multicast": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: anySourceMulticastObj.AttributeTypes(),
			},
		},
		"source_specific_multicast": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sourceSpecificMulticastObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) AncestorName() string {
	return "group-permission"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"group_address": types.StringType,
		"included":      types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) AncestorName() string {
	return "any-source-multicast"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
		"included":       types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) AncestorName() string {
	return "source-specific-multicast"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                     types.BoolType,
		"version":                    types.StringType,
		"max_query_response_time":    types.Float64Type,
		"query_interval":             types.Int64Type,
		"last_member_query_interval": types.Float64Type,
		"immediate_leave":            types.BoolType,
		"robustness":                 types.StringType,
		"max_groups":                 types.StringType,
		"max_sources":                types.StringType,
		"router_alert_policing":      types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) AncestorName() string {
	return "igmp"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) AttributeTypes() map[string]attr.Type {

	var allowedNeighborsObj *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
	return map[string]attr.Type{
		"enable":              types.BoolType,
		"assert_interval":     types.Int64Type,
		"hello_interval":      types.Int64Type,
		"join_prune_interval": types.Int64Type,
		"dr_priority":         types.Int64Type,
		"bsr_border":          types.BoolType,
		"allowed_neighbors": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: allowedNeighborsObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupPimObject) AncestorName() string {
	return "pim"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupPimObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) AncestorName() string {
	return "allowed-neighbors"
}

func (o VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastRpObject) AttributeTypes() map[string]attr.Type {

	var externalRpObj *VirtualRouterDataSourceMulticastRpExternalRpObject

	var localRpObj *VirtualRouterDataSourceMulticastRpLocalRpObject
	return map[string]attr.Type{
		"external_rp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: externalRpObj.AttributeTypes(),
			},
		},
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceMulticastRpObject) AncestorName() string {
	return "rp"
}

func (o VirtualRouterDataSourceMulticastRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"override": types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o VirtualRouterDataSourceMulticastRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var candidateRpObj *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject

	var staticRpObj *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject
	return map[string]attr.Type{
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceMulticastRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o VirtualRouterDataSourceMulticastRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"address":                types.StringType,
		"advertisement_interval": types.Int64Type,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.StringType,
		"priority":  types.Int64Type,
	}
}

func (o VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"address": types.StringType,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.StringType,
		"override":  types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceMulticastSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o VirtualRouterDataSourceMulticastSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o VirtualRouterDataSourceMulticastSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"group_address": types.StringType,
		"included":      types.BoolType,
	}
}

func (o VirtualRouterDataSourceMulticastSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o VirtualRouterDataSourceMulticastSsmAddressSpaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *VirtualRouterDataSourceProtocolBgpObject

	var ospfObj *VirtualRouterDataSourceProtocolOspfObject

	var ospfv3Obj *VirtualRouterDataSourceProtocolOspfv3Object

	var redistProfileObj *VirtualRouterDataSourceProtocolRedistProfileObject

	var redistProfileIpv6Obj *VirtualRouterDataSourceProtocolRedistProfileIpv6Object

	var ripObj *VirtualRouterDataSourceProtocolRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"redist_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistProfileObj.AttributeTypes(),
			},
		},
		"redist_profile_ipv6": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistProfileIpv6Obj.AttributeTypes(),
			},
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolObject) AncestorName() string {
	return "protocol"
}

func (o VirtualRouterDataSourceProtocolObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpObject) AttributeTypes() map[string]attr.Type {

	var authProfileObj *VirtualRouterDataSourceProtocolBgpAuthProfileObject

	var dampeningProfileObj *VirtualRouterDataSourceProtocolBgpDampeningProfileObject

	var globalBfdObj *VirtualRouterDataSourceProtocolBgpGlobalBfdObject

	var peerGroupObj *VirtualRouterDataSourceProtocolBgpPeerGroupObject

	var policyObj *VirtualRouterDataSourceProtocolBgpPolicyObject

	var redistRulesObj *VirtualRouterDataSourceProtocolBgpRedistRulesObject

	var routingOptionsObj *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"dampening_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: dampeningProfileObj.AttributeTypes(),
			},
		},
		"ecmp_multi_as":    types.BoolType,
		"enable":           types.BoolType,
		"enforce_first_as": types.BoolType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"install_route": types.BoolType,
		"local_as":      types.StringType,
		"peer_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerGroupObj.AttributeTypes(),
			},
		},
		"policy": types.ObjectType{
			AttrTypes: policyObj.AttributeTypes(),
		},
		"redist_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistRulesObj.AttributeTypes(),
			},
		},
		"reject_default_route": types.BoolType,
		"router_id":            types.StringType,
		"routing_options": types.ObjectType{
			AttrTypes: routingOptionsObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterDataSourceProtocolBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"secret": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterDataSourceProtocolBgpAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                        types.StringType,
		"enable":                      types.BoolType,
		"cutoff":                      types.Float64Type,
		"reuse":                       types.Float64Type,
		"max_hold_time":               types.Int64Type,
		"decay_half_life_reachable":   types.Int64Type,
		"decay_half_life_unreachable": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolBgpDampeningProfileObject) AncestorName() string {
	return "dampening-profile"
}

func (o VirtualRouterDataSourceProtocolBgpDampeningProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterDataSourceProtocolBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject

	var peerObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
	return map[string]attr.Type{
		"name":                        types.StringType,
		"enable":                      types.BoolType,
		"aggregated_confed_as_path":   types.BoolType,
		"soft_reset_with_stored_info": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject

	var ebgpConfedObj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject

	var ibgpConfedObj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject

	var ebgpObj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp_confed": types.ObjectType{
			AttrTypes: ebgpConfedObj.AttributeTypes(),
		},
		"ibgp_confed": types.ObjectType{
			AttrTypes: ibgpConfedObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) AncestorName() string {
	return "ebgp-confed"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) AncestorName() string {
	return "ibgp-confed"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_nexthop":    types.StringType,
		"export_nexthop":    types.StringType,
		"remove_private_as": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var subsequentAddressFamilyIdentifierObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject

	var localAddressObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"peer_as":                           types.StringType,
		"enable_mp_bgp":                     types.BoolType,
		"address_family_identifier":         types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"reflector_client":                  types.StringType,
		"peering_type":                      types.StringType,
		"max_prefixes":                      types.StringType,
		"subsequent_address_family_identifier": types.ObjectType{
			AttrTypes: subsequentAddressFamilyIdentifierObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) AncestorName() string {
	return "subsequent-address-family-identifier"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	var incomingBgpConnectionObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject

	var outgoingBgpConnectionObj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	return map[string]attr.Type{
		"authentication":         types.StringType,
		"keep_alive_interval":    types.StringType,
		"min_route_adv_interval": types.Int64Type,
		"multihop":               types.Int64Type,
		"open_delay_time":        types.Int64Type,
		"hold_time":              types.StringType,
		"idle_hold_time":         types.Int64Type,
		"incoming_bgp_connection": types.ObjectType{
			AttrTypes: incomingBgpConnectionObj.AttributeTypes(),
		},
		"outgoing_bgp_connection": types.ObjectType{
			AttrTypes: outgoingBgpConnectionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"remote_port": types.Int64Type,
		"allow":       types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) AncestorName() string {
	return "incoming-bgp-connection"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port": types.Int64Type,
		"allow":      types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) AncestorName() string {
	return "outgoing-bgp-connection"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) AttributeTypes() map[string]attr.Type {

	var aggregationObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject

	var conditionalAdvertisementObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject

	var exportObj *VirtualRouterDataSourceProtocolBgpPolicyExportObject

	var importObj *VirtualRouterDataSourceProtocolBgpPolicyImportObject
	return map[string]attr.Type{
		"aggregation": types.ObjectType{
			AttrTypes: aggregationObj.AttributeTypes(),
		},
		"conditional_advertisement": types.ObjectType{
			AttrTypes: conditionalAdvertisementObj.AttributeTypes(),
		},
		"export": types.ObjectType{
			AttrTypes: exportObj.AttributeTypes(),
		},
		"import": types.ObjectType{
			AttrTypes: importObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyObject) AncestorName() string {
	return "policy"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) AttributeTypes() map[string]attr.Type {

	var addressObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
	return map[string]attr.Type{
		"address": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) AncestorName() string {
	return "aggregation"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) AttributeTypes() map[string]attr.Type {

	var aggregateRouteAttributesObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject

	var suppressFiltersObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject

	var advertiseFiltersObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	return map[string]attr.Type{
		"name":    types.StringType,
		"prefix":  types.StringType,
		"enable":  types.BoolType,
		"summary": types.BoolType,
		"as_set":  types.BoolType,
		"aggregate_route_attributes": types.ObjectType{
			AttrTypes: aggregateRouteAttributesObj.AttributeTypes(),
		},
		"suppress_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suppressFiltersObj.AttributeTypes(),
			},
		},
		"advertise_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: advertiseFiltersObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) AncestorName() string {
	return "address"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"weight":           types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) AncestorName() string {
	return "aggregate-route-attributes"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"prepend": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) AncestorName() string {
	return "suppress-filters"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) AncestorName() string {
	return "advertise-filters"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) AttributeTypes() map[string]attr.Type {

	var policyObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	return map[string]attr.Type{
		"policy": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: policyObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) AncestorName() string {
	return "conditional-advertisement"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) AttributeTypes() map[string]attr.Type {

	var nonExistFiltersObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject

	var advertiseFiltersObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"non_exist_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nonExistFiltersObj.AttributeTypes(),
			},
		},
		"advertise_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: advertiseFiltersObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) AncestorName() string {
	return "policy"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) AncestorName() string {
	return "non-exist-filters"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) AncestorName() string {
	return "advertise-filters"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) AttributeTypes() map[string]attr.Type {

	var rulesObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
	return map[string]attr.Type{
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportObject) AncestorName() string {
	return "export"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject

	var actionObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) AncestorName() string {
	return "rules"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) AttributeTypes() map[string]attr.Type {

	var denyObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject

	var allowObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject
	return map[string]attr.Type{
		"deny": types.ObjectType{
			AttrTypes: denyObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) AncestorName() string {
	return "deny"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) AttributeTypes() map[string]attr.Type {

	var updateObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	return map[string]attr.Type{
		"update": types.ObjectType{
			AttrTypes: updateObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) AncestorName() string {
	return "update"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject

	var removeObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove": types.ObjectType{
			AttrTypes: removeObj.AttributeTypes(),
		},
		"prepend":            types.Int64Type,
		"remove_and_prepend": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) AncestorName() string {
	return "remove"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) AttributeTypes() map[string]attr.Type {

	var rulesObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
	return map[string]attr.Type{
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportObject) AncestorName() string {
	return "import"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject

	var actionObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) AncestorName() string {
	return "rules"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) AttributeTypes() map[string]attr.Type {

	var denyObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject

	var allowObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject
	return map[string]attr.Type{
		"deny": types.ObjectType{
			AttrTypes: denyObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) AncestorName() string {
	return "deny"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) AttributeTypes() map[string]attr.Type {

	var updateObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	return map[string]attr.Type{
		"dampening": types.StringType,
		"update": types.ObjectType{
			AttrTypes: updateObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject

	var communityObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject

	var extendedCommunityObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"weight":           types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) AncestorName() string {
	return "update"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject

	var removeObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove": types.ObjectType{
			AttrTypes: removeObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) AncestorName() string {
	return "remove"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                      types.StringType,
		"address_family_identifier": types.StringType,
		"route_table":               types.StringType,
		"enable":                    types.BoolType,
		"set_origin":                types.StringType,
		"set_med":                   types.Int64Type,
		"set_local_preference":      types.Int64Type,
		"set_as_path_limit":         types.Int64Type,
		"metric":                    types.Int64Type,
		"set_community": types.ListType{
			ElemType: types.StringType,
		},
		"set_extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolBgpRedistRulesObject) AncestorName() string {
	return "redist-rules"
}

func (o VirtualRouterDataSourceProtocolBgpRedistRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) AttributeTypes() map[string]attr.Type {

	var aggregateObj *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject

	var gracefulRestartObj *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject

	var medObj *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject

	return map[string]attr.Type{
		"aggregate": types.ObjectType{
			AttrTypes: aggregateObj.AttributeTypes(),
		},
		"as_format":                types.StringType,
		"confederation_member_as":  types.StringType,
		"default_local_preference": types.Int64Type,
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"reflector_cluster_id": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) AncestorName() string {
	return "routing-options"
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"aggregate_med": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) AncestorName() string {
	return "aggregate"
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"local_restart_time":    types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"stale_route_time":      types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) AncestorName() string {
	return "med"
}

func (o VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfObject) AttributeTypes() map[string]attr.Type {

	var areaObj *VirtualRouterDataSourceProtocolOspfAreaObject

	var authProfileObj *VirtualRouterDataSourceProtocolOspfAuthProfileObject

	var exportRulesObj *VirtualRouterDataSourceProtocolOspfExportRulesObject

	var globalBfdObj *VirtualRouterDataSourceProtocolOspfGlobalBfdObject

	var gracefulRestartObj *VirtualRouterDataSourceProtocolOspfGracefulRestartObject

	var timersObj *VirtualRouterDataSourceProtocolOspfTimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"reject_default_route": types.BoolType,
		"rfc1583":              types.BoolType,
		"router_id":            types.StringType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfObject) AncestorName() string {
	return "ospf"
}

func (o VirtualRouterDataSourceProtocolOspfObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterDataSourceProtocolOspfAreaTypeObject

	var rangeObj *VirtualRouterDataSourceProtocolOspfAreaRangeObject

	var interfaceObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject

	var virtualLinkObj *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
	return map[string]attr.Type{
		"name": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaObject) AncestorName() string {
	return "area"
}

func (o VirtualRouterDataSourceProtocolOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject

	var stubObj *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject

	var nssaObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject

	var advertiseObj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject

	var nssaExtRangeObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject

	var advertiseObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
		"type":   types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject

	var suppressObj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject

	var suppressObj *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject

	var neighborObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject

	var bfdObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable":              types.BoolType,
		"passive":             types.BoolType,
		"metric":              types.Int64Type,
		"priority":            types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"gr_delay":            types.Int64Type,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"neighbor_id":         types.StringType,
		"transit_area_id":     types.StringType,
		"enable":              types.BoolType,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
	return map[string]attr.Type{
		"name":     types.StringType,
		"password": types.StringType,
		"md5": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: md5Obj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterDataSourceProtocolOspfAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"key":       types.StringType,
		"preferred": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"new_path_type": types.StringType,
		"new_tag":       types.StringType,
		"metric":        types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterDataSourceProtocolOspfExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterDataSourceProtocolOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
		"strict_l_s_a_checking":     types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterDataSourceProtocolOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfTimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lsa_interval":          types.Float64Type,
		"spf_calculation_delay": types.Float64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfTimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterDataSourceProtocolOspfTimersObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3Object) AttributeTypes() map[string]attr.Type {

	var areaObj *VirtualRouterDataSourceProtocolOspfv3AreaObject

	var authProfileObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject

	var exportRulesObj *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject

	var globalBfdObj *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject

	var gracefulRestartObj *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject

	var timersObj *VirtualRouterDataSourceProtocolOspfv3TimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"disable_transit_traffic": types.BoolType,
		"enable":                  types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"reject_default_route": types.BoolType,
		"router_id":            types.StringType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o VirtualRouterDataSourceProtocolOspfv3Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject

	var rangeObj *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject

	var interfaceObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject

	var virtualLinkObj *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject

	var stubObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject

	var nssaObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject

	var advertiseObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject

	var nssaExtRangeObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject

	var advertiseObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
		"type":   types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject

	var suppressObj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject

	var suppressObj *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject

	var neighborObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject

	var bfdObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable":              types.BoolType,
		"instance_id":         types.Int64Type,
		"passive":             types.BoolType,
		"metric":              types.Int64Type,
		"priority":            types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"gr_delay":            types.Int64Type,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"neighbor_id":         types.StringType,
		"transit_area_id":     types.StringType,
		"enable":              types.BoolType,
		"instance_id":         types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) AttributeTypes() map[string]attr.Type {

	var espObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject

	var ahObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject
	return map[string]attr.Type{
		"name": types.StringType,
		"spi":  types.StringType,
		"esp": types.ObjectType{
			AttrTypes: espObj.AttributeTypes(),
		},
		"ah": types.ObjectType{
			AttrTypes: ahObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) AttributeTypes() map[string]attr.Type {

	var authenticationObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject

	var encryptionObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject
	return map[string]attr.Type{
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"encryption": types.ObjectType{
			AttrTypes: encryptionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) AncestorName() string {
	return "esp"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object

	var sha1Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object

	var sha256Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object

	var sha384Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object

	var sha512Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object

	var noneObj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) AncestorName() string {
	return "sha1"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) AncestorName() string {
	return "sha256"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) AncestorName() string {
	return "sha384"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) AncestorName() string {
	return "sha512"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"algorithm": types.StringType,
		"key":       types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) AncestorName() string {
	return "encryption"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object

	var sha1Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object

	var sha256Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object

	var sha384Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object

	var sha512Obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) AncestorName() string {
	return "ah"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) AncestorName() string {
	return "sha1"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) AncestorName() string {
	return "sha256"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) AncestorName() string {
	return "sha384"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) AncestorName() string {
	return "sha512"
}

func (o VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"new_path_type": types.StringType,
		"new_tag":       types.StringType,
		"metric":        types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
		"strict_l_s_a_checking":     types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lsa_interval":          types.Float64Type,
		"spf_calculation_delay": types.Float64Type,
	}
}

func (o VirtualRouterDataSourceProtocolOspfv3TimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterDataSourceProtocolOspfv3TimersObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileObject) AttributeTypes() map[string]attr.Type {

	var filterObj *VirtualRouterDataSourceProtocolRedistProfileFilterObject

	var actionObj *VirtualRouterDataSourceProtocolRedistProfileActionObject
	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
		"filter": types.ObjectType{
			AttrTypes: filterObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileObject) AncestorName() string {
	return "redist-profile"
}

func (o VirtualRouterDataSourceProtocolRedistProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) AttributeTypes() map[string]attr.Type {

	var ospfObj *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject

	var bgpObj *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject
	return map[string]attr.Type{
		"type": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"destination": types.ListType{
			ElemType: types.StringType,
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterObject) AncestorName() string {
	return "filter"
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"path_type": types.ListType{
			ElemType: types.StringType,
		},
		"area": types.ListType{
			ElemType: types.StringType,
		},
		"tag": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) AncestorName() string {
	return "ospf"
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"community": types.ListType{
			ElemType: types.StringType,
		},
		"extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) AttributeTypes() map[string]attr.Type {

	var noRedistObj *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject

	var redistObj *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject
	return map[string]attr.Type{
		"no_redist": types.ObjectType{
			AttrTypes: noRedistObj.AttributeTypes(),
		},
		"redist": types.ObjectType{
			AttrTypes: redistObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) AncestorName() string {
	return "no-redist"
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) AncestorName() string {
	return "redist"
}

func (o VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	var filterObj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject

	var actionObj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject
	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
		"filter": types.ObjectType{
			AttrTypes: filterObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6Object) AncestorName() string {
	return "redist-profile-ipv6"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) AttributeTypes() map[string]attr.Type {

	var ospfv3Obj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object

	var bgpObj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject
	return map[string]attr.Type{
		"type": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"destination": types.ListType{
			ElemType: types.StringType,
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) AncestorName() string {
	return "filter"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"path_type": types.ListType{
			ElemType: types.StringType,
		},
		"area": types.ListType{
			ElemType: types.StringType,
		},
		"tag": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"community": types.ListType{
			ElemType: types.StringType,
		},
		"extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) AttributeTypes() map[string]attr.Type {

	var noRedistObj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject

	var redistObj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject
	return map[string]attr.Type{
		"no_redist": types.ObjectType{
			AttrTypes: noRedistObj.AttributeTypes(),
		},
		"redist": types.ObjectType{
			AttrTypes: redistObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) AncestorName() string {
	return "no-redist"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) AncestorName() string {
	return "redist"
}

func (o VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipObject) AttributeTypes() map[string]attr.Type {

	var authProfileObj *VirtualRouterDataSourceProtocolRipAuthProfileObject

	var exportRulesObj *VirtualRouterDataSourceProtocolRipExportRulesObject

	var globalBfdObj *VirtualRouterDataSourceProtocolRipGlobalBfdObject

	var interfacesObj *VirtualRouterDataSourceProtocolRipInterfacesObject

	var timersObj *VirtualRouterDataSourceProtocolRipTimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfacesObj.AttributeTypes(),
			},
		},
		"reject_default_route": types.BoolType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRipObject) AncestorName() string {
	return "rip"
}

func (o VirtualRouterDataSourceProtocolRipObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
	return map[string]attr.Type{
		"name":     types.StringType,
		"password": types.StringType,
		"md5": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: md5Obj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterDataSourceProtocolRipAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterDataSourceProtocolRipAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"key":       types.StringType,
		"preferred": types.BoolType,
	}
}

func (o VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolRipExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterDataSourceProtocolRipExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterDataSourceProtocolRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject

	var bfdObj *VirtualRouterDataSourceProtocolRipInterfacesBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"authentication": types.StringType,
		"mode":           types.StringType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o VirtualRouterDataSourceProtocolRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject

	var advertiseObj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterDataSourceProtocolRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterDataSourceProtocolRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterDataSourceProtocolRipTimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"delete_intervals": types.Int64Type,
		"expire_intervals": types.Int64Type,
		"interval_seconds": types.Int64Type,
		"update_intervals": types.Int64Type,
	}
}

func (o VirtualRouterDataSourceProtocolRipTimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterDataSourceProtocolRipTimersObject) EntryName() *string {
	return nil
}

func (o *VirtualRouterDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var administrativeDistances_entry *virtual_router.AdminDists
	if !o.AdministrativeDistances.IsUnknown() && !o.AdministrativeDistances.IsNull() {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(virtual_router.AdminDists)
		}
		var object *VirtualRouterDataSourceAdministrativeDistancesObject
		diags.Append(o.AdministrativeDistances.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *virtual_router.Ecmp
	if !o.Ecmp.IsUnknown() && !o.Ecmp.IsNull() {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}
		var object *VirtualRouterDataSourceEcmpObject
		diags.Append(o.Ecmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_pango_entries []string
	if !o.Interfaces.IsUnknown() && !o.Interfaces.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interfaces.Elements()))
		diags.Append(o.Interfaces.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interfaces_pango_entries = append(interfaces_pango_entries, elt.ValueString())
		}
	}
	var multicast_entry *virtual_router.Multicast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.Multicast)
		}
		var object *VirtualRouterDataSourceMulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}
		var object *VirtualRouterDataSourceProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).Multicast = multicast_entry
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.AdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ebgp_value := o.Ebgp.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdminDists)
	}
	(*obj).Ebgp = ebgp_value
	(*obj).Ibgp = ibgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Rip = rip_value
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Ecmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if !o.Algorithm.IsUnknown() && !o.Algorithm.IsNull() {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}
		var object *VirtualRouterDataSourceEcmpAlgorithmObject
		diags.Append(o.Algorithm.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).SymmetricReturn = symmetricReturn_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if !o.BalancedRoundRobin.IsUnknown() && !o.BalancedRoundRobin.IsNull() {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}
		var object *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject
		diags.Append(o.BalancedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if !o.IpHash.IsUnknown() && !o.IpHash.IsNull() {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}
		var object *VirtualRouterDataSourceEcmpAlgorithmIpHashObject
		diags.Append(o.IpHash.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if !o.IpModulo.IsUnknown() && !o.IpModulo.IsNull() {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}
		var object *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject
		diags.Append(o.IpModulo.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if !o.WeightedRoundRobin.IsUnknown() && !o.WeightedRoundRobin.IsNull() {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}
		var object *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject
		diags.Append(o.WeightedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry
	(*obj).IpHash = ipHash_entry
	(*obj).IpModulo = ipModulo_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hashSeed_value := o.HashSeed.ValueInt64Pointer()
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).HashSeed = hashSeed_value
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var interfaceGroup_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupObject
	var interfaceGroup_pango_entries []virtual_router.MulticastInterfaceGroup
	{
		d := o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaceGroup_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaceGroup_pango_entries = append(interfaceGroup_pango_entries, *entry)
		}
	}
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	var rp_entry *virtual_router.MulticastRp
	if !o.Rp.IsUnknown() && !o.Rp.IsNull() {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(virtual_router.MulticastRp)
		}
		var object *VirtualRouterDataSourceMulticastRpObject
		diags.Append(o.Rp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []VirtualRouterDataSourceMulticastSptThresholdObject
	var sptThreshold_pango_entries []virtual_router.MulticastSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *virtual_router.MulticastSptThreshold
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var ssmAddressSpace_tf_entries []VirtualRouterDataSourceMulticastSsmAddressSpaceObject
	var ssmAddressSpace_pango_entries []virtual_router.MulticastSsmAddressSpace
	{
		d := o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ssmAddressSpace_tf_entries {
			var entry *virtual_router.MulticastSsmAddressSpace
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ssmAddressSpace_pango_entries = append(ssmAddressSpace_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Multicast)
	}
	(*obj).Enable = enable_value
	(*obj).InterfaceGroup = interfaceGroup_pango_entries
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).SsmAddressSpace = ssmAddressSpace_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var groupPermission_entry *virtual_router.MulticastInterfaceGroupGroupPermission
	if !o.GroupPermission.IsUnknown() && !o.GroupPermission.IsNull() {
		if *obj != nil && (*obj).GroupPermission != nil {
			groupPermission_entry = (*obj).GroupPermission
		} else {
			groupPermission_entry = new(virtual_router.MulticastInterfaceGroupGroupPermission)
		}
		var object *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject
		diags.Append(o.GroupPermission.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &groupPermission_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *virtual_router.MulticastInterfaceGroupIgmp
	if !o.Igmp.IsUnknown() && !o.Igmp.IsNull() {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(virtual_router.MulticastInterfaceGroupIgmp)
		}
		var object *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject
		diags.Append(o.Igmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pim_entry *virtual_router.MulticastInterfaceGroupPim
	if !o.Pim.IsUnknown() && !o.Pim.IsNull() {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(virtual_router.MulticastInterfaceGroupPim)
		}
		var object *VirtualRouterDataSourceMulticastInterfaceGroupPimObject
		diags.Append(o.Pim.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Interface = interface_pango_entries
	(*obj).GroupPermission = groupPermission_entry
	(*obj).Igmp = igmp_entry
	(*obj).Pim = pim_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermission, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
	var anySourceMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
	{
		d := o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range anySourceMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			anySourceMulticast_pango_entries = append(anySourceMulticast_pango_entries, *entry)
		}
	}
	var sourceSpecificMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	var sourceSpecificMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
	{
		d := o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sourceSpecificMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sourceSpecificMulticast_pango_entries = append(sourceSpecificMulticast_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermission)
	}
	(*obj).AnySourceMulticast = anySourceMulticast_pango_entries
	(*obj).SourceSpecificMulticast = sourceSpecificMulticast_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	version_value := o.Version.ValueStringPointer()
	maxQueryResponseTime_value := o.MaxQueryResponseTime.ValueFloat64Pointer()
	queryInterval_value := o.QueryInterval.ValueInt64Pointer()
	lastMemberQueryInterval_value := o.LastMemberQueryInterval.ValueFloat64Pointer()
	immediateLeave_value := o.ImmediateLeave.ValueBoolPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Version = version_value
	(*obj).MaxQueryResponseTime = maxQueryResponseTime_value
	(*obj).QueryInterval = queryInterval_value
	(*obj).LastMemberQueryInterval = lastMemberQueryInterval_value
	(*obj).ImmediateLeave = immediateLeave_value
	(*obj).Robustness = robustness_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	assertInterval_value := o.AssertInterval.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	joinPruneInterval_value := o.JoinPruneInterval.ValueInt64Pointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	bsrBorder_value := o.BsrBorder.ValueBoolPointer()
	var allowedNeighbors_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
	var allowedNeighbors_pango_entries []virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
	{
		d := o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range allowedNeighbors_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			allowedNeighbors_pango_entries = append(allowedNeighbors_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPim)
	}
	(*obj).Enable = enable_value
	(*obj).AssertInterval = assertInterval_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).JoinPruneInterval = joinPruneInterval_value
	(*obj).DrPriority = drPriority_value
	(*obj).BsrBorder = bsrBorder_value
	(*obj).AllowedNeighbors = allowedNeighbors_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPimAllowedNeighbors)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_tf_entries []VirtualRouterDataSourceMulticastRpExternalRpObject
	var externalRp_pango_entries []virtual_router.MulticastRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *virtual_router.MulticastRpExternalRp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}
	var localRp_entry *virtual_router.MulticastRpLocalRp
	if !o.LocalRp.IsUnknown() && !o.LocalRp.IsNull() {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(virtual_router.MulticastRpLocalRp)
		}
		var object *VirtualRouterDataSourceMulticastRpLocalRpObject
		diags.Append(o.LocalRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRp)
	}
	(*obj).ExternalRp = externalRp_pango_entries
	(*obj).LocalRp = localRp_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_entry *virtual_router.MulticastRpLocalRpCandidateRp
	if !o.CandidateRp.IsUnknown() && !o.CandidateRp.IsNull() {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(virtual_router.MulticastRpLocalRpCandidateRp)
		}
		var object *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject
		diags.Append(o.CandidateRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_entry *virtual_router.MulticastRpLocalRpStaticRp
	if !o.StaticRp.IsUnknown() && !o.StaticRp.IsNull() {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(virtual_router.MulticastRpLocalRpStaticRp)
		}
		var object *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject
		diags.Append(o.StaticRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRp)
	}
	(*obj).CandidateRp = candidateRp_entry
	(*obj).StaticRp = staticRp_entry

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	interface_value := o.Interface.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpCandidateRp)
	}
	(*obj).Address = address_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Priority = priority_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	interface_value := o.Interface.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpStaticRp)
	}
	(*obj).Address = address_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastSptThresholdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSsmAddressSpace)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *virtual_router.ProtocolBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}
		var object *VirtualRouterDataSourceProtocolBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *virtual_router.ProtocolOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}
		var object *VirtualRouterDataSourceProtocolOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistProfile_tf_entries []VirtualRouterDataSourceProtocolRedistProfileObject
	var redistProfile_pango_entries []virtual_router.ProtocolRedistProfile
	{
		d := o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfile_tf_entries {
			var entry *virtual_router.ProtocolRedistProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistProfile_pango_entries = append(redistProfile_pango_entries, *entry)
		}
	}
	var redistProfileIpv6_tf_entries []VirtualRouterDataSourceProtocolRedistProfileIpv6Object
	var redistProfileIpv6_pango_entries []virtual_router.ProtocolRedistProfileIpv6
	{
		d := o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfileIpv6_tf_entries {
			var entry *virtual_router.ProtocolRedistProfileIpv6
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistProfileIpv6_pango_entries = append(redistProfileIpv6_pango_entries, *entry)
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}
		var object *VirtualRouterDataSourceProtocolRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).RedistProfile = redistProfile_pango_entries
	(*obj).RedistProfileIpv6 = redistProfileIpv6_pango_entries
	(*obj).Rip = rip_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolBgpAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolBgpAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var dampeningProfile_tf_entries []VirtualRouterDataSourceProtocolBgpDampeningProfileObject
	var dampeningProfile_pango_entries []virtual_router.ProtocolBgpDampeningProfile
	{
		d := o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range dampeningProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpDampeningProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			dampeningProfile_pango_entries = append(dampeningProfile_pango_entries, *entry)
		}
	}
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	var globalBfd_entry *virtual_router.ProtocolBgpGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolBgpGlobalBfd)
		}
		var object *VirtualRouterDataSourceProtocolBgpGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	var peerGroup_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupObject
	var peerGroup_pango_entries []virtual_router.ProtocolBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var policy_entry *virtual_router.ProtocolBgpPolicy
	if !o.Policy.IsUnknown() && !o.Policy.IsNull() {
		if *obj != nil && (*obj).Policy != nil {
			policy_entry = (*obj).Policy
		} else {
			policy_entry = new(virtual_router.ProtocolBgpPolicy)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyObject
		diags.Append(o.Policy.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &policy_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistRules_tf_entries []VirtualRouterDataSourceProtocolBgpRedistRulesObject
	var redistRules_pango_entries []virtual_router.ProtocolBgpRedistRules
	{
		d := o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistRules_tf_entries {
			var entry *virtual_router.ProtocolBgpRedistRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistRules_pango_entries = append(redistRules_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var routingOptions_entry *virtual_router.ProtocolBgpRoutingOptions
	if !o.RoutingOptions.IsUnknown() && !o.RoutingOptions.IsNull() {
		if *obj != nil && (*obj).RoutingOptions != nil {
			routingOptions_entry = (*obj).RoutingOptions
		} else {
			routingOptions_entry = new(virtual_router.ProtocolBgpRoutingOptions)
		}
		var object *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject
		diags.Append(o.RoutingOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routingOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).DampeningProfile = dampeningProfile_pango_entries
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).Enable = enable_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).InstallRoute = installRoute_value
	(*obj).LocalAs = localAs_value
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).Policy = policy_entry
	(*obj).RedistRules = redistRules_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value
	(*obj).RoutingOptions = routingOptions_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	secret_value := o.Secret.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Secret = secret_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpDampeningProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	cutoff_value := o.Cutoff.ValueFloat64Pointer()
	reuse_value := o.Reuse.ValueFloat64Pointer()
	maxHoldTime_value := o.MaxHoldTime.ValueInt64Pointer()
	decayHalfLifeReachable_value := o.DecayHalfLifeReachable.ValueInt64Pointer()
	decayHalfLifeUnreachable_value := o.DecayHalfLifeUnreachable.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpDampeningProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Cutoff = cutoff_value
	(*obj).Reuse = reuse_value
	(*obj).MaxHoldTime = maxHoldTime_value
	(*obj).DecayHalfLifeReachable = decayHalfLifeReachable_value
	(*obj).DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	aggregatedConfedAsPath_value := o.AggregatedConfedAsPath.ValueBoolPointer()
	softResetWithStoredInfo_value := o.SoftResetWithStoredInfo.ValueBoolPointer()
	var type_entry *virtual_router.ProtocolBgpPeerGroupType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolBgpPeerGroupType)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
	var peer_pango_entries []virtual_router.ProtocolBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).AggregatedConfedAsPath = aggregatedConfedAsPath_value
	(*obj).SoftResetWithStoredInfo = softResetWithStoredInfo_value
	(*obj).Type = type_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgp
	if !o.Ibgp.IsUnknown() && !o.Ibgp.IsNull() {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject
		diags.Append(o.Ibgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed
	if !o.EbgpConfed.IsUnknown() && !o.EbgpConfed.IsNull() {
		if *obj != nil && (*obj).EbgpConfed != nil {
			ebgpConfed_entry = (*obj).EbgpConfed
		} else {
			ebgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject
		diags.Append(o.EbgpConfed.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgpConfed_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed
	if !o.IbgpConfed.IsUnknown() && !o.IbgpConfed.IsNull() {
		if *obj != nil && (*obj).IbgpConfed != nil {
			ibgpConfed_entry = (*obj).IbgpConfed
		} else {
			ibgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject
		diags.Append(o.IbgpConfed.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgpConfed_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgp
	if !o.Ebgp.IsUnknown() && !o.Ebgp.IsNull() {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject
		diags.Append(o.Ebgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).EbgpConfed = ebgpConfed_entry
	(*obj).IbgpConfed = ibgpConfed_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importNexthop_value := o.ImportNexthop.ValueStringPointer()
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()
	removePrivateAs_value := o.RemovePrivateAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
	}
	(*obj).ImportNexthop = importNexthop_value
	(*obj).ExportNexthop = exportNexthop_value
	(*obj).RemovePrivateAs = removePrivateAs_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableMpBgp_value := o.EnableMpBgp.ValueBoolPointer()
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	reflectorClient_value := o.ReflectorClient.ValueStringPointer()
	peeringType_value := o.PeeringType.ValueStringPointer()
	maxPrefixes_value := o.MaxPrefixes.ValueStringPointer()
	var subsequentAddressFamilyIdentifier_entry *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier
	if !o.SubsequentAddressFamilyIdentifier.IsUnknown() && !o.SubsequentAddressFamilyIdentifier.IsNull() {
		if *obj != nil && (*obj).SubsequentAddressFamilyIdentifier != nil {
			subsequentAddressFamilyIdentifier_entry = (*obj).SubsequentAddressFamilyIdentifier
		} else {
			subsequentAddressFamilyIdentifier_entry = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
		diags.Append(o.SubsequentAddressFamilyIdentifier.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &subsequentAddressFamilyIdentifier_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolBgpPeerGroupPeerBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableMpBgp = enableMpBgp_value
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).ReflectorClient = reflectorClient_value
	(*obj).PeeringType = peeringType_value
	(*obj).MaxPrefixes = maxPrefixes_value
	(*obj).SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
	}
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueStringPointer()
	minRouteAdvInterval_value := o.MinRouteAdvInterval.ValueInt64Pointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	openDelayTime_value := o.OpenDelayTime.ValueInt64Pointer()
	holdTime_value := o.HoldTime.ValueStringPointer()
	idleHoldTime_value := o.IdleHoldTime.ValueInt64Pointer()
	var incomingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection
	if !o.IncomingBgpConnection.IsUnknown() && !o.IncomingBgpConnection.IsNull() {
		if *obj != nil && (*obj).IncomingBgpConnection != nil {
			incomingBgpConnection_entry = (*obj).IncomingBgpConnection
		} else {
			incomingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
		diags.Append(o.IncomingBgpConnection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &incomingBgpConnection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var outgoingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection
	if !o.OutgoingBgpConnection.IsUnknown() && !o.OutgoingBgpConnection.IsNull() {
		if *obj != nil && (*obj).OutgoingBgpConnection != nil {
			outgoingBgpConnection_entry = (*obj).OutgoingBgpConnection
		} else {
			outgoingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
		}
		var object *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
		diags.Append(o.OutgoingBgpConnection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &outgoingBgpConnection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Authentication = authentication_value
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).MinRouteAdvInterval = minRouteAdvInterval_value
	(*obj).Multihop = multihop_value
	(*obj).OpenDelayTime = openDelayTime_value
	(*obj).HoldTime = holdTime_value
	(*obj).IdleHoldTime = idleHoldTime_value
	(*obj).IncomingBgpConnection = incomingBgpConnection_entry
	(*obj).OutgoingBgpConnection = outgoingBgpConnection_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
	}
	(*obj).LocalPort = localPort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregation_entry *virtual_router.ProtocolBgpPolicyAggregation
	if !o.Aggregation.IsUnknown() && !o.Aggregation.IsNull() {
		if *obj != nil && (*obj).Aggregation != nil {
			aggregation_entry = (*obj).Aggregation
		} else {
			aggregation_entry = new(virtual_router.ProtocolBgpPolicyAggregation)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject
		diags.Append(o.Aggregation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var conditionalAdvertisement_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisement
	if !o.ConditionalAdvertisement.IsUnknown() && !o.ConditionalAdvertisement.IsNull() {
		if *obj != nil && (*obj).ConditionalAdvertisement != nil {
			conditionalAdvertisement_entry = (*obj).ConditionalAdvertisement
		} else {
			conditionalAdvertisement_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject
		diags.Append(o.ConditionalAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &conditionalAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_entry *virtual_router.ProtocolBgpPolicyExport
	if !o.Export.IsUnknown() && !o.Export.IsNull() {
		if *obj != nil && (*obj).Export != nil {
			export_entry = (*obj).Export
		} else {
			export_entry = new(virtual_router.ProtocolBgpPolicyExport)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportObject
		diags.Append(o.Export.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &export_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var import_entry *virtual_router.ProtocolBgpPolicyImport
	if !o.Import.IsUnknown() && !o.Import.IsNull() {
		if *obj != nil && (*obj).Import != nil {
			import_entry = (*obj).Import
		} else {
			import_entry = new(virtual_router.ProtocolBgpPolicyImport)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportObject
		diags.Append(o.Import.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &import_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicy)
	}
	(*obj).Aggregation = aggregation_entry
	(*obj).ConditionalAdvertisement = conditionalAdvertisement_entry
	(*obj).Export = export_entry
	(*obj).Import = import_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
	var address_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddress
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregation)
	}
	(*obj).Address = address_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefix_value := o.Prefix.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summary_value := o.Summary.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	var aggregateRouteAttributes_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes
	if !o.AggregateRouteAttributes.IsUnknown() && !o.AggregateRouteAttributes.IsNull() {
		if *obj != nil && (*obj).AggregateRouteAttributes != nil {
			aggregateRouteAttributes_entry = (*obj).AggregateRouteAttributes
		} else {
			aggregateRouteAttributes_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
		diags.Append(o.AggregateRouteAttributes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregateRouteAttributes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppressFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
	var suppressFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
	{
		d := o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suppressFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suppressFilters_pango_entries = append(suppressFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Prefix = prefix_value
	(*obj).Enable = enable_value
	(*obj).Summary = summary_value
	(*obj).AsSet = asSet_value
	(*obj).AggregateRouteAttributes = aggregateRouteAttributes_entry
	(*obj).SuppressFilters = suppressFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Weight = weight_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
	}
	(*obj).None = none_entry
	(*obj).Prepend = prepend_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	var policy_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
	{
		d := o.Policy.ElementsAs(ctx, &policy_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range policy_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			policy_pango_entries = append(policy_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
	}
	(*obj).Policy = policy_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var nonExistFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
	var nonExistFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
	{
		d := o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nonExistFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nonExistFilters_pango_entries = append(nonExistFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).NonExistFilters = nonExistFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyExportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var match_entry *virtual_router.ProtocolBgpPolicyExportRulesMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyExportRulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyExportRulesActionDeny
	if !o.Deny.IsUnknown() && !o.Deny.IsNull() {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject
		diags.Append(o.Deny.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &deny_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate
	if !o.Update.IsUnknown() && !o.Update.IsNull() {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
		diags.Append(o.Update.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &update_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
	}
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove
	if !o.Remove.IsUnknown() && !o.Remove.IsNull() {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
		diags.Append(o.Remove.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &remove_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()
	removeAndPrepend_value := o.RemoveAndPrepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry
	(*obj).Prepend = prepend_value
	(*obj).RemoveAndPrepend = removeAndPrepend_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyImportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var match_entry *virtual_router.ProtocolBgpPolicyImportRulesMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyImportRulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyImportRulesActionDeny
	if !o.Deny.IsUnknown() && !o.Deny.IsNull() {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject
		diags.Append(o.Deny.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &deny_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dampening_value := o.Dampening.ValueStringPointer()
	var update_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate
	if !o.Update.IsUnknown() && !o.Update.IsNull() {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
		diags.Append(o.Update.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &update_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
	}
	(*obj).Dampening = dampening_value
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Weight = weight_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove
	if !o.Remove.IsUnknown() && !o.Remove.IsNull() {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
		diags.Append(o.Remove.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &remove_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRedistRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	setOrigin_value := o.SetOrigin.ValueStringPointer()
	setMed_value := o.SetMed.ValueInt64Pointer()
	setLocalPreference_value := o.SetLocalPreference.ValueInt64Pointer()
	setAsPathLimit_value := o.SetAsPathLimit.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var setCommunity_pango_entries []string
	if !o.SetCommunity.IsUnknown() && !o.SetCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.SetCommunity.Elements()))
		diags.Append(o.SetCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			setCommunity_pango_entries = append(setCommunity_pango_entries, elt.ValueString())
		}
	}
	var setExtendedCommunity_pango_entries []string
	if !o.SetExtendedCommunity.IsUnknown() && !o.SetExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.SetExtendedCommunity.Elements()))
		diags.Append(o.SetExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			setExtendedCommunity_pango_entries = append(setExtendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRedistRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).RouteTable = routeTable_value
	(*obj).Enable = enable_value
	(*obj).SetOrigin = setOrigin_value
	(*obj).SetMed = setMed_value
	(*obj).SetLocalPreference = setLocalPreference_value
	(*obj).SetAsPathLimit = setAsPathLimit_value
	(*obj).Metric = metric_value
	(*obj).SetCommunity = setCommunity_pango_entries
	(*obj).SetExtendedCommunity = setExtendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregate_entry *virtual_router.ProtocolBgpRoutingOptionsAggregate
	if !o.Aggregate.IsUnknown() && !o.Aggregate.IsNull() {
		if *obj != nil && (*obj).Aggregate != nil {
			aggregate_entry = (*obj).Aggregate
		} else {
			aggregate_entry = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
		}
		var object *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject
		diags.Append(o.Aggregate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asFormat_value := o.AsFormat.ValueStringPointer()
	confederationMemberAs_value := o.ConfederationMemberAs.ValueStringPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	var gracefulRestart_entry *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
		}
		var object *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_entry *virtual_router.ProtocolBgpRoutingOptionsMed
	if !o.Med.IsUnknown() && !o.Med.IsNull() {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(virtual_router.ProtocolBgpRoutingOptionsMed)
		}
		var object *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject
		diags.Append(o.Med.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	reflectorClusterId_value := o.ReflectorClusterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptions)
	}
	(*obj).Aggregate = aggregate_entry
	(*obj).AsFormat = asFormat_value
	(*obj).ConfederationMemberAs = confederationMemberAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Med = med_entry
	(*obj).ReflectorClusterId = reflectorClusterId_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsAggregate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	aggregateMed_value := o.AggregateMed.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
	}
	(*obj).AggregateMed = aggregateMed_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).LocalRestartTime = localRestartTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).StaleRouteTime = staleRouteTime_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var area_tf_entries []VirtualRouterDataSourceProtocolOspfAreaObject
	var area_pango_entries []virtual_router.ProtocolOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfArea
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfGlobalBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfGracefulRestart)
		}
		var object *VirtualRouterDataSourceProtocolOspfGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var timers_entry *virtual_router.ProtocolOspfTimers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfTimers)
		}
		var object *VirtualRouterDataSourceProtocolOspfTimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).RouterId = routerId_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *virtual_router.ProtocolOspfAreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfAreaType)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterDataSourceProtocolOspfAreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfAreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfAreaTypeNormal)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfAreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfAreaTypeStub)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfAreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfAreaTypeNssa)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaRangeSuppress)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	priority_value := o.Priority.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfAreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfAreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfAreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).Priority = priority_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfAreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolOspfAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfTimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfTimers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var area_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaObject
	var area_pango_entries []virtual_router.ProtocolOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfv3Area
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfv3AuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfv3AuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfv3ExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfv3ExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfv3ExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfv3GlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfv3GlobalBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfv3GracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfv3GracefulRestart)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var timers_entry *virtual_router.ProtocolOspfv3Timers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfv3Timers)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3TimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *virtual_router.ProtocolOspfv3AreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfv3AreaType)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfv3AreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfv3AreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfv3AreaTypeStub)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfv3AreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	priority_value := o.Priority.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfv3AreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).Priority = priority_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	spi_value := o.Spi.ValueStringPointer()
	var esp_entry *virtual_router.ProtocolOspfv3AuthProfileEsp
	if !o.Esp.IsUnknown() && !o.Esp.IsNull() {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject
		diags.Append(o.Esp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &esp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_entry *virtual_router.ProtocolOspfv3AuthProfileAh
	if !o.Ah.IsUnknown() && !o.Ah.IsNull() {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(virtual_router.ProtocolOspfv3AuthProfileAh)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject
		diags.Append(o.Ah.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ah_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Spi = spi_value
	(*obj).Esp = esp_entry
	(*obj).Ah = ah_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *virtual_router.ProtocolOspfv3AuthProfileEspEncryption
	if !o.Encryption.IsUnknown() && !o.Encryption.IsNull() {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject
		diags.Append(o.Encryption.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &encryption_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileAhMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
		}
		var object *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3ExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3ExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3Timers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Timers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileFilter
	if !o.Filter.IsUnknown() && !o.Filter.IsNull() {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileFilter)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileFilterObject
		diags.Append(o.Filter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileAction)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_pango_entries []string
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		object_entries := make([]types.String, 0, len(o.Type.Elements()))
		diags.Append(o.Type.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			type_pango_entries = append(type_pango_entries, elt.ValueString())
		}
	}
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var destination_pango_entries []string
	if !o.Destination.IsUnknown() && !o.Destination.IsNull() {
		object_entries := make([]types.String, 0, len(o.Destination.Elements()))
		diags.Append(o.Destination.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			destination_pango_entries = append(destination_pango_entries, elt.ValueString())
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var ospf_entry *virtual_router.ProtocolRedistProfileFilterOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolRedistProfileFilterOspf)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileFilterBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileFilterBgp)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospf = ospf_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilterOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_pango_entries []string
	if !o.PathType.IsUnknown() && !o.PathType.IsNull() {
		object_entries := make([]types.String, 0, len(o.PathType.Elements()))
		diags.Append(o.PathType.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			pathType_pango_entries = append(pathType_pango_entries, elt.ValueString())
		}
	}
	var area_pango_entries []string
	if !o.Area.IsUnknown() && !o.Area.IsNull() {
		object_entries := make([]types.String, 0, len(o.Area.Elements()))
		diags.Append(o.Area.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			area_pango_entries = append(area_pango_entries, elt.ValueString())
		}
	}
	var tag_pango_entries []string
	if !o.Tag.IsUnknown() && !o.Tag.IsNull() {
		object_entries := make([]types.String, 0, len(o.Tag.Elements()))
		diags.Append(o.Tag.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			tag_pango_entries = append(tag_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterOspf)
	}
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_pango_entries []string
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		object_entries := make([]types.String, 0, len(o.Community.Elements()))
		diags.Append(o.Community.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			community_pango_entries = append(community_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunity_pango_entries []string
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunity.Elements()))
		diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunity_pango_entries = append(extendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileActionNoRedist
	if !o.NoRedist.IsUnknown() && !o.NoRedist.IsNull() {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileActionNoRedist)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject
		diags.Append(o.NoRedist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &noRedist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileActionRedist
	if !o.Redist.IsUnknown() && !o.Redist.IsNull() {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileActionRedist)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject
		diags.Append(o.Redist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileAction)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileIpv6Filter
	if !o.Filter.IsUnknown() && !o.Filter.IsNull() {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileIpv6Filter)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject
		diags.Append(o.Filter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileIpv6Action
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileIpv6Action)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6Filter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_pango_entries []string
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		object_entries := make([]types.String, 0, len(o.Type.Elements()))
		diags.Append(o.Type.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			type_pango_entries = append(type_pango_entries, elt.ValueString())
		}
	}
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var destination_pango_entries []string
	if !o.Destination.IsUnknown() && !o.Destination.IsNull() {
		object_entries := make([]types.String, 0, len(o.Destination.Elements()))
		diags.Append(o.Destination.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			destination_pango_entries = append(destination_pango_entries, elt.ValueString())
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var ospfv3_entry *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileIpv6FilterBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Filter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_pango_entries []string
	if !o.PathType.IsUnknown() && !o.PathType.IsNull() {
		object_entries := make([]types.String, 0, len(o.PathType.Elements()))
		diags.Append(o.PathType.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			pathType_pango_entries = append(pathType_pango_entries, elt.ValueString())
		}
	}
	var area_pango_entries []string
	if !o.Area.IsUnknown() && !o.Area.IsNull() {
		object_entries := make([]types.String, 0, len(o.Area.Elements()))
		diags.Append(o.Area.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			area_pango_entries = append(area_pango_entries, elt.ValueString())
		}
	}
	var tag_pango_entries []string
	if !o.Tag.IsUnknown() && !o.Tag.IsNull() {
		object_entries := make([]types.String, 0, len(o.Tag.Elements()))
		diags.Append(o.Tag.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			tag_pango_entries = append(tag_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
	}
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6FilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_pango_entries []string
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		object_entries := make([]types.String, 0, len(o.Community.Elements()))
		diags.Append(o.Community.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			community_pango_entries = append(community_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunity_pango_entries []string
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunity.Elements()))
		diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunity_pango_entries = append(extendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6Action, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist
	if !o.NoRedist.IsUnknown() && !o.NoRedist.IsNull() {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject
		diags.Append(o.NoRedist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &noRedist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileIpv6ActionRedist
	if !o.Redist.IsUnknown() && !o.Redist.IsNull() {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
		}
		var object *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject
		diags.Append(o.Redist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Action)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6ActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolRipAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterDataSourceProtocolRipExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolRipExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolRipExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolRipGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolRipGlobalBfd)
		}
		var object *VirtualRouterDataSourceProtocolRipGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []VirtualRouterDataSourceProtocolRipInterfacesObject
	var interfaces_pango_entries []virtual_router.ProtocolRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.ProtocolRipInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolRipTimers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolRipTimers)
		}
		var object *VirtualRouterDataSourceProtocolRipTimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolRipAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	mode_value := o.Mode.ValueStringPointer()
	var defaultRoute_entry *virtual_router.ProtocolRipInterfaceDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
		}
		var object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolRipInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolRipInterfaceBfd)
		}
		var object *VirtualRouterDataSourceProtocolRipInterfacesBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Authentication = authentication_value
	(*obj).Mode = mode_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolRipInterfaceDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
		}
		var object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
		}
		var object *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterDataSourceProtocolRipTimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	deleteIntervals_value := o.DeleteIntervals.ValueInt64Pointer()
	expireIntervals_value := o.ExpireIntervals.ValueInt64Pointer()
	intervalSeconds_value := o.IntervalSeconds.ValueInt64Pointer()
	updateIntervals_value := o.UpdateIntervals.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipTimers)
	}
	(*obj).DeleteIntervals = deleteIntervals_value
	(*obj).ExpireIntervals = expireIntervals_value
	(*obj).IntervalSeconds = intervalSeconds_value
	(*obj).UpdateIntervals = updateIntervals_value

	return diags
}

func (o *VirtualRouterDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interfaces.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistances_obj *VirtualRouterDataSourceAdministrativeDistancesObject
	if o.AdministrativeDistances.IsNull() {
		administrativeDistances_obj = new(VirtualRouterDataSourceAdministrativeDistancesObject)
	} else {
		diags.Append(o.AdministrativeDistances.As(ctx, &administrativeDistances_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	administrativeDistances_object := types.ObjectNull(administrativeDistances_obj.AttributeTypes())
	if obj.AdminDists != nil {
		diags.Append(administrativeDistances_obj.CopyFromPango(ctx, client, ancestors, obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		administrativeDistances_object, diags_tmp = types.ObjectValueFrom(ctx, administrativeDistances_obj.AttributeTypes(), administrativeDistances_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ecmp_obj *VirtualRouterDataSourceEcmpObject
	if o.Ecmp.IsNull() {
		ecmp_obj = new(VirtualRouterDataSourceEcmpObject)
	} else {
		diags.Append(o.Ecmp.As(ctx, &ecmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ecmp_object := types.ObjectNull(ecmp_obj.AttributeTypes())
	if obj.Ecmp != nil {
		diags.Append(ecmp_obj.CopyFromPango(ctx, client, ancestors, obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ecmp_object, diags_tmp = types.ObjectValueFrom(ctx, ecmp_obj.AttributeTypes(), ecmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var multicast_obj *VirtualRouterDataSourceMulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(VirtualRouterDataSourceMulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, ancestors, obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocol_obj *VirtualRouterDataSourceProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(VirtualRouterDataSourceProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, ancestors, obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.AdministrativeDistances = administrativeDistances_object
	o.Ecmp = ecmp_object
	o.Interfaces = interfaces_list
	o.Multicast = multicast_object
	o.Protocol = protocol_object

	return diags
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.AdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	o.Ebgp = ebgp_value
	o.Ibgp = ibgp_value
	o.OspfExt = ospfExt_value
	o.OspfInt = ospfInt_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.Ospfv3Int = ospfv3Int_value
	o.Rip = rip_value
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Ecmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_obj *VirtualRouterDataSourceEcmpAlgorithmObject
	if o.Algorithm.IsNull() {
		algorithm_obj = new(VirtualRouterDataSourceEcmpAlgorithmObject)
	} else {
		diags.Append(o.Algorithm.As(ctx, &algorithm_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	algorithm_object := types.ObjectNull(algorithm_obj.AttributeTypes())
	if obj.Algorithm != nil {
		diags.Append(algorithm_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		algorithm_object, diags_tmp = types.ObjectValueFrom(ctx, algorithm_obj.AttributeTypes(), algorithm_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	o.Algorithm = algorithm_object
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.StrictSourcePath = strictSourcePath_value
	o.SymmetricReturn = symmetricReturn_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var balancedRoundRobin_obj *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject
	if o.BalancedRoundRobin.IsNull() {
		balancedRoundRobin_obj = new(VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject)
	} else {
		diags.Append(o.BalancedRoundRobin.As(ctx, &balancedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	balancedRoundRobin_object := types.ObjectNull(balancedRoundRobin_obj.AttributeTypes())
	if obj.BalancedRoundRobin != nil {
		diags.Append(balancedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		balancedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, balancedRoundRobin_obj.AttributeTypes(), balancedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipHash_obj *VirtualRouterDataSourceEcmpAlgorithmIpHashObject
	if o.IpHash.IsNull() {
		ipHash_obj = new(VirtualRouterDataSourceEcmpAlgorithmIpHashObject)
	} else {
		diags.Append(o.IpHash.As(ctx, &ipHash_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipHash_object := types.ObjectNull(ipHash_obj.AttributeTypes())
	if obj.IpHash != nil {
		diags.Append(ipHash_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipHash_object, diags_tmp = types.ObjectValueFrom(ctx, ipHash_obj.AttributeTypes(), ipHash_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipModulo_obj *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject
	if o.IpModulo.IsNull() {
		ipModulo_obj = new(VirtualRouterDataSourceEcmpAlgorithmIpModuloObject)
	} else {
		diags.Append(o.IpModulo.As(ctx, &ipModulo_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipModulo_object := types.ObjectNull(ipModulo_obj.AttributeTypes())
	if obj.IpModulo != nil {
		diags.Append(ipModulo_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipModulo_object, diags_tmp = types.ObjectValueFrom(ctx, ipModulo_obj.AttributeTypes(), ipModulo_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weightedRoundRobin_obj *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject
	if o.WeightedRoundRobin.IsNull() {
		weightedRoundRobin_obj = new(VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject)
	} else {
		diags.Append(o.WeightedRoundRobin.As(ctx, &weightedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weightedRoundRobin_object := types.ObjectNull(weightedRoundRobin_obj.AttributeTypes())
	if obj.WeightedRoundRobin != nil {
		diags.Append(weightedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weightedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, weightedRoundRobin_obj.AttributeTypes(), weightedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpHash = ipHash_object
	o.IpModulo = ipModulo_object
	o.WeightedRoundRobin = weightedRoundRobin_object

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	o.HashSeed = hashSeed_value
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceGroup_list types.List
	{
		var interfaceGroup_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupObject
		if !o.InterfaceGroup.IsNull() {
			diags.Append(o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.InterfaceGroup {
			entry := VirtualRouterDataSourceMulticastInterfaceGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaceGroup_tf_entries) {
				entry = interfaceGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaceGroup_tf_entries) {
				interfaceGroup_tf_entries[idx] = entry
			} else {
				interfaceGroup_tf_entries = append(interfaceGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface_group")
		interfaceGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaceGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []VirtualRouterDataSourceMulticastSptThresholdObject
		if !o.SptThreshold.IsNull() {
			diags.Append(o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SptThreshold {
			entry := VirtualRouterDataSourceMulticastSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sptThreshold_tf_entries) {
				entry = sptThreshold_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sptThreshold_tf_entries) {
				sptThreshold_tf_entries[idx] = entry
			} else {
				sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var ssmAddressSpace_list types.List
	{
		var ssmAddressSpace_tf_entries []VirtualRouterDataSourceMulticastSsmAddressSpaceObject
		if !o.SsmAddressSpace.IsNull() {
			diags.Append(o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SsmAddressSpace {
			entry := VirtualRouterDataSourceMulticastSsmAddressSpaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ssmAddressSpace_tf_entries) {
				entry = ssmAddressSpace_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ssmAddressSpace_tf_entries) {
				ssmAddressSpace_tf_entries[idx] = entry
			} else {
				ssmAddressSpace_tf_entries = append(ssmAddressSpace_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssm_address_space")
		ssmAddressSpace_list, list_diags = types.ListValueFrom(ctx, schemaType, ssmAddressSpace_tf_entries)
		diags.Append(list_diags...)
	}

	var rp_obj *VirtualRouterDataSourceMulticastRpObject
	if o.Rp.IsNull() {
		rp_obj = new(VirtualRouterDataSourceMulticastRpObject)
	} else {
		diags.Append(o.Rp.As(ctx, &rp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rp_object := types.ObjectNull(rp_obj.AttributeTypes())
	if obj.Rp != nil {
		diags.Append(rp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rp_object, diags_tmp = types.ObjectValueFrom(ctx, rp_obj.AttributeTypes(), rp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	o.Enable = enable_value
	o.InterfaceGroup = interfaceGroup_list
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.SsmAddressSpace = ssmAddressSpace_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var groupPermission_obj *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject
	if o.GroupPermission.IsNull() {
		groupPermission_obj = new(VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject)
	} else {
		diags.Append(o.GroupPermission.As(ctx, &groupPermission_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	groupPermission_object := types.ObjectNull(groupPermission_obj.AttributeTypes())
	if obj.GroupPermission != nil {
		diags.Append(groupPermission_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GroupPermission, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		groupPermission_object, diags_tmp = types.ObjectValueFrom(ctx, groupPermission_obj.AttributeTypes(), groupPermission_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var igmp_obj *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject
	if o.Igmp.IsNull() {
		igmp_obj = new(VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject)
	} else {
		diags.Append(o.Igmp.As(ctx, &igmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	igmp_object := types.ObjectNull(igmp_obj.AttributeTypes())
	if obj.Igmp != nil {
		diags.Append(igmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		igmp_object, diags_tmp = types.ObjectValueFrom(ctx, igmp_obj.AttributeTypes(), igmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pim_obj *VirtualRouterDataSourceMulticastInterfaceGroupPimObject
	if o.Pim.IsNull() {
		pim_obj = new(VirtualRouterDataSourceMulticastInterfaceGroupPimObject)
	} else {
		diags.Append(o.Pim.As(ctx, &pim_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pim_object := types.ObjectNull(pim_obj.AttributeTypes())
	if obj.Pim != nil {
		diags.Append(pim_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pim_object, diags_tmp = types.ObjectValueFrom(ctx, pim_obj.AttributeTypes(), pim_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Interface = interface_list
	o.GroupPermission = groupPermission_object
	o.Igmp = igmp_object
	o.Pim = pim_object

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermission, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_list types.List
	{
		var anySourceMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
		if !o.AnySourceMulticast.IsNull() {
			diags.Append(o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AnySourceMulticast {
			entry := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(anySourceMulticast_tf_entries) {
				entry = anySourceMulticast_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(anySourceMulticast_tf_entries) {
				anySourceMulticast_tf_entries[idx] = entry
			} else {
				anySourceMulticast_tf_entries = append(anySourceMulticast_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("any_source_multicast")
		anySourceMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, anySourceMulticast_tf_entries)
		diags.Append(list_diags...)
	}
	var sourceSpecificMulticast_list types.List
	{
		var sourceSpecificMulticast_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
		if !o.SourceSpecificMulticast.IsNull() {
			diags.Append(o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SourceSpecificMulticast {
			entry := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sourceSpecificMulticast_tf_entries) {
				entry = sourceSpecificMulticast_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sourceSpecificMulticast_tf_entries) {
				sourceSpecificMulticast_tf_entries[idx] = entry
			} else {
				sourceSpecificMulticast_tf_entries = append(sourceSpecificMulticast_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("source_specific_multicast")
		sourceSpecificMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, sourceSpecificMulticast_tf_entries)
		diags.Append(list_diags...)
	}

	o.AnySourceMulticast = anySourceMulticast_list
	o.SourceSpecificMulticast = sourceSpecificMulticast_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var maxQueryResponseTime_value types.Float64
	if obj.MaxQueryResponseTime != nil {
		maxQueryResponseTime_value = types.Float64Value(*obj.MaxQueryResponseTime)
	}
	var queryInterval_value types.Int64
	if obj.QueryInterval != nil {
		queryInterval_value = types.Int64Value(*obj.QueryInterval)
	}
	var lastMemberQueryInterval_value types.Float64
	if obj.LastMemberQueryInterval != nil {
		lastMemberQueryInterval_value = types.Float64Value(*obj.LastMemberQueryInterval)
	}
	var immediateLeave_value types.Bool
	if obj.ImmediateLeave != nil {
		immediateLeave_value = types.BoolValue(*obj.ImmediateLeave)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Enable = enable_value
	o.Version = version_value
	o.MaxQueryResponseTime = maxQueryResponseTime_value
	o.QueryInterval = queryInterval_value
	o.LastMemberQueryInterval = lastMemberQueryInterval_value
	o.ImmediateLeave = immediateLeave_value
	o.Robustness = robustness_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var allowedNeighbors_list types.List
	{
		var allowedNeighbors_tf_entries []VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject
		if !o.AllowedNeighbors.IsNull() {
			diags.Append(o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AllowedNeighbors {
			entry := VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(allowedNeighbors_tf_entries) {
				entry = allowedNeighbors_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(allowedNeighbors_tf_entries) {
				allowedNeighbors_tf_entries[idx] = entry
			} else {
				allowedNeighbors_tf_entries = append(allowedNeighbors_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("allowed_neighbors")
		allowedNeighbors_list, list_diags = types.ListValueFrom(ctx, schemaType, allowedNeighbors_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var assertInterval_value types.Int64
	if obj.AssertInterval != nil {
		assertInterval_value = types.Int64Value(*obj.AssertInterval)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var joinPruneInterval_value types.Int64
	if obj.JoinPruneInterval != nil {
		joinPruneInterval_value = types.Int64Value(*obj.JoinPruneInterval)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var bsrBorder_value types.Bool
	if obj.BsrBorder != nil {
		bsrBorder_value = types.BoolValue(*obj.BsrBorder)
	}
	o.Enable = enable_value
	o.AssertInterval = assertInterval_value
	o.HelloInterval = helloInterval_value
	o.JoinPruneInterval = joinPruneInterval_value
	o.DrPriority = drPriority_value
	o.BsrBorder = bsrBorder_value
	o.AllowedNeighbors = allowedNeighbors_list

	return diags
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []VirtualRouterDataSourceMulticastRpExternalRpObject
		if !o.ExternalRp.IsNull() {
			diags.Append(o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExternalRp {
			entry := VirtualRouterDataSourceMulticastRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(externalRp_tf_entries) {
				entry = externalRp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(externalRp_tf_entries) {
				externalRp_tf_entries[idx] = entry
			} else {
				externalRp_tf_entries = append(externalRp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}

	var localRp_obj *VirtualRouterDataSourceMulticastRpLocalRpObject
	if o.LocalRp.IsNull() {
		localRp_obj = new(VirtualRouterDataSourceMulticastRpLocalRpObject)
	} else {
		diags.Append(o.LocalRp.As(ctx, &localRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localRp_object := types.ObjectNull(localRp_obj.AttributeTypes())
	if obj.LocalRp != nil {
		diags.Append(localRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localRp_object, diags_tmp = types.ObjectValueFrom(ctx, localRp_obj.AttributeTypes(), localRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ExternalRp = externalRp_list
	o.LocalRp = localRp_object

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddresses = groupAddresses_list
	o.Override = override_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var candidateRp_obj *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject
	if o.CandidateRp.IsNull() {
		candidateRp_obj = new(VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject)
	} else {
		diags.Append(o.CandidateRp.As(ctx, &candidateRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	candidateRp_object := types.ObjectNull(candidateRp_obj.AttributeTypes())
	if obj.CandidateRp != nil {
		diags.Append(candidateRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		candidateRp_object, diags_tmp = types.ObjectValueFrom(ctx, candidateRp_obj.AttributeTypes(), candidateRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticRp_obj *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject
	if o.StaticRp.IsNull() {
		staticRp_obj = new(VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject)
	} else {
		diags.Append(o.StaticRp.As(ctx, &staticRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticRp_object := types.ObjectNull(staticRp_obj.AttributeTypes())
	if obj.StaticRp != nil {
		diags.Append(staticRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticRp_object, diags_tmp = types.ObjectValueFrom(ctx, staticRp_obj.AttributeTypes(), staticRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CandidateRp = candidateRp_object
	o.StaticRp = staticRp_object

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Address = address_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Priority = priority_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Address = address_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Override = override_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastSptThresholdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistProfile_list types.List
	{
		var redistProfile_tf_entries []VirtualRouterDataSourceProtocolRedistProfileObject
		if !o.RedistProfile.IsNull() {
			diags.Append(o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistProfile {
			entry := VirtualRouterDataSourceProtocolRedistProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistProfile_tf_entries) {
				entry = redistProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistProfile_tf_entries) {
				redistProfile_tf_entries[idx] = entry
			} else {
				redistProfile_tf_entries = append(redistProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile")
		redistProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var redistProfileIpv6_list types.List
	{
		var redistProfileIpv6_tf_entries []VirtualRouterDataSourceProtocolRedistProfileIpv6Object
		if !o.RedistProfileIpv6.IsNull() {
			diags.Append(o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistProfileIpv6 {
			entry := VirtualRouterDataSourceProtocolRedistProfileIpv6Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistProfileIpv6_tf_entries) {
				entry = redistProfileIpv6_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistProfileIpv6_tf_entries) {
				redistProfileIpv6_tf_entries[idx] = entry
			} else {
				redistProfileIpv6_tf_entries = append(redistProfileIpv6_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile_ipv6")
		redistProfileIpv6_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfileIpv6_tf_entries)
		diags.Append(list_diags...)
	}

	var bgp_obj *VirtualRouterDataSourceProtocolBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterDataSourceProtocolBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *VirtualRouterDataSourceProtocolOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(VirtualRouterDataSourceProtocolOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *VirtualRouterDataSourceProtocolOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(VirtualRouterDataSourceProtocolOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *VirtualRouterDataSourceProtocolRipObject
	if o.Rip.IsNull() {
		rip_obj = new(VirtualRouterDataSourceProtocolRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.RedistProfile = redistProfile_list
	o.RedistProfileIpv6 = redistProfileIpv6_list
	o.Rip = rip_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolBgpAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterDataSourceProtocolBgpAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var dampeningProfile_list types.List
	{
		var dampeningProfile_tf_entries []VirtualRouterDataSourceProtocolBgpDampeningProfileObject
		if !o.DampeningProfile.IsNull() {
			diags.Append(o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.DampeningProfile {
			entry := VirtualRouterDataSourceProtocolBgpDampeningProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(dampeningProfile_tf_entries) {
				entry = dampeningProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(dampeningProfile_tf_entries) {
				dampeningProfile_tf_entries[idx] = entry
			} else {
				dampeningProfile_tf_entries = append(dampeningProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("dampening_profile")
		dampeningProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, dampeningProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupObject
		if !o.PeerGroup.IsNull() {
			diags.Append(o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PeerGroup {
			entry := VirtualRouterDataSourceProtocolBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peerGroup_tf_entries) {
				entry = peerGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peerGroup_tf_entries) {
				peerGroup_tf_entries[idx] = entry
			} else {
				peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var redistRules_list types.List
	{
		var redistRules_tf_entries []VirtualRouterDataSourceProtocolBgpRedistRulesObject
		if !o.RedistRules.IsNull() {
			diags.Append(o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistRules {
			entry := VirtualRouterDataSourceProtocolBgpRedistRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistRules_tf_entries) {
				entry = redistRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistRules_tf_entries) {
				redistRules_tf_entries[idx] = entry
			} else {
				redistRules_tf_entries = append(redistRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_rules")
		redistRules_list, list_diags = types.ListValueFrom(ctx, schemaType, redistRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterDataSourceProtocolBgpGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterDataSourceProtocolBgpGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var policy_obj *VirtualRouterDataSourceProtocolBgpPolicyObject
	if o.Policy.IsNull() {
		policy_obj = new(VirtualRouterDataSourceProtocolBgpPolicyObject)
	} else {
		diags.Append(o.Policy.As(ctx, &policy_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	policy_object := types.ObjectNull(policy_obj.AttributeTypes())
	if obj.Policy != nil {
		diags.Append(policy_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Policy, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		policy_object, diags_tmp = types.ObjectValueFrom(ctx, policy_obj.AttributeTypes(), policy_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routingOptions_obj *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject
	if o.RoutingOptions.IsNull() {
		routingOptions_obj = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsObject)
	} else {
		diags.Append(o.RoutingOptions.As(ctx, &routingOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routingOptions_object := types.ObjectNull(routingOptions_obj.AttributeTypes())
	if obj.RoutingOptions != nil {
		diags.Append(routingOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RoutingOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routingOptions_object, diags_tmp = types.ObjectValueFrom(ctx, routingOptions_obj.AttributeTypes(), routingOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.DampeningProfile = dampeningProfile_list
	o.EcmpMultiAs = ecmpMultiAs_value
	o.Enable = enable_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.GlobalBfd = globalBfd_object
	o.InstallRoute = installRoute_value
	o.LocalAs = localAs_value
	o.PeerGroup = peerGroup_list
	o.Policy = policy_object
	o.RedistRules = redistRules_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value
	o.RoutingOptions = routingOptions_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var secret_value types.String
	if obj.Secret != nil {
		secret_value = types.StringValue(*obj.Secret)
	}
	o.Name = types.StringValue(obj.Name)
	o.Secret = secret_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpDampeningProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var cutoff_value types.Float64
	if obj.Cutoff != nil {
		cutoff_value = types.Float64Value(*obj.Cutoff)
	}
	var reuse_value types.Float64
	if obj.Reuse != nil {
		reuse_value = types.Float64Value(*obj.Reuse)
	}
	var maxHoldTime_value types.Int64
	if obj.MaxHoldTime != nil {
		maxHoldTime_value = types.Int64Value(*obj.MaxHoldTime)
	}
	var decayHalfLifeReachable_value types.Int64
	if obj.DecayHalfLifeReachable != nil {
		decayHalfLifeReachable_value = types.Int64Value(*obj.DecayHalfLifeReachable)
	}
	var decayHalfLifeUnreachable_value types.Int64
	if obj.DecayHalfLifeUnreachable != nil {
		decayHalfLifeUnreachable_value = types.Int64Value(*obj.DecayHalfLifeUnreachable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Cutoff = cutoff_value
	o.Reuse = reuse_value
	o.MaxHoldTime = maxHoldTime_value
	o.DecayHalfLifeReachable = decayHalfLifeReachable_value
	o.DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var aggregatedConfedAsPath_value types.Bool
	if obj.AggregatedConfedAsPath != nil {
		aggregatedConfedAsPath_value = types.BoolValue(*obj.AggregatedConfedAsPath)
	}
	var softResetWithStoredInfo_value types.Bool
	if obj.SoftResetWithStoredInfo != nil {
		softResetWithStoredInfo_value = types.BoolValue(*obj.SoftResetWithStoredInfo)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.AggregatedConfedAsPath = aggregatedConfedAsPath_value
	o.SoftResetWithStoredInfo = softResetWithStoredInfo_value
	o.Type = type_object
	o.Peer = peer_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ibgp_obj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject
	if o.Ibgp.IsNull() {
		ibgp_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject)
	} else {
		diags.Append(o.Ibgp.As(ctx, &ibgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgp_object := types.ObjectNull(ibgp_obj.AttributeTypes())
	if obj.Ibgp != nil {
		diags.Append(ibgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgp_object, diags_tmp = types.ObjectValueFrom(ctx, ibgp_obj.AttributeTypes(), ibgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgpConfed_obj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject
	if o.EbgpConfed.IsNull() {
		ebgpConfed_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject)
	} else {
		diags.Append(o.EbgpConfed.As(ctx, &ebgpConfed_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgpConfed_object := types.ObjectNull(ebgpConfed_obj.AttributeTypes())
	if obj.EbgpConfed != nil {
		diags.Append(ebgpConfed_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EbgpConfed, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgpConfed_object, diags_tmp = types.ObjectValueFrom(ctx, ebgpConfed_obj.AttributeTypes(), ebgpConfed_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ibgpConfed_obj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject
	if o.IbgpConfed.IsNull() {
		ibgpConfed_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject)
	} else {
		diags.Append(o.IbgpConfed.As(ctx, &ibgpConfed_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgpConfed_object := types.ObjectNull(ibgpConfed_obj.AttributeTypes())
	if obj.IbgpConfed != nil {
		diags.Append(ibgpConfed_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IbgpConfed, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgpConfed_object, diags_tmp = types.ObjectValueFrom(ctx, ibgpConfed_obj.AttributeTypes(), ibgpConfed_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgp_obj *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject
	if o.Ebgp.IsNull() {
		ebgp_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject)
	} else {
		diags.Append(o.Ebgp.As(ctx, &ebgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgp_object := types.ObjectNull(ebgp_obj.AttributeTypes())
	if obj.Ebgp != nil {
		diags.Append(ebgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgp_object, diags_tmp = types.ObjectValueFrom(ctx, ebgp_obj.AttributeTypes(), ebgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.EbgpConfed = ebgpConfed_object
	o.IbgpConfed = ibgpConfed_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importNexthop_value types.String
	if obj.ImportNexthop != nil {
		importNexthop_value = types.StringValue(*obj.ImportNexthop)
	}
	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	var removePrivateAs_value types.Bool
	if obj.RemovePrivateAs != nil {
		removePrivateAs_value = types.BoolValue(*obj.RemovePrivateAs)
	}
	o.ImportNexthop = importNexthop_value
	o.ExportNexthop = exportNexthop_value
	o.RemovePrivateAs = removePrivateAs_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var subsequentAddressFamilyIdentifier_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
	if o.SubsequentAddressFamilyIdentifier.IsNull() {
		subsequentAddressFamilyIdentifier_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject)
	} else {
		diags.Append(o.SubsequentAddressFamilyIdentifier.As(ctx, &subsequentAddressFamilyIdentifier_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	subsequentAddressFamilyIdentifier_object := types.ObjectNull(subsequentAddressFamilyIdentifier_obj.AttributeTypes())
	if obj.SubsequentAddressFamilyIdentifier != nil {
		diags.Append(subsequentAddressFamilyIdentifier_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SubsequentAddressFamilyIdentifier, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		subsequentAddressFamilyIdentifier_object, diags_tmp = types.ObjectValueFrom(ctx, subsequentAddressFamilyIdentifier_obj.AttributeTypes(), subsequentAddressFamilyIdentifier_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableMpBgp_value types.Bool
	if obj.EnableMpBgp != nil {
		enableMpBgp_value = types.BoolValue(*obj.EnableMpBgp)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	var reflectorClient_value types.String
	if obj.ReflectorClient != nil {
		reflectorClient_value = types.StringValue(*obj.ReflectorClient)
	}
	var peeringType_value types.String
	if obj.PeeringType != nil {
		peeringType_value = types.StringValue(*obj.PeeringType)
	}
	var maxPrefixes_value types.String
	if obj.MaxPrefixes != nil {
		maxPrefixes_value = types.StringValue(*obj.MaxPrefixes)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.EnableMpBgp = enableMpBgp_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.ReflectorClient = reflectorClient_value
	o.PeeringType = peeringType_value
	o.MaxPrefixes = maxPrefixes_value
	o.SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	o.Unicast = unicast_value
	o.Multicast = multicast_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var incomingBgpConnection_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
	if o.IncomingBgpConnection.IsNull() {
		incomingBgpConnection_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject)
	} else {
		diags.Append(o.IncomingBgpConnection.As(ctx, &incomingBgpConnection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	incomingBgpConnection_object := types.ObjectNull(incomingBgpConnection_obj.AttributeTypes())
	if obj.IncomingBgpConnection != nil {
		diags.Append(incomingBgpConnection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IncomingBgpConnection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		incomingBgpConnection_object, diags_tmp = types.ObjectValueFrom(ctx, incomingBgpConnection_obj.AttributeTypes(), incomingBgpConnection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var outgoingBgpConnection_obj *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	if o.OutgoingBgpConnection.IsNull() {
		outgoingBgpConnection_obj = new(VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject)
	} else {
		diags.Append(o.OutgoingBgpConnection.As(ctx, &outgoingBgpConnection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	outgoingBgpConnection_object := types.ObjectNull(outgoingBgpConnection_obj.AttributeTypes())
	if obj.OutgoingBgpConnection != nil {
		diags.Append(outgoingBgpConnection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.OutgoingBgpConnection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		outgoingBgpConnection_object, diags_tmp = types.ObjectValueFrom(ctx, outgoingBgpConnection_obj.AttributeTypes(), outgoingBgpConnection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var keepAliveInterval_value types.String
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.StringValue(*obj.KeepAliveInterval)
	}
	var minRouteAdvInterval_value types.Int64
	if obj.MinRouteAdvInterval != nil {
		minRouteAdvInterval_value = types.Int64Value(*obj.MinRouteAdvInterval)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var openDelayTime_value types.Int64
	if obj.OpenDelayTime != nil {
		openDelayTime_value = types.Int64Value(*obj.OpenDelayTime)
	}
	var holdTime_value types.String
	if obj.HoldTime != nil {
		holdTime_value = types.StringValue(*obj.HoldTime)
	}
	var idleHoldTime_value types.Int64
	if obj.IdleHoldTime != nil {
		idleHoldTime_value = types.Int64Value(*obj.IdleHoldTime)
	}
	o.Authentication = authentication_value
	o.KeepAliveInterval = keepAliveInterval_value
	o.MinRouteAdvInterval = minRouteAdvInterval_value
	o.Multihop = multihop_value
	o.OpenDelayTime = openDelayTime_value
	o.HoldTime = holdTime_value
	o.IdleHoldTime = idleHoldTime_value
	o.IncomingBgpConnection = incomingBgpConnection_object
	o.OutgoingBgpConnection = outgoingBgpConnection_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.RemotePort = remotePort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.LocalPort = localPort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregation_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject
	if o.Aggregation.IsNull() {
		aggregation_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationObject)
	} else {
		diags.Append(o.Aggregation.As(ctx, &aggregation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregation_object := types.ObjectNull(aggregation_obj.AttributeTypes())
	if obj.Aggregation != nil {
		diags.Append(aggregation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregation_object, diags_tmp = types.ObjectValueFrom(ctx, aggregation_obj.AttributeTypes(), aggregation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var conditionalAdvertisement_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject
	if o.ConditionalAdvertisement.IsNull() {
		conditionalAdvertisement_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject)
	} else {
		diags.Append(o.ConditionalAdvertisement.As(ctx, &conditionalAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	conditionalAdvertisement_object := types.ObjectNull(conditionalAdvertisement_obj.AttributeTypes())
	if obj.ConditionalAdvertisement != nil {
		diags.Append(conditionalAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConditionalAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		conditionalAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, conditionalAdvertisement_obj.AttributeTypes(), conditionalAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var export_obj *VirtualRouterDataSourceProtocolBgpPolicyExportObject
	if o.Export.IsNull() {
		export_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportObject)
	} else {
		diags.Append(o.Export.As(ctx, &export_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	export_object := types.ObjectNull(export_obj.AttributeTypes())
	if obj.Export != nil {
		diags.Append(export_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Export, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		export_object, diags_tmp = types.ObjectValueFrom(ctx, export_obj.AttributeTypes(), export_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var import_obj *VirtualRouterDataSourceProtocolBgpPolicyImportObject
	if o.Import.IsNull() {
		import_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportObject)
	} else {
		diags.Append(o.Import.As(ctx, &import_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	import_object := types.ObjectNull(import_obj.AttributeTypes())
	if obj.Import != nil {
		diags.Append(import_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Import, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		import_object, diags_tmp = types.ObjectValueFrom(ctx, import_obj.AttributeTypes(), import_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Aggregation = aggregation_object
	o.ConditionalAdvertisement = conditionalAdvertisement_object
	o.Export = export_object
	o.Import = import_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject
		if !o.Address.IsNull() {
			diags.Append(o.Address.ElementsAs(ctx, &address_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(address_tf_entries) {
				entry = address_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(address_tf_entries) {
				address_tf_entries[idx] = entry
			} else {
				address_tf_entries = append(address_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	o.Address = address_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppressFilters_list types.List
	{
		var suppressFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
		if !o.SuppressFilters.IsNull() {
			diags.Append(o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SuppressFilters {
			entry := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suppressFilters_tf_entries) {
				entry = suppressFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suppressFilters_tf_entries) {
				suppressFilters_tf_entries[idx] = entry
			} else {
				suppressFilters_tf_entries = append(suppressFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suppress_filters")
		suppressFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, suppressFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
		if !o.AdvertiseFilters.IsNull() {
			diags.Append(o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AdvertiseFilters {
			entry := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(advertiseFilters_tf_entries) {
				entry = advertiseFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(advertiseFilters_tf_entries) {
				advertiseFilters_tf_entries[idx] = entry
			} else {
				advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}

	var aggregateRouteAttributes_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
	if o.AggregateRouteAttributes.IsNull() {
		aggregateRouteAttributes_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject)
	} else {
		diags.Append(o.AggregateRouteAttributes.As(ctx, &aggregateRouteAttributes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregateRouteAttributes_object := types.ObjectNull(aggregateRouteAttributes_obj.AttributeTypes())
	if obj.AggregateRouteAttributes != nil {
		diags.Append(aggregateRouteAttributes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AggregateRouteAttributes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregateRouteAttributes_object, diags_tmp = types.ObjectValueFrom(ctx, aggregateRouteAttributes_obj.AttributeTypes(), aggregateRouteAttributes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summary_value types.Bool
	if obj.Summary != nil {
		summary_value = types.BoolValue(*obj.Summary)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	o.Name = types.StringValue(obj.Name)
	o.Prefix = prefix_value
	o.Enable = enable_value
	o.Summary = summary_value
	o.AsSet = asSet_value
	o.AggregateRouteAttributes = aggregateRouteAttributes_object
	o.SuppressFilters = suppressFilters_list
	o.AdvertiseFilters = advertiseFilters_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Weight = weight_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	o.None = none_object
	o.Prepend = prepend_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_list types.List
	{
		var policy_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
		if !o.Policy.IsNull() {
			diags.Append(o.Policy.ElementsAs(ctx, &policy_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Policy {
			entry := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(policy_tf_entries) {
				entry = policy_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(policy_tf_entries) {
				policy_tf_entries[idx] = entry
			} else {
				policy_tf_entries = append(policy_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("policy")
		policy_list, list_diags = types.ListValueFrom(ctx, schemaType, policy_tf_entries)
		diags.Append(list_diags...)
	}

	o.Policy = policy_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nonExistFilters_list types.List
	{
		var nonExistFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
		if !o.NonExistFilters.IsNull() {
			diags.Append(o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NonExistFilters {
			entry := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nonExistFilters_tf_entries) {
				entry = nonExistFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nonExistFilters_tf_entries) {
				nonExistFilters_tf_entries[idx] = entry
			} else {
				nonExistFilters_tf_entries = append(nonExistFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("non_exist_filters")
		nonExistFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, nonExistFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
		if !o.AdvertiseFilters.IsNull() {
			diags.Append(o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AdvertiseFilters {
			entry := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(advertiseFilters_tf_entries) {
				entry = advertiseFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(advertiseFilters_tf_entries) {
				advertiseFilters_tf_entries[idx] = entry
			} else {
				advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.NonExistFilters = nonExistFilters_list
	o.AdvertiseFilters = advertiseFilters_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deny_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject
	if o.Deny.IsNull() {
		deny_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject)
	} else {
		diags.Append(o.Deny.As(ctx, &deny_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	deny_object := types.ObjectNull(deny_obj.AttributeTypes())
	if obj.Deny != nil {
		diags.Append(deny_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Deny, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		deny_object, diags_tmp = types.ObjectValueFrom(ctx, deny_obj.AttributeTypes(), deny_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var update_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	if o.Update.IsNull() {
		update_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject)
	} else {
		diags.Append(o.Update.As(ctx, &update_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	update_object := types.ObjectNull(update_obj.AttributeTypes())
	if obj.Update != nil {
		diags.Append(update_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Update, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		update_object, diags_tmp = types.ObjectValueFrom(ctx, update_obj.AttributeTypes(), update_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Update = update_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var remove_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
	if o.Remove.IsNull() {
		remove_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject)
	} else {
		diags.Append(o.Remove.As(ctx, &remove_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	remove_object := types.ObjectNull(remove_obj.AttributeTypes())
	if obj.Remove != nil {
		diags.Append(remove_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Remove, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		remove_object, diags_tmp = types.ObjectValueFrom(ctx, remove_obj.AttributeTypes(), remove_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	var removeAndPrepend_value types.Int64
	if obj.RemoveAndPrepend != nil {
		removeAndPrepend_value = types.Int64Value(*obj.RemoveAndPrepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value
	o.RemoveAndPrepend = removeAndPrepend_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var match_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deny_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject
	if o.Deny.IsNull() {
		deny_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject)
	} else {
		diags.Append(o.Deny.As(ctx, &deny_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	deny_object := types.ObjectNull(deny_obj.AttributeTypes())
	if obj.Deny != nil {
		diags.Append(deny_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Deny, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		deny_object, diags_tmp = types.ObjectValueFrom(ctx, deny_obj.AttributeTypes(), deny_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var update_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	if o.Update.IsNull() {
		update_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject)
	} else {
		diags.Append(o.Update.As(ctx, &update_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	update_object := types.ObjectNull(update_obj.AttributeTypes())
	if obj.Update != nil {
		diags.Append(update_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Update, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		update_object, diags_tmp = types.ObjectValueFrom(ctx, update_obj.AttributeTypes(), update_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Dampening = dampening_value
	o.Update = update_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Weight = weight_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var remove_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	if o.Remove.IsNull() {
		remove_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject)
	} else {
		diags.Append(o.Remove.As(ctx, &remove_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	remove_object := types.ObjectNull(remove_obj.AttributeTypes())
	if obj.Remove != nil {
		diags.Append(remove_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Remove, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		remove_object, diags_tmp = types.ObjectValueFrom(ctx, remove_obj.AttributeTypes(), remove_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.None = none_object
	o.Remove = remove_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRedistRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var setCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SetCommunity.IsNull() || len(obj.SetCommunity) > 0 {
			entries = obj.SetCommunity
		}

		setCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var setExtendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SetExtendedCommunity.IsNull() || len(obj.SetExtendedCommunity) > 0 {
			entries = obj.SetExtendedCommunity
		}

		setExtendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var setOrigin_value types.String
	if obj.SetOrigin != nil {
		setOrigin_value = types.StringValue(*obj.SetOrigin)
	}
	var setMed_value types.Int64
	if obj.SetMed != nil {
		setMed_value = types.Int64Value(*obj.SetMed)
	}
	var setLocalPreference_value types.Int64
	if obj.SetLocalPreference != nil {
		setLocalPreference_value = types.Int64Value(*obj.SetLocalPreference)
	}
	var setAsPathLimit_value types.Int64
	if obj.SetAsPathLimit != nil {
		setAsPathLimit_value = types.Int64Value(*obj.SetAsPathLimit)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.RouteTable = routeTable_value
	o.Enable = enable_value
	o.SetOrigin = setOrigin_value
	o.SetMed = setMed_value
	o.SetLocalPreference = setLocalPreference_value
	o.SetAsPathLimit = setAsPathLimit_value
	o.Metric = metric_value
	o.SetCommunity = setCommunity_list
	o.SetExtendedCommunity = setExtendedCommunity_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregate_obj *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject
	if o.Aggregate.IsNull() {
		aggregate_obj = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject)
	} else {
		diags.Append(o.Aggregate.As(ctx, &aggregate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregate_object := types.ObjectNull(aggregate_obj.AttributeTypes())
	if obj.Aggregate != nil {
		diags.Append(aggregate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregate_object, diags_tmp = types.ObjectValueFrom(ctx, aggregate_obj.AttributeTypes(), aggregate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var med_obj *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject
	if o.Med.IsNull() {
		med_obj = new(VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject)
	} else {
		diags.Append(o.Med.As(ctx, &med_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	med_object := types.ObjectNull(med_obj.AttributeTypes())
	if obj.Med != nil {
		diags.Append(med_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		med_object, diags_tmp = types.ObjectValueFrom(ctx, med_obj.AttributeTypes(), med_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asFormat_value types.String
	if obj.AsFormat != nil {
		asFormat_value = types.StringValue(*obj.AsFormat)
	}
	var confederationMemberAs_value types.String
	if obj.ConfederationMemberAs != nil {
		confederationMemberAs_value = types.StringValue(*obj.ConfederationMemberAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var reflectorClusterId_value types.String
	if obj.ReflectorClusterId != nil {
		reflectorClusterId_value = types.StringValue(*obj.ReflectorClusterId)
	}
	o.Aggregate = aggregate_object
	o.AsFormat = asFormat_value
	o.ConfederationMemberAs = confederationMemberAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulRestart = gracefulRestart_object
	o.Med = med_object
	o.ReflectorClusterId = reflectorClusterId_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsAggregate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregateMed_value types.Bool
	if obj.AggregateMed != nil {
		aggregateMed_value = types.BoolValue(*obj.AggregateMed)
	}
	o.AggregateMed = aggregateMed_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	o.Enable = enable_value
	o.LocalRestartTime = localRestartTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.StaleRouteTime = staleRouteTime_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterDataSourceProtocolOspfAreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := VirtualRouterDataSourceProtocolOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterDataSourceProtocolOspfAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterDataSourceProtocolOspfExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterDataSourceProtocolOspfGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterDataSourceProtocolOspfGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterDataSourceProtocolOspfGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterDataSourceProtocolOspfGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterDataSourceProtocolOspfTimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterDataSourceProtocolOspfTimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Rfc1583 = rfc1583_value
	o.RouterId = routerId_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterDataSourceProtocolOspfAreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := VirtualRouterDataSourceProtocolOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterDataSourceProtocolOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterDataSourceProtocolOspfAreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultRoute_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var linkType_obj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.Metric = metric_value
	o.Priority = priority_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object
		if !o.Md5.IsNull() {
			diags.Append(o.Md5.ElementsAs(ctx, &md5_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Md5 {
			entry := VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(md5_tf_entries) {
				entry = md5_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(md5_tf_entries) {
				md5_tf_entries[idx] = entry
			} else {
				md5_tf_entries = append(md5_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfTimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolOspfv3AuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterDataSourceProtocolOspfv3AuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolOspfv3ExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterDataSourceProtocolOspfv3ExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterDataSourceProtocolOspfv3TimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterDataSourceProtocolOspfv3TimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultRoute_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var linkType_obj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Passive = passive_value
	o.Metric = metric_value
	o.Priority = priority_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var esp_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject
	if o.Esp.IsNull() {
		esp_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject)
	} else {
		diags.Append(o.Esp.As(ctx, &esp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	esp_object := types.ObjectNull(esp_obj.AttributeTypes())
	if obj.Esp != nil {
		diags.Append(esp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Esp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		esp_object, diags_tmp = types.ObjectValueFrom(ctx, esp_obj.AttributeTypes(), esp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ah_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject
	if o.Ah.IsNull() {
		ah_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject)
	} else {
		diags.Append(o.Ah.As(ctx, &ah_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ah_object := types.ObjectNull(ah_obj.AttributeTypes())
	if obj.Ah != nil {
		diags.Append(ah_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ah, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ah_object, diags_tmp = types.ObjectValueFrom(ctx, ah_obj.AttributeTypes(), ah_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var spi_value types.String
	if obj.Spi != nil {
		spi_value = types.StringValue(*obj.Spi)
	}
	o.Name = types.StringValue(obj.Name)
	o.Spi = spi_value
	o.Esp = esp_object
	o.Ah = ah_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var encryption_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject
	if o.Encryption.IsNull() {
		encryption_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject)
	} else {
		diags.Append(o.Encryption.As(ctx, &encryption_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	encryption_object := types.ObjectNull(encryption_obj.AttributeTypes())
	if obj.Encryption != nil {
		diags.Append(encryption_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Encryption, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		encryption_object, diags_tmp = types.ObjectValueFrom(ctx, encryption_obj.AttributeTypes(), encryption_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.None = none_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3ExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3Timers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var filter_obj *VirtualRouterDataSourceProtocolRedistProfileFilterObject
	if o.Filter.IsNull() {
		filter_obj = new(VirtualRouterDataSourceProtocolRedistProfileFilterObject)
	} else {
		diags.Append(o.Filter.As(ctx, &filter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filter_object := types.ObjectNull(filter_obj.AttributeTypes())
	if obj.Filter != nil {
		diags.Append(filter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Filter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filter_object, diags_tmp = types.ObjectValueFrom(ctx, filter_obj.AttributeTypes(), filter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterDataSourceProtocolRedistProfileActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterDataSourceProtocolRedistProfileActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Type.IsNull() || len(obj.Type) > 0 {
			entries = obj.Type
		}

		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Destination.IsNull() || len(obj.Destination) > 0 {
			entries = obj.Destination
		}

		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospf = ospf_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilterOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PathType.IsNull() || len(obj.PathType) > 0 {
			entries = obj.PathType
		}

		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Area.IsNull() || len(obj.Area) > 0 {
			entries = obj.Area
		}

		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Tag.IsNull() || len(obj.Tag) > 0 {
			entries = obj.Tag
		}

		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Community.IsNull() || len(obj.Community) > 0 {
			entries = obj.Community
		}

		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunity.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var noRedist_obj *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject
	if o.NoRedist.IsNull() {
		noRedist_obj = new(VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject)
	} else {
		diags.Append(o.NoRedist.As(ctx, &noRedist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	noRedist_object := types.ObjectNull(noRedist_obj.AttributeTypes())
	if obj.NoRedist != nil {
		diags.Append(noRedist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NoRedist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		noRedist_object, diags_tmp = types.ObjectValueFrom(ctx, noRedist_obj.AttributeTypes(), noRedist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redist_obj *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject
	if o.Redist.IsNull() {
		redist_obj = new(VirtualRouterDataSourceProtocolRedistProfileActionRedistObject)
	} else {
		diags.Append(o.Redist.As(ctx, &redist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redist_object := types.ObjectNull(redist_obj.AttributeTypes())
	if obj.Redist != nil {
		diags.Append(redist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Redist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redist_object, diags_tmp = types.ObjectValueFrom(ctx, redist_obj.AttributeTypes(), redist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var filter_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject
	if o.Filter.IsNull() {
		filter_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject)
	} else {
		diags.Append(o.Filter.As(ctx, &filter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filter_object := types.ObjectNull(filter_obj.AttributeTypes())
	if obj.Filter != nil {
		diags.Append(filter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Filter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filter_object, diags_tmp = types.ObjectValueFrom(ctx, filter_obj.AttributeTypes(), filter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6Filter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Type.IsNull() || len(obj.Type) > 0 {
			entries = obj.Type
		}

		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Destination.IsNull() || len(obj.Destination) > 0 {
			entries = obj.Destination
		}

		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PathType.IsNull() || len(obj.PathType) > 0 {
			entries = obj.PathType
		}

		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Area.IsNull() || len(obj.Area) > 0 {
			entries = obj.Area
		}

		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Tag.IsNull() || len(obj.Tag) > 0 {
			entries = obj.Tag
		}

		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6FilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Community.IsNull() || len(obj.Community) > 0 {
			entries = obj.Community
		}

		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunity.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6Action, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var noRedist_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject
	if o.NoRedist.IsNull() {
		noRedist_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject)
	} else {
		diags.Append(o.NoRedist.As(ctx, &noRedist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	noRedist_object := types.ObjectNull(noRedist_obj.AttributeTypes())
	if obj.NoRedist != nil {
		diags.Append(noRedist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NoRedist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		noRedist_object, diags_tmp = types.ObjectValueFrom(ctx, noRedist_obj.AttributeTypes(), noRedist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redist_obj *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject
	if o.Redist.IsNull() {
		redist_obj = new(VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject)
	} else {
		diags.Append(o.Redist.As(ctx, &redist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redist_object := types.ObjectNull(redist_obj.AttributeTypes())
	if obj.Redist != nil {
		diags.Append(redist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Redist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redist_object, diags_tmp = types.ObjectValueFrom(ctx, redist_obj.AttributeTypes(), redist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6ActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterDataSourceProtocolRipAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterDataSourceProtocolRipExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterDataSourceProtocolRipExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterDataSourceProtocolRipInterfacesObject
		if !o.Interfaces.IsNull() {
			diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterDataSourceProtocolRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaces_tf_entries) {
				entry = interfaces_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaces_tf_entries) {
				interfaces_tf_entries[idx] = entry
			} else {
				interfaces_tf_entries = append(interfaces_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterDataSourceProtocolRipGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterDataSourceProtocolRipGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterDataSourceProtocolRipTimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterDataSourceProtocolRipTimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.Interfaces = interfaces_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterDataSourceProtocolRipAuthProfileMd5Object
		if !o.Md5.IsNull() {
			diags.Append(o.Md5.ElementsAs(ctx, &md5_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Md5 {
			entry := VirtualRouterDataSourceProtocolRipAuthProfileMd5Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(md5_tf_entries) {
				entry = md5_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(md5_tf_entries) {
				md5_tf_entries[idx] = entry
			} else {
				md5_tf_entries = append(md5_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterDataSourceProtocolRipInterfacesBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterDataSourceProtocolRipInterfacesBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Authentication = authentication_value
	o.Mode = mode_value
	o.DefaultRoute = defaultRoute_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterDataSourceProtocolRipTimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deleteIntervals_value types.Int64
	if obj.DeleteIntervals != nil {
		deleteIntervals_value = types.Int64Value(*obj.DeleteIntervals)
	}
	var expireIntervals_value types.Int64
	if obj.ExpireIntervals != nil {
		expireIntervals_value = types.Int64Value(*obj.ExpireIntervals)
	}
	var intervalSeconds_value types.Int64
	if obj.IntervalSeconds != nil {
		intervalSeconds_value = types.Int64Value(*obj.IntervalSeconds)
	}
	var updateIntervals_value types.Int64
	if obj.UpdateIntervals != nil {
		updateIntervals_value = types.Int64Value(*obj.UpdateIntervals)
	}
	o.DeleteIntervals = deleteIntervals_value
	o.ExpireIntervals = expireIntervals_value
	o.IntervalSeconds = intervalSeconds_value
	o.UpdateIntervals = updateIntervals_value

	return diags
}

func (o *VirtualRouterDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func VirtualRouterDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": VirtualRouterDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"administrative_distances": VirtualRouterDataSourceAdministrativeDistancesSchema(),

			"ecmp": VirtualRouterDataSourceEcmpSchema(),

			"interfaces": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"multicast": VirtualRouterDataSourceMulticastSchema(),

			"protocol": VirtualRouterDataSourceProtocolSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceAdministrativeDistancesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ebgp": dsschema.Int64Attribute{
				Description: "administrative distance used for eBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ibgp": dsschema.Int64Attribute{
				Description: "administrative distance used for iBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_ext": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPF external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospf_int": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPF internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_ext": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ospfv3_int": dsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rip": dsschema.Int64Attribute{
				Description: "administrative distance used for RIP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static": dsschema.Int64Attribute{
				Description: "administrative distance used for static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_ipv6": dsschema.Int64Attribute{
				Description: "administrative distance used for ipv6 static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": VirtualRouterDataSourceEcmpAlgorithmSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": dsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_source_path": dsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": dsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"balanced_round_robin": VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_hash": VirtualRouterDataSourceEcmpAlgorithmIpHashSchema(),

			"ip_modulo": VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema(),

			"weighted_round_robin": VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpHashSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"hash_seed": dsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"src_only": dsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": dsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupSchema(),
			},

			"route_ageout_time": dsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rp": VirtualRouterDataSourceMulticastRpSchema(),

			"spt_threshold": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastSptThresholdSchema(),
			},

			"ssm_address_space": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastSsmAddressSpaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_permission": VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema(),

			"igmp": VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema(),

			"pim": VirtualRouterDataSourceMulticastInterfaceGroupPimSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"any_source_multicast": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema(),
			},

			"source_specific_multicast": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": dsschema.StringAttribute{
				Description: "source-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"version": dsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_query_response_time": dsschema.Float64Attribute{
				Description: "maximum query response time for general group membership queries in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"query_interval": dsschema.Int64Attribute{
				Description: "interval between group/source specific query messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"last_member_query_interval": dsschema.Float64Attribute{
				Description: "interval between group/source specific query messages (including those sent in response of leave group messages)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"immediate_leave": dsschema.BoolAttribute{
				Description: "leave group immediately when a leave message is received",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": dsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_groups": dsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_sources": dsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_alert_policing": dsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupIgmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupPimSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"assert_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Assert messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Hello messages, in seconds, a value of 0 represents an 'infinite' interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"join_prune_interval": dsschema.Int64Attribute{
				Description: "interval between PIM Join/Prune messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dr_priority": dsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bsr_border": dsschema.BoolAttribute{
				Description: "interface is bootstrap border",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allowed_neighbors": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastInterfaceGroupPimAllowedNeighborsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"external_rp": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceMulticastRpExternalRpSchema(),
			},

			"local_rp": VirtualRouterDataSourceMulticastRpLocalRpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpExternalRpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"candidate_rp": VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema(),

			"static_rp": VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": dsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.StringAttribute{
				Description: "local RP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": dsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSptThresholdSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceMulticastSsmAddressSpaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": dsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": dsschema.BoolAttribute{
				Description: "included",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceMulticastSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceMulticastSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"bgp": VirtualRouterDataSourceProtocolBgpSchema(),

			"ospf": VirtualRouterDataSourceProtocolOspfSchema(),

			"ospfv3": VirtualRouterDataSourceProtocolOspfv3Schema(),

			"redist_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRedistProfileSchema(),
			},

			"redist_profile_ipv6": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRedistProfileIpv6Schema(),
			},

			"rip": VirtualRouterDataSourceProtocolRipSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to BGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpAuthProfileSchema(),
			},

			"dampening_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpDampeningProfileSchema(),
			},

			"ecmp_multi_as": dsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": dsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": VirtualRouterDataSourceProtocolBgpGlobalBfdSchema(),

			"install_route": dsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": dsschema.StringAttribute{
				Description: "local AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_group": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPeerGroupSchema(),
			},

			"policy": VirtualRouterDataSourceProtocolBgpPolicySchema(),

			"redist_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpRedistRulesSchema(),
			},

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from BGP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"routing_options": VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"secret": dsschema.StringAttribute{
				Description: "shared secret for the TCP MD5 authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpDampeningProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cutoff": dsschema.Float64Attribute{
				Description: "cutoff threshold value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reuse": dsschema.Float64Attribute{
				Description: "reuse threshold value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_hold_time": dsschema.Int64Attribute{
				Description: "maximum of hold-down time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decay_half_life_reachable": dsschema.Int64Attribute{
				Description: "Decay half-life while reachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decay_half_life_unreachable": dsschema.Int64Attribute{
				Description: "Decay half-life while unreachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpDampeningProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpDampeningProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregated_confed_as_path": dsschema.BoolAttribute{
				Description: "the peers understand aggregated confederation AS path",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"soft_reset_with_stored_info": dsschema.BoolAttribute{
				Description: "soft reset with stored info",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema(),

			"peer": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ibgp": VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema(),

			"ebgp_confed": VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema(),

			"ibgp_confed": VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema(),

			"ebgp": VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeIbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"import_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_nexthop": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remove_private_as": dsschema.BoolAttribute{
				Description: "remove private AS when exporting route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": dsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_mp_bgp": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_family_identifier": dsschema.StringAttribute{
				Description: "select AFI for this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_sender_side_loop_detection": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reflector_client": dsschema.StringAttribute{
				Description: "this peer is reflector client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peering_type": dsschema.StringAttribute{
				Description: "peering type that affects NOPEER community value handling",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_prefixes": dsschema.StringAttribute{
				Description: "maximum of prefixes to receive from peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"subsequent_address_family_identifier": VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema(),

			"local_address": VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"interface": dsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": dsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ip": dsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"fqdn": dsschema.StringAttribute{
				Description: "bgp peer FQDN address object configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": dsschema.StringAttribute{
				Description: "keep-alive interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_route_adv_interval": dsschema.Int64Attribute{
				Description: "Minimum Route Advertisement Interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multihop": dsschema.Int64Attribute{
				Description: "IP TTL value used for sending BGP packet. set to 0 means eBGP use 2, iBGP use 255",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"open_delay_time": dsschema.Int64Attribute{
				Description: "open delay time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hold_time": dsschema.StringAttribute{
				Description: "hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"idle_hold_time": dsschema.Int64Attribute{
				Description: "idle hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"incoming_bgp_connection": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema(),

			"outgoing_bgp_connection": VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"remote_port": dsschema.Int64Attribute{
				Description: "restrict remote port for incoming BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_port": dsschema.Int64Attribute{
				Description: "use specific local port for outgoing BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allow": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregation": VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema(),

			"conditional_advertisement": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema(),

			"export": VirtualRouterDataSourceProtocolBgpPolicyExportSchema(),

			"import": VirtualRouterDataSourceProtocolBgpPolicyImportSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"address": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"prefix": dsschema.StringAttribute{
				Description: "aggregating address prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enable aggregation for this prefix",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary": dsschema.BoolAttribute{
				Description: "summarize route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": dsschema.BoolAttribute{
				Description: "generate AS-set attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregate_route_attributes": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema(),

			"suppress_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema(),
			},

			"advertise_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema(),

			"prepend": dsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("prepend"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"policy": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this policy",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"non_exist_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema(),
			},

			"advertise_filters": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema(),

			"action": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"deny": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema(),

			"allow": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"update": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema(),

			"prepend": dsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"remove_and_prepend": dsschema.Int64Attribute{
				Description: "remove matched AS path(s), and prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema(),

			"action": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"route_table": dsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": dsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"regex": dsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"deny": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema(),

			"allow": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"dampening": dsschema.StringAttribute{
				Description: "route flap dampening profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"update": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"local_preference": dsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": dsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": dsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": dsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": dsschema.StringAttribute{
				Description: "new route origin",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": dsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"none": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": dsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRedistRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"address_family_identifier": dsschema.StringAttribute{
				Description: "select redistribution profile type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"route_table": dsschema.StringAttribute{
				Description: "select destination SAFI for redistribution",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_origin": dsschema.StringAttribute{
				Description: "add the ORIGIN path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_med": dsschema.Int64Attribute{
				Description: "add the MULTI_EXIT_DISC path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_local_preference": dsschema.Int64Attribute{
				Description: "add the LOCAL_PREF path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_as_path_limit": dsschema.Int64Attribute{
				Description: "add the AS_PATHLIMIT path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"set_extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRedistRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRedistRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregate": VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema(),

			"as_format": dsschema.StringAttribute{
				Description: "AS format",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"confederation_member_as": dsschema.StringAttribute{
				Description: "confederation requires member-AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": dsschema.Int64Attribute{
				Description: "default local preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"graceful_restart": VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema(),

			"med": VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema(),

			"reflector_cluster_id": dsschema.StringAttribute{
				Description: "route reflector cluster ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"aggregate_med": dsschema.BoolAttribute{
				Description: "aggregate route only if they have same MED attributes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsAggregateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": dsschema.Int64Attribute{
				Description: "local restart time to advertise to peer (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_peer_restart_time": dsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"stale_route_time": dsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"always_compare_med": dsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": dsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolBgpRoutingOptionsMedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolBgpRoutingOptionsMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaSchema(),
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAuthProfileSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfExportRulesSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolOspfGlobalBfdSchema(),

			"graceful_restart": VirtualRouterDataSourceProtocolOspfGracefulRestartSchema(),

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": dsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterDataSourceProtocolOspfTimersSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolOspfAreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema(),

			"stub": VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema(),

			"nssa": VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": dsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema(),

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"md5": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": dsschema.BoolAttribute{
				Description: "use this key when sending packet",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": dsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"new_tag": dsschema.StringAttribute{
				Description: "new tag value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfGracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_l_s_a_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfTimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lsa_interval": dsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": dsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaSchema(),
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema(),
			},

			"disable_transit_traffic": dsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema(),

			"graceful_restart": VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema(),

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": dsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterDataSourceProtocolOspfv3TimersSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema(),

			"range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema(),
			},

			"interface": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"normal": VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema(),

			"stub": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema(),

			"nssa": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"accept_summary": dsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": dsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": dsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": dsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_type": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema(),

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"broadcast": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": dsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": dsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": dsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dead_counts": dsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmit_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_delay": dsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"spi": dsschema.StringAttribute{
				Description: "SPI for both inbound and outbound SA, hex format xxxxxxxx.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"esp": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema(),

			"ah": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"authentication": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema(),

			"encryption": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"md5": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema(),

			"sha1": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema(),

			"sha256": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema(),

			"sha384": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema(),

			"sha512": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema(),

			"none": VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"algorithm": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: 3des: 6, aes128: 4, aes192: 6, aes256: 8",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"md5": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema(),

			"sha1": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema(),

			"sha256": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema(),

			"sha384": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema(),

			"sha512": VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"key": dsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3AuthProfileAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": dsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"new_tag": dsschema.StringAttribute{
				Description: "new tag value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3ExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3ExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": dsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"helper_enable": dsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": dsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"strict_l_s_a_checking": dsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolOspfv3TimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lsa_interval": dsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": dsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolOspfv3TimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolOspfv3TimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterDataSourceProtocolRedistProfileFilterSchema(),

			"action": VirtualRouterDataSourceProtocolRedistProfileActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospf": VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema(),

			"bgp": VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"path_type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileFilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileFilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no_redist": VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema(),

			"redist": VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": dsschema.Int64Attribute{
				Description: "priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema(),

			"action": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospfv3": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema(),

			"bgp": VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"path_type": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6FilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no_redist": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema(),

			"redist": VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRedistProfileIpv6ActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"allow_redist_default_route": dsschema.BoolAttribute{
				Description: "allow redistribute default route to RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipAuthProfileSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipExportRulesSchema(),
			},

			"global_bfd": VirtualRouterDataSourceProtocolRipGlobalBfdSchema(),

			"interfaces": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipInterfacesSchema(),
			},

			"reject_default_route": dsschema.BoolAttribute{
				Description: "do not learn default route from RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterDataSourceProtocolRipTimersSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipAuthProfileSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"md5": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": dsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": dsschema.BoolAttribute{
				Description: "prefer to use this key when sending packet",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipExportRulesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"metric": dsschema.Int64Attribute{
				Description: "metric value",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipGlobalBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema(),

			"bfd": VirtualRouterDataSourceProtocolRipInterfacesBfdSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"disable": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema(),

			"advertise": VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"metric": dsschema.Int64Attribute{
				Description: "metric to be used when advertise default route via RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipInterfacesBfdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"profile": dsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceProtocolRipTimersSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"delete_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route expiration to its deletion",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"expire_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route last updated to its expiration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interval_seconds": dsschema.Int64Attribute{
				Description: "timer interval value in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"update_intervals": dsschema.Int64Attribute{
				Description: "number of intervals take between route advertisement (RIP response packet)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterDataSourceProtocolRipTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterDataSourceProtocolRipTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterDataSourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

// Metadata returns the data source type name.
func (d *VirtualRouterDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

// Schema defines the schema for this data source.
func (d *VirtualRouterDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = VirtualRouterDataSourceSchema()
}

// Configure prepares the struct.
func (d *VirtualRouterDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := virtual_router.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service](d.client, virtual_router.NewService(d.client), batchSize, specifier, virtual_router.SpecMatches)
}
func (o *VirtualRouterDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state VirtualRouterDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location virtual_router.Location

	{
		var terraformLocation VirtualRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &virtual_router.NgfwLocation{}
			var innerLocation VirtualRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &virtual_router.TemplateLocation{}
			var innerLocation VirtualRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &virtual_router.TemplateStackLocation{}
			var innerLocation VirtualRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &VirtualRouterResource{}
	_ resource.ResourceWithConfigure   = &VirtualRouterResource{}
	_ resource.ResourceWithImportState = &VirtualRouterResource{}
)

func NewVirtualRouterResource() resource.Resource {
	if _, found := resourceFuncMap["panos_virtual_router"]; !found {
		resourceFuncMap["panos_virtual_router"] = resourceFuncs{
			CreateImportId: VirtualRouterImportStateCreator,
		}
	}
	return &VirtualRouterResource{}
}

type VirtualRouterResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service]
}

func VirtualRouterResourceLocationSchema() rsschema.Attribute {
	return VirtualRouterLocationSchema()
}

type VirtualRouterResourceModel struct {
	Location                types.Object `tfsdk:"location"`
	Name                    types.String `tfsdk:"name"`
	AdministrativeDistances types.Object `tfsdk:"administrative_distances"`
	Ecmp                    types.Object `tfsdk:"ecmp"`
	Interfaces              types.List   `tfsdk:"interfaces"`
	Multicast               types.Object `tfsdk:"multicast"`
	Protocol                types.Object `tfsdk:"protocol"`
}
type VirtualRouterResourceAdministrativeDistancesObject struct {
	Ebgp       types.Int64 `tfsdk:"ebgp"`
	Ibgp       types.Int64 `tfsdk:"ibgp"`
	OspfExt    types.Int64 `tfsdk:"ospf_ext"`
	OspfInt    types.Int64 `tfsdk:"ospf_int"`
	Ospfv3Ext  types.Int64 `tfsdk:"ospfv3_ext"`
	Ospfv3Int  types.Int64 `tfsdk:"ospfv3_int"`
	Rip        types.Int64 `tfsdk:"rip"`
	Static     types.Int64 `tfsdk:"static"`
	StaticIpv6 types.Int64 `tfsdk:"static_ipv6"`
}
type VirtualRouterResourceEcmpObject struct {
	Algorithm        types.Object `tfsdk:"algorithm"`
	Enable           types.Bool   `tfsdk:"enable"`
	MaxPaths         types.Int64  `tfsdk:"max_paths"`
	StrictSourcePath types.Bool   `tfsdk:"strict_source_path"`
	SymmetricReturn  types.Bool   `tfsdk:"symmetric_return"`
}
type VirtualRouterResourceEcmpAlgorithmObject struct {
	BalancedRoundRobin types.Object `tfsdk:"balanced_round_robin"`
	IpHash             types.Object `tfsdk:"ip_hash"`
	IpModulo           types.Object `tfsdk:"ip_modulo"`
	WeightedRoundRobin types.Object `tfsdk:"weighted_round_robin"`
}
type VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject struct {
}
type VirtualRouterResourceEcmpAlgorithmIpHashObject struct {
	HashSeed types.Int64 `tfsdk:"hash_seed"`
	SrcOnly  types.Bool  `tfsdk:"src_only"`
	UsePort  types.Bool  `tfsdk:"use_port"`
}
type VirtualRouterResourceEcmpAlgorithmIpModuloObject struct {
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject struct {
	Interface types.List `tfsdk:"interface"`
}
type VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject struct {
	Name   types.String `tfsdk:"name"`
	Weight types.Int64  `tfsdk:"weight"`
}
type VirtualRouterResourceMulticastObject struct {
	Enable          types.Bool   `tfsdk:"enable"`
	InterfaceGroup  types.List   `tfsdk:"interface_group"`
	RouteAgeoutTime types.Int64  `tfsdk:"route_ageout_time"`
	Rp              types.Object `tfsdk:"rp"`
	SptThreshold    types.List   `tfsdk:"spt_threshold"`
	SsmAddressSpace types.List   `tfsdk:"ssm_address_space"`
}
type VirtualRouterResourceMulticastInterfaceGroupObject struct {
	Name            types.String `tfsdk:"name"`
	Description     types.String `tfsdk:"description"`
	Interface       types.List   `tfsdk:"interface"`
	GroupPermission types.Object `tfsdk:"group_permission"`
	Igmp            types.Object `tfsdk:"igmp"`
	Pim             types.Object `tfsdk:"pim"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject struct {
	AnySourceMulticast      types.List `tfsdk:"any_source_multicast"`
	SourceSpecificMulticast types.List `tfsdk:"source_specific_multicast"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject struct {
	Name          types.String `tfsdk:"name"`
	GroupAddress  types.String `tfsdk:"group_address"`
	SourceAddress types.String `tfsdk:"source_address"`
	Included      types.Bool   `tfsdk:"included"`
}
type VirtualRouterResourceMulticastInterfaceGroupIgmpObject struct {
	Enable                  types.Bool    `tfsdk:"enable"`
	Version                 types.String  `tfsdk:"version"`
	MaxQueryResponseTime    types.Float64 `tfsdk:"max_query_response_time"`
	QueryInterval           types.Int64   `tfsdk:"query_interval"`
	LastMemberQueryInterval types.Float64 `tfsdk:"last_member_query_interval"`
	ImmediateLeave          types.Bool    `tfsdk:"immediate_leave"`
	Robustness              types.String  `tfsdk:"robustness"`
	MaxGroups               types.String  `tfsdk:"max_groups"`
	MaxSources              types.String  `tfsdk:"max_sources"`
	RouterAlertPolicing     types.Bool    `tfsdk:"router_alert_policing"`
}
type VirtualRouterResourceMulticastInterfaceGroupPimObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	AssertInterval    types.Int64 `tfsdk:"assert_interval"`
	HelloInterval     types.Int64 `tfsdk:"hello_interval"`
	JoinPruneInterval types.Int64 `tfsdk:"join_prune_interval"`
	DrPriority        types.Int64 `tfsdk:"dr_priority"`
	BsrBorder         types.Bool  `tfsdk:"bsr_border"`
	AllowedNeighbors  types.List  `tfsdk:"allowed_neighbors"`
}
type VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceMulticastRpObject struct {
	ExternalRp types.List   `tfsdk:"external_rp"`
	LocalRp    types.Object `tfsdk:"local_rp"`
}
type VirtualRouterResourceMulticastRpExternalRpObject struct {
	Name           types.String `tfsdk:"name"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterResourceMulticastRpLocalRpObject struct {
	CandidateRp types.Object `tfsdk:"candidate_rp"`
	StaticRp    types.Object `tfsdk:"static_rp"`
}
type VirtualRouterResourceMulticastRpLocalRpCandidateRpObject struct {
	Address               types.String `tfsdk:"address"`
	AdvertisementInterval types.Int64  `tfsdk:"advertisement_interval"`
	GroupAddresses        types.List   `tfsdk:"group_addresses"`
	Interface             types.String `tfsdk:"interface"`
	Priority              types.Int64  `tfsdk:"priority"`
}
type VirtualRouterResourceMulticastRpLocalRpStaticRpObject struct {
	Address        types.String `tfsdk:"address"`
	GroupAddresses types.List   `tfsdk:"group_addresses"`
	Interface      types.String `tfsdk:"interface"`
	Override       types.Bool   `tfsdk:"override"`
}
type VirtualRouterResourceMulticastSptThresholdObject struct {
	Name      types.String `tfsdk:"name"`
	Threshold types.String `tfsdk:"threshold"`
}
type VirtualRouterResourceMulticastSsmAddressSpaceObject struct {
	Name         types.String `tfsdk:"name"`
	GroupAddress types.String `tfsdk:"group_address"`
	Included     types.Bool   `tfsdk:"included"`
}
type VirtualRouterResourceProtocolObject struct {
	Bgp               types.Object `tfsdk:"bgp"`
	Ospf              types.Object `tfsdk:"ospf"`
	Ospfv3            types.Object `tfsdk:"ospfv3"`
	RedistProfile     types.List   `tfsdk:"redist_profile"`
	RedistProfileIpv6 types.List   `tfsdk:"redist_profile_ipv6"`
	Rip               types.Object `tfsdk:"rip"`
}
type VirtualRouterResourceProtocolBgpObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	DampeningProfile        types.List   `tfsdk:"dampening_profile"`
	EcmpMultiAs             types.Bool   `tfsdk:"ecmp_multi_as"`
	Enable                  types.Bool   `tfsdk:"enable"`
	EnforceFirstAs          types.Bool   `tfsdk:"enforce_first_as"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	InstallRoute            types.Bool   `tfsdk:"install_route"`
	LocalAs                 types.String `tfsdk:"local_as"`
	PeerGroup               types.List   `tfsdk:"peer_group"`
	Policy                  types.Object `tfsdk:"policy"`
	RedistRules             types.List   `tfsdk:"redist_rules"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	RouterId                types.String `tfsdk:"router_id"`
	RoutingOptions          types.Object `tfsdk:"routing_options"`
}
type VirtualRouterResourceProtocolBgpAuthProfileObject struct {
	Name   types.String `tfsdk:"name"`
	Secret types.String `tfsdk:"secret"`
}
type VirtualRouterResourceProtocolBgpDampeningProfileObject struct {
	Name                     types.String  `tfsdk:"name"`
	Enable                   types.Bool    `tfsdk:"enable"`
	Cutoff                   types.Float64 `tfsdk:"cutoff"`
	Reuse                    types.Float64 `tfsdk:"reuse"`
	MaxHoldTime              types.Int64   `tfsdk:"max_hold_time"`
	DecayHalfLifeReachable   types.Int64   `tfsdk:"decay_half_life_reachable"`
	DecayHalfLifeUnreachable types.Int64   `tfsdk:"decay_half_life_unreachable"`
}
type VirtualRouterResourceProtocolBgpGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolBgpPeerGroupObject struct {
	Name                    types.String `tfsdk:"name"`
	Enable                  types.Bool   `tfsdk:"enable"`
	AggregatedConfedAsPath  types.Bool   `tfsdk:"aggregated_confed_as_path"`
	SoftResetWithStoredInfo types.Bool   `tfsdk:"soft_reset_with_stored_info"`
	Type                    types.Object `tfsdk:"type"`
	Peer                    types.List   `tfsdk:"peer"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeObject struct {
	Ibgp       types.Object `tfsdk:"ibgp"`
	EbgpConfed types.Object `tfsdk:"ebgp_confed"`
	IbgpConfed types.Object `tfsdk:"ibgp_confed"`
	Ebgp       types.Object `tfsdk:"ebgp"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject struct {
	ExportNexthop types.String `tfsdk:"export_nexthop"`
}
type VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject struct {
	ImportNexthop   types.String `tfsdk:"import_nexthop"`
	ExportNexthop   types.String `tfsdk:"export_nexthop"`
	RemovePrivateAs types.Bool   `tfsdk:"remove_private_as"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerObject struct {
	Name                              types.String `tfsdk:"name"`
	Enable                            types.Bool   `tfsdk:"enable"`
	PeerAs                            types.String `tfsdk:"peer_as"`
	EnableMpBgp                       types.Bool   `tfsdk:"enable_mp_bgp"`
	AddressFamilyIdentifier           types.String `tfsdk:"address_family_identifier"`
	EnableSenderSideLoopDetection     types.Bool   `tfsdk:"enable_sender_side_loop_detection"`
	ReflectorClient                   types.String `tfsdk:"reflector_client"`
	PeeringType                       types.String `tfsdk:"peering_type"`
	MaxPrefixes                       types.String `tfsdk:"max_prefixes"`
	SubsequentAddressFamilyIdentifier types.Object `tfsdk:"subsequent_address_family_identifier"`
	LocalAddress                      types.Object `tfsdk:"local_address"`
	PeerAddress                       types.Object `tfsdk:"peer_address"`
	ConnectionOptions                 types.Object `tfsdk:"connection_options"`
	Bfd                               types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject struct {
	Unicast   types.Bool `tfsdk:"unicast"`
	Multicast types.Bool `tfsdk:"multicast"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject struct {
	Interface types.String `tfsdk:"interface"`
	Ip        types.String `tfsdk:"ip"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject struct {
	Ip   types.String `tfsdk:"ip"`
	Fqdn types.String `tfsdk:"fqdn"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject struct {
	Authentication        types.String `tfsdk:"authentication"`
	KeepAliveInterval     types.String `tfsdk:"keep_alive_interval"`
	MinRouteAdvInterval   types.Int64  `tfsdk:"min_route_adv_interval"`
	Multihop              types.Int64  `tfsdk:"multihop"`
	OpenDelayTime         types.Int64  `tfsdk:"open_delay_time"`
	HoldTime              types.String `tfsdk:"hold_time"`
	IdleHoldTime          types.Int64  `tfsdk:"idle_hold_time"`
	IncomingBgpConnection types.Object `tfsdk:"incoming_bgp_connection"`
	OutgoingBgpConnection types.Object `tfsdk:"outgoing_bgp_connection"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject struct {
	RemotePort types.Int64 `tfsdk:"remote_port"`
	Allow      types.Bool  `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject struct {
	LocalPort types.Int64 `tfsdk:"local_port"`
	Allow     types.Bool  `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolBgpPolicyObject struct {
	Aggregation              types.Object `tfsdk:"aggregation"`
	ConditionalAdvertisement types.Object `tfsdk:"conditional_advertisement"`
	Export                   types.Object `tfsdk:"export"`
	Import                   types.Object `tfsdk:"import"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationObject struct {
	Address types.List `tfsdk:"address"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject struct {
	Name                     types.String `tfsdk:"name"`
	Prefix                   types.String `tfsdk:"prefix"`
	Enable                   types.Bool   `tfsdk:"enable"`
	Summary                  types.Bool   `tfsdk:"summary"`
	AsSet                    types.Bool   `tfsdk:"as_set"`
	AggregateRouteAttributes types.Object `tfsdk:"aggregate_route_attributes"`
	SuppressFilters          types.List   `tfsdk:"suppress_filters"`
	AdvertiseFilters         types.List   `tfsdk:"advertise_filters"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Weight            types.Int64  `tfsdk:"weight"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject struct {
	None    types.Object `tfsdk:"none"`
	Prepend types.Int64  `tfsdk:"prepend"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject struct {
	Policy types.List `tfsdk:"policy"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject struct {
	Name             types.String `tfsdk:"name"`
	Enable           types.Bool   `tfsdk:"enable"`
	UsedBy           types.List   `tfsdk:"used_by"`
	NonExistFilters  types.List   `tfsdk:"non_exist_filters"`
	AdvertiseFilters types.List   `tfsdk:"advertise_filters"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	Match  types.Object `tfsdk:"match"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	UsedBy types.List   `tfsdk:"used_by"`
	Match  types.Object `tfsdk:"match"`
	Action types.Object `tfsdk:"action"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject struct {
	Deny  types.Object `tfsdk:"deny"`
	Allow types.Object `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject struct {
	Update types.Object `tfsdk:"update"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject struct {
	None             types.Object `tfsdk:"none"`
	Remove           types.Object `tfsdk:"remove"`
	Prepend          types.Int64  `tfsdk:"prepend"`
	RemoveAndPrepend types.Int64  `tfsdk:"remove_and_prepend"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportObject struct {
	Rules types.List `tfsdk:"rules"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Enable types.Bool   `tfsdk:"enable"`
	UsedBy types.List   `tfsdk:"used_by"`
	Match  types.Object `tfsdk:"match"`
	Action types.Object `tfsdk:"action"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject struct {
	RouteTable        types.String `tfsdk:"route_table"`
	Med               types.Int64  `tfsdk:"med"`
	AddressPrefix     types.List   `tfsdk:"address_prefix"`
	Nexthop           types.List   `tfsdk:"nexthop"`
	FromPeer          types.List   `tfsdk:"from_peer"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject struct {
	Name  types.String `tfsdk:"name"`
	Exact types.Bool   `tfsdk:"exact"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject struct {
	Regex types.String `tfsdk:"regex"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject struct {
	Deny  types.Object `tfsdk:"deny"`
	Allow types.Object `tfsdk:"allow"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject struct {
	Dampening types.String `tfsdk:"dampening"`
	Update    types.Object `tfsdk:"update"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject struct {
	LocalPreference   types.Int64  `tfsdk:"local_preference"`
	Med               types.Int64  `tfsdk:"med"`
	Weight            types.Int64  `tfsdk:"weight"`
	Nexthop           types.String `tfsdk:"nexthop"`
	Origin            types.String `tfsdk:"origin"`
	AsPathLimit       types.Int64  `tfsdk:"as_path_limit"`
	AsPath            types.Object `tfsdk:"as_path"`
	Community         types.Object `tfsdk:"community"`
	ExtendedCommunity types.Object `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject struct {
	None   types.Object `tfsdk:"none"`
	Remove types.Object `tfsdk:"remove"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject struct {
	None        types.Object `tfsdk:"none"`
	RemoveAll   types.Object `tfsdk:"remove_all"`
	RemoveRegex types.String `tfsdk:"remove_regex"`
	Append      types.List   `tfsdk:"append"`
	Overwrite   types.List   `tfsdk:"overwrite"`
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject struct {
}
type VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject struct {
}
type VirtualRouterResourceProtocolBgpRedistRulesObject struct {
	Name                    types.String `tfsdk:"name"`
	AddressFamilyIdentifier types.String `tfsdk:"address_family_identifier"`
	RouteTable              types.String `tfsdk:"route_table"`
	Enable                  types.Bool   `tfsdk:"enable"`
	SetOrigin               types.String `tfsdk:"set_origin"`
	SetMed                  types.Int64  `tfsdk:"set_med"`
	SetLocalPreference      types.Int64  `tfsdk:"set_local_preference"`
	SetAsPathLimit          types.Int64  `tfsdk:"set_as_path_limit"`
	Metric                  types.Int64  `tfsdk:"metric"`
	SetCommunity            types.List   `tfsdk:"set_community"`
	SetExtendedCommunity    types.List   `tfsdk:"set_extended_community"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsObject struct {
	Aggregate              types.Object `tfsdk:"aggregate"`
	AsFormat               types.String `tfsdk:"as_format"`
	ConfederationMemberAs  types.String `tfsdk:"confederation_member_as"`
	DefaultLocalPreference types.Int64  `tfsdk:"default_local_preference"`
	GracefulRestart        types.Object `tfsdk:"graceful_restart"`
	Med                    types.Object `tfsdk:"med"`
	ReflectorClusterId     types.String `tfsdk:"reflector_cluster_id"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject struct {
	AggregateMed types.Bool `tfsdk:"aggregate_med"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject struct {
	Enable             types.Bool  `tfsdk:"enable"`
	LocalRestartTime   types.Int64 `tfsdk:"local_restart_time"`
	MaxPeerRestartTime types.Int64 `tfsdk:"max_peer_restart_time"`
	StaleRouteTime     types.Int64 `tfsdk:"stale_route_time"`
}
type VirtualRouterResourceProtocolBgpRoutingOptionsMedObject struct {
	AlwaysCompareMed           types.Bool `tfsdk:"always_compare_med"`
	DeterministicMedComparison types.Bool `tfsdk:"deterministic_med_comparison"`
}
type VirtualRouterResourceProtocolOspfObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	Area                    types.List   `tfsdk:"area"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	GracefulRestart         types.Object `tfsdk:"graceful_restart"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	Rfc1583                 types.Bool   `tfsdk:"rfc1583"`
	RouterId                types.String `tfsdk:"router_id"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterResourceProtocolOspfAreaObject struct {
	Name        types.String `tfsdk:"name"`
	Type        types.Object `tfsdk:"type"`
	Range       types.List   `tfsdk:"range"`
	Interface   types.List   `tfsdk:"interface"`
	VirtualLink types.List   `tfsdk:"virtual_link"`
}
type VirtualRouterResourceProtocolOspfAreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNormalObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeStubObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
	NssaExtRange  types.List   `tfsdk:"nssa_ext_range"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfAreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfAreaRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceObject struct {
	Name               types.String `tfsdk:"name"`
	Enable             types.Bool   `tfsdk:"enable"`
	Passive            types.Bool   `tfsdk:"passive"`
	Metric             types.Int64  `tfsdk:"metric"`
	Priority           types.Int64  `tfsdk:"priority"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	GrDelay            types.Int64  `tfsdk:"gr_delay"`
	LinkType           types.Object `tfsdk:"link_type"`
	Neighbor           types.List   `tfsdk:"neighbor"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfAreaVirtualLinkObject struct {
	Name               types.String `tfsdk:"name"`
	NeighborId         types.String `tfsdk:"neighbor_id"`
	TransitAreaId      types.String `tfsdk:"transit_area_id"`
	Enable             types.Bool   `tfsdk:"enable"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterResourceProtocolOspfAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterResourceProtocolOspfExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfGracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterResourceProtocolOspfTimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterResourceProtocolOspfv3Object struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	Area                    types.List   `tfsdk:"area"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	DisableTransitTraffic   types.Bool   `tfsdk:"disable_transit_traffic"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	GracefulRestart         types.Object `tfsdk:"graceful_restart"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	RouterId                types.String `tfsdk:"router_id"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterResourceProtocolOspfv3AreaObject struct {
	Name           types.String `tfsdk:"name"`
	Authentication types.String `tfsdk:"authentication"`
	Type           types.Object `tfsdk:"type"`
	Range          types.List   `tfsdk:"range"`
	Interface      types.List   `tfsdk:"interface"`
	VirtualLink    types.List   `tfsdk:"virtual_link"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeObject struct {
	Normal types.Object `tfsdk:"normal"`
	Stub   types.Object `tfsdk:"stub"`
	Nssa   types.Object `tfsdk:"nssa"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject struct {
	AcceptSummary types.Bool   `tfsdk:"accept_summary"`
	DefaultRoute  types.Object `tfsdk:"default_route"`
	NssaExtRange  types.List   `tfsdk:"nssa_ext_range"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject struct {
	Metric types.Int64  `tfsdk:"metric"`
	Type   types.String `tfsdk:"type"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaRangeObject struct {
	Name      types.String `tfsdk:"name"`
	Advertise types.Object `tfsdk:"advertise"`
	Suppress  types.Object `tfsdk:"suppress"`
}
type VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceObject struct {
	Name               types.String `tfsdk:"name"`
	Enable             types.Bool   `tfsdk:"enable"`
	InstanceId         types.Int64  `tfsdk:"instance_id"`
	Passive            types.Bool   `tfsdk:"passive"`
	Metric             types.Int64  `tfsdk:"metric"`
	Priority           types.Int64  `tfsdk:"priority"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	GrDelay            types.Int64  `tfsdk:"gr_delay"`
	LinkType           types.Object `tfsdk:"link_type"`
	Neighbor           types.List   `tfsdk:"neighbor"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject struct {
	Broadcast types.Object `tfsdk:"broadcast"`
	P2p       types.Object `tfsdk:"p2p"`
	P2mp      types.Object `tfsdk:"p2mp"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject struct {
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject struct {
	Name types.String `tfsdk:"name"`
}
type VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject struct {
	Name               types.String `tfsdk:"name"`
	NeighborId         types.String `tfsdk:"neighbor_id"`
	TransitAreaId      types.String `tfsdk:"transit_area_id"`
	Enable             types.Bool   `tfsdk:"enable"`
	InstanceId         types.Int64  `tfsdk:"instance_id"`
	HelloInterval      types.Int64  `tfsdk:"hello_interval"`
	DeadCounts         types.Int64  `tfsdk:"dead_counts"`
	RetransmitInterval types.Int64  `tfsdk:"retransmit_interval"`
	TransitDelay       types.Int64  `tfsdk:"transit_delay"`
	Authentication     types.String `tfsdk:"authentication"`
	Bfd                types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileObject struct {
	Name types.String `tfsdk:"name"`
	Spi  types.String `tfsdk:"spi"`
	Esp  types.Object `tfsdk:"esp"`
	Ah   types.Object `tfsdk:"ah"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspObject struct {
	Authentication types.Object `tfsdk:"authentication"`
	Encryption     types.Object `tfsdk:"encryption"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
	None   types.Object `tfsdk:"none"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject struct {
}
type VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject struct {
	Algorithm types.String `tfsdk:"algorithm"`
	Key       types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhObject struct {
	Md5    types.Object `tfsdk:"md5"`
	Sha1   types.Object `tfsdk:"sha1"`
	Sha256 types.Object `tfsdk:"sha256"`
	Sha384 types.Object `tfsdk:"sha384"`
	Sha512 types.Object `tfsdk:"sha512"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object struct {
	Key types.String `tfsdk:"key"`
}
type VirtualRouterResourceProtocolOspfv3ExportRulesObject struct {
	Name        types.String `tfsdk:"name"`
	NewPathType types.String `tfsdk:"new_path_type"`
	NewTag      types.String `tfsdk:"new_tag"`
	Metric      types.Int64  `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolOspfv3GlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolOspfv3GracefulRestartObject struct {
	Enable                 types.Bool  `tfsdk:"enable"`
	GracePeriod            types.Int64 `tfsdk:"grace_period"`
	HelperEnable           types.Bool  `tfsdk:"helper_enable"`
	MaxNeighborRestartTime types.Int64 `tfsdk:"max_neighbor_restart_time"`
	StrictLSAChecking      types.Bool  `tfsdk:"strict_l_s_a_checking"`
}
type VirtualRouterResourceProtocolOspfv3TimersObject struct {
	LsaInterval         types.Float64 `tfsdk:"lsa_interval"`
	SpfCalculationDelay types.Float64 `tfsdk:"spf_calculation_delay"`
}
type VirtualRouterResourceProtocolRedistProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
	Filter   types.Object `tfsdk:"filter"`
	Action   types.Object `tfsdk:"action"`
}
type VirtualRouterResourceProtocolRedistProfileFilterObject struct {
	Type        types.List   `tfsdk:"type"`
	Interface   types.List   `tfsdk:"interface"`
	Destination types.List   `tfsdk:"destination"`
	Nexthop     types.List   `tfsdk:"nexthop"`
	Ospf        types.Object `tfsdk:"ospf"`
	Bgp         types.Object `tfsdk:"bgp"`
}
type VirtualRouterResourceProtocolRedistProfileFilterOspfObject struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterResourceProtocolRedistProfileFilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolRedistProfileActionObject struct {
	NoRedist types.Object `tfsdk:"no_redist"`
	Redist   types.Object `tfsdk:"redist"`
}
type VirtualRouterResourceProtocolRedistProfileActionNoRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileActionRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileIpv6Object struct {
	Name     types.String `tfsdk:"name"`
	Priority types.Int64  `tfsdk:"priority"`
	Filter   types.Object `tfsdk:"filter"`
	Action   types.Object `tfsdk:"action"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterObject struct {
	Type        types.List   `tfsdk:"type"`
	Interface   types.List   `tfsdk:"interface"`
	Destination types.List   `tfsdk:"destination"`
	Nexthop     types.List   `tfsdk:"nexthop"`
	Ospfv3      types.Object `tfsdk:"ospfv3"`
	Bgp         types.Object `tfsdk:"bgp"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object struct {
	PathType types.List `tfsdk:"path_type"`
	Area     types.List `tfsdk:"area"`
	Tag      types.List `tfsdk:"tag"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject struct {
	Community         types.List `tfsdk:"community"`
	ExtendedCommunity types.List `tfsdk:"extended_community"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionObject struct {
	NoRedist types.Object `tfsdk:"no_redist"`
	Redist   types.Object `tfsdk:"redist"`
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject struct {
}
type VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject struct {
}
type VirtualRouterResourceProtocolRipObject struct {
	AllowRedistDefaultRoute types.Bool   `tfsdk:"allow_redist_default_route"`
	AuthProfile             types.List   `tfsdk:"auth_profile"`
	Enable                  types.Bool   `tfsdk:"enable"`
	ExportRules             types.List   `tfsdk:"export_rules"`
	GlobalBfd               types.Object `tfsdk:"global_bfd"`
	Interfaces              types.List   `tfsdk:"interfaces"`
	RejectDefaultRoute      types.Bool   `tfsdk:"reject_default_route"`
	Timers                  types.Object `tfsdk:"timers"`
}
type VirtualRouterResourceProtocolRipAuthProfileObject struct {
	Name     types.String `tfsdk:"name"`
	Password types.String `tfsdk:"password"`
	Md5      types.List   `tfsdk:"md5"`
}
type VirtualRouterResourceProtocolRipAuthProfileMd5Object struct {
	Name      types.String `tfsdk:"name"`
	Key       types.String `tfsdk:"key"`
	Preferred types.Bool   `tfsdk:"preferred"`
}
type VirtualRouterResourceProtocolRipExportRulesObject struct {
	Name   types.String `tfsdk:"name"`
	Metric types.Int64  `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolRipGlobalBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolRipInterfacesObject struct {
	Name           types.String `tfsdk:"name"`
	Enable         types.Bool   `tfsdk:"enable"`
	Authentication types.String `tfsdk:"authentication"`
	Mode           types.String `tfsdk:"mode"`
	DefaultRoute   types.Object `tfsdk:"default_route"`
	Bfd            types.Object `tfsdk:"bfd"`
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject struct {
	Disable   types.Object `tfsdk:"disable"`
	Advertise types.Object `tfsdk:"advertise"`
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject struct {
}
type VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject struct {
	Metric types.Int64 `tfsdk:"metric"`
}
type VirtualRouterResourceProtocolRipInterfacesBfdObject struct {
	Profile types.String `tfsdk:"profile"`
}
type VirtualRouterResourceProtocolRipTimersObject struct {
	DeleteIntervals types.Int64 `tfsdk:"delete_intervals"`
	ExpireIntervals types.Int64 `tfsdk:"expire_intervals"`
	IntervalSeconds types.Int64 `tfsdk:"interval_seconds"`
	UpdateIntervals types.Int64 `tfsdk:"update_intervals"`
}

func (o *VirtualRouterResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func VirtualRouterResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": VirtualRouterResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"administrative_distances": VirtualRouterResourceAdministrativeDistancesSchema(),

			"ecmp": VirtualRouterResourceEcmpSchema(),

			"interfaces": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"multicast": VirtualRouterResourceMulticastSchema(),

			"protocol": VirtualRouterResourceProtocolSchema(),
		},
	}
}

func (o *VirtualRouterResourceModel) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceAdministrativeDistancesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ebgp": rsschema.Int64Attribute{
				Description: "administrative distance used for eBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(20),
			},

			"ibgp": rsschema.Int64Attribute{
				Description: "administrative distance used for iBGP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"ospf_ext": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPF external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospf_int": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPF internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"ospfv3_ext": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(110),
			},

			"ospfv3_int": rsschema.Int64Attribute{
				Description: "administrative distance used for OSPFv3 internal routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"rip": rsschema.Int64Attribute{
				Description: "administrative distance used for RIP routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"static": rsschema.Int64Attribute{
				Description: "administrative distance used for static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"static_ipv6": rsschema.Int64Attribute{
				Description: "administrative distance used for ipv6 static routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceAdministrativeDistancesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": VirtualRouterResourceEcmpAlgorithmSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "enable Equal Cost Multipath routing, change this configuration will result in a virtual router restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_paths": rsschema.Int64Attribute{
				Description: "Maxmum number of ECMP paths supported, change this configuration will result in a virtual router restart",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(2),
			},

			"strict_source_path": rsschema.BoolAttribute{
				Description: "force VPN traffic to exit interface that the source-ip belongs to",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"symmetric_return": rsschema.BoolAttribute{
				Description: "allows return packets to egress out of the ingress interface of the flow",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"balanced_round_robin": VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema(),

			"ip_hash": VirtualRouterResourceEcmpAlgorithmIpHashSchema(),

			"ip_modulo": VirtualRouterResourceEcmpAlgorithmIpModuloSchema(),

			"weighted_round_robin": VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema(),
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpHashSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"hash_seed": rsschema.Int64Attribute{
				Description: "User-specified hash seed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"src_only": rsschema.BoolAttribute{
				Description: "only use source address for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"use_port": rsschema.BoolAttribute{
				Description: "use source/destination port for hash",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpHashSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmIpModuloSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmIpModuloSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("balanced_round_robin"),
				path.MatchRelative().AtParent().AtName("ip_hash"),
				path.MatchRelative().AtParent().AtName("ip_modulo"),
				path.MatchRelative().AtParent().AtName("weighted_round_robin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "interface ECMP weight",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable multicast protocol",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupSchema(),
			},

			"route_ageout_time": rsschema.Int64Attribute{
				Description: "time to wait before aging out a multicast route after data stops, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(210),
			},

			"rp": VirtualRouterResourceMulticastRpSchema(),

			"spt_threshold": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastSptThresholdSchema(),
			},

			"ssm_address_space": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastSsmAddressSpaceSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"group_permission": VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema(),

			"igmp": VirtualRouterResourceMulticastInterfaceGroupIgmpSchema(),

			"pim": VirtualRouterResourceMulticastInterfaceGroupPimSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"any_source_multicast": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema(),
			},

			"source_specific_multicast": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source_address": rsschema.StringAttribute{
				Description: "source-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupIgmpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable IGMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"version": rsschema.StringAttribute{
				Description: "IGMP version number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("3"),
			},

			"max_query_response_time": rsschema.Float64Attribute{
				Description: "maximum query response time for general group membership queries in seconds",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"query_interval": rsschema.Int64Attribute{
				Description: "interval between group/source specific query messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(125),
			},

			"last_member_query_interval": rsschema.Float64Attribute{
				Description: "interval between group/source specific query messages (including those sent in response of leave group messages)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"immediate_leave": rsschema.BoolAttribute{
				Description: "leave group immediately when a leave message is received",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"robustness": rsschema.StringAttribute{
				Description: "robustness variable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2"),
			},

			"max_groups": rsschema.StringAttribute{
				Description: "maximum number of groups allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"max_sources": rsschema.StringAttribute{
				Description: "maximum number of source-specific memberships allowed on this interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unlimited"),
			},

			"router_alert_policing": rsschema.BoolAttribute{
				Description: "drop IGMP packets without Router Alert option",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupIgmpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupPimSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"assert_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Assert messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(177),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Hello messages, in seconds, a value of 0 represents an 'infinite' interval",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"join_prune_interval": rsschema.Int64Attribute{
				Description: "interval between PIM Join/Prune messages, in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"dr_priority": rsschema.Int64Attribute{
				Description: "Designated Router priority",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"bsr_border": rsschema.BoolAttribute{
				Description: "interface is bootstrap border",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"allowed_neighbors": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupPimSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"external_rp": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceMulticastRpExternalRpSchema(),
			},

			"local_rp": VirtualRouterResourceMulticastRpLocalRpSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpExternalRpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpExternalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpExternalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"candidate_rp": VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema(),

			"static_rp": VirtualRouterResourceMulticastRpLocalRpStaticRpSchema(),
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.StringAttribute{
				Description: "candidate RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertisement_interval": rsschema.Int64Attribute{
				Description: "The time interval in seconds between candidate rp advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.StringAttribute{
				Description: "candidate RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "The priority for this candidate rt",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(192),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpCandidateRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastRpLocalRpStaticRpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("candidate_rp"),
				path.MatchRelative().AtParent().AtName("static_rp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.StringAttribute{
				Description: "local RP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_addresses": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.StringAttribute{
				Description: "local RP interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"override": rsschema.BoolAttribute{
				Description: "Override learned RP for the same group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastRpLocalRpStaticRpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSptThresholdSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"threshold": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("0"),
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastSptThresholdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSptThresholdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceMulticastSsmAddressSpaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"group_address": rsschema.StringAttribute{
				Description: "group-address/prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"included": rsschema.BoolAttribute{
				Description: "included",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceMulticastSsmAddressSpaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"bgp": VirtualRouterResourceProtocolBgpSchema(),

			"ospf": VirtualRouterResourceProtocolOspfSchema(),

			"ospfv3": VirtualRouterResourceProtocolOspfv3Schema(),

			"redist_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRedistProfileSchema(),
			},

			"redist_profile_ipv6": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRedistProfileIpv6Schema(),
			},

			"rip": VirtualRouterResourceProtocolRipSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to BGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpAuthProfileSchema(),
			},

			"dampening_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpDampeningProfileSchema(),
			},

			"ecmp_multi_as": rsschema.BoolAttribute{
				Description: "Support multiple AS in ECMP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enforce_first_as": rsschema.BoolAttribute{
				Description: "Enforce First AS for EBGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"global_bfd": VirtualRouterResourceProtocolBgpGlobalBfdSchema(),

			"install_route": rsschema.BoolAttribute{
				Description: "Populate BGP learned route to global route table",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_as": rsschema.StringAttribute{
				Description: "local AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_group": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPeerGroupSchema(),
			},

			"policy": VirtualRouterResourceProtocolBgpPolicySchema(),

			"redist_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpRedistRulesSchema(),
			},

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from BGP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this BGP instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"routing_options": VirtualRouterResourceProtocolBgpRoutingOptionsSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"secret": rsschema.StringAttribute{
				Description: "shared secret for the TCP MD5 authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpDampeningProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"cutoff": rsschema.Float64Attribute{
				Description: "cutoff threshold value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reuse": rsschema.Float64Attribute{
				Description: "reuse threshold value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_hold_time": rsschema.Int64Attribute{
				Description: "maximum of hold-down time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(900),
			},

			"decay_half_life_reachable": rsschema.Int64Attribute{
				Description: "Decay half-life while reachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(300),
			},

			"decay_half_life_unreachable": rsschema.Int64Attribute{
				Description: "Decay half-life while unreachable (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(900),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpDampeningProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregated_confed_as_path": rsschema.BoolAttribute{
				Description: "the peers understand aggregated confederation AS path",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"soft_reset_with_stored_info": rsschema.BoolAttribute{
				Description: "soft reset with stored info",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterResourceProtocolBgpPeerGroupTypeSchema(),

			"peer": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPeerGroupPeerSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ibgp": VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema(),

			"ebgp_confed": VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema(),

			"ibgp_confed": VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema(),

			"ebgp": VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ibgp"),
				path.MatchRelative().AtParent().AtName("ebgp_confed"),
				path.MatchRelative().AtParent().AtName("ibgp_confed"),
				path.MatchRelative().AtParent().AtName("ebgp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"import_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("original"),
			},

			"export_nexthop": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("resolve"),
			},

			"remove_private_as": rsschema.BoolAttribute{
				Description: "remove private AS when exporting route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"peer_as": rsschema.StringAttribute{
				Description: "peer AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_mp_bgp": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_family_identifier": rsschema.StringAttribute{
				Description: "select AFI for this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"enable_sender_side_loop_detection": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reflector_client": rsschema.StringAttribute{
				Description: "this peer is reflector client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("non-client"),
			},

			"peering_type": rsschema.StringAttribute{
				Description: "peering type that affects NOPEER community value handling",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"max_prefixes": rsschema.StringAttribute{
				Description: "maximum of prefixes to receive from peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("5000"),
			},

			"subsequent_address_family_identifier": VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema(),

			"local_address": VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema(),

			"peer_address": VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema(),

			"connection_options": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema(),

			"bfd": VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"multicast": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"interface": rsschema.StringAttribute{
				Description: "interface to accept BGP session",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip": rsschema.StringAttribute{
				Description: "specify exact IP address if interface has multiple addresses",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ip": rsschema.StringAttribute{
				Description: "peer address configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ip"),
						path.MatchRelative().AtParent().AtName("fqdn"),
					}...),
				},
			},

			"fqdn": rsschema.StringAttribute{
				Description: "bgp peer FQDN address object configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"keep_alive_interval": rsschema.StringAttribute{
				Description: "keep-alive interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("30"),
			},

			"min_route_adv_interval": rsschema.Int64Attribute{
				Description: "Minimum Route Advertisement Interval (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"multihop": rsschema.Int64Attribute{
				Description: "IP TTL value used for sending BGP packet. set to 0 means eBGP use 2, iBGP use 255",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"open_delay_time": rsschema.Int64Attribute{
				Description: "open delay time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"hold_time": rsschema.StringAttribute{
				Description: "hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("90"),
			},

			"idle_hold_time": rsschema.Int64Attribute{
				Description: "idle hold time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(15),
			},

			"incoming_bgp_connection": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema(),

			"outgoing_bgp_connection": VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"remote_port": rsschema.Int64Attribute{
				Description: "restrict remote port for incoming BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"allow": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_port": rsschema.Int64Attribute{
				Description: "use specific local port for outgoing BGP connections",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"allow": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPeerGroupPeerBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregation": VirtualRouterResourceProtocolBgpPolicyAggregationSchema(),

			"conditional_advertisement": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema(),

			"export": VirtualRouterResourceProtocolBgpPolicyExportSchema(),

			"import": VirtualRouterResourceProtocolBgpPolicyImportSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"address": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"prefix": rsschema.StringAttribute{
				Description: "aggregating address prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enable aggregation for this prefix",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"summary": rsschema.BoolAttribute{
				Description: "summarize route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_set": rsschema.BoolAttribute{
				Description: "generate AS-set attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"aggregate_route_attributes": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema(),

			"suppress_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema(),
			},

			"advertise_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema(),

			"prepend": rsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this rule",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"policy": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this policy",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"non_exist_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema(),
			},

			"advertise_filters": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "enble this filter",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyExportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema(),

			"action": VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"deny": VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema(),

			"allow": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"update": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema(),

			"prepend": rsschema.Int64Attribute{
				Description: "prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"remove_and_prepend": rsschema.Int64Attribute{
				Description: "remove matched AS path(s), and prepend local AS for specified number of times",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
				path.MatchRelative().AtParent().AtName("prepend"),
				path.MatchRelative().AtParent().AtName("remove_and_prepend"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyImportRulesSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"used_by": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"match": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema(),

			"action": VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"route_table": rsschema.StringAttribute{
				Description: "route table to match rule",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"med": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"address_prefix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema(),
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"from_peer": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"exact": rsschema.BoolAttribute{
				Description: "match exact prefix length",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"regex": rsschema.StringAttribute{
				Description: "AS-path regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("regex"),
					}...),
				},
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"deny": VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema(),

			"allow": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("deny"),
				path.MatchRelative().AtParent().AtName("allow"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"dampening": rsschema.StringAttribute{
				Description: "route flap dampening profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"update": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"local_preference": rsschema.Int64Attribute{
				Description: "new local preference value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"med": rsschema.Int64Attribute{
				Description: "new MED value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"weight": rsschema.Int64Attribute{
				Description: "new weight value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"nexthop": rsschema.StringAttribute{
				Description: "nexthop address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": rsschema.StringAttribute{
				Description: "new route origin",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path_limit": rsschema.Int64Attribute{
				Description: "add AS path limit attribute if it does not exist ",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"as_path": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema(),

			"community": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema(),

			"extended_community": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema(),

			"remove": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"none": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema(),

			"remove_all": VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema(),

			"remove_regex": rsschema.StringAttribute{
				Description: "remove specified coummnity match regular expression",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"append": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"overwrite": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("none"),
				path.MatchRelative().AtParent().AtName("remove_all"),
				path.MatchRelative().AtParent().AtName("remove_regex"),
				path.MatchRelative().AtParent().AtName("append"),
				path.MatchRelative().AtParent().AtName("overwrite"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRedistRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"address_family_identifier": rsschema.StringAttribute{
				Description: "select redistribution profile type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ipv4"),
			},

			"route_table": rsschema.StringAttribute{
				Description: "select destination SAFI for redistribution",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unicast"),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_origin": rsschema.StringAttribute{
				Description: "add the ORIGIN path attribute",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("incomplete"),
			},

			"set_med": rsschema.Int64Attribute{
				Description: "add the MULTI_EXIT_DISC path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_local_preference": rsschema.Int64Attribute{
				Description: "add the LOCAL_PREF path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_as_path_limit": rsschema.Int64Attribute{
				Description: "add the AS_PATHLIMIT path attribute",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"set_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"set_extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRedistRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregate": VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema(),

			"as_format": rsschema.StringAttribute{
				Description: "AS format",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2-byte"),
			},

			"confederation_member_as": rsschema.StringAttribute{
				Description: "confederation requires member-AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_local_preference": rsschema.Int64Attribute{
				Description: "default local preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},

			"graceful_restart": VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema(),

			"med": VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema(),

			"reflector_cluster_id": rsschema.StringAttribute{
				Description: "route reflector cluster ID",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"aggregate_med": rsschema.BoolAttribute{
				Description: "aggregate route only if they have same MED attributes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsAggregateSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"local_restart_time": rsschema.Int64Attribute{
				Description: "local restart time to advertise to peer (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"max_peer_restart_time": rsschema.Int64Attribute{
				Description: "maximum of peer restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"stale_route_time": rsschema.Int64Attribute{
				Description: "time to remove stale routes after peer restart (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"always_compare_med": rsschema.BoolAttribute{
				Description: "always compare MEDs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"deterministic_med_comparison": rsschema.BoolAttribute{
				Description: "deterministic MEDs comparison",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolBgpRoutingOptionsMedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaSchema(),
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAuthProfileSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfExportRulesSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolOspfGlobalBfdSchema(),

			"graceful_restart": VirtualRouterResourceProtocolOspfGracefulRestartSchema(),

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"rfc1583": rsschema.BoolAttribute{
				Description: "rfc-1583 compatibility",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPF instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterResourceProtocolOspfTimersSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": VirtualRouterResourceProtocolOspfAreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": VirtualRouterResourceProtocolOspfAreaTypeNormalSchema(),

			"stub": VirtualRouterResourceProtocolOspfAreaTypeStubSchema(),

			"nssa": VirtualRouterResourceProtocolOspfAreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"type": rsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": rsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"link_type": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema(),

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": rsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("password"),
						path.MatchRelative().AtParent().AtName("md5"),
					}...),
				},
			},

			"md5": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfAuthProfileMd5Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": rsschema.BoolAttribute{
				Description: "use this key when sending packet",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": rsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},

			"new_tag": rsschema.StringAttribute{
				Description: "new tag value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfGracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},

			"strict_l_s_a_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfGracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfTimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lsa_interval": rsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": rsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"area": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaSchema(),
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AuthProfileSchema(),
			},

			"disable_transit_traffic": rsschema.BoolAttribute{
				Description: "whether OSPFv3 should set the R- and V6-bits in its Router-LSAs",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3ExportRulesSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolOspfv3GlobalBfdSchema(),

			"graceful_restart": VirtualRouterResourceProtocolOspfv3GracefulRestartSchema(),

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from OSPF",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_id": rsschema.StringAttribute{
				Description: "router id of this OSPFv3 instance",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterResourceProtocolOspfv3TimersSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": VirtualRouterResourceProtocolOspfv3AreaTypeSchema(),

			"range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaRangeSchema(),
			},

			"interface": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema(),
			},

			"virtual_link": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"normal": VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema(),

			"stub": VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema(),

			"nssa": VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNormalSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("normal"),
				path.MatchRelative().AtParent().AtName("stub"),
				path.MatchRelative().AtParent().AtName("nssa"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"accept_summary": rsschema.BoolAttribute{
				Description: "Enable the origination and propagation of summary LSA to this area",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema(),

			"nssa_ext_range": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route within this stub area",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"type": rsschema.StringAttribute{
				Description: "metric type to be used when advertise default route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"advertise": VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema(),

			"suppress": VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("advertise"),
				path.MatchRelative().AtParent().AtName("suppress"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaRangeSuppressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable OSPF in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"passive": rsschema.BoolAttribute{
				Description: "Suppress the sending of hello packets in this interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "Cost of OSPF interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"priority": rsschema.Int64Attribute{
				Description: "Priority for OSPF designated router selection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"gr_delay": rsschema.Int64Attribute{
				Description: "Period (in seconds) used to send grace LSAs before first hello is sent when graceful restart starts",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"link_type": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema(),

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema(),
			},

			"bfd": VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"broadcast": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema(),

			"p2p": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema(),

			"p2mp": VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("broadcast"),
				path.MatchRelative().AtParent().AtName("p2p"),
				path.MatchRelative().AtParent().AtName("p2mp"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"neighbor_id": rsschema.StringAttribute{
				Description: "neighbor router id for virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"transit_area_id": rsschema.StringAttribute{
				Description: "id of transit area, cannot be backbone, stub or NSSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable this virtual link",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"instance_id": rsschema.Int64Attribute{
				Description: "OSPFv3 instance ID",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},

			"hello_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to send Hello packets",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"dead_counts": rsschema.Int64Attribute{
				Description: "number of lost hello packets to declare router down",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(4),
			},

			"retransmit_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) to retransmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(5),
			},

			"transit_delay": rsschema.Int64Attribute{
				Description: "Estimated delay (in seconds) to transmit LSAs",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"bfd": VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaVirtualLinkSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"spi": rsschema.StringAttribute{
				Description: "SPI for both inbound and outbound SA, hex format xxxxxxxx.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"esp": VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema(),

			"ah": VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"authentication": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema(),

			"encryption": VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"md5": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema(),

			"sha1": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema(),

			"sha256": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema(),

			"sha384": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema(),

			"sha512": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema(),

			"none": VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
				path.MatchRelative().AtParent().AtName("none"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"algorithm": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total number of sections: 3des: 6, aes128: 4, aes192: 6, aes256: 8",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("esp"),
				path.MatchRelative().AtParent().AtName("ah"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"md5": VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema(),

			"sha1": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema(),

			"sha256": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema(),

			"sha384": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema(),

			"sha512": VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 4 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 5 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 8 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 12 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("md5"),
				path.MatchRelative().AtParent().AtName("sha1"),
				path.MatchRelative().AtParent().AtName("sha256"),
				path.MatchRelative().AtParent().AtName("sha384"),
				path.MatchRelative().AtParent().AtName("sha512"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"key": rsschema.StringAttribute{
				Description: "hex format xxxxxxxx[-xxxxxxxx]... total 16 sections",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3ExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"new_path_type": rsschema.StringAttribute{
				Description: "path type to be used for imported external routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("ext-2"),
			},

			"new_tag": rsschema.StringAttribute{
				Description: "new tag value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3ExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3GlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3GlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3GracefulRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"grace_period": rsschema.Int64Attribute{
				Description: "maximum local restarting time (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"helper_enable": rsschema.BoolAttribute{
				Description: "enable/disable helping neighboring routers to graceful restart",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_neighbor_restart_time": rsschema.Int64Attribute{
				Description: "maximum of neighbor restart time accepted (in seconds)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(140),
			},

			"strict_l_s_a_checking": rsschema.BoolAttribute{
				Description: "enable/disable strict LSA checking. Abort GR if lsa change is detected",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3GracefulRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolOspfv3TimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lsa_interval": rsschema.Float64Attribute{
				Description: "The minimum time in seconds between distinct originations of any particular LSA",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"spf_calculation_delay": rsschema.Float64Attribute{
				Description: "Delay in seconds before running the SPF algorithm",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolOspfv3TimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolOspfv3TimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "priority",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterResourceProtocolRedistProfileFilterSchema(),

			"action": VirtualRouterResourceProtocolRedistProfileActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospf": VirtualRouterResourceProtocolRedistProfileFilterOspfSchema(),

			"bgp": VirtualRouterResourceProtocolRedistProfileFilterBgpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterOspfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"path_type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterOspfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileFilterBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileFilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no_redist": VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema(),

			"redist": VirtualRouterResourceProtocolRedistProfileActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileActionRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"priority": rsschema.Int64Attribute{
				Description: "priority",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"filter": VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema(),

			"action": VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"interface": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"destination": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"nexthop": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ospfv3": VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema(),

			"bgp": VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"path_type": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"area": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"tag": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"extended_community": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no_redist": VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema(),

			"redist": VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no_redist"),
				path.MatchRelative().AtParent().AtName("redist"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"allow_redist_default_route": rsschema.BoolAttribute{
				Description: "allow redistribute default route to RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth_profile": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipAuthProfileSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"export_rules": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipExportRulesSchema(),
			},

			"global_bfd": VirtualRouterResourceProtocolRipGlobalBfdSchema(),

			"interfaces": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipInterfacesSchema(),
			},

			"reject_default_route": rsschema.BoolAttribute{
				Description: "do not learn default route from RIP",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timers": VirtualRouterResourceProtocolRipTimersSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRipObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipAuthProfileSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"password": rsschema.StringAttribute{
				Description: "Simple password authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("password"),
						path.MatchRelative().AtParent().AtName("md5"),
					}...),
				},
			},

			"md5": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: VirtualRouterResourceProtocolRipAuthProfileMd5Schema(),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipAuthProfileObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipAuthProfileSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipAuthProfileMd5Schema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("password"),
				path.MatchRelative().AtParent().AtName("md5"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"key": rsschema.StringAttribute{
				Description: "key for the authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred": rsschema.BoolAttribute{
				Description: "prefer to use this key when sending packet",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipAuthProfileMd5Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipExportRulesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"metric": rsschema.Int64Attribute{
				Description: "metric value",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipExportRulesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipExportRulesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipGlobalBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipGlobalBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "Authentication options",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"mode": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("normal"),
			},

			"default_route": VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema(),

			"bfd": VirtualRouterResourceProtocolRipInterfacesBfdSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"disable": VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema(),

			"advertise": VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema(),
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("disable"),
				path.MatchRelative().AtParent().AtName("advertise"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"metric": rsschema.Int64Attribute{
				Description: "metric to be used when advertise default route via RIP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipInterfacesBfdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"profile": rsschema.StringAttribute{
				Description: "BFD profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Inherit-vr-global-setting"),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipInterfacesBfdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func VirtualRouterResourceProtocolRipTimersSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"delete_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route expiration to its deletion",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(120),
			},

			"expire_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route last updated to its expiration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(180),
			},

			"interval_seconds": rsschema.Int64Attribute{
				Description: "timer interval value in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"update_intervals": rsschema.Int64Attribute{
				Description: "number of intervals take between route advertisement (RIP response packet)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},
		},
	}
}

func (o *VirtualRouterResourceProtocolRipTimersObject) getTypeFor(name string) attr.Type {
	schema := VirtualRouterResourceProtocolRipTimersSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *VirtualRouterResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_virtual_router"
}

func (o *VirtualRouterResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = VirtualRouterResourceSchema()
}

// </ResourceSchema>

func (o *VirtualRouterResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := virtual_router.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*virtual_router.Entry, virtual_router.Location, *virtual_router.Service](o.client, virtual_router.NewService(o.client), batchSize, specifier, virtual_router.SpecMatches)
}

func (o *VirtualRouterResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj VirtualRouterLocation

	var administrativeDistancesObj *VirtualRouterResourceAdministrativeDistancesObject

	var ecmpObj *VirtualRouterResourceEcmpObject

	var multicastObj *VirtualRouterResourceMulticastObject

	var protocolObj *VirtualRouterResourceProtocolObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"administrative_distances": types.ObjectType{
			AttrTypes: administrativeDistancesObj.AttributeTypes(),
		},
		"ecmp": types.ObjectType{
			AttrTypes: ecmpObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.StringType,
		},
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"protocol": types.ObjectType{
			AttrTypes: protocolObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceModel) AncestorName() string {
	return ""
}

func (o VirtualRouterResourceModel) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceAdministrativeDistancesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ebgp":        types.Int64Type,
		"ibgp":        types.Int64Type,
		"ospf_ext":    types.Int64Type,
		"ospf_int":    types.Int64Type,
		"ospfv3_ext":  types.Int64Type,
		"ospfv3_int":  types.Int64Type,
		"rip":         types.Int64Type,
		"static":      types.Int64Type,
		"static_ipv6": types.Int64Type,
	}
}

func (o VirtualRouterResourceAdministrativeDistancesObject) AncestorName() string {
	return "administrative-distances"
}

func (o VirtualRouterResourceAdministrativeDistancesObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpObject) AttributeTypes() map[string]attr.Type {

	var algorithmObj *VirtualRouterResourceEcmpAlgorithmObject

	return map[string]attr.Type{
		"algorithm": types.ObjectType{
			AttrTypes: algorithmObj.AttributeTypes(),
		},
		"enable":             types.BoolType,
		"max_paths":          types.Int64Type,
		"strict_source_path": types.BoolType,
		"symmetric_return":   types.BoolType,
	}
}

func (o VirtualRouterResourceEcmpObject) AncestorName() string {
	return "ecmp"
}

func (o VirtualRouterResourceEcmpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmObject) AttributeTypes() map[string]attr.Type {

	var balancedRoundRobinObj *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject

	var ipHashObj *VirtualRouterResourceEcmpAlgorithmIpHashObject

	var ipModuloObj *VirtualRouterResourceEcmpAlgorithmIpModuloObject

	var weightedRoundRobinObj *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject
	return map[string]attr.Type{
		"balanced_round_robin": types.ObjectType{
			AttrTypes: balancedRoundRobinObj.AttributeTypes(),
		},
		"ip_hash": types.ObjectType{
			AttrTypes: ipHashObj.AttributeTypes(),
		},
		"ip_modulo": types.ObjectType{
			AttrTypes: ipModuloObj.AttributeTypes(),
		},
		"weighted_round_robin": types.ObjectType{
			AttrTypes: weightedRoundRobinObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceEcmpAlgorithmObject) AncestorName() string {
	return "algorithm"
}

func (o VirtualRouterResourceEcmpAlgorithmObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) AncestorName() string {
	return "balanced-round-robin"
}

func (o VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"hash_seed": types.Int64Type,
		"src_only":  types.BoolType,
		"use_port":  types.BoolType,
	}
}

func (o VirtualRouterResourceEcmpAlgorithmIpHashObject) AncestorName() string {
	return "ip-hash"
}

func (o VirtualRouterResourceEcmpAlgorithmIpHashObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceEcmpAlgorithmIpModuloObject) AncestorName() string {
	return "ip-modulo"
}

func (o VirtualRouterResourceEcmpAlgorithmIpModuloObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) AttributeTypes() map[string]attr.Type {

	var interfaceObj *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	return map[string]attr.Type{
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) AncestorName() string {
	return "weighted-round-robin"
}

func (o VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"weight": types.Int64Type,
	}
}

func (o VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastObject) AttributeTypes() map[string]attr.Type {

	var interfaceGroupObj *VirtualRouterResourceMulticastInterfaceGroupObject

	var rpObj *VirtualRouterResourceMulticastRpObject

	var sptThresholdObj *VirtualRouterResourceMulticastSptThresholdObject

	var ssmAddressSpaceObj *VirtualRouterResourceMulticastSsmAddressSpaceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"interface_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceGroupObj.AttributeTypes(),
			},
		},
		"route_ageout_time": types.Int64Type,
		"rp": types.ObjectType{
			AttrTypes: rpObj.AttributeTypes(),
		},
		"spt_threshold": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sptThresholdObj.AttributeTypes(),
			},
		},
		"ssm_address_space": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ssmAddressSpaceObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceMulticastObject) AncestorName() string {
	return "multicast"
}

func (o VirtualRouterResourceMulticastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastInterfaceGroupObject) AttributeTypes() map[string]attr.Type {

	var groupPermissionObj *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject

	var igmpObj *VirtualRouterResourceMulticastInterfaceGroupIgmpObject

	var pimObj *VirtualRouterResourceMulticastInterfaceGroupPimObject
	return map[string]attr.Type{
		"name":        types.StringType,
		"description": types.StringType,
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"group_permission": types.ObjectType{
			AttrTypes: groupPermissionObj.AttributeTypes(),
		},
		"igmp": types.ObjectType{
			AttrTypes: igmpObj.AttributeTypes(),
		},
		"pim": types.ObjectType{
			AttrTypes: pimObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupObject) AncestorName() string {
	return "interface-group"
}

func (o VirtualRouterResourceMulticastInterfaceGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) AttributeTypes() map[string]attr.Type {

	var anySourceMulticastObj *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject

	var sourceSpecificMulticastObj *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	return map[string]attr.Type{
		"any_source_multicast": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: anySourceMulticastObj.AttributeTypes(),
			},
		},
		"source_specific_multicast": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: sourceSpecificMulticastObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) AncestorName() string {
	return "group-permission"
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"group_address": types.StringType,
		"included":      types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) AncestorName() string {
	return "any-source-multicast"
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":           types.StringType,
		"group_address":  types.StringType,
		"source_address": types.StringType,
		"included":       types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) AncestorName() string {
	return "source-specific-multicast"
}

func (o VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                     types.BoolType,
		"version":                    types.StringType,
		"max_query_response_time":    types.Float64Type,
		"query_interval":             types.Int64Type,
		"last_member_query_interval": types.Float64Type,
		"immediate_leave":            types.BoolType,
		"robustness":                 types.StringType,
		"max_groups":                 types.StringType,
		"max_sources":                types.StringType,
		"router_alert_policing":      types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupIgmpObject) AncestorName() string {
	return "igmp"
}

func (o VirtualRouterResourceMulticastInterfaceGroupIgmpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) AttributeTypes() map[string]attr.Type {

	var allowedNeighborsObj *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
	return map[string]attr.Type{
		"enable":              types.BoolType,
		"assert_interval":     types.Int64Type,
		"hello_interval":      types.Int64Type,
		"join_prune_interval": types.Int64Type,
		"dr_priority":         types.Int64Type,
		"bsr_border":          types.BoolType,
		"allowed_neighbors": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: allowedNeighborsObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupPimObject) AncestorName() string {
	return "pim"
}

func (o VirtualRouterResourceMulticastInterfaceGroupPimObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) AncestorName() string {
	return "allowed-neighbors"
}

func (o VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastRpObject) AttributeTypes() map[string]attr.Type {

	var externalRpObj *VirtualRouterResourceMulticastRpExternalRpObject

	var localRpObj *VirtualRouterResourceMulticastRpLocalRpObject
	return map[string]attr.Type{
		"external_rp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: externalRpObj.AttributeTypes(),
			},
		},
		"local_rp": types.ObjectType{
			AttrTypes: localRpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceMulticastRpObject) AncestorName() string {
	return "rp"
}

func (o VirtualRouterResourceMulticastRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastRpExternalRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"override": types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastRpExternalRpObject) AncestorName() string {
	return "external-rp"
}

func (o VirtualRouterResourceMulticastRpExternalRpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastRpLocalRpObject) AttributeTypes() map[string]attr.Type {

	var candidateRpObj *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject

	var staticRpObj *VirtualRouterResourceMulticastRpLocalRpStaticRpObject
	return map[string]attr.Type{
		"candidate_rp": types.ObjectType{
			AttrTypes: candidateRpObj.AttributeTypes(),
		},
		"static_rp": types.ObjectType{
			AttrTypes: staticRpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceMulticastRpLocalRpObject) AncestorName() string {
	return "local-rp"
}

func (o VirtualRouterResourceMulticastRpLocalRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"address":                types.StringType,
		"advertisement_interval": types.Int64Type,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.StringType,
		"priority":  types.Int64Type,
	}
}

func (o VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) AncestorName() string {
	return "candidate-rp"
}

func (o VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"address": types.StringType,
		"group_addresses": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.StringType,
		"override":  types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastRpLocalRpStaticRpObject) AncestorName() string {
	return "static-rp"
}

func (o VirtualRouterResourceMulticastRpLocalRpStaticRpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceMulticastSptThresholdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"threshold": types.StringType,
	}
}

func (o VirtualRouterResourceMulticastSptThresholdObject) AncestorName() string {
	return "spt-threshold"
}

func (o VirtualRouterResourceMulticastSptThresholdObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"group_address": types.StringType,
		"included":      types.BoolType,
	}
}

func (o VirtualRouterResourceMulticastSsmAddressSpaceObject) AncestorName() string {
	return "ssm-address-space"
}

func (o VirtualRouterResourceMulticastSsmAddressSpaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolObject) AttributeTypes() map[string]attr.Type {

	var bgpObj *VirtualRouterResourceProtocolBgpObject

	var ospfObj *VirtualRouterResourceProtocolOspfObject

	var ospfv3Obj *VirtualRouterResourceProtocolOspfv3Object

	var redistProfileObj *VirtualRouterResourceProtocolRedistProfileObject

	var redistProfileIpv6Obj *VirtualRouterResourceProtocolRedistProfileIpv6Object

	var ripObj *VirtualRouterResourceProtocolRipObject
	return map[string]attr.Type{
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"redist_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistProfileObj.AttributeTypes(),
			},
		},
		"redist_profile_ipv6": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistProfileIpv6Obj.AttributeTypes(),
			},
		},
		"rip": types.ObjectType{
			AttrTypes: ripObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolObject) AncestorName() string {
	return "protocol"
}

func (o VirtualRouterResourceProtocolObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpObject) AttributeTypes() map[string]attr.Type {

	var authProfileObj *VirtualRouterResourceProtocolBgpAuthProfileObject

	var dampeningProfileObj *VirtualRouterResourceProtocolBgpDampeningProfileObject

	var globalBfdObj *VirtualRouterResourceProtocolBgpGlobalBfdObject

	var peerGroupObj *VirtualRouterResourceProtocolBgpPeerGroupObject

	var policyObj *VirtualRouterResourceProtocolBgpPolicyObject

	var redistRulesObj *VirtualRouterResourceProtocolBgpRedistRulesObject

	var routingOptionsObj *VirtualRouterResourceProtocolBgpRoutingOptionsObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"dampening_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: dampeningProfileObj.AttributeTypes(),
			},
		},
		"ecmp_multi_as":    types.BoolType,
		"enable":           types.BoolType,
		"enforce_first_as": types.BoolType,
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"install_route": types.BoolType,
		"local_as":      types.StringType,
		"peer_group": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerGroupObj.AttributeTypes(),
			},
		},
		"policy": types.ObjectType{
			AttrTypes: policyObj.AttributeTypes(),
		},
		"redist_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: redistRulesObj.AttributeTypes(),
			},
		},
		"reject_default_route": types.BoolType,
		"router_id":            types.StringType,
		"routing_options": types.ObjectType{
			AttrTypes: routingOptionsObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterResourceProtocolBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"secret": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterResourceProtocolBgpAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                        types.StringType,
		"enable":                      types.BoolType,
		"cutoff":                      types.Float64Type,
		"reuse":                       types.Float64Type,
		"max_hold_time":               types.Int64Type,
		"decay_half_life_reachable":   types.Int64Type,
		"decay_half_life_unreachable": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolBgpDampeningProfileObject) AncestorName() string {
	return "dampening-profile"
}

func (o VirtualRouterResourceProtocolBgpDampeningProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterResourceProtocolBgpGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterResourceProtocolBgpPeerGroupTypeObject

	var peerObj *VirtualRouterResourceProtocolBgpPeerGroupPeerObject
	return map[string]attr.Type{
		"name":                        types.StringType,
		"enable":                      types.BoolType,
		"aggregated_confed_as_path":   types.BoolType,
		"soft_reset_with_stored_info": types.BoolType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"peer": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: peerObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupObject) AncestorName() string {
	return "peer-group"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) AttributeTypes() map[string]attr.Type {

	var ibgpObj *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject

	var ebgpConfedObj *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject

	var ibgpConfedObj *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject

	var ebgpObj *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject
	return map[string]attr.Type{
		"ibgp": types.ObjectType{
			AttrTypes: ibgpObj.AttributeTypes(),
		},
		"ebgp_confed": types.ObjectType{
			AttrTypes: ebgpConfedObj.AttributeTypes(),
		},
		"ibgp_confed": types.ObjectType{
			AttrTypes: ibgpConfedObj.AttributeTypes(),
		},
		"ebgp": types.ObjectType{
			AttrTypes: ebgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) AncestorName() string {
	return "ibgp"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) AncestorName() string {
	return "ebgp-confed"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"export_nexthop": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) AncestorName() string {
	return "ibgp-confed"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"import_nexthop":    types.StringType,
		"export_nexthop":    types.StringType,
		"remove_private_as": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) AncestorName() string {
	return "ebgp"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) AttributeTypes() map[string]attr.Type {

	var subsequentAddressFamilyIdentifierObj *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject

	var localAddressObj *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject

	var peerAddressObj *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject

	var connectionOptionsObj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject

	var bfdObj *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject
	return map[string]attr.Type{
		"name":                              types.StringType,
		"enable":                            types.BoolType,
		"peer_as":                           types.StringType,
		"enable_mp_bgp":                     types.BoolType,
		"address_family_identifier":         types.StringType,
		"enable_sender_side_loop_detection": types.BoolType,
		"reflector_client":                  types.StringType,
		"peering_type":                      types.StringType,
		"max_prefixes":                      types.StringType,
		"subsequent_address_family_identifier": types.ObjectType{
			AttrTypes: subsequentAddressFamilyIdentifierObj.AttributeTypes(),
		},
		"local_address": types.ObjectType{
			AttrTypes: localAddressObj.AttributeTypes(),
		},
		"peer_address": types.ObjectType{
			AttrTypes: peerAddressObj.AttributeTypes(),
		},
		"connection_options": types.ObjectType{
			AttrTypes: connectionOptionsObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerObject) AncestorName() string {
	return "peer"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"unicast":   types.BoolType,
		"multicast": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) AncestorName() string {
	return "subsequent-address-family-identifier"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interface": types.StringType,
		"ip":        types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) AncestorName() string {
	return "local-address"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ip":   types.StringType,
		"fqdn": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) AncestorName() string {
	return "peer-address"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) AttributeTypes() map[string]attr.Type {

	var incomingBgpConnectionObj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject

	var outgoingBgpConnectionObj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	return map[string]attr.Type{
		"authentication":         types.StringType,
		"keep_alive_interval":    types.StringType,
		"min_route_adv_interval": types.Int64Type,
		"multihop":               types.Int64Type,
		"open_delay_time":        types.Int64Type,
		"hold_time":              types.StringType,
		"idle_hold_time":         types.Int64Type,
		"incoming_bgp_connection": types.ObjectType{
			AttrTypes: incomingBgpConnectionObj.AttributeTypes(),
		},
		"outgoing_bgp_connection": types.ObjectType{
			AttrTypes: outgoingBgpConnectionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) AncestorName() string {
	return "connection-options"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"remote_port": types.Int64Type,
		"allow":       types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) AncestorName() string {
	return "incoming-bgp-connection"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"local_port": types.Int64Type,
		"allow":      types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) AncestorName() string {
	return "outgoing-bgp-connection"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyObject) AttributeTypes() map[string]attr.Type {

	var aggregationObj *VirtualRouterResourceProtocolBgpPolicyAggregationObject

	var conditionalAdvertisementObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject

	var exportObj *VirtualRouterResourceProtocolBgpPolicyExportObject

	var importObj *VirtualRouterResourceProtocolBgpPolicyImportObject
	return map[string]attr.Type{
		"aggregation": types.ObjectType{
			AttrTypes: aggregationObj.AttributeTypes(),
		},
		"conditional_advertisement": types.ObjectType{
			AttrTypes: conditionalAdvertisementObj.AttributeTypes(),
		},
		"export": types.ObjectType{
			AttrTypes: exportObj.AttributeTypes(),
		},
		"import": types.ObjectType{
			AttrTypes: importObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyObject) AncestorName() string {
	return "policy"
}

func (o VirtualRouterResourceProtocolBgpPolicyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) AttributeTypes() map[string]attr.Type {

	var addressObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
	return map[string]attr.Type{
		"address": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationObject) AncestorName() string {
	return "aggregation"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) AttributeTypes() map[string]attr.Type {

	var aggregateRouteAttributesObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject

	var suppressFiltersObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject

	var advertiseFiltersObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	return map[string]attr.Type{
		"name":    types.StringType,
		"prefix":  types.StringType,
		"enable":  types.BoolType,
		"summary": types.BoolType,
		"as_set":  types.BoolType,
		"aggregate_route_attributes": types.ObjectType{
			AttrTypes: aggregateRouteAttributesObj.AttributeTypes(),
		},
		"suppress_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suppressFiltersObj.AttributeTypes(),
			},
		},
		"advertise_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: advertiseFiltersObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) AncestorName() string {
	return "address"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"weight":           types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) AncestorName() string {
	return "aggregate-route-attributes"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"prepend": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) AncestorName() string {
	return "suppress-filters"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) AncestorName() string {
	return "advertise-filters"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) AttributeTypes() map[string]attr.Type {

	var policyObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	return map[string]attr.Type{
		"policy": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: policyObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) AncestorName() string {
	return "conditional-advertisement"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) AttributeTypes() map[string]attr.Type {

	var nonExistFiltersObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject

	var advertiseFiltersObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"non_exist_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nonExistFiltersObj.AttributeTypes(),
			},
		},
		"advertise_filters": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: advertiseFiltersObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) AncestorName() string {
	return "policy"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) AncestorName() string {
	return "non-exist-filters"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) AncestorName() string {
	return "advertise-filters"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) AttributeTypes() map[string]attr.Type {

	var rulesObj *VirtualRouterResourceProtocolBgpPolicyExportRulesObject
	return map[string]attr.Type{
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportObject) AncestorName() string {
	return "export"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject

	var actionObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesObject) AncestorName() string {
	return "rules"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) AttributeTypes() map[string]attr.Type {

	var denyObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject

	var allowObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject
	return map[string]attr.Type{
		"deny": types.ObjectType{
			AttrTypes: denyObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) AncestorName() string {
	return "deny"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) AttributeTypes() map[string]attr.Type {

	var updateObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	return map[string]attr.Type{
		"update": types.ObjectType{
			AttrTypes: updateObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) AncestorName() string {
	return "update"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject

	var removeObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove": types.ObjectType{
			AttrTypes: removeObj.AttributeTypes(),
		},
		"prepend":            types.Int64Type,
		"remove_and_prepend": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) AncestorName() string {
	return "remove"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) AttributeTypes() map[string]attr.Type {

	var rulesObj *VirtualRouterResourceProtocolBgpPolicyImportRulesObject
	return map[string]attr.Type{
		"rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rulesObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportObject) AncestorName() string {
	return "import"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) AttributeTypes() map[string]attr.Type {

	var matchObj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject

	var actionObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject
	return map[string]attr.Type{
		"name":   types.StringType,
		"enable": types.BoolType,
		"used_by": types.ListType{
			ElemType: types.StringType,
		},
		"match": types.ObjectType{
			AttrTypes: matchObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesObject) AncestorName() string {
	return "rules"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) AttributeTypes() map[string]attr.Type {

	var addressPrefixObj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	return map[string]attr.Type{
		"route_table": types.StringType,
		"med":         types.Int64Type,
		"address_prefix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressPrefixObj.AttributeTypes(),
			},
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"from_peer": types.ListType{
			ElemType: types.StringType,
		},
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) AncestorName() string {
	return "match"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"exact": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) AncestorName() string {
	return "address-prefix"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"regex": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) AttributeTypes() map[string]attr.Type {

	var denyObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject

	var allowObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject
	return map[string]attr.Type{
		"deny": types.ObjectType{
			AttrTypes: denyObj.AttributeTypes(),
		},
		"allow": types.ObjectType{
			AttrTypes: allowObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) AncestorName() string {
	return "deny"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) AttributeTypes() map[string]attr.Type {

	var updateObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	return map[string]attr.Type{
		"dampening": types.StringType,
		"update": types.ObjectType{
			AttrTypes: updateObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) AncestorName() string {
	return "allow"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) AttributeTypes() map[string]attr.Type {

	var asPathObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject

	var communityObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject

	var extendedCommunityObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	return map[string]attr.Type{
		"local_preference": types.Int64Type,
		"med":              types.Int64Type,
		"weight":           types.Int64Type,
		"nexthop":          types.StringType,
		"origin":           types.StringType,
		"as_path_limit":    types.Int64Type,
		"as_path": types.ObjectType{
			AttrTypes: asPathObj.AttributeTypes(),
		},
		"community": types.ObjectType{
			AttrTypes: communityObj.AttributeTypes(),
		},
		"extended_community": types.ObjectType{
			AttrTypes: extendedCommunityObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) AncestorName() string {
	return "update"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject

	var removeObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove": types.ObjectType{
			AttrTypes: removeObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) AncestorName() string {
	return "as-path"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) AncestorName() string {
	return "remove"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) AncestorName() string {
	return "community"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) AttributeTypes() map[string]attr.Type {

	var noneObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject

	var removeAllObj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject

	return map[string]attr.Type{
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
		"remove_all": types.ObjectType{
			AttrTypes: removeAllObj.AttributeTypes(),
		},
		"remove_regex": types.StringType,
		"append": types.ListType{
			ElemType: types.StringType,
		},
		"overwrite": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) AncestorName() string {
	return "extended-community"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) AncestorName() string {
	return "remove-all"
}

func (o VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":                      types.StringType,
		"address_family_identifier": types.StringType,
		"route_table":               types.StringType,
		"enable":                    types.BoolType,
		"set_origin":                types.StringType,
		"set_med":                   types.Int64Type,
		"set_local_preference":      types.Int64Type,
		"set_as_path_limit":         types.Int64Type,
		"metric":                    types.Int64Type,
		"set_community": types.ListType{
			ElemType: types.StringType,
		},
		"set_extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolBgpRedistRulesObject) AncestorName() string {
	return "redist-rules"
}

func (o VirtualRouterResourceProtocolBgpRedistRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) AttributeTypes() map[string]attr.Type {

	var aggregateObj *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject

	var gracefulRestartObj *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject

	var medObj *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject

	return map[string]attr.Type{
		"aggregate": types.ObjectType{
			AttrTypes: aggregateObj.AttributeTypes(),
		},
		"as_format":                types.StringType,
		"confederation_member_as":  types.StringType,
		"default_local_preference": types.Int64Type,
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"med": types.ObjectType{
			AttrTypes: medObj.AttributeTypes(),
		},
		"reflector_cluster_id": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsObject) AncestorName() string {
	return "routing-options"
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"aggregate_med": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) AncestorName() string {
	return "aggregate"
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                types.BoolType,
		"local_restart_time":    types.Int64Type,
		"max_peer_restart_time": types.Int64Type,
		"stale_route_time":      types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"always_compare_med":           types.BoolType,
		"deterministic_med_comparison": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) AncestorName() string {
	return "med"
}

func (o VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfObject) AttributeTypes() map[string]attr.Type {

	var areaObj *VirtualRouterResourceProtocolOspfAreaObject

	var authProfileObj *VirtualRouterResourceProtocolOspfAuthProfileObject

	var exportRulesObj *VirtualRouterResourceProtocolOspfExportRulesObject

	var globalBfdObj *VirtualRouterResourceProtocolOspfGlobalBfdObject

	var gracefulRestartObj *VirtualRouterResourceProtocolOspfGracefulRestartObject

	var timersObj *VirtualRouterResourceProtocolOspfTimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"reject_default_route": types.BoolType,
		"rfc1583":              types.BoolType,
		"router_id":            types.StringType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfObject) AncestorName() string {
	return "ospf"
}

func (o VirtualRouterResourceProtocolOspfObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterResourceProtocolOspfAreaTypeObject

	var rangeObj *VirtualRouterResourceProtocolOspfAreaRangeObject

	var interfaceObj *VirtualRouterResourceProtocolOspfAreaInterfaceObject

	var virtualLinkObj *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
	return map[string]attr.Type{
		"name": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaObject) AncestorName() string {
	return "area"
}

func (o VirtualRouterResourceProtocolOspfAreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *VirtualRouterResourceProtocolOspfAreaTypeNormalObject

	var stubObj *VirtualRouterResourceProtocolOspfAreaTypeStubObject

	var nssaObj *VirtualRouterResourceProtocolOspfAreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject

	var advertiseObj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject

	var nssaExtRangeObj *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject

	var advertiseObj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
		"type":   types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject

	var suppressObj *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject

	var suppressObj *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaRangeObject) AncestorName() string {
	return "range"
}

func (o VirtualRouterResourceProtocolOspfAreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject

	var neighborObj *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject

	var bfdObj *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable":              types.BoolType,
		"passive":             types.BoolType,
		"metric":              types.Int64Type,
		"priority":            types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"gr_delay":            types.Int64Type,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject

	var p2pObj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject

	var p2mpObj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"neighbor_id":         types.StringType,
		"transit_area_id":     types.StringType,
		"enable":              types.BoolType,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterResourceProtocolOspfAuthProfileMd5Object
	return map[string]attr.Type{
		"name":     types.StringType,
		"password": types.StringType,
		"md5": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: md5Obj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolOspfAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterResourceProtocolOspfAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"key":       types.StringType,
		"preferred": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolOspfAuthProfileMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterResourceProtocolOspfAuthProfileMd5Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"new_path_type": types.StringType,
		"new_tag":       types.StringType,
		"metric":        types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterResourceProtocolOspfExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterResourceProtocolOspfGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
		"strict_l_s_a_checking":     types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolOspfGracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterResourceProtocolOspfGracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfTimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lsa_interval":          types.Float64Type,
		"spf_calculation_delay": types.Float64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfTimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterResourceProtocolOspfTimersObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3Object) AttributeTypes() map[string]attr.Type {

	var areaObj *VirtualRouterResourceProtocolOspfv3AreaObject

	var authProfileObj *VirtualRouterResourceProtocolOspfv3AuthProfileObject

	var exportRulesObj *VirtualRouterResourceProtocolOspfv3ExportRulesObject

	var globalBfdObj *VirtualRouterResourceProtocolOspfv3GlobalBfdObject

	var gracefulRestartObj *VirtualRouterResourceProtocolOspfv3GracefulRestartObject

	var timersObj *VirtualRouterResourceProtocolOspfv3TimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"area": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: areaObj.AttributeTypes(),
			},
		},
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"disable_transit_traffic": types.BoolType,
		"enable":                  types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"graceful_restart": types.ObjectType{
			AttrTypes: gracefulRestartObj.AttributeTypes(),
		},
		"reject_default_route": types.BoolType,
		"router_id":            types.StringType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o VirtualRouterResourceProtocolOspfv3Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaObject) AttributeTypes() map[string]attr.Type {

	var typeObj *VirtualRouterResourceProtocolOspfv3AreaTypeObject

	var rangeObj *VirtualRouterResourceProtocolOspfv3AreaRangeObject

	var interfaceObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject

	var virtualLinkObj *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"authentication": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
		"range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: rangeObj.AttributeTypes(),
			},
		},
		"interface": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfaceObj.AttributeTypes(),
			},
		},
		"virtual_link": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: virtualLinkObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaObject) AncestorName() string {
	return "area"
}

func (o VirtualRouterResourceProtocolOspfv3AreaObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) AttributeTypes() map[string]attr.Type {

	var normalObj *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject

	var stubObj *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject

	var nssaObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject
	return map[string]attr.Type{
		"normal": types.ObjectType{
			AttrTypes: normalObj.AttributeTypes(),
		},
		"stub": types.ObjectType{
			AttrTypes: stubObj.AttributeTypes(),
		},
		"nssa": types.ObjectType{
			AttrTypes: nssaObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeObject) AncestorName() string {
	return "type"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) AncestorName() string {
	return "normal"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) AncestorName() string {
	return "stub"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject

	var advertiseObj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject

	var nssaExtRangeObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	return map[string]attr.Type{
		"accept_summary": types.BoolType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"nssa_ext_range": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: nssaExtRangeObj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) AncestorName() string {
	return "nssa"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject

	var advertiseObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
		"type":   types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject

	var suppressObj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) AncestorName() string {
	return "nssa-ext-range"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject

	var suppressObj *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject
	return map[string]attr.Type{
		"name": types.StringType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
		"suppress": types.ObjectType{
			AttrTypes: suppressObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeObject) AncestorName() string {
	return "range"
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) AncestorName() string {
	return "suppress"
}

func (o VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) AttributeTypes() map[string]attr.Type {

	var linkTypeObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject

	var neighborObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject

	var bfdObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable":              types.BoolType,
		"instance_id":         types.Int64Type,
		"passive":             types.BoolType,
		"metric":              types.Int64Type,
		"priority":            types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"gr_delay":            types.Int64Type,
		"link_type": types.ObjectType{
			AttrTypes: linkTypeObj.AttributeTypes(),
		},
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) AncestorName() string {
	return "interface"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) AttributeTypes() map[string]attr.Type {

	var broadcastObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject

	var p2pObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject

	var p2mpObj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	return map[string]attr.Type{
		"broadcast": types.ObjectType{
			AttrTypes: broadcastObj.AttributeTypes(),
		},
		"p2p": types.ObjectType{
			AttrTypes: p2pObj.AttributeTypes(),
		},
		"p2mp": types.ObjectType{
			AttrTypes: p2mpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) AncestorName() string {
	return "link-type"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) AncestorName() string {
	return "broadcast"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) AncestorName() string {
	return "p2p"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) AncestorName() string {
	return "p2mp"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) AttributeTypes() map[string]attr.Type {

	var bfdObj *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"neighbor_id":         types.StringType,
		"transit_area_id":     types.StringType,
		"enable":              types.BoolType,
		"instance_id":         types.Int64Type,
		"hello_interval":      types.Int64Type,
		"dead_counts":         types.Int64Type,
		"retransmit_interval": types.Int64Type,
		"transit_delay":       types.Int64Type,
		"authentication":      types.StringType,
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) AncestorName() string {
	return "virtual-link"
}

func (o VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) AttributeTypes() map[string]attr.Type {

	var espObj *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject

	var ahObj *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject
	return map[string]attr.Type{
		"name": types.StringType,
		"spi":  types.StringType,
		"esp": types.ObjectType{
			AttrTypes: espObj.AttributeTypes(),
		},
		"ah": types.ObjectType{
			AttrTypes: ahObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) AttributeTypes() map[string]attr.Type {

	var authenticationObj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject

	var encryptionObj *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject
	return map[string]attr.Type{
		"authentication": types.ObjectType{
			AttrTypes: authenticationObj.AttributeTypes(),
		},
		"encryption": types.ObjectType{
			AttrTypes: encryptionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) AncestorName() string {
	return "esp"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object

	var sha1Obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object

	var sha256Obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object

	var sha384Obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object

	var sha512Obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object

	var noneObj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
		"none": types.ObjectType{
			AttrTypes: noneObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) AncestorName() string {
	return "authentication"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) AncestorName() string {
	return "sha1"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) AncestorName() string {
	return "sha256"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) AncestorName() string {
	return "sha384"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) AncestorName() string {
	return "sha512"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) AncestorName() string {
	return "none"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"algorithm": types.StringType,
		"key":       types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) AncestorName() string {
	return "encryption"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object

	var sha1Obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object

	var sha256Obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object

	var sha384Obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object

	var sha512Obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object
	return map[string]attr.Type{
		"md5": types.ObjectType{
			AttrTypes: md5Obj.AttributeTypes(),
		},
		"sha1": types.ObjectType{
			AttrTypes: sha1Obj.AttributeTypes(),
		},
		"sha256": types.ObjectType{
			AttrTypes: sha256Obj.AttributeTypes(),
		},
		"sha384": types.ObjectType{
			AttrTypes: sha384Obj.AttributeTypes(),
		},
		"sha512": types.ObjectType{
			AttrTypes: sha512Obj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) AncestorName() string {
	return "ah"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) AncestorName() string {
	return "sha1"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) AncestorName() string {
	return "sha256"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) AncestorName() string {
	return "sha384"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"key": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) AncestorName() string {
	return "sha512"
}

func (o VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"new_path_type": types.StringType,
		"new_tag":       types.StringType,
		"metric":        types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfv3ExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterResourceProtocolOspfv3ExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3GlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterResourceProtocolOspfv3GlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                    types.BoolType,
		"grace_period":              types.Int64Type,
		"helper_enable":             types.BoolType,
		"max_neighbor_restart_time": types.Int64Type,
		"strict_l_s_a_checking":     types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolOspfv3GracefulRestartObject) AncestorName() string {
	return "graceful-restart"
}

func (o VirtualRouterResourceProtocolOspfv3GracefulRestartObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolOspfv3TimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"lsa_interval":          types.Float64Type,
		"spf_calculation_delay": types.Float64Type,
	}
}

func (o VirtualRouterResourceProtocolOspfv3TimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterResourceProtocolOspfv3TimersObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileObject) AttributeTypes() map[string]attr.Type {

	var filterObj *VirtualRouterResourceProtocolRedistProfileFilterObject

	var actionObj *VirtualRouterResourceProtocolRedistProfileActionObject
	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
		"filter": types.ObjectType{
			AttrTypes: filterObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileObject) AncestorName() string {
	return "redist-profile"
}

func (o VirtualRouterResourceProtocolRedistProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) AttributeTypes() map[string]attr.Type {

	var ospfObj *VirtualRouterResourceProtocolRedistProfileFilterOspfObject

	var bgpObj *VirtualRouterResourceProtocolRedistProfileFilterBgpObject
	return map[string]attr.Type{
		"type": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"destination": types.ListType{
			ElemType: types.StringType,
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"ospf": types.ObjectType{
			AttrTypes: ospfObj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileFilterObject) AncestorName() string {
	return "filter"
}

func (o VirtualRouterResourceProtocolRedistProfileFilterObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"path_type": types.ListType{
			ElemType: types.StringType,
		},
		"area": types.ListType{
			ElemType: types.StringType,
		},
		"tag": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileFilterOspfObject) AncestorName() string {
	return "ospf"
}

func (o VirtualRouterResourceProtocolRedistProfileFilterOspfObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"community": types.ListType{
			ElemType: types.StringType,
		},
		"extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileFilterBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterResourceProtocolRedistProfileFilterBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileActionObject) AttributeTypes() map[string]attr.Type {

	var noRedistObj *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject

	var redistObj *VirtualRouterResourceProtocolRedistProfileActionRedistObject
	return map[string]attr.Type{
		"no_redist": types.ObjectType{
			AttrTypes: noRedistObj.AttributeTypes(),
		},
		"redist": types.ObjectType{
			AttrTypes: redistObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterResourceProtocolRedistProfileActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) AncestorName() string {
	return "no-redist"
}

func (o VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolRedistProfileActionRedistObject) AncestorName() string {
	return "redist"
}

func (o VirtualRouterResourceProtocolRedistProfileActionRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) AttributeTypes() map[string]attr.Type {

	var filterObj *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject

	var actionObj *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject
	return map[string]attr.Type{
		"name":     types.StringType,
		"priority": types.Int64Type,
		"filter": types.ObjectType{
			AttrTypes: filterObj.AttributeTypes(),
		},
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6Object) AncestorName() string {
	return "redist-profile-ipv6"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) AttributeTypes() map[string]attr.Type {

	var ospfv3Obj *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object

	var bgpObj *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject
	return map[string]attr.Type{
		"type": types.ListType{
			ElemType: types.StringType,
		},
		"interface": types.ListType{
			ElemType: types.StringType,
		},
		"destination": types.ListType{
			ElemType: types.StringType,
		},
		"nexthop": types.ListType{
			ElemType: types.StringType,
		},
		"ospfv3": types.ObjectType{
			AttrTypes: ospfv3Obj.AttributeTypes(),
		},
		"bgp": types.ObjectType{
			AttrTypes: bgpObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) AncestorName() string {
	return "filter"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"path_type": types.ListType{
			ElemType: types.StringType,
		},
		"area": types.ListType{
			ElemType: types.StringType,
		},
		"tag": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) AncestorName() string {
	return "ospfv3"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"community": types.ListType{
			ElemType: types.StringType,
		},
		"extended_community": types.ListType{
			ElemType: types.StringType,
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) AncestorName() string {
	return "bgp"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) AttributeTypes() map[string]attr.Type {

	var noRedistObj *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject

	var redistObj *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject
	return map[string]attr.Type{
		"no_redist": types.ObjectType{
			AttrTypes: noRedistObj.AttributeTypes(),
		},
		"redist": types.ObjectType{
			AttrTypes: redistObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) AncestorName() string {
	return "action"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) AncestorName() string {
	return "no-redist"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) AncestorName() string {
	return "redist"
}

func (o VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipObject) AttributeTypes() map[string]attr.Type {

	var authProfileObj *VirtualRouterResourceProtocolRipAuthProfileObject

	var exportRulesObj *VirtualRouterResourceProtocolRipExportRulesObject

	var globalBfdObj *VirtualRouterResourceProtocolRipGlobalBfdObject

	var interfacesObj *VirtualRouterResourceProtocolRipInterfacesObject

	var timersObj *VirtualRouterResourceProtocolRipTimersObject
	return map[string]attr.Type{
		"allow_redist_default_route": types.BoolType,
		"auth_profile": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: authProfileObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"export_rules": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: exportRulesObj.AttributeTypes(),
			},
		},
		"global_bfd": types.ObjectType{
			AttrTypes: globalBfdObj.AttributeTypes(),
		},
		"interfaces": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: interfacesObj.AttributeTypes(),
			},
		},
		"reject_default_route": types.BoolType,
		"timers": types.ObjectType{
			AttrTypes: timersObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRipObject) AncestorName() string {
	return "rip"
}

func (o VirtualRouterResourceProtocolRipObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipAuthProfileObject) AttributeTypes() map[string]attr.Type {

	var md5Obj *VirtualRouterResourceProtocolRipAuthProfileMd5Object
	return map[string]attr.Type{
		"name":     types.StringType,
		"password": types.StringType,
		"md5": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: md5Obj.AttributeTypes(),
			},
		},
	}
}

func (o VirtualRouterResourceProtocolRipAuthProfileObject) AncestorName() string {
	return "auth-profile"
}

func (o VirtualRouterResourceProtocolRipAuthProfileObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":      types.StringType,
		"key":       types.StringType,
		"preferred": types.BoolType,
	}
}

func (o VirtualRouterResourceProtocolRipAuthProfileMd5Object) AncestorName() string {
	return "md5"
}

func (o VirtualRouterResourceProtocolRipAuthProfileMd5Object) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRipExportRulesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolRipExportRulesObject) AncestorName() string {
	return "export-rules"
}

func (o VirtualRouterResourceProtocolRipExportRulesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolRipGlobalBfdObject) AncestorName() string {
	return "global-bfd"
}

func (o VirtualRouterResourceProtocolRipGlobalBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipInterfacesObject) AttributeTypes() map[string]attr.Type {

	var defaultRouteObj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject

	var bfdObj *VirtualRouterResourceProtocolRipInterfacesBfdObject
	return map[string]attr.Type{
		"name":           types.StringType,
		"enable":         types.BoolType,
		"authentication": types.StringType,
		"mode":           types.StringType,
		"default_route": types.ObjectType{
			AttrTypes: defaultRouteObj.AttributeTypes(),
		},
		"bfd": types.ObjectType{
			AttrTypes: bfdObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRipInterfacesObject) AncestorName() string {
	return "interfaces"
}

func (o VirtualRouterResourceProtocolRipInterfacesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) AttributeTypes() map[string]attr.Type {

	var disableObj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject

	var advertiseObj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	return map[string]attr.Type{
		"disable": types.ObjectType{
			AttrTypes: disableObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) AncestorName() string {
	return "default-route"
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) AncestorName() string {
	return "disable"
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"metric": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"profile": types.StringType,
	}
}

func (o VirtualRouterResourceProtocolRipInterfacesBfdObject) AncestorName() string {
	return "bfd"
}

func (o VirtualRouterResourceProtocolRipInterfacesBfdObject) EntryName() *string {
	return nil
}
func (o *VirtualRouterResourceProtocolRipTimersObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"delete_intervals": types.Int64Type,
		"expire_intervals": types.Int64Type,
		"interval_seconds": types.Int64Type,
		"update_intervals": types.Int64Type,
	}
}

func (o VirtualRouterResourceProtocolRipTimersObject) AncestorName() string {
	return "timers"
}

func (o VirtualRouterResourceProtocolRipTimersObject) EntryName() *string {
	return nil
}

func (o *VirtualRouterResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var administrativeDistances_entry *virtual_router.AdminDists
	if !o.AdministrativeDistances.IsUnknown() && !o.AdministrativeDistances.IsNull() {
		if *obj != nil && (*obj).AdminDists != nil {
			administrativeDistances_entry = (*obj).AdminDists
		} else {
			administrativeDistances_entry = new(virtual_router.AdminDists)
		}
		var object *VirtualRouterResourceAdministrativeDistancesObject
		diags.Append(o.AdministrativeDistances.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &administrativeDistances_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ecmp_entry *virtual_router.Ecmp
	if !o.Ecmp.IsUnknown() && !o.Ecmp.IsNull() {
		if *obj != nil && (*obj).Ecmp != nil {
			ecmp_entry = (*obj).Ecmp
		} else {
			ecmp_entry = new(virtual_router.Ecmp)
		}
		var object *VirtualRouterResourceEcmpObject
		diags.Append(o.Ecmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ecmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_pango_entries []string
	if !o.Interfaces.IsUnknown() && !o.Interfaces.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interfaces.Elements()))
		diags.Append(o.Interfaces.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interfaces_pango_entries = append(interfaces_pango_entries, elt.ValueString())
		}
	}
	var multicast_entry *virtual_router.Multicast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(virtual_router.Multicast)
		}
		var object *VirtualRouterResourceMulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var protocol_entry *virtual_router.Protocol
	if !o.Protocol.IsUnknown() && !o.Protocol.IsNull() {
		if *obj != nil && (*obj).Protocol != nil {
			protocol_entry = (*obj).Protocol
		} else {
			protocol_entry = new(virtual_router.Protocol)
		}
		var object *VirtualRouterResourceProtocolObject
		diags.Append(o.Protocol.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &protocol_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AdminDists = administrativeDistances_entry
	(*obj).Ecmp = ecmp_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).Multicast = multicast_entry
	(*obj).Protocol = protocol_entry

	return diags
}
func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.AdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ebgp_value := o.Ebgp.ValueInt64Pointer()
	ibgp_value := o.Ibgp.ValueInt64Pointer()
	ospfExt_value := o.OspfExt.ValueInt64Pointer()
	ospfInt_value := o.OspfInt.ValueInt64Pointer()
	ospfv3Ext_value := o.Ospfv3Ext.ValueInt64Pointer()
	ospfv3Int_value := o.Ospfv3Int.ValueInt64Pointer()
	rip_value := o.Rip.ValueInt64Pointer()
	static_value := o.Static.ValueInt64Pointer()
	staticIpv6_value := o.StaticIpv6.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.AdminDists)
	}
	(*obj).Ebgp = ebgp_value
	(*obj).Ibgp = ibgp_value
	(*obj).OspfExt = ospfExt_value
	(*obj).OspfInt = ospfInt_value
	(*obj).Ospfv3Ext = ospfv3Ext_value
	(*obj).Ospfv3Int = ospfv3Int_value
	(*obj).Rip = rip_value
	(*obj).Static = static_value
	(*obj).StaticIpv6 = staticIpv6_value

	return diags
}
func (o *VirtualRouterResourceEcmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Ecmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var algorithm_entry *virtual_router.EcmpAlgorithm
	if !o.Algorithm.IsUnknown() && !o.Algorithm.IsNull() {
		if *obj != nil && (*obj).Algorithm != nil {
			algorithm_entry = (*obj).Algorithm
		} else {
			algorithm_entry = new(virtual_router.EcmpAlgorithm)
		}
		var object *VirtualRouterResourceEcmpAlgorithmObject
		diags.Append(o.Algorithm.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &algorithm_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	maxPaths_value := o.MaxPaths.ValueInt64Pointer()
	strictSourcePath_value := o.StrictSourcePath.ValueBoolPointer()
	symmetricReturn_value := o.SymmetricReturn.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.Ecmp)
	}
	(*obj).Algorithm = algorithm_entry
	(*obj).Enable = enable_value
	(*obj).MaxPath = maxPaths_value
	(*obj).StrictSourcePath = strictSourcePath_value
	(*obj).SymmetricReturn = symmetricReturn_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var balancedRoundRobin_entry *virtual_router.EcmpAlgorithmBalancedRoundRobin
	if !o.BalancedRoundRobin.IsUnknown() && !o.BalancedRoundRobin.IsNull() {
		if *obj != nil && (*obj).BalancedRoundRobin != nil {
			balancedRoundRobin_entry = (*obj).BalancedRoundRobin
		} else {
			balancedRoundRobin_entry = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
		}
		var object *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject
		diags.Append(o.BalancedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &balancedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipHash_entry *virtual_router.EcmpAlgorithmIpHash
	if !o.IpHash.IsUnknown() && !o.IpHash.IsNull() {
		if *obj != nil && (*obj).IpHash != nil {
			ipHash_entry = (*obj).IpHash
		} else {
			ipHash_entry = new(virtual_router.EcmpAlgorithmIpHash)
		}
		var object *VirtualRouterResourceEcmpAlgorithmIpHashObject
		diags.Append(o.IpHash.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipHash_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipModulo_entry *virtual_router.EcmpAlgorithmIpModulo
	if !o.IpModulo.IsUnknown() && !o.IpModulo.IsNull() {
		if *obj != nil && (*obj).IpModulo != nil {
			ipModulo_entry = (*obj).IpModulo
		} else {
			ipModulo_entry = new(virtual_router.EcmpAlgorithmIpModulo)
		}
		var object *VirtualRouterResourceEcmpAlgorithmIpModuloObject
		diags.Append(o.IpModulo.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipModulo_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var weightedRoundRobin_entry *virtual_router.EcmpAlgorithmWeightedRoundRobin
	if !o.WeightedRoundRobin.IsUnknown() && !o.WeightedRoundRobin.IsNull() {
		if *obj != nil && (*obj).WeightedRoundRobin != nil {
			weightedRoundRobin_entry = (*obj).WeightedRoundRobin
		} else {
			weightedRoundRobin_entry = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
		}
		var object *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject
		diags.Append(o.WeightedRoundRobin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &weightedRoundRobin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithm)
	}
	(*obj).BalancedRoundRobin = balancedRoundRobin_entry
	(*obj).IpHash = ipHash_entry
	(*obj).IpModulo = ipModulo_entry
	(*obj).WeightedRoundRobin = weightedRoundRobin_entry

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmBalancedRoundRobin)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hashSeed_value := o.HashSeed.ValueInt64Pointer()
	srcOnly_value := o.SrcOnly.ValueBoolPointer()
	usePort_value := o.UsePort.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpHash)
	}
	(*obj).HashSeed = hashSeed_value
	(*obj).SrcOnly = srcOnly_value
	(*obj).UsePort = usePort_value

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmIpModulo)
	}

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
	var interface_pango_entries []virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobin)
	}
	(*obj).Interface = interface_pango_entries

	return diags
}
func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	weight_value := o.Weight.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.EcmpAlgorithmWeightedRoundRobinInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Weight = weight_value

	return diags
}
func (o *VirtualRouterResourceMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var interfaceGroup_tf_entries []VirtualRouterResourceMulticastInterfaceGroupObject
	var interfaceGroup_pango_entries []virtual_router.MulticastInterfaceGroup
	{
		d := o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaceGroup_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaceGroup_pango_entries = append(interfaceGroup_pango_entries, *entry)
		}
	}
	routeAgeoutTime_value := o.RouteAgeoutTime.ValueInt64Pointer()
	var rp_entry *virtual_router.MulticastRp
	if !o.Rp.IsUnknown() && !o.Rp.IsNull() {
		if *obj != nil && (*obj).Rp != nil {
			rp_entry = (*obj).Rp
		} else {
			rp_entry = new(virtual_router.MulticastRp)
		}
		var object *VirtualRouterResourceMulticastRpObject
		diags.Append(o.Rp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sptThreshold_tf_entries []VirtualRouterResourceMulticastSptThresholdObject
	var sptThreshold_pango_entries []virtual_router.MulticastSptThreshold
	{
		d := o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sptThreshold_tf_entries {
			var entry *virtual_router.MulticastSptThreshold
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sptThreshold_pango_entries = append(sptThreshold_pango_entries, *entry)
		}
	}
	var ssmAddressSpace_tf_entries []VirtualRouterResourceMulticastSsmAddressSpaceObject
	var ssmAddressSpace_pango_entries []virtual_router.MulticastSsmAddressSpace
	{
		d := o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ssmAddressSpace_tf_entries {
			var entry *virtual_router.MulticastSsmAddressSpace
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ssmAddressSpace_pango_entries = append(ssmAddressSpace_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Multicast)
	}
	(*obj).Enable = enable_value
	(*obj).InterfaceGroup = interfaceGroup_pango_entries
	(*obj).RouteAgeoutTime = routeAgeoutTime_value
	(*obj).Rp = rp_entry
	(*obj).SptThreshold = sptThreshold_pango_entries
	(*obj).SsmAddressSpace = ssmAddressSpace_pango_entries

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var groupPermission_entry *virtual_router.MulticastInterfaceGroupGroupPermission
	if !o.GroupPermission.IsUnknown() && !o.GroupPermission.IsNull() {
		if *obj != nil && (*obj).GroupPermission != nil {
			groupPermission_entry = (*obj).GroupPermission
		} else {
			groupPermission_entry = new(virtual_router.MulticastInterfaceGroupGroupPermission)
		}
		var object *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject
		diags.Append(o.GroupPermission.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &groupPermission_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var igmp_entry *virtual_router.MulticastInterfaceGroupIgmp
	if !o.Igmp.IsUnknown() && !o.Igmp.IsNull() {
		if *obj != nil && (*obj).Igmp != nil {
			igmp_entry = (*obj).Igmp
		} else {
			igmp_entry = new(virtual_router.MulticastInterfaceGroupIgmp)
		}
		var object *VirtualRouterResourceMulticastInterfaceGroupIgmpObject
		diags.Append(o.Igmp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &igmp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var pim_entry *virtual_router.MulticastInterfaceGroupPim
	if !o.Pim.IsUnknown() && !o.Pim.IsNull() {
		if *obj != nil && (*obj).Pim != nil {
			pim_entry = (*obj).Pim
		} else {
			pim_entry = new(virtual_router.MulticastInterfaceGroupPim)
		}
		var object *VirtualRouterResourceMulticastInterfaceGroupPimObject
		diags.Append(o.Pim.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pim_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Description = description_value
	(*obj).Interface = interface_pango_entries
	(*obj).GroupPermission = groupPermission_entry
	(*obj).Igmp = igmp_entry
	(*obj).Pim = pim_entry

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermission, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
	var anySourceMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
	{
		d := o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range anySourceMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			anySourceMulticast_pango_entries = append(anySourceMulticast_pango_entries, *entry)
		}
	}
	var sourceSpecificMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
	var sourceSpecificMulticast_pango_entries []virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
	{
		d := o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range sourceSpecificMulticast_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			sourceSpecificMulticast_pango_entries = append(sourceSpecificMulticast_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermission)
	}
	(*obj).AnySourceMulticast = anySourceMulticast_pango_entries
	(*obj).SourceSpecificMulticast = sourceSpecificMulticast_pango_entries

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	sourceAddress_value := o.SourceAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).SourceAddress = sourceAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	version_value := o.Version.ValueStringPointer()
	maxQueryResponseTime_value := o.MaxQueryResponseTime.ValueFloat64Pointer()
	queryInterval_value := o.QueryInterval.ValueInt64Pointer()
	lastMemberQueryInterval_value := o.LastMemberQueryInterval.ValueFloat64Pointer()
	immediateLeave_value := o.ImmediateLeave.ValueBoolPointer()
	robustness_value := o.Robustness.ValueStringPointer()
	maxGroups_value := o.MaxGroups.ValueStringPointer()
	maxSources_value := o.MaxSources.ValueStringPointer()
	routerAlertPolicing_value := o.RouterAlertPolicing.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupIgmp)
	}
	(*obj).Enable = enable_value
	(*obj).Version = version_value
	(*obj).MaxQueryResponseTime = maxQueryResponseTime_value
	(*obj).QueryInterval = queryInterval_value
	(*obj).LastMemberQueryInterval = lastMemberQueryInterval_value
	(*obj).ImmediateLeave = immediateLeave_value
	(*obj).Robustness = robustness_value
	(*obj).MaxGroups = maxGroups_value
	(*obj).MaxSources = maxSources_value
	(*obj).RouterAlertPolicing = routerAlertPolicing_value

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	assertInterval_value := o.AssertInterval.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	joinPruneInterval_value := o.JoinPruneInterval.ValueInt64Pointer()
	drPriority_value := o.DrPriority.ValueInt64Pointer()
	bsrBorder_value := o.BsrBorder.ValueBoolPointer()
	var allowedNeighbors_tf_entries []VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
	var allowedNeighbors_pango_entries []virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
	{
		d := o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range allowedNeighbors_tf_entries {
			var entry *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			allowedNeighbors_pango_entries = append(allowedNeighbors_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPim)
	}
	(*obj).Enable = enable_value
	(*obj).AssertInterval = assertInterval_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).JoinPruneInterval = joinPruneInterval_value
	(*obj).DrPriority = drPriority_value
	(*obj).BsrBorder = bsrBorder_value
	(*obj).AllowedNeighbors = allowedNeighbors_pango_entries

	return diags
}
func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastInterfaceGroupPimAllowedNeighbors)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceMulticastRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_tf_entries []VirtualRouterResourceMulticastRpExternalRpObject
	var externalRp_pango_entries []virtual_router.MulticastRpExternalRp
	{
		d := o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range externalRp_tf_entries {
			var entry *virtual_router.MulticastRpExternalRp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			externalRp_pango_entries = append(externalRp_pango_entries, *entry)
		}
	}
	var localRp_entry *virtual_router.MulticastRpLocalRp
	if !o.LocalRp.IsUnknown() && !o.LocalRp.IsNull() {
		if *obj != nil && (*obj).LocalRp != nil {
			localRp_entry = (*obj).LocalRp
		} else {
			localRp_entry = new(virtual_router.MulticastRpLocalRp)
		}
		var object *VirtualRouterResourceMulticastRpLocalRpObject
		diags.Append(o.LocalRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRp)
	}
	(*obj).ExternalRp = externalRp_pango_entries
	(*obj).LocalRp = localRp_entry

	return diags
}
func (o *VirtualRouterResourceMulticastRpExternalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpExternalRp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var candidateRp_entry *virtual_router.MulticastRpLocalRpCandidateRp
	if !o.CandidateRp.IsUnknown() && !o.CandidateRp.IsNull() {
		if *obj != nil && (*obj).CandidateRp != nil {
			candidateRp_entry = (*obj).CandidateRp
		} else {
			candidateRp_entry = new(virtual_router.MulticastRpLocalRpCandidateRp)
		}
		var object *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject
		diags.Append(o.CandidateRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &candidateRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticRp_entry *virtual_router.MulticastRpLocalRpStaticRp
	if !o.StaticRp.IsUnknown() && !o.StaticRp.IsNull() {
		if *obj != nil && (*obj).StaticRp != nil {
			staticRp_entry = (*obj).StaticRp
		} else {
			staticRp_entry = new(virtual_router.MulticastRpLocalRpStaticRp)
		}
		var object *VirtualRouterResourceMulticastRpLocalRpStaticRpObject
		diags.Append(o.StaticRp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticRp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRp)
	}
	(*obj).CandidateRp = candidateRp_entry
	(*obj).StaticRp = staticRp_entry

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	advertisementInterval_value := o.AdvertisementInterval.ValueInt64Pointer()
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	interface_value := o.Interface.ValueStringPointer()
	priority_value := o.Priority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpCandidateRp)
	}
	(*obj).Address = address_value
	(*obj).AdvertisementInterval = advertisementInterval_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Priority = priority_value

	return diags
}
func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	address_value := o.Address.ValueStringPointer()
	var groupAddresses_pango_entries []string
	if !o.GroupAddresses.IsUnknown() && !o.GroupAddresses.IsNull() {
		object_entries := make([]types.String, 0, len(o.GroupAddresses.Elements()))
		diags.Append(o.GroupAddresses.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			groupAddresses_pango_entries = append(groupAddresses_pango_entries, elt.ValueString())
		}
	}
	interface_value := o.Interface.ValueStringPointer()
	override_value := o.Override.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastRpLocalRpStaticRp)
	}
	(*obj).Address = address_value
	(*obj).GroupAddresses = groupAddresses_pango_entries
	(*obj).Interface = interface_value
	(*obj).Override = override_value

	return diags
}
func (o *VirtualRouterResourceMulticastSptThresholdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	threshold_value := o.Threshold.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSptThreshold)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Threshold = threshold_value

	return diags
}
func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.MulticastSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	groupAddress_value := o.GroupAddress.ValueStringPointer()
	included_value := o.Included.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.MulticastSsmAddressSpace)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).GroupAddress = groupAddress_value
	(*obj).Included = included_value

	return diags
}
func (o *VirtualRouterResourceProtocolObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var bgp_entry *virtual_router.ProtocolBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolBgp)
		}
		var object *VirtualRouterResourceProtocolBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospf_entry *virtual_router.ProtocolOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolOspf)
		}
		var object *VirtualRouterResourceProtocolOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ospfv3_entry *virtual_router.ProtocolOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolOspfv3)
		}
		var object *VirtualRouterResourceProtocolOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistProfile_tf_entries []VirtualRouterResourceProtocolRedistProfileObject
	var redistProfile_pango_entries []virtual_router.ProtocolRedistProfile
	{
		d := o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfile_tf_entries {
			var entry *virtual_router.ProtocolRedistProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistProfile_pango_entries = append(redistProfile_pango_entries, *entry)
		}
	}
	var redistProfileIpv6_tf_entries []VirtualRouterResourceProtocolRedistProfileIpv6Object
	var redistProfileIpv6_pango_entries []virtual_router.ProtocolRedistProfileIpv6
	{
		d := o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistProfileIpv6_tf_entries {
			var entry *virtual_router.ProtocolRedistProfileIpv6
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistProfileIpv6_pango_entries = append(redistProfileIpv6_pango_entries, *entry)
		}
	}
	var rip_entry *virtual_router.ProtocolRip
	if !o.Rip.IsUnknown() && !o.Rip.IsNull() {
		if *obj != nil && (*obj).Rip != nil {
			rip_entry = (*obj).Rip
		} else {
			rip_entry = new(virtual_router.ProtocolRip)
		}
		var object *VirtualRouterResourceProtocolRipObject
		diags.Append(o.Rip.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &rip_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.Protocol)
	}
	(*obj).Bgp = bgp_entry
	(*obj).Ospf = ospf_entry
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).RedistProfile = redistProfile_pango_entries
	(*obj).RedistProfileIpv6 = redistProfileIpv6_pango_entries
	(*obj).Rip = rip_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterResourceProtocolBgpAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolBgpAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	var dampeningProfile_tf_entries []VirtualRouterResourceProtocolBgpDampeningProfileObject
	var dampeningProfile_pango_entries []virtual_router.ProtocolBgpDampeningProfile
	{
		d := o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range dampeningProfile_tf_entries {
			var entry *virtual_router.ProtocolBgpDampeningProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			dampeningProfile_pango_entries = append(dampeningProfile_pango_entries, *entry)
		}
	}
	ecmpMultiAs_value := o.EcmpMultiAs.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	enforceFirstAs_value := o.EnforceFirstAs.ValueBoolPointer()
	var globalBfd_entry *virtual_router.ProtocolBgpGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolBgpGlobalBfd)
		}
		var object *VirtualRouterResourceProtocolBgpGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	installRoute_value := o.InstallRoute.ValueBoolPointer()
	localAs_value := o.LocalAs.ValueStringPointer()
	var peerGroup_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupObject
	var peerGroup_pango_entries []virtual_router.ProtocolBgpPeerGroup
	{
		d := o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peerGroup_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroup
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peerGroup_pango_entries = append(peerGroup_pango_entries, *entry)
		}
	}
	var policy_entry *virtual_router.ProtocolBgpPolicy
	if !o.Policy.IsUnknown() && !o.Policy.IsNull() {
		if *obj != nil && (*obj).Policy != nil {
			policy_entry = (*obj).Policy
		} else {
			policy_entry = new(virtual_router.ProtocolBgpPolicy)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyObject
		diags.Append(o.Policy.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &policy_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redistRules_tf_entries []VirtualRouterResourceProtocolBgpRedistRulesObject
	var redistRules_pango_entries []virtual_router.ProtocolBgpRedistRules
	{
		d := o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range redistRules_tf_entries {
			var entry *virtual_router.ProtocolBgpRedistRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			redistRules_pango_entries = append(redistRules_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var routingOptions_entry *virtual_router.ProtocolBgpRoutingOptions
	if !o.RoutingOptions.IsUnknown() && !o.RoutingOptions.IsNull() {
		if *obj != nil && (*obj).RoutingOptions != nil {
			routingOptions_entry = (*obj).RoutingOptions
		} else {
			routingOptions_entry = new(virtual_router.ProtocolBgpRoutingOptions)
		}
		var object *VirtualRouterResourceProtocolBgpRoutingOptionsObject
		diags.Append(o.RoutingOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routingOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgp)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).DampeningProfile = dampeningProfile_pango_entries
	(*obj).EcmpMultiAs = ecmpMultiAs_value
	(*obj).Enable = enable_value
	(*obj).EnforceFirstAs = enforceFirstAs_value
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).InstallRoute = installRoute_value
	(*obj).LocalAs = localAs_value
	(*obj).PeerGroup = peerGroup_pango_entries
	(*obj).Policy = policy_entry
	(*obj).RedistRules = redistRules_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value
	(*obj).RoutingOptions = routingOptions_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	secret_value := o.Secret.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Secret = secret_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpDampeningProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	cutoff_value := o.Cutoff.ValueFloat64Pointer()
	reuse_value := o.Reuse.ValueFloat64Pointer()
	maxHoldTime_value := o.MaxHoldTime.ValueInt64Pointer()
	decayHalfLifeReachable_value := o.DecayHalfLifeReachable.ValueInt64Pointer()
	decayHalfLifeUnreachable_value := o.DecayHalfLifeUnreachable.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpDampeningProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Cutoff = cutoff_value
	(*obj).Reuse = reuse_value
	(*obj).MaxHoldTime = maxHoldTime_value
	(*obj).DecayHalfLifeReachable = decayHalfLifeReachable_value
	(*obj).DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	aggregatedConfedAsPath_value := o.AggregatedConfedAsPath.ValueBoolPointer()
	softResetWithStoredInfo_value := o.SoftResetWithStoredInfo.ValueBoolPointer()
	var type_entry *virtual_router.ProtocolBgpPeerGroupType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolBgpPeerGroupType)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peer_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupPeerObject
	var peer_pango_entries []virtual_router.ProtocolBgpPeerGroupPeer
	{
		d := o.Peer.ElementsAs(ctx, &peer_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range peer_tf_entries {
			var entry *virtual_router.ProtocolBgpPeerGroupPeer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			peer_pango_entries = append(peer_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroup)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).AggregatedConfedAsPath = aggregatedConfedAsPath_value
	(*obj).SoftResetWithStoredInfo = softResetWithStoredInfo_value
	(*obj).Type = type_entry
	(*obj).Peer = peer_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ibgp_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgp
	if !o.Ibgp.IsUnknown() && !o.Ibgp.IsNull() {
		if *obj != nil && (*obj).Ibgp != nil {
			ibgp_entry = (*obj).Ibgp
		} else {
			ibgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject
		diags.Append(o.Ibgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed
	if !o.EbgpConfed.IsUnknown() && !o.EbgpConfed.IsNull() {
		if *obj != nil && (*obj).EbgpConfed != nil {
			ebgpConfed_entry = (*obj).EbgpConfed
		} else {
			ebgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject
		diags.Append(o.EbgpConfed.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgpConfed_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ibgpConfed_entry *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed
	if !o.IbgpConfed.IsUnknown() && !o.IbgpConfed.IsNull() {
		if *obj != nil && (*obj).IbgpConfed != nil {
			ibgpConfed_entry = (*obj).IbgpConfed
		} else {
			ibgpConfed_entry = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject
		diags.Append(o.IbgpConfed.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ibgpConfed_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ebgp_entry *virtual_router.ProtocolBgpPeerGroupTypeEbgp
	if !o.Ebgp.IsUnknown() && !o.Ebgp.IsNull() {
		if *obj != nil && (*obj).Ebgp != nil {
			ebgp_entry = (*obj).Ebgp
		} else {
			ebgp_entry = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject
		diags.Append(o.Ebgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ebgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupType)
	}
	(*obj).Ibgp = ibgp_entry
	(*obj).EbgpConfed = ebgpConfed_entry
	(*obj).IbgpConfed = ibgpConfed_entry
	(*obj).Ebgp = ebgp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgp)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed)
	}
	(*obj).ExportNexthop = exportNexthop_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	importNexthop_value := o.ImportNexthop.ValueStringPointer()
	exportNexthop_value := o.ExportNexthop.ValueStringPointer()
	removePrivateAs_value := o.RemovePrivateAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupTypeEbgp)
	}
	(*obj).ImportNexthop = importNexthop_value
	(*obj).ExportNexthop = exportNexthop_value
	(*obj).RemovePrivateAs = removePrivateAs_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	peerAs_value := o.PeerAs.ValueStringPointer()
	enableMpBgp_value := o.EnableMpBgp.ValueBoolPointer()
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	enableSenderSideLoopDetection_value := o.EnableSenderSideLoopDetection.ValueBoolPointer()
	reflectorClient_value := o.ReflectorClient.ValueStringPointer()
	peeringType_value := o.PeeringType.ValueStringPointer()
	maxPrefixes_value := o.MaxPrefixes.ValueStringPointer()
	var subsequentAddressFamilyIdentifier_entry *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier
	if !o.SubsequentAddressFamilyIdentifier.IsUnknown() && !o.SubsequentAddressFamilyIdentifier.IsNull() {
		if *obj != nil && (*obj).SubsequentAddressFamilyIdentifier != nil {
			subsequentAddressFamilyIdentifier_entry = (*obj).SubsequentAddressFamilyIdentifier
		} else {
			subsequentAddressFamilyIdentifier_entry = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
		diags.Append(o.SubsequentAddressFamilyIdentifier.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &subsequentAddressFamilyIdentifier_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var localAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress
	if !o.LocalAddress.IsUnknown() && !o.LocalAddress.IsNull() {
		if *obj != nil && (*obj).LocalAddress != nil {
			localAddress_entry = (*obj).LocalAddress
		} else {
			localAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject
		diags.Append(o.LocalAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &localAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var peerAddress_entry *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress
	if !o.PeerAddress.IsUnknown() && !o.PeerAddress.IsNull() {
		if *obj != nil && (*obj).PeerAddress != nil {
			peerAddress_entry = (*obj).PeerAddress
		} else {
			peerAddress_entry = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject
		diags.Append(o.PeerAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &peerAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var connectionOptions_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions
	if !o.ConnectionOptions.IsUnknown() && !o.ConnectionOptions.IsNull() {
		if *obj != nil && (*obj).ConnectionOptions != nil {
			connectionOptions_entry = (*obj).ConnectionOptions
		} else {
			connectionOptions_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject
		diags.Append(o.ConnectionOptions.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &connectionOptions_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolBgpPeerGroupPeerBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).PeerAs = peerAs_value
	(*obj).EnableMpBgp = enableMpBgp_value
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	(*obj).ReflectorClient = reflectorClient_value
	(*obj).PeeringType = peeringType_value
	(*obj).MaxPrefixes = maxPrefixes_value
	(*obj).SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_entry
	(*obj).LocalAddress = localAddress_entry
	(*obj).PeerAddress = peerAddress_entry
	(*obj).ConnectionOptions = connectionOptions_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	unicast_value := o.Unicast.ValueBoolPointer()
	multicast_value := o.Multicast.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier)
	}
	(*obj).Unicast = unicast_value
	(*obj).Multicast = multicast_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interface_value := o.Interface.ValueStringPointer()
	ip_value := o.Ip.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerLocalAddress)
	}
	(*obj).Interface = interface_value
	(*obj).Ip = ip_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ip_value := o.Ip.ValueStringPointer()
	fqdn_value := o.Fqdn.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerPeerAddress)
	}
	(*obj).Ip = ip_value
	(*obj).Fqdn = fqdn_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	keepAliveInterval_value := o.KeepAliveInterval.ValueStringPointer()
	minRouteAdvInterval_value := o.MinRouteAdvInterval.ValueInt64Pointer()
	multihop_value := o.Multihop.ValueInt64Pointer()
	openDelayTime_value := o.OpenDelayTime.ValueInt64Pointer()
	holdTime_value := o.HoldTime.ValueStringPointer()
	idleHoldTime_value := o.IdleHoldTime.ValueInt64Pointer()
	var incomingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection
	if !o.IncomingBgpConnection.IsUnknown() && !o.IncomingBgpConnection.IsNull() {
		if *obj != nil && (*obj).IncomingBgpConnection != nil {
			incomingBgpConnection_entry = (*obj).IncomingBgpConnection
		} else {
			incomingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
		diags.Append(o.IncomingBgpConnection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &incomingBgpConnection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var outgoingBgpConnection_entry *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection
	if !o.OutgoingBgpConnection.IsUnknown() && !o.OutgoingBgpConnection.IsNull() {
		if *obj != nil && (*obj).OutgoingBgpConnection != nil {
			outgoingBgpConnection_entry = (*obj).OutgoingBgpConnection
		} else {
			outgoingBgpConnection_entry = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
		}
		var object *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
		diags.Append(o.OutgoingBgpConnection.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &outgoingBgpConnection_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions)
	}
	(*obj).Authentication = authentication_value
	(*obj).KeepAliveInterval = keepAliveInterval_value
	(*obj).MinRouteAdvInterval = minRouteAdvInterval_value
	(*obj).Multihop = multihop_value
	(*obj).OpenDelayTime = openDelayTime_value
	(*obj).HoldTime = holdTime_value
	(*obj).IdleHoldTime = idleHoldTime_value
	(*obj).IncomingBgpConnection = incomingBgpConnection_entry
	(*obj).OutgoingBgpConnection = outgoingBgpConnection_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	remotePort_value := o.RemotePort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection)
	}
	(*obj).RemotePort = remotePort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPort_value := o.LocalPort.ValueInt64Pointer()
	allow_value := o.Allow.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection)
	}
	(*obj).LocalPort = localPort_value
	(*obj).Allow = allow_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPeerGroupPeerBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregation_entry *virtual_router.ProtocolBgpPolicyAggregation
	if !o.Aggregation.IsUnknown() && !o.Aggregation.IsNull() {
		if *obj != nil && (*obj).Aggregation != nil {
			aggregation_entry = (*obj).Aggregation
		} else {
			aggregation_entry = new(virtual_router.ProtocolBgpPolicyAggregation)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationObject
		diags.Append(o.Aggregation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var conditionalAdvertisement_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisement
	if !o.ConditionalAdvertisement.IsUnknown() && !o.ConditionalAdvertisement.IsNull() {
		if *obj != nil && (*obj).ConditionalAdvertisement != nil {
			conditionalAdvertisement_entry = (*obj).ConditionalAdvertisement
		} else {
			conditionalAdvertisement_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject
		diags.Append(o.ConditionalAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &conditionalAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var export_entry *virtual_router.ProtocolBgpPolicyExport
	if !o.Export.IsUnknown() && !o.Export.IsNull() {
		if *obj != nil && (*obj).Export != nil {
			export_entry = (*obj).Export
		} else {
			export_entry = new(virtual_router.ProtocolBgpPolicyExport)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportObject
		diags.Append(o.Export.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &export_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var import_entry *virtual_router.ProtocolBgpPolicyImport
	if !o.Import.IsUnknown() && !o.Import.IsNull() {
		if *obj != nil && (*obj).Import != nil {
			import_entry = (*obj).Import
		} else {
			import_entry = new(virtual_router.ProtocolBgpPolicyImport)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportObject
		diags.Append(o.Import.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &import_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicy)
	}
	(*obj).Aggregation = aggregation_entry
	(*obj).ConditionalAdvertisement = conditionalAdvertisement_entry
	(*obj).Export = export_entry
	(*obj).Import = import_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
	var address_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddress
	{
		d := o.Address.ElementsAs(ctx, &address_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range address_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddress
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			address_pango_entries = append(address_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregation)
	}
	(*obj).Address = address_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefix_value := o.Prefix.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	summary_value := o.Summary.ValueBoolPointer()
	asSet_value := o.AsSet.ValueBoolPointer()
	var aggregateRouteAttributes_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes
	if !o.AggregateRouteAttributes.IsUnknown() && !o.AggregateRouteAttributes.IsNull() {
		if *obj != nil && (*obj).AggregateRouteAttributes != nil {
			aggregateRouteAttributes_entry = (*obj).AggregateRouteAttributes
		} else {
			aggregateRouteAttributes_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
		diags.Append(o.AggregateRouteAttributes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregateRouteAttributes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppressFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
	var suppressFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
	{
		d := o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suppressFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suppressFilters_pango_entries = append(suppressFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Prefix = prefix_value
	(*obj).Enable = enable_value
	(*obj).Summary = summary_value
	(*obj).AsSet = asSet_value
	(*obj).AggregateRouteAttributes = aggregateRouteAttributes_entry
	(*obj).SuppressFilters = suppressFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Weight = weight_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath)
	}
	(*obj).None = none_entry
	(*obj).Prepend = prepend_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
	var policy_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
	{
		d := o.Policy.ElementsAs(ctx, &policy_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range policy_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			policy_pango_entries = append(policy_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisement)
	}
	(*obj).Policy = policy_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var nonExistFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
	var nonExistFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
	{
		d := o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nonExistFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nonExistFilters_pango_entries = append(nonExistFilters_pango_entries, *entry)
		}
	}
	var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
	var advertiseFilters_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
	{
		d := o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range advertiseFilters_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			advertiseFilters_pango_entries = append(advertiseFilters_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).NonExistFilters = nonExistFilters_pango_entries
	(*obj).AdvertiseFilters = advertiseFilters_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var match_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Match = match_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyExportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var match_entry *virtual_router.ProtocolBgpPolicyExportRulesMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyExportRulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyExportRulesActionDeny
	if !o.Deny.IsUnknown() && !o.Deny.IsNull() {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject
		diags.Append(o.Deny.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &deny_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var update_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate
	if !o.Update.IsUnknown() && !o.Update.IsNull() {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
		diags.Append(o.Update.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &update_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllow)
	}
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove
	if !o.Remove.IsUnknown() && !o.Remove.IsNull() {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
		diags.Append(o.Remove.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &remove_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	prepend_value := o.Prepend.ValueInt64Pointer()
	removeAndPrepend_value := o.RemoveAndPrepend.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry
	(*obj).Prepend = prepend_value
	(*obj).RemoveAndPrepend = removeAndPrepend_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesObject
	var rules_pango_entries []virtual_router.ProtocolBgpPolicyImportRules
	{
		d := o.Rules.ElementsAs(ctx, &rules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range rules_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			rules_pango_entries = append(rules_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImport)
	}
	(*obj).Rules = rules_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var usedBy_pango_entries []string
	if !o.UsedBy.IsUnknown() && !o.UsedBy.IsNull() {
		object_entries := make([]types.String, 0, len(o.UsedBy.Elements()))
		diags.Append(o.UsedBy.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			usedBy_pango_entries = append(usedBy_pango_entries, elt.ValueString())
		}
	}
	var match_entry *virtual_router.ProtocolBgpPolicyImportRulesMatch
	if !o.Match.IsUnknown() && !o.Match.IsNull() {
		if *obj != nil && (*obj).Match != nil {
			match_entry = (*obj).Match
		} else {
			match_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject
		diags.Append(o.Match.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &match_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolBgpPolicyImportRulesAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).UsedBy = usedBy_pango_entries
	(*obj).Match = match_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	routeTable_value := o.RouteTable.ValueStringPointer()
	med_value := o.Med.ValueInt64Pointer()
	var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
	var addressPrefix_pango_entries []virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
	{
		d := o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addressPrefix_tf_entries {
			var entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addressPrefix_pango_entries = append(addressPrefix_pango_entries, *entry)
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var fromPeer_pango_entries []string
	if !o.FromPeer.IsUnknown() && !o.FromPeer.IsNull() {
		object_entries := make([]types.String, 0, len(o.FromPeer.Elements()))
		diags.Append(o.FromPeer.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			fromPeer_pango_entries = append(fromPeer_pango_entries, elt.ValueString())
		}
	}
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatch)
	}
	(*obj).RouteTable = routeTable_value
	(*obj).Med = med_value
	(*obj).AddressPrefix = addressPrefix_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).FromPeer = fromPeer_pango_entries
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	exact_value := o.Exact.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Exact = exact_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	regex_value := o.Regex.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity)
	}
	(*obj).Regex = regex_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var deny_entry *virtual_router.ProtocolBgpPolicyImportRulesActionDeny
	if !o.Deny.IsUnknown() && !o.Deny.IsNull() {
		if *obj != nil && (*obj).Deny != nil {
			deny_entry = (*obj).Deny
		} else {
			deny_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject
		diags.Append(o.Deny.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &deny_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allow_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllow
	if !o.Allow.IsUnknown() && !o.Allow.IsNull() {
		if *obj != nil && (*obj).Allow != nil {
			allow_entry = (*obj).Allow
		} else {
			allow_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject
		diags.Append(o.Allow.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allow_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesAction)
	}
	(*obj).Deny = deny_entry
	(*obj).Allow = allow_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionDeny)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dampening_value := o.Dampening.ValueStringPointer()
	var update_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate
	if !o.Update.IsUnknown() && !o.Update.IsNull() {
		if *obj != nil && (*obj).Update != nil {
			update_entry = (*obj).Update
		} else {
			update_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
		diags.Append(o.Update.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &update_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllow)
	}
	(*obj).Dampening = dampening_value
	(*obj).Update = update_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	localPreference_value := o.LocalPreference.ValueInt64Pointer()
	med_value := o.Med.ValueInt64Pointer()
	weight_value := o.Weight.ValueInt64Pointer()
	nexthop_value := o.Nexthop.ValueStringPointer()
	origin_value := o.Origin.ValueStringPointer()
	asPathLimit_value := o.AsPathLimit.ValueInt64Pointer()
	var asPath_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath
	if !o.AsPath.IsUnknown() && !o.AsPath.IsNull() {
		if *obj != nil && (*obj).AsPath != nil {
			asPath_entry = (*obj).AsPath
		} else {
			asPath_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
		diags.Append(o.AsPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &asPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var community_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		if *obj != nil && (*obj).Community != nil {
			community_entry = (*obj).Community
		} else {
			community_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
		diags.Append(o.Community.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &community_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		if *obj != nil && (*obj).ExtendedCommunity != nil {
			extendedCommunity_entry = (*obj).ExtendedCommunity
		} else {
			extendedCommunity_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
		diags.Append(o.ExtendedCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extendedCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate)
	}
	(*obj).LocalPreference = localPreference_value
	(*obj).Med = med_value
	(*obj).Weight = weight_value
	(*obj).Nexthop = nexthop_value
	(*obj).Origin = origin_value
	(*obj).AsPathLimit = asPathLimit_value
	(*obj).AsPath = asPath_entry
	(*obj).Community = community_entry
	(*obj).ExtendedCommunity = extendedCommunity_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var remove_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove
	if !o.Remove.IsUnknown() && !o.Remove.IsNull() {
		if *obj != nil && (*obj).Remove != nil {
			remove_entry = (*obj).Remove
		} else {
			remove_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
		diags.Append(o.Remove.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &remove_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath)
	}
	(*obj).None = none_entry
	(*obj).Remove = remove_entry

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var none_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removeAll_entry *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll
	if !o.RemoveAll.IsUnknown() && !o.RemoveAll.IsNull() {
		if *obj != nil && (*obj).RemoveAll != nil {
			removeAll_entry = (*obj).RemoveAll
		} else {
			removeAll_entry = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
		}
		var object *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
		diags.Append(o.RemoveAll.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removeAll_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	removeRegex_value := o.RemoveRegex.ValueStringPointer()
	var append_pango_entries []string
	if !o.Append.IsUnknown() && !o.Append.IsNull() {
		object_entries := make([]types.String, 0, len(o.Append.Elements()))
		diags.Append(o.Append.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			append_pango_entries = append(append_pango_entries, elt.ValueString())
		}
	}
	var overwrite_pango_entries []string
	if !o.Overwrite.IsUnknown() && !o.Overwrite.IsNull() {
		object_entries := make([]types.String, 0, len(o.Overwrite.Elements()))
		diags.Append(o.Overwrite.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			overwrite_pango_entries = append(overwrite_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity)
	}
	(*obj).None = none_entry
	(*obj).RemoveAll = removeAll_entry
	(*obj).RemoveRegex = removeRegex_value
	(*obj).Append = append_pango_entries
	(*obj).Overwrite = overwrite_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRedistRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	addressFamilyIdentifier_value := o.AddressFamilyIdentifier.ValueStringPointer()
	routeTable_value := o.RouteTable.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	setOrigin_value := o.SetOrigin.ValueStringPointer()
	setMed_value := o.SetMed.ValueInt64Pointer()
	setLocalPreference_value := o.SetLocalPreference.ValueInt64Pointer()
	setAsPathLimit_value := o.SetAsPathLimit.ValueInt64Pointer()
	metric_value := o.Metric.ValueInt64Pointer()
	var setCommunity_pango_entries []string
	if !o.SetCommunity.IsUnknown() && !o.SetCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.SetCommunity.Elements()))
		diags.Append(o.SetCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			setCommunity_pango_entries = append(setCommunity_pango_entries, elt.ValueString())
		}
	}
	var setExtendedCommunity_pango_entries []string
	if !o.SetExtendedCommunity.IsUnknown() && !o.SetExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.SetExtendedCommunity.Elements()))
		diags.Append(o.SetExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			setExtendedCommunity_pango_entries = append(setExtendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRedistRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).AddressFamilyIdentifier = addressFamilyIdentifier_value
	(*obj).RouteTable = routeTable_value
	(*obj).Enable = enable_value
	(*obj).SetOrigin = setOrigin_value
	(*obj).SetMed = setMed_value
	(*obj).SetLocalPreference = setLocalPreference_value
	(*obj).SetAsPathLimit = setAsPathLimit_value
	(*obj).Metric = metric_value
	(*obj).SetCommunity = setCommunity_pango_entries
	(*obj).SetExtendedCommunity = setExtendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var aggregate_entry *virtual_router.ProtocolBgpRoutingOptionsAggregate
	if !o.Aggregate.IsUnknown() && !o.Aggregate.IsNull() {
		if *obj != nil && (*obj).Aggregate != nil {
			aggregate_entry = (*obj).Aggregate
		} else {
			aggregate_entry = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
		}
		var object *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject
		diags.Append(o.Aggregate.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &aggregate_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asFormat_value := o.AsFormat.ValueStringPointer()
	confederationMemberAs_value := o.ConfederationMemberAs.ValueStringPointer()
	defaultLocalPreference_value := o.DefaultLocalPreference.ValueInt64Pointer()
	var gracefulRestart_entry *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
		}
		var object *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var med_entry *virtual_router.ProtocolBgpRoutingOptionsMed
	if !o.Med.IsUnknown() && !o.Med.IsNull() {
		if *obj != nil && (*obj).Med != nil {
			med_entry = (*obj).Med
		} else {
			med_entry = new(virtual_router.ProtocolBgpRoutingOptionsMed)
		}
		var object *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject
		diags.Append(o.Med.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &med_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	reflectorClusterId_value := o.ReflectorClusterId.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptions)
	}
	(*obj).Aggregate = aggregate_entry
	(*obj).AsFormat = asFormat_value
	(*obj).ConfederationMemberAs = confederationMemberAs_value
	(*obj).DefaultLocalPreference = defaultLocalPreference_value
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).Med = med_entry
	(*obj).ReflectorClusterId = reflectorClusterId_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsAggregate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	aggregateMed_value := o.AggregateMed.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsAggregate)
	}
	(*obj).AggregateMed = aggregateMed_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	localRestartTime_value := o.LocalRestartTime.ValueInt64Pointer()
	maxPeerRestartTime_value := o.MaxPeerRestartTime.ValueInt64Pointer()
	staleRouteTime_value := o.StaleRouteTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).LocalRestartTime = localRestartTime_value
	(*obj).MaxPeerRestartTime = maxPeerRestartTime_value
	(*obj).StaleRouteTime = staleRouteTime_value

	return diags
}
func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolBgpRoutingOptionsMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	alwaysCompareMed_value := o.AlwaysCompareMed.ValueBoolPointer()
	deterministicMedComparison_value := o.DeterministicMedComparison.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolBgpRoutingOptionsMed)
	}
	(*obj).AlwaysCompareMed = alwaysCompareMed_value
	(*obj).DeterministicMedComparison = deterministicMedComparison_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var area_tf_entries []VirtualRouterResourceProtocolOspfAreaObject
	var area_pango_entries []virtual_router.ProtocolOspfArea
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfArea
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolOspfExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfGlobalBfd)
		}
		var object *VirtualRouterResourceProtocolOspfGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfGracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfGracefulRestart)
		}
		var object *VirtualRouterResourceProtocolOspfGracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	rfc1583_value := o.Rfc1583.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var timers_entry *virtual_router.ProtocolOspfTimers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfTimers)
		}
		var object *VirtualRouterResourceProtocolOspfTimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspf)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Rfc1583 = rfc1583_value
	(*obj).RouterId = routerId_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *virtual_router.ProtocolOspfAreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfAreaType)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterResourceProtocolOspfAreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfAreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfAreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfAreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfArea)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfAreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfAreaTypeNormal)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfAreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfAreaTypeStub)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfAreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfAreaTypeNssa)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
		}
		var object *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfAreaRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfAreaRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfAreaRangeSuppress)
		}
		var object *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	priority_value := o.Priority.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfAreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
		}
		var object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfAreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfAreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfAreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
		}
		var object *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).Priority = priority_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
		}
		var object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
		}
		var object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
		}
		var object *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfAreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
		}
		var object *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolOspfAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolOspfAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfGracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfTimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfTimers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var area_tf_entries []VirtualRouterResourceProtocolOspfv3AreaObject
	var area_pango_entries []virtual_router.ProtocolOspfv3Area
	{
		d := o.Area.ElementsAs(ctx, &area_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range area_tf_entries {
			var entry *virtual_router.ProtocolOspfv3Area
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			area_pango_entries = append(area_pango_entries, *entry)
		}
	}
	var authProfile_tf_entries []VirtualRouterResourceProtocolOspfv3AuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolOspfv3AuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	disableTransitTraffic_value := o.DisableTransitTraffic.ValueBoolPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolOspfv3ExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolOspfv3ExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolOspfv3ExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolOspfv3GlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolOspfv3GlobalBfd)
		}
		var object *VirtualRouterResourceProtocolOspfv3GlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var gracefulRestart_entry *virtual_router.ProtocolOspfv3GracefulRestart
	if !o.GracefulRestart.IsUnknown() && !o.GracefulRestart.IsNull() {
		if *obj != nil && (*obj).GracefulRestart != nil {
			gracefulRestart_entry = (*obj).GracefulRestart
		} else {
			gracefulRestart_entry = new(virtual_router.ProtocolOspfv3GracefulRestart)
		}
		var object *VirtualRouterResourceProtocolOspfv3GracefulRestartObject
		diags.Append(o.GracefulRestart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gracefulRestart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	routerId_value := o.RouterId.ValueStringPointer()
	var timers_entry *virtual_router.ProtocolOspfv3Timers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolOspfv3Timers)
		}
		var object *VirtualRouterResourceProtocolOspfv3TimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).Area = area_pango_entries
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).DisableTransitTraffic = disableTransitTraffic_value
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).GracefulRestart = gracefulRestart_entry
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).RouterId = routerId_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	authentication_value := o.Authentication.ValueStringPointer()
	var type_entry *virtual_router.ProtocolOspfv3AreaType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(virtual_router.ProtocolOspfv3AreaType)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var range_tf_entries []VirtualRouterResourceProtocolOspfv3AreaRangeObject
	var range_pango_entries []virtual_router.ProtocolOspfv3AreaRange
	{
		d := o.Range.ElementsAs(ctx, &range_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range range_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			range_pango_entries = append(range_pango_entries, *entry)
		}
	}
	var interface_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceObject
	var interface_pango_entries []virtual_router.ProtocolOspfv3AreaInterface
	{
		d := o.Interface.ElementsAs(ctx, &interface_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interface_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interface_pango_entries = append(interface_pango_entries, *entry)
		}
	}
	var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
	var virtualLink_pango_entries []virtual_router.ProtocolOspfv3AreaVirtualLink
	{
		d := o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range virtualLink_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaVirtualLink
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			virtualLink_pango_entries = append(virtualLink_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Area)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Authentication = authentication_value
	(*obj).Type = type_entry
	(*obj).Range = range_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).VirtualLink = virtualLink_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var normal_entry *virtual_router.ProtocolOspfv3AreaTypeNormal
	if !o.Normal.IsUnknown() && !o.Normal.IsNull() {
		if *obj != nil && (*obj).Normal != nil {
			normal_entry = (*obj).Normal
		} else {
			normal_entry = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject
		diags.Append(o.Normal.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &normal_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var stub_entry *virtual_router.ProtocolOspfv3AreaTypeStub
	if !o.Stub.IsUnknown() && !o.Stub.IsNull() {
		if *obj != nil && (*obj).Stub != nil {
			stub_entry = (*obj).Stub
		} else {
			stub_entry = new(virtual_router.ProtocolOspfv3AreaTypeStub)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject
		diags.Append(o.Stub.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &stub_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssa_entry *virtual_router.ProtocolOspfv3AreaTypeNssa
	if !o.Nssa.IsUnknown() && !o.Nssa.IsNull() {
		if *obj != nil && (*obj).Nssa != nil {
			nssa_entry = (*obj).Nssa
		} else {
			nssa_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject
		diags.Append(o.Nssa.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nssa_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaType)
	}
	(*obj).Normal = normal_entry
	(*obj).Stub = stub_entry
	(*obj).Nssa = nssa_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNormal)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStub)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptSummary_value := o.AcceptSummary.ValueBoolPointer()
	var defaultRoute_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
	var nssaExtRange_pango_entries []virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
	{
		d := o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range nssaExtRange_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			nssaExtRange_pango_entries = append(nssaExtRange_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssa)
	}
	(*obj).AcceptSummary = acceptSummary_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).NssaExtRange = nssaExtRange_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()
	type_value := o.Type.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value
	(*obj).Type = type_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var advertise_entry *virtual_router.ProtocolOspfv3AreaRangeAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var suppress_entry *virtual_router.ProtocolOspfv3AreaRangeSuppress
	if !o.Suppress.IsUnknown() && !o.Suppress.IsNull() {
		if *obj != nil && (*obj).Suppress != nil {
			suppress_entry = (*obj).Suppress
		} else {
			suppress_entry = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject
		diags.Append(o.Suppress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &suppress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRange)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Advertise = advertise_entry
	(*obj).Suppress = suppress_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeAdvertise)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaRangeSuppress)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	passive_value := o.Passive.ValueBoolPointer()
	metric_value := o.Metric.ValueInt64Pointer()
	priority_value := o.Priority.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	grDelay_value := o.GrDelay.ValueInt64Pointer()
	var linkType_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkType
	if !o.LinkType.IsUnknown() && !o.LinkType.IsNull() {
		if *obj != nil && (*obj).LinkType != nil {
			linkType_entry = (*obj).LinkType
		} else {
			linkType_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject
		diags.Append(o.LinkType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &linkType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var neighbor_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject
	var neighbor_pango_entries []virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	var bfd_entry *virtual_router.ProtocolOspfv3AreaInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).Passive = passive_value
	(*obj).Metric = metric_value
	(*obj).Priority = priority_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).GrDelay = grDelay_value
	(*obj).LinkType = linkType_entry
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var broadcast_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast
	if !o.Broadcast.IsUnknown() && !o.Broadcast.IsNull() {
		if *obj != nil && (*obj).Broadcast != nil {
			broadcast_entry = (*obj).Broadcast
		} else {
			broadcast_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
		diags.Append(o.Broadcast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &broadcast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2p_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p
	if !o.P2p.IsUnknown() && !o.P2p.IsNull() {
		if *obj != nil && (*obj).P2p != nil {
			p2p_entry = (*obj).P2p
		} else {
			p2p_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
		diags.Append(o.P2p.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2p_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var p2mp_entry *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp
	if !o.P2mp.IsUnknown() && !o.P2mp.IsNull() {
		if *obj != nil && (*obj).P2mp != nil {
			p2mp_entry = (*obj).P2mp
		} else {
			p2mp_entry = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
		diags.Append(o.P2mp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &p2mp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkType)
	}
	(*obj).Broadcast = broadcast_entry
	(*obj).P2p = p2p_entry
	(*obj).P2mp = p2mp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceNeighbor)
	}
	(*obj).Name = o.Name.ValueString()

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	neighborId_value := o.NeighborId.ValueStringPointer()
	transitAreaId_value := o.TransitAreaId.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	instanceId_value := o.InstanceId.ValueInt64Pointer()
	helloInterval_value := o.HelloInterval.ValueInt64Pointer()
	deadCounts_value := o.DeadCounts.ValueInt64Pointer()
	retransmitInterval_value := o.RetransmitInterval.ValueInt64Pointer()
	transitDelay_value := o.TransitDelay.ValueInt64Pointer()
	authentication_value := o.Authentication.ValueStringPointer()
	var bfd_entry *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
		}
		var object *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLink)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NeighborId = neighborId_value
	(*obj).TransitAreaId = transitAreaId_value
	(*obj).Enable = enable_value
	(*obj).InstanceId = instanceId_value
	(*obj).HelloInterval = helloInterval_value
	(*obj).DeadCounts = deadCounts_value
	(*obj).RetransmitInterval = retransmitInterval_value
	(*obj).TransitDelay = transitDelay_value
	(*obj).Authentication = authentication_value
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AreaVirtualLinkBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	spi_value := o.Spi.ValueStringPointer()
	var esp_entry *virtual_router.ProtocolOspfv3AuthProfileEsp
	if !o.Esp.IsUnknown() && !o.Esp.IsNull() {
		if *obj != nil && (*obj).Esp != nil {
			esp_entry = (*obj).Esp
		} else {
			esp_entry = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject
		diags.Append(o.Esp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &esp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ah_entry *virtual_router.ProtocolOspfv3AuthProfileAh
	if !o.Ah.IsUnknown() && !o.Ah.IsNull() {
		if *obj != nil && (*obj).Ah != nil {
			ah_entry = (*obj).Ah
		} else {
			ah_entry = new(virtual_router.ProtocolOspfv3AuthProfileAh)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject
		diags.Append(o.Ah.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ah_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Spi = spi_value
	(*obj).Esp = esp_entry
	(*obj).Ah = ah_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authentication_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication
	if !o.Authentication.IsUnknown() && !o.Authentication.IsNull() {
		if *obj != nil && (*obj).Authentication != nil {
			authentication_entry = (*obj).Authentication
		} else {
			authentication_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject
		diags.Append(o.Authentication.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &authentication_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var encryption_entry *virtual_router.ProtocolOspfv3AuthProfileEspEncryption
	if !o.Encryption.IsUnknown() && !o.Encryption.IsNull() {
		if *obj != nil && (*obj).Encryption != nil {
			encryption_entry = (*obj).Encryption
		} else {
			encryption_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject
		diags.Append(o.Encryption.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &encryption_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEsp)
	}
	(*obj).Authentication = authentication_entry
	(*obj).Encryption = encryption_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var none_entry *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone
	if !o.None.IsUnknown() && !o.None.IsNull() {
		if *obj != nil && (*obj).None != nil {
			none_entry = (*obj).None
		} else {
			none_entry = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
		diags.Append(o.None.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &none_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthentication)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry
	(*obj).None = none_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	algorithm_value := o.Algorithm.ValueStringPointer()
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileEspEncryption)
	}
	(*obj).Algorithm = algorithm_value
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_entry *virtual_router.ProtocolOspfv3AuthProfileAhMd5
	if !o.Md5.IsUnknown() && !o.Md5.IsNull() {
		if *obj != nil && (*obj).Md5 != nil {
			md5_entry = (*obj).Md5
		} else {
			md5_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object
		diags.Append(o.Md5.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &md5_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha1_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha1
	if !o.Sha1.IsUnknown() && !o.Sha1.IsNull() {
		if *obj != nil && (*obj).Sha1 != nil {
			sha1_entry = (*obj).Sha1
		} else {
			sha1_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object
		diags.Append(o.Sha1.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha1_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha256_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha256
	if !o.Sha256.IsUnknown() && !o.Sha256.IsNull() {
		if *obj != nil && (*obj).Sha256 != nil {
			sha256_entry = (*obj).Sha256
		} else {
			sha256_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object
		diags.Append(o.Sha256.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha256_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha384_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha384
	if !o.Sha384.IsUnknown() && !o.Sha384.IsNull() {
		if *obj != nil && (*obj).Sha384 != nil {
			sha384_entry = (*obj).Sha384
		} else {
			sha384_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object
		diags.Append(o.Sha384.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha384_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sha512_entry *virtual_router.ProtocolOspfv3AuthProfileAhSha512
	if !o.Sha512.IsUnknown() && !o.Sha512.IsNull() {
		if *obj != nil && (*obj).Sha512 != nil {
			sha512_entry = (*obj).Sha512
		} else {
			sha512_entry = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
		}
		var object *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object
		diags.Append(o.Sha512.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sha512_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAh)
	}
	(*obj).Md5 = md5_entry
	(*obj).Sha1 = sha1_entry
	(*obj).Sha256 = sha256_entry
	(*obj).Sha384 = sha384_entry
	(*obj).Sha512 = sha512_entry

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhMd5)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha1)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha256)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha384)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3AuthProfileAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3AuthProfileAhSha512)
	}
	(*obj).Key = key_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3ExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	newPathType_value := o.NewPathType.ValueStringPointer()
	newTag_value := o.NewTag.ValueStringPointer()
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3ExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).NewPathType = newPathType_value
	(*obj).NewTag = newTag_value
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	gracePeriod_value := o.GracePeriod.ValueInt64Pointer()
	helperEnable_value := o.HelperEnable.ValueBoolPointer()
	maxNeighborRestartTime_value := o.MaxNeighborRestartTime.ValueInt64Pointer()
	strictLSAChecking_value := o.StrictLSAChecking.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3GracefulRestart)
	}
	(*obj).Enable = enable_value
	(*obj).GracePeriod = gracePeriod_value
	(*obj).HelperEnable = helperEnable_value
	(*obj).MaxNeighborRestartTime = maxNeighborRestartTime_value
	(*obj).StrictLSAChecking = strictLSAChecking_value

	return diags
}
func (o *VirtualRouterResourceProtocolOspfv3TimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolOspfv3Timers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lsaInterval_value := o.LsaInterval.ValueFloat64Pointer()
	spfCalculationDelay_value := o.SpfCalculationDelay.ValueFloat64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolOspfv3Timers)
	}
	(*obj).LsaInterval = lsaInterval_value
	(*obj).SpfCalculationDelay = spfCalculationDelay_value

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileFilter
	if !o.Filter.IsUnknown() && !o.Filter.IsNull() {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileFilter)
		}
		var object *VirtualRouterResourceProtocolRedistProfileFilterObject
		diags.Append(o.Filter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileAction)
		}
		var object *VirtualRouterResourceProtocolRedistProfileActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_pango_entries []string
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		object_entries := make([]types.String, 0, len(o.Type.Elements()))
		diags.Append(o.Type.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			type_pango_entries = append(type_pango_entries, elt.ValueString())
		}
	}
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var destination_pango_entries []string
	if !o.Destination.IsUnknown() && !o.Destination.IsNull() {
		object_entries := make([]types.String, 0, len(o.Destination.Elements()))
		diags.Append(o.Destination.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			destination_pango_entries = append(destination_pango_entries, elt.ValueString())
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var ospf_entry *virtual_router.ProtocolRedistProfileFilterOspf
	if !o.Ospf.IsUnknown() && !o.Ospf.IsNull() {
		if *obj != nil && (*obj).Ospf != nil {
			ospf_entry = (*obj).Ospf
		} else {
			ospf_entry = new(virtual_router.ProtocolRedistProfileFilterOspf)
		}
		var object *VirtualRouterResourceProtocolRedistProfileFilterOspfObject
		diags.Append(o.Ospf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileFilterBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileFilterBgp)
		}
		var object *VirtualRouterResourceProtocolRedistProfileFilterBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospf = ospf_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilterOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_pango_entries []string
	if !o.PathType.IsUnknown() && !o.PathType.IsNull() {
		object_entries := make([]types.String, 0, len(o.PathType.Elements()))
		diags.Append(o.PathType.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			pathType_pango_entries = append(pathType_pango_entries, elt.ValueString())
		}
	}
	var area_pango_entries []string
	if !o.Area.IsUnknown() && !o.Area.IsNull() {
		object_entries := make([]types.String, 0, len(o.Area.Elements()))
		diags.Append(o.Area.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			area_pango_entries = append(area_pango_entries, elt.ValueString())
		}
	}
	var tag_pango_entries []string
	if !o.Tag.IsUnknown() && !o.Tag.IsNull() {
		object_entries := make([]types.String, 0, len(o.Tag.Elements()))
		diags.Append(o.Tag.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			tag_pango_entries = append(tag_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterOspf)
	}
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileFilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_pango_entries []string
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		object_entries := make([]types.String, 0, len(o.Community.Elements()))
		diags.Append(o.Community.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			community_pango_entries = append(community_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunity_pango_entries []string
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunity.Elements()))
		diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunity_pango_entries = append(extendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileFilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileActionNoRedist
	if !o.NoRedist.IsUnknown() && !o.NoRedist.IsNull() {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileActionNoRedist)
		}
		var object *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject
		diags.Append(o.NoRedist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &noRedist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileActionRedist
	if !o.Redist.IsUnknown() && !o.Redist.IsNull() {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileActionRedist)
		}
		var object *VirtualRouterResourceProtocolRedistProfileActionRedistObject
		diags.Append(o.Redist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileAction)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileActionRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	priority_value := o.Priority.ValueInt64Pointer()
	var filter_entry *virtual_router.ProtocolRedistProfileIpv6Filter
	if !o.Filter.IsUnknown() && !o.Filter.IsNull() {
		if *obj != nil && (*obj).Filter != nil {
			filter_entry = (*obj).Filter
		} else {
			filter_entry = new(virtual_router.ProtocolRedistProfileIpv6Filter)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject
		diags.Append(o.Filter.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &filter_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var action_entry *virtual_router.ProtocolRedistProfileIpv6Action
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(virtual_router.ProtocolRedistProfileIpv6Action)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Priority = priority_value
	(*obj).Filter = filter_entry
	(*obj).Action = action_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6Filter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_pango_entries []string
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		object_entries := make([]types.String, 0, len(o.Type.Elements()))
		diags.Append(o.Type.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			type_pango_entries = append(type_pango_entries, elt.ValueString())
		}
	}
	var interface_pango_entries []string
	if !o.Interface.IsUnknown() && !o.Interface.IsNull() {
		object_entries := make([]types.String, 0, len(o.Interface.Elements()))
		diags.Append(o.Interface.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			interface_pango_entries = append(interface_pango_entries, elt.ValueString())
		}
	}
	var destination_pango_entries []string
	if !o.Destination.IsUnknown() && !o.Destination.IsNull() {
		object_entries := make([]types.String, 0, len(o.Destination.Elements()))
		diags.Append(o.Destination.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			destination_pango_entries = append(destination_pango_entries, elt.ValueString())
		}
	}
	var nexthop_pango_entries []string
	if !o.Nexthop.IsUnknown() && !o.Nexthop.IsNull() {
		object_entries := make([]types.String, 0, len(o.Nexthop.Elements()))
		diags.Append(o.Nexthop.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			nexthop_pango_entries = append(nexthop_pango_entries, elt.ValueString())
		}
	}
	var ospfv3_entry *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3
	if !o.Ospfv3.IsUnknown() && !o.Ospfv3.IsNull() {
		if *obj != nil && (*obj).Ospfv3 != nil {
			ospfv3_entry = (*obj).Ospfv3
		} else {
			ospfv3_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object
		diags.Append(o.Ospfv3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ospfv3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bgp_entry *virtual_router.ProtocolRedistProfileIpv6FilterBgp
	if !o.Bgp.IsUnknown() && !o.Bgp.IsNull() {
		if *obj != nil && (*obj).Bgp != nil {
			bgp_entry = (*obj).Bgp
		} else {
			bgp_entry = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject
		diags.Append(o.Bgp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bgp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Filter)
	}
	(*obj).Type = type_pango_entries
	(*obj).Interface = interface_pango_entries
	(*obj).Destination = destination_pango_entries
	(*obj).Nexthop = nexthop_pango_entries
	(*obj).Ospfv3 = ospfv3_entry
	(*obj).Bgp = bgp_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_pango_entries []string
	if !o.PathType.IsUnknown() && !o.PathType.IsNull() {
		object_entries := make([]types.String, 0, len(o.PathType.Elements()))
		diags.Append(o.PathType.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			pathType_pango_entries = append(pathType_pango_entries, elt.ValueString())
		}
	}
	var area_pango_entries []string
	if !o.Area.IsUnknown() && !o.Area.IsNull() {
		object_entries := make([]types.String, 0, len(o.Area.Elements()))
		diags.Append(o.Area.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			area_pango_entries = append(area_pango_entries, elt.ValueString())
		}
	}
	var tag_pango_entries []string
	if !o.Tag.IsUnknown() && !o.Tag.IsNull() {
		object_entries := make([]types.String, 0, len(o.Tag.Elements()))
		diags.Append(o.Tag.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			tag_pango_entries = append(tag_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterOspfv3)
	}
	(*obj).PathType = pathType_pango_entries
	(*obj).Area = area_pango_entries
	(*obj).Tag = tag_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6FilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_pango_entries []string
	if !o.Community.IsUnknown() && !o.Community.IsNull() {
		object_entries := make([]types.String, 0, len(o.Community.Elements()))
		diags.Append(o.Community.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			community_pango_entries = append(community_pango_entries, elt.ValueString())
		}
	}
	var extendedCommunity_pango_entries []string
	if !o.ExtendedCommunity.IsUnknown() && !o.ExtendedCommunity.IsNull() {
		object_entries := make([]types.String, 0, len(o.ExtendedCommunity.Elements()))
		diags.Append(o.ExtendedCommunity.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			extendedCommunity_pango_entries = append(extendedCommunity_pango_entries, elt.ValueString())
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6FilterBgp)
	}
	(*obj).Community = community_pango_entries
	(*obj).ExtendedCommunity = extendedCommunity_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6Action, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var noRedist_entry *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist
	if !o.NoRedist.IsUnknown() && !o.NoRedist.IsNull() {
		if *obj != nil && (*obj).NoRedist != nil {
			noRedist_entry = (*obj).NoRedist
		} else {
			noRedist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject
		diags.Append(o.NoRedist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &noRedist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var redist_entry *virtual_router.ProtocolRedistProfileIpv6ActionRedist
	if !o.Redist.IsUnknown() && !o.Redist.IsNull() {
		if *obj != nil && (*obj).Redist != nil {
			redist_entry = (*obj).Redist
		} else {
			redist_entry = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
		}
		var object *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject
		diags.Append(o.Redist.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &redist_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6Action)
	}
	(*obj).NoRedist = noRedist_entry
	(*obj).Redist = redist_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionNoRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRedistProfileIpv6ActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRedistProfileIpv6ActionRedist)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRipObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	allowRedistDefaultRoute_value := o.AllowRedistDefaultRoute.ValueBoolPointer()
	var authProfile_tf_entries []VirtualRouterResourceProtocolRipAuthProfileObject
	var authProfile_pango_entries []virtual_router.ProtocolRipAuthProfile
	{
		d := o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range authProfile_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfile
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			authProfile_pango_entries = append(authProfile_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var exportRules_tf_entries []VirtualRouterResourceProtocolRipExportRulesObject
	var exportRules_pango_entries []virtual_router.ProtocolRipExportRules
	{
		d := o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range exportRules_tf_entries {
			var entry *virtual_router.ProtocolRipExportRules
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			exportRules_pango_entries = append(exportRules_pango_entries, *entry)
		}
	}
	var globalBfd_entry *virtual_router.ProtocolRipGlobalBfd
	if !o.GlobalBfd.IsUnknown() && !o.GlobalBfd.IsNull() {
		if *obj != nil && (*obj).GlobalBfd != nil {
			globalBfd_entry = (*obj).GlobalBfd
		} else {
			globalBfd_entry = new(virtual_router.ProtocolRipGlobalBfd)
		}
		var object *VirtualRouterResourceProtocolRipGlobalBfdObject
		diags.Append(o.GlobalBfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &globalBfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var interfaces_tf_entries []VirtualRouterResourceProtocolRipInterfacesObject
	var interfaces_pango_entries []virtual_router.ProtocolRipInterface
	{
		d := o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range interfaces_tf_entries {
			var entry *virtual_router.ProtocolRipInterface
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			interfaces_pango_entries = append(interfaces_pango_entries, *entry)
		}
	}
	rejectDefaultRoute_value := o.RejectDefaultRoute.ValueBoolPointer()
	var timers_entry *virtual_router.ProtocolRipTimers
	if !o.Timers.IsUnknown() && !o.Timers.IsNull() {
		if *obj != nil && (*obj).Timers != nil {
			timers_entry = (*obj).Timers
		} else {
			timers_entry = new(virtual_router.ProtocolRipTimers)
		}
		var object *VirtualRouterResourceProtocolRipTimersObject
		diags.Append(o.Timers.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &timers_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRip)
	}
	(*obj).AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	(*obj).AuthProfile = authProfile_pango_entries
	(*obj).Enable = enable_value
	(*obj).ExportRules = exportRules_pango_entries
	(*obj).GlobalBfd = globalBfd_entry
	(*obj).Interface = interfaces_pango_entries
	(*obj).RejectDefaultRoute = rejectDefaultRoute_value
	(*obj).Timers = timers_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipAuthProfileObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	var md5_tf_entries []VirtualRouterResourceProtocolRipAuthProfileMd5Object
	var md5_pango_entries []virtual_router.ProtocolRipAuthProfileMd5
	{
		d := o.Md5.ElementsAs(ctx, &md5_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range md5_tf_entries {
			var entry *virtual_router.ProtocolRipAuthProfileMd5
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			md5_pango_entries = append(md5_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfile)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Password = password_value
	(*obj).Md5 = md5_pango_entries

	return diags
}
func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	key_value := o.Key.ValueStringPointer()
	preferred_value := o.Preferred.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipAuthProfileMd5)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Key = key_value
	(*obj).Preferred = preferred_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipExportRulesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipExportRules)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipGlobalBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	mode_value := o.Mode.ValueStringPointer()
	var defaultRoute_entry *virtual_router.ProtocolRipInterfaceDefaultRoute
	if !o.DefaultRoute.IsUnknown() && !o.DefaultRoute.IsNull() {
		if *obj != nil && (*obj).DefaultRoute != nil {
			defaultRoute_entry = (*obj).DefaultRoute
		} else {
			defaultRoute_entry = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
		}
		var object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject
		diags.Append(o.DefaultRoute.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &defaultRoute_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var bfd_entry *virtual_router.ProtocolRipInterfaceBfd
	if !o.Bfd.IsUnknown() && !o.Bfd.IsNull() {
		if *obj != nil && (*obj).Bfd != nil {
			bfd_entry = (*obj).Bfd
		} else {
			bfd_entry = new(virtual_router.ProtocolRipInterfaceBfd)
		}
		var object *VirtualRouterResourceProtocolRipInterfacesBfdObject
		diags.Append(o.Bfd.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bfd_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterface)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Enable = enable_value
	(*obj).Authentication = authentication_value
	(*obj).Mode = mode_value
	(*obj).DefaultRoute = defaultRoute_entry
	(*obj).Bfd = bfd_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var disable_entry *virtual_router.ProtocolRipInterfaceDefaultRouteDisable
	if !o.Disable.IsUnknown() && !o.Disable.IsNull() {
		if *obj != nil && (*obj).Disable != nil {
			disable_entry = (*obj).Disable
		} else {
			disable_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
		}
		var object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject
		diags.Append(o.Disable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &disable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
		}
		var object *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRoute)
	}
	(*obj).Disable = disable_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteDisable)
	}

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	metric_value := o.Metric.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise)
	}
	(*obj).Metric = metric_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipInterfaceBfd)
	}
	(*obj).Profile = profile_value

	return diags
}
func (o *VirtualRouterResourceProtocolRipTimersObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **virtual_router.ProtocolRipTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	deleteIntervals_value := o.DeleteIntervals.ValueInt64Pointer()
	expireIntervals_value := o.ExpireIntervals.ValueInt64Pointer()
	intervalSeconds_value := o.IntervalSeconds.ValueInt64Pointer()
	updateIntervals_value := o.UpdateIntervals.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(virtual_router.ProtocolRipTimers)
	}
	(*obj).DeleteIntervals = deleteIntervals_value
	(*obj).ExpireIntervals = expireIntervals_value
	(*obj).IntervalSeconds = intervalSeconds_value
	(*obj).UpdateIntervals = updateIntervals_value

	return diags
}

func (o *VirtualRouterResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaces_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interfaces.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interfaces_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var administrativeDistances_obj *VirtualRouterResourceAdministrativeDistancesObject
	if o.AdministrativeDistances.IsNull() {
		administrativeDistances_obj = new(VirtualRouterResourceAdministrativeDistancesObject)
	} else {
		diags.Append(o.AdministrativeDistances.As(ctx, &administrativeDistances_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	administrativeDistances_object := types.ObjectNull(administrativeDistances_obj.AttributeTypes())
	if obj.AdminDists != nil {
		diags.Append(administrativeDistances_obj.CopyFromPango(ctx, client, ancestors, obj.AdminDists, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		administrativeDistances_object, diags_tmp = types.ObjectValueFrom(ctx, administrativeDistances_obj.AttributeTypes(), administrativeDistances_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ecmp_obj *VirtualRouterResourceEcmpObject
	if o.Ecmp.IsNull() {
		ecmp_obj = new(VirtualRouterResourceEcmpObject)
	} else {
		diags.Append(o.Ecmp.As(ctx, &ecmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ecmp_object := types.ObjectNull(ecmp_obj.AttributeTypes())
	if obj.Ecmp != nil {
		diags.Append(ecmp_obj.CopyFromPango(ctx, client, ancestors, obj.Ecmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ecmp_object, diags_tmp = types.ObjectValueFrom(ctx, ecmp_obj.AttributeTypes(), ecmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var multicast_obj *VirtualRouterResourceMulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(VirtualRouterResourceMulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, ancestors, obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var protocol_obj *VirtualRouterResourceProtocolObject
	if o.Protocol.IsNull() {
		protocol_obj = new(VirtualRouterResourceProtocolObject)
	} else {
		diags.Append(o.Protocol.As(ctx, &protocol_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	protocol_object := types.ObjectNull(protocol_obj.AttributeTypes())
	if obj.Protocol != nil {
		diags.Append(protocol_obj.CopyFromPango(ctx, client, ancestors, obj.Protocol, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		protocol_object, diags_tmp = types.ObjectValueFrom(ctx, protocol_obj.AttributeTypes(), protocol_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.AdministrativeDistances = administrativeDistances_object
	o.Ecmp = ecmp_object
	o.Interfaces = interfaces_list
	o.Multicast = multicast_object
	o.Protocol = protocol_object

	return diags
}

func (o *VirtualRouterResourceAdministrativeDistancesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.AdminDists, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ebgp_value types.Int64
	if obj.Ebgp != nil {
		ebgp_value = types.Int64Value(*obj.Ebgp)
	}
	var ibgp_value types.Int64
	if obj.Ibgp != nil {
		ibgp_value = types.Int64Value(*obj.Ibgp)
	}
	var ospfExt_value types.Int64
	if obj.OspfExt != nil {
		ospfExt_value = types.Int64Value(*obj.OspfExt)
	}
	var ospfInt_value types.Int64
	if obj.OspfInt != nil {
		ospfInt_value = types.Int64Value(*obj.OspfInt)
	}
	var ospfv3Ext_value types.Int64
	if obj.Ospfv3Ext != nil {
		ospfv3Ext_value = types.Int64Value(*obj.Ospfv3Ext)
	}
	var ospfv3Int_value types.Int64
	if obj.Ospfv3Int != nil {
		ospfv3Int_value = types.Int64Value(*obj.Ospfv3Int)
	}
	var rip_value types.Int64
	if obj.Rip != nil {
		rip_value = types.Int64Value(*obj.Rip)
	}
	var static_value types.Int64
	if obj.Static != nil {
		static_value = types.Int64Value(*obj.Static)
	}
	var staticIpv6_value types.Int64
	if obj.StaticIpv6 != nil {
		staticIpv6_value = types.Int64Value(*obj.StaticIpv6)
	}
	o.Ebgp = ebgp_value
	o.Ibgp = ibgp_value
	o.OspfExt = ospfExt_value
	o.OspfInt = ospfInt_value
	o.Ospfv3Ext = ospfv3Ext_value
	o.Ospfv3Int = ospfv3Int_value
	o.Rip = rip_value
	o.Static = static_value
	o.StaticIpv6 = staticIpv6_value

	return diags
}

func (o *VirtualRouterResourceEcmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Ecmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_obj *VirtualRouterResourceEcmpAlgorithmObject
	if o.Algorithm.IsNull() {
		algorithm_obj = new(VirtualRouterResourceEcmpAlgorithmObject)
	} else {
		diags.Append(o.Algorithm.As(ctx, &algorithm_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	algorithm_object := types.ObjectNull(algorithm_obj.AttributeTypes())
	if obj.Algorithm != nil {
		diags.Append(algorithm_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Algorithm, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		algorithm_object, diags_tmp = types.ObjectValueFrom(ctx, algorithm_obj.AttributeTypes(), algorithm_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var maxPaths_value types.Int64
	if obj.MaxPath != nil {
		maxPaths_value = types.Int64Value(*obj.MaxPath)
	}
	var strictSourcePath_value types.Bool
	if obj.StrictSourcePath != nil {
		strictSourcePath_value = types.BoolValue(*obj.StrictSourcePath)
	}
	var symmetricReturn_value types.Bool
	if obj.SymmetricReturn != nil {
		symmetricReturn_value = types.BoolValue(*obj.SymmetricReturn)
	}
	o.Algorithm = algorithm_object
	o.Enable = enable_value
	o.MaxPaths = maxPaths_value
	o.StrictSourcePath = strictSourcePath_value
	o.SymmetricReturn = symmetricReturn_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithm, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var balancedRoundRobin_obj *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject
	if o.BalancedRoundRobin.IsNull() {
		balancedRoundRobin_obj = new(VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject)
	} else {
		diags.Append(o.BalancedRoundRobin.As(ctx, &balancedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	balancedRoundRobin_object := types.ObjectNull(balancedRoundRobin_obj.AttributeTypes())
	if obj.BalancedRoundRobin != nil {
		diags.Append(balancedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.BalancedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		balancedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, balancedRoundRobin_obj.AttributeTypes(), balancedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipHash_obj *VirtualRouterResourceEcmpAlgorithmIpHashObject
	if o.IpHash.IsNull() {
		ipHash_obj = new(VirtualRouterResourceEcmpAlgorithmIpHashObject)
	} else {
		diags.Append(o.IpHash.As(ctx, &ipHash_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipHash_object := types.ObjectNull(ipHash_obj.AttributeTypes())
	if obj.IpHash != nil {
		diags.Append(ipHash_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpHash, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipHash_object, diags_tmp = types.ObjectValueFrom(ctx, ipHash_obj.AttributeTypes(), ipHash_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipModulo_obj *VirtualRouterResourceEcmpAlgorithmIpModuloObject
	if o.IpModulo.IsNull() {
		ipModulo_obj = new(VirtualRouterResourceEcmpAlgorithmIpModuloObject)
	} else {
		diags.Append(o.IpModulo.As(ctx, &ipModulo_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipModulo_object := types.ObjectNull(ipModulo_obj.AttributeTypes())
	if obj.IpModulo != nil {
		diags.Append(ipModulo_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IpModulo, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipModulo_object, diags_tmp = types.ObjectValueFrom(ctx, ipModulo_obj.AttributeTypes(), ipModulo_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var weightedRoundRobin_obj *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject
	if o.WeightedRoundRobin.IsNull() {
		weightedRoundRobin_obj = new(VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject)
	} else {
		diags.Append(o.WeightedRoundRobin.As(ctx, &weightedRoundRobin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	weightedRoundRobin_object := types.ObjectNull(weightedRoundRobin_obj.AttributeTypes())
	if obj.WeightedRoundRobin != nil {
		diags.Append(weightedRoundRobin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WeightedRoundRobin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		weightedRoundRobin_object, diags_tmp = types.ObjectValueFrom(ctx, weightedRoundRobin_obj.AttributeTypes(), weightedRoundRobin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.BalancedRoundRobin = balancedRoundRobin_object
	o.IpHash = ipHash_object
	o.IpModulo = ipModulo_object
	o.WeightedRoundRobin = weightedRoundRobin_object

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmBalancedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmBalancedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpHashObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmIpHash, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hashSeed_value types.Int64
	if obj.HashSeed != nil {
		hashSeed_value = types.Int64Value(*obj.HashSeed)
	}
	var srcOnly_value types.Bool
	if obj.SrcOnly != nil {
		srcOnly_value = types.BoolValue(*obj.SrcOnly)
	}
	var usePort_value types.Bool
	if obj.UsePort != nil {
		usePort_value = types.BoolValue(*obj.UsePort)
	}
	o.HashSeed = hashSeed_value
	o.SrcOnly = srcOnly_value
	o.UsePort = usePort_value

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmIpModuloObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmIpModulo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmWeightedRoundRobin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}

	o.Interface = interface_list

	return diags
}

func (o *VirtualRouterResourceEcmpAlgorithmWeightedRoundRobinInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.EcmpAlgorithmWeightedRoundRobinInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	o.Name = types.StringValue(obj.Name)
	o.Weight = weight_value

	return diags
}

func (o *VirtualRouterResourceMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interfaceGroup_list types.List
	{
		var interfaceGroup_tf_entries []VirtualRouterResourceMulticastInterfaceGroupObject
		if !o.InterfaceGroup.IsNull() {
			diags.Append(o.InterfaceGroup.ElementsAs(ctx, &interfaceGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.InterfaceGroup {
			entry := VirtualRouterResourceMulticastInterfaceGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaceGroup_tf_entries) {
				entry = interfaceGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaceGroup_tf_entries) {
				interfaceGroup_tf_entries[idx] = entry
			} else {
				interfaceGroup_tf_entries = append(interfaceGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface_group")
		interfaceGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaceGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var sptThreshold_list types.List
	{
		var sptThreshold_tf_entries []VirtualRouterResourceMulticastSptThresholdObject
		if !o.SptThreshold.IsNull() {
			diags.Append(o.SptThreshold.ElementsAs(ctx, &sptThreshold_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SptThreshold {
			entry := VirtualRouterResourceMulticastSptThresholdObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sptThreshold_tf_entries) {
				entry = sptThreshold_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sptThreshold_tf_entries) {
				sptThreshold_tf_entries[idx] = entry
			} else {
				sptThreshold_tf_entries = append(sptThreshold_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("spt_threshold")
		sptThreshold_list, list_diags = types.ListValueFrom(ctx, schemaType, sptThreshold_tf_entries)
		diags.Append(list_diags...)
	}
	var ssmAddressSpace_list types.List
	{
		var ssmAddressSpace_tf_entries []VirtualRouterResourceMulticastSsmAddressSpaceObject
		if !o.SsmAddressSpace.IsNull() {
			diags.Append(o.SsmAddressSpace.ElementsAs(ctx, &ssmAddressSpace_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SsmAddressSpace {
			entry := VirtualRouterResourceMulticastSsmAddressSpaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ssmAddressSpace_tf_entries) {
				entry = ssmAddressSpace_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ssmAddressSpace_tf_entries) {
				ssmAddressSpace_tf_entries[idx] = entry
			} else {
				ssmAddressSpace_tf_entries = append(ssmAddressSpace_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ssm_address_space")
		ssmAddressSpace_list, list_diags = types.ListValueFrom(ctx, schemaType, ssmAddressSpace_tf_entries)
		diags.Append(list_diags...)
	}

	var rp_obj *VirtualRouterResourceMulticastRpObject
	if o.Rp.IsNull() {
		rp_obj = new(VirtualRouterResourceMulticastRpObject)
	} else {
		diags.Append(o.Rp.As(ctx, &rp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rp_object := types.ObjectNull(rp_obj.AttributeTypes())
	if obj.Rp != nil {
		diags.Append(rp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rp_object, diags_tmp = types.ObjectValueFrom(ctx, rp_obj.AttributeTypes(), rp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeAgeoutTime_value types.Int64
	if obj.RouteAgeoutTime != nil {
		routeAgeoutTime_value = types.Int64Value(*obj.RouteAgeoutTime)
	}
	o.Enable = enable_value
	o.InterfaceGroup = interfaceGroup_list
	o.RouteAgeoutTime = routeAgeoutTime_value
	o.Rp = rp_object
	o.SptThreshold = sptThreshold_list
	o.SsmAddressSpace = ssmAddressSpace_list

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var groupPermission_obj *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject
	if o.GroupPermission.IsNull() {
		groupPermission_obj = new(VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject)
	} else {
		diags.Append(o.GroupPermission.As(ctx, &groupPermission_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	groupPermission_object := types.ObjectNull(groupPermission_obj.AttributeTypes())
	if obj.GroupPermission != nil {
		diags.Append(groupPermission_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GroupPermission, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		groupPermission_object, diags_tmp = types.ObjectValueFrom(ctx, groupPermission_obj.AttributeTypes(), groupPermission_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var igmp_obj *VirtualRouterResourceMulticastInterfaceGroupIgmpObject
	if o.Igmp.IsNull() {
		igmp_obj = new(VirtualRouterResourceMulticastInterfaceGroupIgmpObject)
	} else {
		diags.Append(o.Igmp.As(ctx, &igmp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	igmp_object := types.ObjectNull(igmp_obj.AttributeTypes())
	if obj.Igmp != nil {
		diags.Append(igmp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Igmp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		igmp_object, diags_tmp = types.ObjectValueFrom(ctx, igmp_obj.AttributeTypes(), igmp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pim_obj *VirtualRouterResourceMulticastInterfaceGroupPimObject
	if o.Pim.IsNull() {
		pim_obj = new(VirtualRouterResourceMulticastInterfaceGroupPimObject)
	} else {
		diags.Append(o.Pim.As(ctx, &pim_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pim_object := types.ObjectNull(pim_obj.AttributeTypes())
	if obj.Pim != nil {
		diags.Append(pim_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pim, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pim_object, diags_tmp = types.ObjectValueFrom(ctx, pim_obj.AttributeTypes(), pim_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Name = types.StringValue(obj.Name)
	o.Description = description_value
	o.Interface = interface_list
	o.GroupPermission = groupPermission_object
	o.Igmp = igmp_object
	o.Pim = pim_object

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermission, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var anySourceMulticast_list types.List
	{
		var anySourceMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject
		if !o.AnySourceMulticast.IsNull() {
			diags.Append(o.AnySourceMulticast.ElementsAs(ctx, &anySourceMulticast_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AnySourceMulticast {
			entry := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(anySourceMulticast_tf_entries) {
				entry = anySourceMulticast_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(anySourceMulticast_tf_entries) {
				anySourceMulticast_tf_entries[idx] = entry
			} else {
				anySourceMulticast_tf_entries = append(anySourceMulticast_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("any_source_multicast")
		anySourceMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, anySourceMulticast_tf_entries)
		diags.Append(list_diags...)
	}
	var sourceSpecificMulticast_list types.List
	{
		var sourceSpecificMulticast_tf_entries []VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject
		if !o.SourceSpecificMulticast.IsNull() {
			diags.Append(o.SourceSpecificMulticast.ElementsAs(ctx, &sourceSpecificMulticast_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SourceSpecificMulticast {
			entry := VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(sourceSpecificMulticast_tf_entries) {
				entry = sourceSpecificMulticast_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(sourceSpecificMulticast_tf_entries) {
				sourceSpecificMulticast_tf_entries[idx] = entry
			} else {
				sourceSpecificMulticast_tf_entries = append(sourceSpecificMulticast_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("source_specific_multicast")
		sourceSpecificMulticast_list, list_diags = types.ListValueFrom(ctx, schemaType, sourceSpecificMulticast_tf_entries)
		diags.Append(list_diags...)
	}

	o.AnySourceMulticast = anySourceMulticast_list
	o.SourceSpecificMulticast = sourceSpecificMulticast_list

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionAnySourceMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermissionAnySourceMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupGroupPermissionSourceSpecificMulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupGroupPermissionSourceSpecificMulticast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var sourceAddress_value types.String
	if obj.SourceAddress != nil {
		sourceAddress_value = types.StringValue(*obj.SourceAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.SourceAddress = sourceAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupIgmpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupIgmp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var version_value types.String
	if obj.Version != nil {
		version_value = types.StringValue(*obj.Version)
	}
	var maxQueryResponseTime_value types.Float64
	if obj.MaxQueryResponseTime != nil {
		maxQueryResponseTime_value = types.Float64Value(*obj.MaxQueryResponseTime)
	}
	var queryInterval_value types.Int64
	if obj.QueryInterval != nil {
		queryInterval_value = types.Int64Value(*obj.QueryInterval)
	}
	var lastMemberQueryInterval_value types.Float64
	if obj.LastMemberQueryInterval != nil {
		lastMemberQueryInterval_value = types.Float64Value(*obj.LastMemberQueryInterval)
	}
	var immediateLeave_value types.Bool
	if obj.ImmediateLeave != nil {
		immediateLeave_value = types.BoolValue(*obj.ImmediateLeave)
	}
	var robustness_value types.String
	if obj.Robustness != nil {
		robustness_value = types.StringValue(*obj.Robustness)
	}
	var maxGroups_value types.String
	if obj.MaxGroups != nil {
		maxGroups_value = types.StringValue(*obj.MaxGroups)
	}
	var maxSources_value types.String
	if obj.MaxSources != nil {
		maxSources_value = types.StringValue(*obj.MaxSources)
	}
	var routerAlertPolicing_value types.Bool
	if obj.RouterAlertPolicing != nil {
		routerAlertPolicing_value = types.BoolValue(*obj.RouterAlertPolicing)
	}
	o.Enable = enable_value
	o.Version = version_value
	o.MaxQueryResponseTime = maxQueryResponseTime_value
	o.QueryInterval = queryInterval_value
	o.LastMemberQueryInterval = lastMemberQueryInterval_value
	o.ImmediateLeave = immediateLeave_value
	o.Robustness = robustness_value
	o.MaxGroups = maxGroups_value
	o.MaxSources = maxSources_value
	o.RouterAlertPolicing = routerAlertPolicing_value

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupPim, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var allowedNeighbors_list types.List
	{
		var allowedNeighbors_tf_entries []VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject
		if !o.AllowedNeighbors.IsNull() {
			diags.Append(o.AllowedNeighbors.ElementsAs(ctx, &allowedNeighbors_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AllowedNeighbors {
			entry := VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(allowedNeighbors_tf_entries) {
				entry = allowedNeighbors_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(allowedNeighbors_tf_entries) {
				allowedNeighbors_tf_entries[idx] = entry
			} else {
				allowedNeighbors_tf_entries = append(allowedNeighbors_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("allowed_neighbors")
		allowedNeighbors_list, list_diags = types.ListValueFrom(ctx, schemaType, allowedNeighbors_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var assertInterval_value types.Int64
	if obj.AssertInterval != nil {
		assertInterval_value = types.Int64Value(*obj.AssertInterval)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var joinPruneInterval_value types.Int64
	if obj.JoinPruneInterval != nil {
		joinPruneInterval_value = types.Int64Value(*obj.JoinPruneInterval)
	}
	var drPriority_value types.Int64
	if obj.DrPriority != nil {
		drPriority_value = types.Int64Value(*obj.DrPriority)
	}
	var bsrBorder_value types.Bool
	if obj.BsrBorder != nil {
		bsrBorder_value = types.BoolValue(*obj.BsrBorder)
	}
	o.Enable = enable_value
	o.AssertInterval = assertInterval_value
	o.HelloInterval = helloInterval_value
	o.JoinPruneInterval = joinPruneInterval_value
	o.DrPriority = drPriority_value
	o.BsrBorder = bsrBorder_value
	o.AllowedNeighbors = allowedNeighbors_list

	return diags
}

func (o *VirtualRouterResourceMulticastInterfaceGroupPimAllowedNeighborsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastInterfaceGroupPimAllowedNeighbors, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceMulticastRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var externalRp_list types.List
	{
		var externalRp_tf_entries []VirtualRouterResourceMulticastRpExternalRpObject
		if !o.ExternalRp.IsNull() {
			diags.Append(o.ExternalRp.ElementsAs(ctx, &externalRp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExternalRp {
			entry := VirtualRouterResourceMulticastRpExternalRpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(externalRp_tf_entries) {
				entry = externalRp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(externalRp_tf_entries) {
				externalRp_tf_entries[idx] = entry
			} else {
				externalRp_tf_entries = append(externalRp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("external_rp")
		externalRp_list, list_diags = types.ListValueFrom(ctx, schemaType, externalRp_tf_entries)
		diags.Append(list_diags...)
	}

	var localRp_obj *VirtualRouterResourceMulticastRpLocalRpObject
	if o.LocalRp.IsNull() {
		localRp_obj = new(VirtualRouterResourceMulticastRpLocalRpObject)
	} else {
		diags.Append(o.LocalRp.As(ctx, &localRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localRp_object := types.ObjectNull(localRp_obj.AttributeTypes())
	if obj.LocalRp != nil {
		diags.Append(localRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localRp_object, diags_tmp = types.ObjectValueFrom(ctx, localRp_obj.AttributeTypes(), localRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.ExternalRp = externalRp_list
	o.LocalRp = localRp_object

	return diags
}

func (o *VirtualRouterResourceMulticastRpExternalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpExternalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddresses = groupAddresses_list
	o.Override = override_value

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var candidateRp_obj *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject
	if o.CandidateRp.IsNull() {
		candidateRp_obj = new(VirtualRouterResourceMulticastRpLocalRpCandidateRpObject)
	} else {
		diags.Append(o.CandidateRp.As(ctx, &candidateRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	candidateRp_object := types.ObjectNull(candidateRp_obj.AttributeTypes())
	if obj.CandidateRp != nil {
		diags.Append(candidateRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.CandidateRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		candidateRp_object, diags_tmp = types.ObjectValueFrom(ctx, candidateRp_obj.AttributeTypes(), candidateRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticRp_obj *VirtualRouterResourceMulticastRpLocalRpStaticRpObject
	if o.StaticRp.IsNull() {
		staticRp_obj = new(VirtualRouterResourceMulticastRpLocalRpStaticRpObject)
	} else {
		diags.Append(o.StaticRp.As(ctx, &staticRp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticRp_object := types.ObjectNull(staticRp_obj.AttributeTypes())
	if obj.StaticRp != nil {
		diags.Append(staticRp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticRp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticRp_object, diags_tmp = types.ObjectValueFrom(ctx, staticRp_obj.AttributeTypes(), staticRp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.CandidateRp = candidateRp_object
	o.StaticRp = staticRp_object

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpCandidateRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRpCandidateRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var advertisementInterval_value types.Int64
	if obj.AdvertisementInterval != nil {
		advertisementInterval_value = types.Int64Value(*obj.AdvertisementInterval)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Address = address_value
	o.AdvertisementInterval = advertisementInterval_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Priority = priority_value

	return diags
}

func (o *VirtualRouterResourceMulticastRpLocalRpStaticRpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastRpLocalRpStaticRp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var groupAddresses_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.GroupAddresses.IsNull() || len(obj.GroupAddresses) > 0 {
			entries = obj.GroupAddresses
		}

		groupAddresses_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var address_value types.String
	if obj.Address != nil {
		address_value = types.StringValue(*obj.Address)
	}
	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var override_value types.Bool
	if obj.Override != nil {
		override_value = types.BoolValue(*obj.Override)
	}
	o.Address = address_value
	o.GroupAddresses = groupAddresses_list
	o.Interface = interface_value
	o.Override = override_value

	return diags
}

func (o *VirtualRouterResourceMulticastSptThresholdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastSptThreshold, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var threshold_value types.String
	if obj.Threshold != nil {
		threshold_value = types.StringValue(*obj.Threshold)
	}
	o.Name = types.StringValue(obj.Name)
	o.Threshold = threshold_value

	return diags
}

func (o *VirtualRouterResourceMulticastSsmAddressSpaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.MulticastSsmAddressSpace, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var groupAddress_value types.String
	if obj.GroupAddress != nil {
		groupAddress_value = types.StringValue(*obj.GroupAddress)
	}
	var included_value types.Bool
	if obj.Included != nil {
		included_value = types.BoolValue(*obj.Included)
	}
	o.Name = types.StringValue(obj.Name)
	o.GroupAddress = groupAddress_value
	o.Included = included_value

	return diags
}

func (o *VirtualRouterResourceProtocolObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.Protocol, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var redistProfile_list types.List
	{
		var redistProfile_tf_entries []VirtualRouterResourceProtocolRedistProfileObject
		if !o.RedistProfile.IsNull() {
			diags.Append(o.RedistProfile.ElementsAs(ctx, &redistProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistProfile {
			entry := VirtualRouterResourceProtocolRedistProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistProfile_tf_entries) {
				entry = redistProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistProfile_tf_entries) {
				redistProfile_tf_entries[idx] = entry
			} else {
				redistProfile_tf_entries = append(redistProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile")
		redistProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var redistProfileIpv6_list types.List
	{
		var redistProfileIpv6_tf_entries []VirtualRouterResourceProtocolRedistProfileIpv6Object
		if !o.RedistProfileIpv6.IsNull() {
			diags.Append(o.RedistProfileIpv6.ElementsAs(ctx, &redistProfileIpv6_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistProfileIpv6 {
			entry := VirtualRouterResourceProtocolRedistProfileIpv6Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistProfileIpv6_tf_entries) {
				entry = redistProfileIpv6_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistProfileIpv6_tf_entries) {
				redistProfileIpv6_tf_entries[idx] = entry
			} else {
				redistProfileIpv6_tf_entries = append(redistProfileIpv6_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_profile_ipv6")
		redistProfileIpv6_list, list_diags = types.ListValueFrom(ctx, schemaType, redistProfileIpv6_tf_entries)
		diags.Append(list_diags...)
	}

	var bgp_obj *VirtualRouterResourceProtocolBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterResourceProtocolBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *VirtualRouterResourceProtocolOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(VirtualRouterResourceProtocolOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *VirtualRouterResourceProtocolOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(VirtualRouterResourceProtocolOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var rip_obj *VirtualRouterResourceProtocolRipObject
	if o.Rip.IsNull() {
		rip_obj = new(VirtualRouterResourceProtocolRipObject)
	} else {
		diags.Append(o.Rip.As(ctx, &rip_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	rip_object := types.ObjectNull(rip_obj.AttributeTypes())
	if obj.Rip != nil {
		diags.Append(rip_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Rip, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		rip_object, diags_tmp = types.ObjectValueFrom(ctx, rip_obj.AttributeTypes(), rip_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Bgp = bgp_object
	o.Ospf = ospf_object
	o.Ospfv3 = ospfv3_object
	o.RedistProfile = redistProfile_list
	o.RedistProfileIpv6 = redistProfileIpv6_list
	o.Rip = rip_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolBgpAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterResourceProtocolBgpAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var dampeningProfile_list types.List
	{
		var dampeningProfile_tf_entries []VirtualRouterResourceProtocolBgpDampeningProfileObject
		if !o.DampeningProfile.IsNull() {
			diags.Append(o.DampeningProfile.ElementsAs(ctx, &dampeningProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.DampeningProfile {
			entry := VirtualRouterResourceProtocolBgpDampeningProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(dampeningProfile_tf_entries) {
				entry = dampeningProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(dampeningProfile_tf_entries) {
				dampeningProfile_tf_entries[idx] = entry
			} else {
				dampeningProfile_tf_entries = append(dampeningProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("dampening_profile")
		dampeningProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, dampeningProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var peerGroup_list types.List
	{
		var peerGroup_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupObject
		if !o.PeerGroup.IsNull() {
			diags.Append(o.PeerGroup.ElementsAs(ctx, &peerGroup_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.PeerGroup {
			entry := VirtualRouterResourceProtocolBgpPeerGroupObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peerGroup_tf_entries) {
				entry = peerGroup_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peerGroup_tf_entries) {
				peerGroup_tf_entries[idx] = entry
			} else {
				peerGroup_tf_entries = append(peerGroup_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer_group")
		peerGroup_list, list_diags = types.ListValueFrom(ctx, schemaType, peerGroup_tf_entries)
		diags.Append(list_diags...)
	}
	var redistRules_list types.List
	{
		var redistRules_tf_entries []VirtualRouterResourceProtocolBgpRedistRulesObject
		if !o.RedistRules.IsNull() {
			diags.Append(o.RedistRules.ElementsAs(ctx, &redistRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.RedistRules {
			entry := VirtualRouterResourceProtocolBgpRedistRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(redistRules_tf_entries) {
				entry = redistRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(redistRules_tf_entries) {
				redistRules_tf_entries[idx] = entry
			} else {
				redistRules_tf_entries = append(redistRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("redist_rules")
		redistRules_list, list_diags = types.ListValueFrom(ctx, schemaType, redistRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterResourceProtocolBgpGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterResourceProtocolBgpGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var policy_obj *VirtualRouterResourceProtocolBgpPolicyObject
	if o.Policy.IsNull() {
		policy_obj = new(VirtualRouterResourceProtocolBgpPolicyObject)
	} else {
		diags.Append(o.Policy.As(ctx, &policy_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	policy_object := types.ObjectNull(policy_obj.AttributeTypes())
	if obj.Policy != nil {
		diags.Append(policy_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Policy, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		policy_object, diags_tmp = types.ObjectValueFrom(ctx, policy_obj.AttributeTypes(), policy_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routingOptions_obj *VirtualRouterResourceProtocolBgpRoutingOptionsObject
	if o.RoutingOptions.IsNull() {
		routingOptions_obj = new(VirtualRouterResourceProtocolBgpRoutingOptionsObject)
	} else {
		diags.Append(o.RoutingOptions.As(ctx, &routingOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routingOptions_object := types.ObjectNull(routingOptions_obj.AttributeTypes())
	if obj.RoutingOptions != nil {
		diags.Append(routingOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RoutingOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routingOptions_object, diags_tmp = types.ObjectValueFrom(ctx, routingOptions_obj.AttributeTypes(), routingOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var ecmpMultiAs_value types.Bool
	if obj.EcmpMultiAs != nil {
		ecmpMultiAs_value = types.BoolValue(*obj.EcmpMultiAs)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enforceFirstAs_value types.Bool
	if obj.EnforceFirstAs != nil {
		enforceFirstAs_value = types.BoolValue(*obj.EnforceFirstAs)
	}
	var installRoute_value types.Bool
	if obj.InstallRoute != nil {
		installRoute_value = types.BoolValue(*obj.InstallRoute)
	}
	var localAs_value types.String
	if obj.LocalAs != nil {
		localAs_value = types.StringValue(*obj.LocalAs)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.DampeningProfile = dampeningProfile_list
	o.EcmpMultiAs = ecmpMultiAs_value
	o.Enable = enable_value
	o.EnforceFirstAs = enforceFirstAs_value
	o.GlobalBfd = globalBfd_object
	o.InstallRoute = installRoute_value
	o.LocalAs = localAs_value
	o.PeerGroup = peerGroup_list
	o.Policy = policy_object
	o.RedistRules = redistRules_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value
	o.RoutingOptions = routingOptions_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var secret_value types.String
	if obj.Secret != nil {
		secret_value = types.StringValue(*obj.Secret)
	}
	o.Name = types.StringValue(obj.Name)
	o.Secret = secret_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpDampeningProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpDampeningProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var cutoff_value types.Float64
	if obj.Cutoff != nil {
		cutoff_value = types.Float64Value(*obj.Cutoff)
	}
	var reuse_value types.Float64
	if obj.Reuse != nil {
		reuse_value = types.Float64Value(*obj.Reuse)
	}
	var maxHoldTime_value types.Int64
	if obj.MaxHoldTime != nil {
		maxHoldTime_value = types.Int64Value(*obj.MaxHoldTime)
	}
	var decayHalfLifeReachable_value types.Int64
	if obj.DecayHalfLifeReachable != nil {
		decayHalfLifeReachable_value = types.Int64Value(*obj.DecayHalfLifeReachable)
	}
	var decayHalfLifeUnreachable_value types.Int64
	if obj.DecayHalfLifeUnreachable != nil {
		decayHalfLifeUnreachable_value = types.Int64Value(*obj.DecayHalfLifeUnreachable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Cutoff = cutoff_value
	o.Reuse = reuse_value
	o.MaxHoldTime = maxHoldTime_value
	o.DecayHalfLifeReachable = decayHalfLifeReachable_value
	o.DecayHalfLifeUnreachable = decayHalfLifeUnreachable_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroup, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var peer_list types.List
	{
		var peer_tf_entries []VirtualRouterResourceProtocolBgpPeerGroupPeerObject
		if !o.Peer.IsNull() {
			diags.Append(o.Peer.ElementsAs(ctx, &peer_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Peer {
			entry := VirtualRouterResourceProtocolBgpPeerGroupPeerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(peer_tf_entries) {
				entry = peer_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(peer_tf_entries) {
				peer_tf_entries[idx] = entry
			} else {
				peer_tf_entries = append(peer_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("peer")
		peer_list, list_diags = types.ListValueFrom(ctx, schemaType, peer_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterResourceProtocolBgpPeerGroupTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterResourceProtocolBgpPeerGroupTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var aggregatedConfedAsPath_value types.Bool
	if obj.AggregatedConfedAsPath != nil {
		aggregatedConfedAsPath_value = types.BoolValue(*obj.AggregatedConfedAsPath)
	}
	var softResetWithStoredInfo_value types.Bool
	if obj.SoftResetWithStoredInfo != nil {
		softResetWithStoredInfo_value = types.BoolValue(*obj.SoftResetWithStoredInfo)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.AggregatedConfedAsPath = aggregatedConfedAsPath_value
	o.SoftResetWithStoredInfo = softResetWithStoredInfo_value
	o.Type = type_object
	o.Peer = peer_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ibgp_obj *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject
	if o.Ibgp.IsNull() {
		ibgp_obj = new(VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject)
	} else {
		diags.Append(o.Ibgp.As(ctx, &ibgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgp_object := types.ObjectNull(ibgp_obj.AttributeTypes())
	if obj.Ibgp != nil {
		diags.Append(ibgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ibgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgp_object, diags_tmp = types.ObjectValueFrom(ctx, ibgp_obj.AttributeTypes(), ibgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgpConfed_obj *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject
	if o.EbgpConfed.IsNull() {
		ebgpConfed_obj = new(VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject)
	} else {
		diags.Append(o.EbgpConfed.As(ctx, &ebgpConfed_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgpConfed_object := types.ObjectNull(ebgpConfed_obj.AttributeTypes())
	if obj.EbgpConfed != nil {
		diags.Append(ebgpConfed_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.EbgpConfed, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgpConfed_object, diags_tmp = types.ObjectValueFrom(ctx, ebgpConfed_obj.AttributeTypes(), ebgpConfed_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ibgpConfed_obj *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject
	if o.IbgpConfed.IsNull() {
		ibgpConfed_obj = new(VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject)
	} else {
		diags.Append(o.IbgpConfed.As(ctx, &ibgpConfed_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ibgpConfed_object := types.ObjectNull(ibgpConfed_obj.AttributeTypes())
	if obj.IbgpConfed != nil {
		diags.Append(ibgpConfed_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IbgpConfed, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ibgpConfed_object, diags_tmp = types.ObjectValueFrom(ctx, ibgpConfed_obj.AttributeTypes(), ibgpConfed_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ebgp_obj *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject
	if o.Ebgp.IsNull() {
		ebgp_obj = new(VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject)
	} else {
		diags.Append(o.Ebgp.As(ctx, &ebgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ebgp_object := types.ObjectNull(ebgp_obj.AttributeTypes())
	if obj.Ebgp != nil {
		diags.Append(ebgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ebgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ebgp_object, diags_tmp = types.ObjectValueFrom(ctx, ebgp_obj.AttributeTypes(), ebgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Ibgp = ibgp_object
	o.EbgpConfed = ebgpConfed_object
	o.IbgpConfed = ibgpConfed_object
	o.Ebgp = ebgp_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpConfedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeIbgpConfedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeIbgpConfed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	o.ExportNexthop = exportNexthop_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupTypeEbgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupTypeEbgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var importNexthop_value types.String
	if obj.ImportNexthop != nil {
		importNexthop_value = types.StringValue(*obj.ImportNexthop)
	}
	var exportNexthop_value types.String
	if obj.ExportNexthop != nil {
		exportNexthop_value = types.StringValue(*obj.ExportNexthop)
	}
	var removePrivateAs_value types.Bool
	if obj.RemovePrivateAs != nil {
		removePrivateAs_value = types.BoolValue(*obj.RemovePrivateAs)
	}
	o.ImportNexthop = importNexthop_value
	o.ExportNexthop = exportNexthop_value
	o.RemovePrivateAs = removePrivateAs_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var subsequentAddressFamilyIdentifier_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject
	if o.SubsequentAddressFamilyIdentifier.IsNull() {
		subsequentAddressFamilyIdentifier_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject)
	} else {
		diags.Append(o.SubsequentAddressFamilyIdentifier.As(ctx, &subsequentAddressFamilyIdentifier_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	subsequentAddressFamilyIdentifier_object := types.ObjectNull(subsequentAddressFamilyIdentifier_obj.AttributeTypes())
	if obj.SubsequentAddressFamilyIdentifier != nil {
		diags.Append(subsequentAddressFamilyIdentifier_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SubsequentAddressFamilyIdentifier, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		subsequentAddressFamilyIdentifier_object, diags_tmp = types.ObjectValueFrom(ctx, subsequentAddressFamilyIdentifier_obj.AttributeTypes(), subsequentAddressFamilyIdentifier_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localAddress_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject
	if o.LocalAddress.IsNull() {
		localAddress_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject)
	} else {
		diags.Append(o.LocalAddress.As(ctx, &localAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	localAddress_object := types.ObjectNull(localAddress_obj.AttributeTypes())
	if obj.LocalAddress != nil {
		diags.Append(localAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LocalAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		localAddress_object, diags_tmp = types.ObjectValueFrom(ctx, localAddress_obj.AttributeTypes(), localAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var peerAddress_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject
	if o.PeerAddress.IsNull() {
		peerAddress_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject)
	} else {
		diags.Append(o.PeerAddress.As(ctx, &peerAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	peerAddress_object := types.ObjectNull(peerAddress_obj.AttributeTypes())
	if obj.PeerAddress != nil {
		diags.Append(peerAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PeerAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		peerAddress_object, diags_tmp = types.ObjectValueFrom(ctx, peerAddress_obj.AttributeTypes(), peerAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var connectionOptions_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject
	if o.ConnectionOptions.IsNull() {
		connectionOptions_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject)
	} else {
		diags.Append(o.ConnectionOptions.As(ctx, &connectionOptions_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	connectionOptions_object := types.ObjectNull(connectionOptions_obj.AttributeTypes())
	if obj.ConnectionOptions != nil {
		diags.Append(connectionOptions_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConnectionOptions, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		connectionOptions_object, diags_tmp = types.ObjectValueFrom(ctx, connectionOptions_obj.AttributeTypes(), connectionOptions_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var peerAs_value types.String
	if obj.PeerAs != nil {
		peerAs_value = types.StringValue(*obj.PeerAs)
	}
	var enableMpBgp_value types.Bool
	if obj.EnableMpBgp != nil {
		enableMpBgp_value = types.BoolValue(*obj.EnableMpBgp)
	}
	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var enableSenderSideLoopDetection_value types.Bool
	if obj.EnableSenderSideLoopDetection != nil {
		enableSenderSideLoopDetection_value = types.BoolValue(*obj.EnableSenderSideLoopDetection)
	}
	var reflectorClient_value types.String
	if obj.ReflectorClient != nil {
		reflectorClient_value = types.StringValue(*obj.ReflectorClient)
	}
	var peeringType_value types.String
	if obj.PeeringType != nil {
		peeringType_value = types.StringValue(*obj.PeeringType)
	}
	var maxPrefixes_value types.String
	if obj.MaxPrefixes != nil {
		maxPrefixes_value = types.StringValue(*obj.MaxPrefixes)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.PeerAs = peerAs_value
	o.EnableMpBgp = enableMpBgp_value
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.EnableSenderSideLoopDetection = enableSenderSideLoopDetection_value
	o.ReflectorClient = reflectorClient_value
	o.PeeringType = peeringType_value
	o.MaxPrefixes = maxPrefixes_value
	o.SubsequentAddressFamilyIdentifier = subsequentAddressFamilyIdentifier_object
	o.LocalAddress = localAddress_object
	o.PeerAddress = peerAddress_object
	o.ConnectionOptions = connectionOptions_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifierObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerSubsequentAddressFamilyIdentifier, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_value types.Bool
	if obj.Unicast != nil {
		unicast_value = types.BoolValue(*obj.Unicast)
	}
	var multicast_value types.Bool
	if obj.Multicast != nil {
		multicast_value = types.BoolValue(*obj.Multicast)
	}
	o.Unicast = unicast_value
	o.Multicast = multicast_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerLocalAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerLocalAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interface_value types.String
	if obj.Interface != nil {
		interface_value = types.StringValue(*obj.Interface)
	}
	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	o.Interface = interface_value
	o.Ip = ip_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerPeerAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerPeerAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ip_value types.String
	if obj.Ip != nil {
		ip_value = types.StringValue(*obj.Ip)
	}
	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	o.Ip = ip_value
	o.Fqdn = fqdn_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var incomingBgpConnection_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject
	if o.IncomingBgpConnection.IsNull() {
		incomingBgpConnection_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject)
	} else {
		diags.Append(o.IncomingBgpConnection.As(ctx, &incomingBgpConnection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	incomingBgpConnection_object := types.ObjectNull(incomingBgpConnection_obj.AttributeTypes())
	if obj.IncomingBgpConnection != nil {
		diags.Append(incomingBgpConnection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.IncomingBgpConnection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		incomingBgpConnection_object, diags_tmp = types.ObjectValueFrom(ctx, incomingBgpConnection_obj.AttributeTypes(), incomingBgpConnection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var outgoingBgpConnection_obj *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject
	if o.OutgoingBgpConnection.IsNull() {
		outgoingBgpConnection_obj = new(VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject)
	} else {
		diags.Append(o.OutgoingBgpConnection.As(ctx, &outgoingBgpConnection_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	outgoingBgpConnection_object := types.ObjectNull(outgoingBgpConnection_obj.AttributeTypes())
	if obj.OutgoingBgpConnection != nil {
		diags.Append(outgoingBgpConnection_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.OutgoingBgpConnection, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		outgoingBgpConnection_object, diags_tmp = types.ObjectValueFrom(ctx, outgoingBgpConnection_obj.AttributeTypes(), outgoingBgpConnection_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var keepAliveInterval_value types.String
	if obj.KeepAliveInterval != nil {
		keepAliveInterval_value = types.StringValue(*obj.KeepAliveInterval)
	}
	var minRouteAdvInterval_value types.Int64
	if obj.MinRouteAdvInterval != nil {
		minRouteAdvInterval_value = types.Int64Value(*obj.MinRouteAdvInterval)
	}
	var multihop_value types.Int64
	if obj.Multihop != nil {
		multihop_value = types.Int64Value(*obj.Multihop)
	}
	var openDelayTime_value types.Int64
	if obj.OpenDelayTime != nil {
		openDelayTime_value = types.Int64Value(*obj.OpenDelayTime)
	}
	var holdTime_value types.String
	if obj.HoldTime != nil {
		holdTime_value = types.StringValue(*obj.HoldTime)
	}
	var idleHoldTime_value types.Int64
	if obj.IdleHoldTime != nil {
		idleHoldTime_value = types.Int64Value(*obj.IdleHoldTime)
	}
	o.Authentication = authentication_value
	o.KeepAliveInterval = keepAliveInterval_value
	o.MinRouteAdvInterval = minRouteAdvInterval_value
	o.Multihop = multihop_value
	o.OpenDelayTime = openDelayTime_value
	o.HoldTime = holdTime_value
	o.IdleHoldTime = idleHoldTime_value
	o.IncomingBgpConnection = incomingBgpConnection_object
	o.OutgoingBgpConnection = outgoingBgpConnection_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsIncomingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var remotePort_value types.Int64
	if obj.RemotePort != nil {
		remotePort_value = types.Int64Value(*obj.RemotePort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.RemotePort = remotePort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnectionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerConnectionOptionsOutgoingBgpConnection, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var localPort_value types.Int64
	if obj.LocalPort != nil {
		localPort_value = types.Int64Value(*obj.LocalPort)
	}
	var allow_value types.Bool
	if obj.Allow != nil {
		allow_value = types.BoolValue(*obj.Allow)
	}
	o.LocalPort = localPort_value
	o.Allow = allow_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPeerGroupPeerBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPeerGroupPeerBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregation_obj *VirtualRouterResourceProtocolBgpPolicyAggregationObject
	if o.Aggregation.IsNull() {
		aggregation_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationObject)
	} else {
		diags.Append(o.Aggregation.As(ctx, &aggregation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregation_object := types.ObjectNull(aggregation_obj.AttributeTypes())
	if obj.Aggregation != nil {
		diags.Append(aggregation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregation_object, diags_tmp = types.ObjectValueFrom(ctx, aggregation_obj.AttributeTypes(), aggregation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var conditionalAdvertisement_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject
	if o.ConditionalAdvertisement.IsNull() {
		conditionalAdvertisement_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject)
	} else {
		diags.Append(o.ConditionalAdvertisement.As(ctx, &conditionalAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	conditionalAdvertisement_object := types.ObjectNull(conditionalAdvertisement_obj.AttributeTypes())
	if obj.ConditionalAdvertisement != nil {
		diags.Append(conditionalAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ConditionalAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		conditionalAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, conditionalAdvertisement_obj.AttributeTypes(), conditionalAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var export_obj *VirtualRouterResourceProtocolBgpPolicyExportObject
	if o.Export.IsNull() {
		export_obj = new(VirtualRouterResourceProtocolBgpPolicyExportObject)
	} else {
		diags.Append(o.Export.As(ctx, &export_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	export_object := types.ObjectNull(export_obj.AttributeTypes())
	if obj.Export != nil {
		diags.Append(export_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Export, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		export_object, diags_tmp = types.ObjectValueFrom(ctx, export_obj.AttributeTypes(), export_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var import_obj *VirtualRouterResourceProtocolBgpPolicyImportObject
	if o.Import.IsNull() {
		import_obj = new(VirtualRouterResourceProtocolBgpPolicyImportObject)
	} else {
		diags.Append(o.Import.As(ctx, &import_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	import_object := types.ObjectNull(import_obj.AttributeTypes())
	if obj.Import != nil {
		diags.Append(import_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Import, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		import_object, diags_tmp = types.ObjectValueFrom(ctx, import_obj.AttributeTypes(), import_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Aggregation = aggregation_object
	o.ConditionalAdvertisement = conditionalAdvertisement_object
	o.Export = export_object
	o.Import = import_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var address_list types.List
	{
		var address_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject
		if !o.Address.IsNull() {
			diags.Append(o.Address.ElementsAs(ctx, &address_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(address_tf_entries) {
				entry = address_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(address_tf_entries) {
				address_tf_entries[idx] = entry
			} else {
				address_tf_entries = append(address_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address")
		address_list, list_diags = types.ListValueFrom(ctx, schemaType, address_tf_entries)
		diags.Append(list_diags...)
	}

	o.Address = address_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suppressFilters_list types.List
	{
		var suppressFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject
		if !o.SuppressFilters.IsNull() {
			diags.Append(o.SuppressFilters.ElementsAs(ctx, &suppressFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.SuppressFilters {
			entry := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suppressFilters_tf_entries) {
				entry = suppressFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suppressFilters_tf_entries) {
				suppressFilters_tf_entries[idx] = entry
			} else {
				suppressFilters_tf_entries = append(suppressFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suppress_filters")
		suppressFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, suppressFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject
		if !o.AdvertiseFilters.IsNull() {
			diags.Append(o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AdvertiseFilters {
			entry := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(advertiseFilters_tf_entries) {
				entry = advertiseFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(advertiseFilters_tf_entries) {
				advertiseFilters_tf_entries[idx] = entry
			} else {
				advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}

	var aggregateRouteAttributes_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject
	if o.AggregateRouteAttributes.IsNull() {
		aggregateRouteAttributes_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject)
	} else {
		diags.Append(o.AggregateRouteAttributes.As(ctx, &aggregateRouteAttributes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregateRouteAttributes_object := types.ObjectNull(aggregateRouteAttributes_obj.AttributeTypes())
	if obj.AggregateRouteAttributes != nil {
		diags.Append(aggregateRouteAttributes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AggregateRouteAttributes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregateRouteAttributes_object, diags_tmp = types.ObjectValueFrom(ctx, aggregateRouteAttributes_obj.AttributeTypes(), aggregateRouteAttributes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prefix_value types.String
	if obj.Prefix != nil {
		prefix_value = types.StringValue(*obj.Prefix)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var summary_value types.Bool
	if obj.Summary != nil {
		summary_value = types.BoolValue(*obj.Summary)
	}
	var asSet_value types.Bool
	if obj.AsSet != nil {
		asSet_value = types.BoolValue(*obj.AsSet)
	}
	o.Name = types.StringValue(obj.Name)
	o.Prefix = prefix_value
	o.Enable = enable_value
	o.Summary = summary_value
	o.AsSet = asSet_value
	o.AggregateRouteAttributes = aggregateRouteAttributes_object
	o.SuppressFilters = suppressFilters_list
	o.AdvertiseFilters = advertiseFilters_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Weight = weight_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	o.None = none_object
	o.Prepend = prepend_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAggregateRouteAttributesExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressSuppressFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyAggregationAddressAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var policy_list types.List
	{
		var policy_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject
		if !o.Policy.IsNull() {
			diags.Append(o.Policy.ElementsAs(ctx, &policy_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Policy {
			entry := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(policy_tf_entries) {
				entry = policy_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(policy_tf_entries) {
				policy_tf_entries[idx] = entry
			} else {
				policy_tf_entries = append(policy_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("policy")
		policy_list, list_diags = types.ListValueFrom(ctx, schemaType, policy_tf_entries)
		diags.Append(list_diags...)
	}

	o.Policy = policy_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nonExistFilters_list types.List
	{
		var nonExistFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject
		if !o.NonExistFilters.IsNull() {
			diags.Append(o.NonExistFilters.ElementsAs(ctx, &nonExistFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NonExistFilters {
			entry := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nonExistFilters_tf_entries) {
				entry = nonExistFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nonExistFilters_tf_entries) {
				nonExistFilters_tf_entries[idx] = entry
			} else {
				nonExistFilters_tf_entries = append(nonExistFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("non_exist_filters")
		nonExistFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, nonExistFilters_tf_entries)
		diags.Append(list_diags...)
	}
	var advertiseFilters_list types.List
	{
		var advertiseFilters_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject
		if !o.AdvertiseFilters.IsNull() {
			diags.Append(o.AdvertiseFilters.ElementsAs(ctx, &advertiseFilters_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AdvertiseFilters {
			entry := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(advertiseFilters_tf_entries) {
				entry = advertiseFilters_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(advertiseFilters_tf_entries) {
				advertiseFilters_tf_entries[idx] = entry
			} else {
				advertiseFilters_tf_entries = append(advertiseFilters_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("advertise_filters")
		advertiseFilters_list, list_diags = types.ListValueFrom(ctx, schemaType, advertiseFilters_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.NonExistFilters = nonExistFilters_list
	o.AdvertiseFilters = advertiseFilters_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyNonExistFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFilters, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var match_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Match = match_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyConditionalAdvertisementPolicyAdvertiseFiltersMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VirtualRouterResourceProtocolBgpPolicyExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var match_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deny_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject
	if o.Deny.IsNull() {
		deny_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject)
	} else {
		diags.Append(o.Deny.As(ctx, &deny_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	deny_object := types.ObjectNull(deny_obj.AttributeTypes())
	if obj.Deny != nil {
		diags.Append(deny_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Deny, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		deny_object, diags_tmp = types.ObjectValueFrom(ctx, deny_obj.AttributeTypes(), deny_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionDenyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var update_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject
	if o.Update.IsNull() {
		update_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject)
	} else {
		diags.Append(o.Update.As(ctx, &update_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	update_object := types.ObjectNull(update_obj.AttributeTypes())
	if obj.Update != nil {
		diags.Append(update_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Update, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		update_object, diags_tmp = types.ObjectValueFrom(ctx, update_obj.AttributeTypes(), update_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Update = update_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var remove_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject
	if o.Remove.IsNull() {
		remove_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject)
	} else {
		diags.Append(o.Remove.As(ctx, &remove_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	remove_object := types.ObjectNull(remove_obj.AttributeTypes())
	if obj.Remove != nil {
		diags.Append(remove_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Remove, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		remove_object, diags_tmp = types.ObjectValueFrom(ctx, remove_obj.AttributeTypes(), remove_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prepend_value types.Int64
	if obj.Prepend != nil {
		prepend_value = types.Int64Value(*obj.Prepend)
	}
	var removeAndPrepend_value types.Int64
	if obj.RemoveAndPrepend != nil {
		removeAndPrepend_value = types.Int64Value(*obj.RemoveAndPrepend)
	}
	o.None = none_object
	o.Remove = remove_object
	o.Prepend = prepend_value
	o.RemoveAndPrepend = removeAndPrepend_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyExportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var rules_list types.List
	{
		var rules_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesObject
		if !o.Rules.IsNull() {
			diags.Append(o.Rules.ElementsAs(ctx, &rules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Rules {
			entry := VirtualRouterResourceProtocolBgpPolicyImportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(rules_tf_entries) {
				entry = rules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(rules_tf_entries) {
				rules_tf_entries[idx] = entry
			} else {
				rules_tf_entries = append(rules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("rules")
		rules_list, list_diags = types.ListValueFrom(ctx, schemaType, rules_tf_entries)
		diags.Append(list_diags...)
	}

	o.Rules = rules_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var usedBy_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.UsedBy.IsNull() || len(obj.UsedBy) > 0 {
			entries = obj.UsedBy
		}

		usedBy_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var match_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject
	if o.Match.IsNull() {
		match_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject)
	} else {
		diags.Append(o.Match.As(ctx, &match_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	match_object := types.ObjectNull(match_obj.AttributeTypes())
	if obj.Match != nil {
		diags.Append(match_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Match, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		match_object, diags_tmp = types.ObjectValueFrom(ctx, match_obj.AttributeTypes(), match_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.UsedBy = usedBy_list
	o.Match = match_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatch, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addressPrefix_list types.List
	{
		var addressPrefix_tf_entries []VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject
		if !o.AddressPrefix.IsNull() {
			diags.Append(o.AddressPrefix.ElementsAs(ctx, &addressPrefix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AddressPrefix {
			entry := VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addressPrefix_tf_entries) {
				entry = addressPrefix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addressPrefix_tf_entries) {
				addressPrefix_tf_entries[idx] = entry
			} else {
				addressPrefix_tf_entries = append(addressPrefix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("address_prefix")
		addressPrefix_list, list_diags = types.ListValueFrom(ctx, schemaType, addressPrefix_tf_entries)
		diags.Append(list_diags...)
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var fromPeer_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.FromPeer.IsNull() || len(obj.FromPeer) > 0 {
			entries = obj.FromPeer
		}

		fromPeer_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	o.RouteTable = routeTable_value
	o.Med = med_value
	o.AddressPrefix = addressPrefix_list
	o.Nexthop = nexthop_list
	o.FromPeer = fromPeer_list
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAddressPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var exact_value types.Bool
	if obj.Exact != nil {
		exact_value = types.BoolValue(*obj.Exact)
	}
	o.Name = types.StringValue(obj.Name)
	o.Exact = exact_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesMatchExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesMatchExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var regex_value types.String
	if obj.Regex != nil {
		regex_value = types.StringValue(*obj.Regex)
	}
	o.Regex = regex_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deny_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject
	if o.Deny.IsNull() {
		deny_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject)
	} else {
		diags.Append(o.Deny.As(ctx, &deny_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	deny_object := types.ObjectNull(deny_obj.AttributeTypes())
	if obj.Deny != nil {
		diags.Append(deny_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Deny, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		deny_object, diags_tmp = types.ObjectValueFrom(ctx, deny_obj.AttributeTypes(), deny_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allow_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject
	if o.Allow.IsNull() {
		allow_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject)
	} else {
		diags.Append(o.Allow.As(ctx, &allow_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allow_object := types.ObjectNull(allow_obj.AttributeTypes())
	if obj.Allow != nil {
		diags.Append(allow_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Allow, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allow_object, diags_tmp = types.ObjectValueFrom(ctx, allow_obj.AttributeTypes(), allow_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Deny = deny_object
	o.Allow = allow_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionDenyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionDeny, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllow, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var update_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject
	if o.Update.IsNull() {
		update_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject)
	} else {
		diags.Append(o.Update.As(ctx, &update_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	update_object := types.ObjectNull(update_obj.AttributeTypes())
	if obj.Update != nil {
		diags.Append(update_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Update, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		update_object, diags_tmp = types.ObjectValueFrom(ctx, update_obj.AttributeTypes(), update_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dampening_value types.String
	if obj.Dampening != nil {
		dampening_value = types.StringValue(*obj.Dampening)
	}
	o.Dampening = dampening_value
	o.Update = update_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var asPath_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject
	if o.AsPath.IsNull() {
		asPath_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject)
	} else {
		diags.Append(o.AsPath.As(ctx, &asPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	asPath_object := types.ObjectNull(asPath_obj.AttributeTypes())
	if obj.AsPath != nil {
		diags.Append(asPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AsPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		asPath_object, diags_tmp = types.ObjectValueFrom(ctx, asPath_obj.AttributeTypes(), asPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var community_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject
	if o.Community.IsNull() {
		community_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject)
	} else {
		diags.Append(o.Community.As(ctx, &community_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	community_object := types.ObjectNull(community_obj.AttributeTypes())
	if obj.Community != nil {
		diags.Append(community_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Community, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		community_object, diags_tmp = types.ObjectValueFrom(ctx, community_obj.AttributeTypes(), community_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extendedCommunity_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject
	if o.ExtendedCommunity.IsNull() {
		extendedCommunity_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject)
	} else {
		diags.Append(o.ExtendedCommunity.As(ctx, &extendedCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extendedCommunity_object := types.ObjectNull(extendedCommunity_obj.AttributeTypes())
	if obj.ExtendedCommunity != nil {
		diags.Append(extendedCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ExtendedCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extendedCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, extendedCommunity_obj.AttributeTypes(), extendedCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var localPreference_value types.Int64
	if obj.LocalPreference != nil {
		localPreference_value = types.Int64Value(*obj.LocalPreference)
	}
	var med_value types.Int64
	if obj.Med != nil {
		med_value = types.Int64Value(*obj.Med)
	}
	var weight_value types.Int64
	if obj.Weight != nil {
		weight_value = types.Int64Value(*obj.Weight)
	}
	var nexthop_value types.String
	if obj.Nexthop != nil {
		nexthop_value = types.StringValue(*obj.Nexthop)
	}
	var origin_value types.String
	if obj.Origin != nil {
		origin_value = types.StringValue(*obj.Origin)
	}
	var asPathLimit_value types.Int64
	if obj.AsPathLimit != nil {
		asPathLimit_value = types.Int64Value(*obj.AsPathLimit)
	}
	o.LocalPreference = localPreference_value
	o.Med = med_value
	o.Weight = weight_value
	o.Nexthop = nexthop_value
	o.Origin = origin_value
	o.AsPathLimit = asPathLimit_value
	o.AsPath = asPath_object
	o.Community = community_object
	o.ExtendedCommunity = extendedCommunity_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var none_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var remove_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject
	if o.Remove.IsNull() {
		remove_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject)
	} else {
		diags.Append(o.Remove.As(ctx, &remove_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	remove_object := types.ObjectNull(remove_obj.AttributeTypes())
	if obj.Remove != nil {
		diags.Append(remove_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Remove, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		remove_object, diags_tmp = types.ObjectValueFrom(ctx, remove_obj.AttributeTypes(), remove_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.None = none_object
	o.Remove = remove_object

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemoveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateAsPathRemove, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var append_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Append.IsNull() || len(obj.Append) > 0 {
			entries = obj.Append
		}

		append_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var overwrite_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Overwrite.IsNull() || len(obj.Overwrite) > 0 {
			entries = obj.Overwrite
		}

		overwrite_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeAll_obj *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject
	if o.RemoveAll.IsNull() {
		removeAll_obj = new(VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject)
	} else {
		diags.Append(o.RemoveAll.As(ctx, &removeAll_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removeAll_object := types.ObjectNull(removeAll_obj.AttributeTypes())
	if obj.RemoveAll != nil {
		diags.Append(removeAll_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemoveAll, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removeAll_object, diags_tmp = types.ObjectValueFrom(ctx, removeAll_obj.AttributeTypes(), removeAll_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removeRegex_value types.String
	if obj.RemoveRegex != nil {
		removeRegex_value = types.StringValue(*obj.RemoveRegex)
	}
	o.None = none_object
	o.RemoveAll = removeAll_object
	o.RemoveRegex = removeRegex_value
	o.Append = append_list
	o.Overwrite = overwrite_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpPolicyImportRulesActionAllowUpdateExtendedCommunityRemoveAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRedistRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRedistRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var setCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SetCommunity.IsNull() || len(obj.SetCommunity) > 0 {
			entries = obj.SetCommunity
		}

		setCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var setExtendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.SetExtendedCommunity.IsNull() || len(obj.SetExtendedCommunity) > 0 {
			entries = obj.SetExtendedCommunity
		}

		setExtendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var addressFamilyIdentifier_value types.String
	if obj.AddressFamilyIdentifier != nil {
		addressFamilyIdentifier_value = types.StringValue(*obj.AddressFamilyIdentifier)
	}
	var routeTable_value types.String
	if obj.RouteTable != nil {
		routeTable_value = types.StringValue(*obj.RouteTable)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var setOrigin_value types.String
	if obj.SetOrigin != nil {
		setOrigin_value = types.StringValue(*obj.SetOrigin)
	}
	var setMed_value types.Int64
	if obj.SetMed != nil {
		setMed_value = types.Int64Value(*obj.SetMed)
	}
	var setLocalPreference_value types.Int64
	if obj.SetLocalPreference != nil {
		setLocalPreference_value = types.Int64Value(*obj.SetLocalPreference)
	}
	var setAsPathLimit_value types.Int64
	if obj.SetAsPathLimit != nil {
		setAsPathLimit_value = types.Int64Value(*obj.SetAsPathLimit)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.AddressFamilyIdentifier = addressFamilyIdentifier_value
	o.RouteTable = routeTable_value
	o.Enable = enable_value
	o.SetOrigin = setOrigin_value
	o.SetMed = setMed_value
	o.SetLocalPreference = setLocalPreference_value
	o.SetAsPathLimit = setAsPathLimit_value
	o.Metric = metric_value
	o.SetCommunity = setCommunity_list
	o.SetExtendedCommunity = setExtendedCommunity_list

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptions, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregate_obj *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject
	if o.Aggregate.IsNull() {
		aggregate_obj = new(VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject)
	} else {
		diags.Append(o.Aggregate.As(ctx, &aggregate_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	aggregate_object := types.ObjectNull(aggregate_obj.AttributeTypes())
	if obj.Aggregate != nil {
		diags.Append(aggregate_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Aggregate, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		aggregate_object, diags_tmp = types.ObjectValueFrom(ctx, aggregate_obj.AttributeTypes(), aggregate_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var med_obj *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject
	if o.Med.IsNull() {
		med_obj = new(VirtualRouterResourceProtocolBgpRoutingOptionsMedObject)
	} else {
		diags.Append(o.Med.As(ctx, &med_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	med_object := types.ObjectNull(med_obj.AttributeTypes())
	if obj.Med != nil {
		diags.Append(med_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Med, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		med_object, diags_tmp = types.ObjectValueFrom(ctx, med_obj.AttributeTypes(), med_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asFormat_value types.String
	if obj.AsFormat != nil {
		asFormat_value = types.StringValue(*obj.AsFormat)
	}
	var confederationMemberAs_value types.String
	if obj.ConfederationMemberAs != nil {
		confederationMemberAs_value = types.StringValue(*obj.ConfederationMemberAs)
	}
	var defaultLocalPreference_value types.Int64
	if obj.DefaultLocalPreference != nil {
		defaultLocalPreference_value = types.Int64Value(*obj.DefaultLocalPreference)
	}
	var reflectorClusterId_value types.String
	if obj.ReflectorClusterId != nil {
		reflectorClusterId_value = types.StringValue(*obj.ReflectorClusterId)
	}
	o.Aggregate = aggregate_object
	o.AsFormat = asFormat_value
	o.ConfederationMemberAs = confederationMemberAs_value
	o.DefaultLocalPreference = defaultLocalPreference_value
	o.GracefulRestart = gracefulRestart_object
	o.Med = med_object
	o.ReflectorClusterId = reflectorClusterId_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsAggregateObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsAggregate, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var aggregateMed_value types.Bool
	if obj.AggregateMed != nil {
		aggregateMed_value = types.BoolValue(*obj.AggregateMed)
	}
	o.AggregateMed = aggregateMed_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var localRestartTime_value types.Int64
	if obj.LocalRestartTime != nil {
		localRestartTime_value = types.Int64Value(*obj.LocalRestartTime)
	}
	var maxPeerRestartTime_value types.Int64
	if obj.MaxPeerRestartTime != nil {
		maxPeerRestartTime_value = types.Int64Value(*obj.MaxPeerRestartTime)
	}
	var staleRouteTime_value types.Int64
	if obj.StaleRouteTime != nil {
		staleRouteTime_value = types.Int64Value(*obj.StaleRouteTime)
	}
	o.Enable = enable_value
	o.LocalRestartTime = localRestartTime_value
	o.MaxPeerRestartTime = maxPeerRestartTime_value
	o.StaleRouteTime = staleRouteTime_value

	return diags
}

func (o *VirtualRouterResourceProtocolBgpRoutingOptionsMedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolBgpRoutingOptionsMed, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var alwaysCompareMed_value types.Bool
	if obj.AlwaysCompareMed != nil {
		alwaysCompareMed_value = types.BoolValue(*obj.AlwaysCompareMed)
	}
	var deterministicMedComparison_value types.Bool
	if obj.DeterministicMedComparison != nil {
		deterministicMedComparison_value = types.BoolValue(*obj.DeterministicMedComparison)
	}
	o.AlwaysCompareMed = alwaysCompareMed_value
	o.DeterministicMedComparison = deterministicMedComparison_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterResourceProtocolOspfAreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := VirtualRouterResourceProtocolOspfAreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterResourceProtocolOspfAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolOspfExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterResourceProtocolOspfExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterResourceProtocolOspfGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterResourceProtocolOspfGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterResourceProtocolOspfGracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterResourceProtocolOspfGracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterResourceProtocolOspfTimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterResourceProtocolOspfTimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var rfc1583_value types.Bool
	if obj.Rfc1583 != nil {
		rfc1583_value = types.BoolValue(*obj.Rfc1583)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Rfc1583 = rfc1583_value
	o.RouterId = routerId_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfArea, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterResourceProtocolOspfAreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := VirtualRouterResourceProtocolOspfAreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterResourceProtocolOspfAreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfAreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := VirtualRouterResourceProtocolOspfAreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterResourceProtocolOspfAreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterResourceProtocolOspfAreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *VirtualRouterResourceProtocolOspfAreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *VirtualRouterResourceProtocolOspfAreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(VirtualRouterResourceProtocolOspfAreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultRoute_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterResourceProtocolOspfAreaRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var linkType_obj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Passive = passive_value
	o.Metric = metric_value
	o.Priority = priority_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterResourceProtocolOspfAuthProfileMd5Object
		if !o.Md5.IsNull() {
			diags.Append(o.Md5.ElementsAs(ctx, &md5_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Md5 {
			entry := VirtualRouterResourceProtocolOspfAuthProfileMd5Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(md5_tf_entries) {
				entry = md5_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(md5_tf_entries) {
				md5_tf_entries[idx] = entry
			} else {
				md5_tf_entries = append(md5_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfAuthProfileMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfGracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfGracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfTimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var area_list types.List
	{
		var area_tf_entries []VirtualRouterResourceProtocolOspfv3AreaObject
		if !o.Area.IsNull() {
			diags.Append(o.Area.ElementsAs(ctx, &area_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Area {
			entry := VirtualRouterResourceProtocolOspfv3AreaObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(area_tf_entries) {
				entry = area_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(area_tf_entries) {
				area_tf_entries[idx] = entry
			} else {
				area_tf_entries = append(area_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("area")
		area_list, list_diags = types.ListValueFrom(ctx, schemaType, area_tf_entries)
		diags.Append(list_diags...)
	}
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolOspfv3AuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterResourceProtocolOspfv3AuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolOspfv3ExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterResourceProtocolOspfv3ExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterResourceProtocolOspfv3GlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterResourceProtocolOspfv3GlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var gracefulRestart_obj *VirtualRouterResourceProtocolOspfv3GracefulRestartObject
	if o.GracefulRestart.IsNull() {
		gracefulRestart_obj = new(VirtualRouterResourceProtocolOspfv3GracefulRestartObject)
	} else {
		diags.Append(o.GracefulRestart.As(ctx, &gracefulRestart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gracefulRestart_object := types.ObjectNull(gracefulRestart_obj.AttributeTypes())
	if obj.GracefulRestart != nil {
		diags.Append(gracefulRestart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GracefulRestart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gracefulRestart_object, diags_tmp = types.ObjectValueFrom(ctx, gracefulRestart_obj.AttributeTypes(), gracefulRestart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterResourceProtocolOspfv3TimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterResourceProtocolOspfv3TimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var disableTransitTraffic_value types.Bool
	if obj.DisableTransitTraffic != nil {
		disableTransitTraffic_value = types.BoolValue(*obj.DisableTransitTraffic)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	var routerId_value types.String
	if obj.RouterId != nil {
		routerId_value = types.StringValue(*obj.RouterId)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.Area = area_list
	o.AuthProfile = authProfile_list
	o.DisableTransitTraffic = disableTransitTraffic_value
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.GracefulRestart = gracefulRestart_object
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.RouterId = routerId_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3Area, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var range_list types.List
	{
		var range_tf_entries []VirtualRouterResourceProtocolOspfv3AreaRangeObject
		if !o.Range.IsNull() {
			diags.Append(o.Range.ElementsAs(ctx, &range_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Range {
			entry := VirtualRouterResourceProtocolOspfv3AreaRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(range_tf_entries) {
				entry = range_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(range_tf_entries) {
				range_tf_entries[idx] = entry
			} else {
				range_tf_entries = append(range_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("range")
		range_list, list_diags = types.ListValueFrom(ctx, schemaType, range_tf_entries)
		diags.Append(list_diags...)
	}
	var interface_list types.List
	{
		var interface_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceObject
		if !o.Interface.IsNull() {
			diags.Append(o.Interface.ElementsAs(ctx, &interface_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterResourceProtocolOspfv3AreaInterfaceObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interface_tf_entries) {
				entry = interface_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interface_tf_entries) {
				interface_tf_entries[idx] = entry
			} else {
				interface_tf_entries = append(interface_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interface")
		interface_list, list_diags = types.ListValueFrom(ctx, schemaType, interface_tf_entries)
		diags.Append(list_diags...)
	}
	var virtualLink_list types.List
	{
		var virtualLink_tf_entries []VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject
		if !o.VirtualLink.IsNull() {
			diags.Append(o.VirtualLink.ElementsAs(ctx, &virtualLink_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.VirtualLink {
			entry := VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(virtualLink_tf_entries) {
				entry = virtualLink_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(virtualLink_tf_entries) {
				virtualLink_tf_entries[idx] = entry
			} else {
				virtualLink_tf_entries = append(virtualLink_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("virtual_link")
		virtualLink_list, list_diags = types.ListValueFrom(ctx, schemaType, virtualLink_tf_entries)
		diags.Append(list_diags...)
	}

	var type_obj *VirtualRouterResourceProtocolOspfv3AreaTypeObject
	if o.Type.IsNull() {
		type_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.Authentication = authentication_value
	o.Type = type_object
	o.Range = range_list
	o.Interface = interface_list
	o.VirtualLink = virtualLink_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var normal_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject
	if o.Normal.IsNull() {
		normal_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject)
	} else {
		diags.Append(o.Normal.As(ctx, &normal_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	normal_object := types.ObjectNull(normal_obj.AttributeTypes())
	if obj.Normal != nil {
		diags.Append(normal_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Normal, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		normal_object, diags_tmp = types.ObjectValueFrom(ctx, normal_obj.AttributeTypes(), normal_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var stub_obj *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject
	if o.Stub.IsNull() {
		stub_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubObject)
	} else {
		diags.Append(o.Stub.As(ctx, &stub_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	stub_object := types.ObjectNull(stub_obj.AttributeTypes())
	if obj.Stub != nil {
		diags.Append(stub_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Stub, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		stub_object, diags_tmp = types.ObjectValueFrom(ctx, stub_obj.AttributeTypes(), stub_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nssa_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject
	if o.Nssa.IsNull() {
		nssa_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject)
	} else {
		diags.Append(o.Nssa.As(ctx, &nssa_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nssa_object := types.ObjectNull(nssa_obj.AttributeTypes())
	if obj.Nssa != nil {
		diags.Append(nssa_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Nssa, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nssa_object, diags_tmp = types.ObjectValueFrom(ctx, nssa_obj.AttributeTypes(), nssa_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Normal = normal_object
	o.Stub = stub_object
	o.Nssa = nssa_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNormalObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNormal, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStub, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeStubDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeStubDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssa, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var nssaExtRange_list types.List
	{
		var nssaExtRange_tf_entries []VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject
		if !o.NssaExtRange.IsNull() {
			diags.Append(o.NssaExtRange.ElementsAs(ctx, &nssaExtRange_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.NssaExtRange {
			entry := VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(nssaExtRange_tf_entries) {
				entry = nssaExtRange_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(nssaExtRange_tf_entries) {
				nssaExtRange_tf_entries[idx] = entry
			} else {
				nssaExtRange_tf_entries = append(nssaExtRange_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("nssa_ext_range")
		nssaExtRange_list, list_diags = types.ListValueFrom(ctx, schemaType, nssaExtRange_tf_entries)
		diags.Append(list_diags...)
	}

	var defaultRoute_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptSummary_value types.Bool
	if obj.AcceptSummary != nil {
		acceptSummary_value = types.BoolValue(*obj.AcceptSummary)
	}
	o.AcceptSummary = acceptSummary_value
	o.DefaultRoute = defaultRoute_object
	o.NssaExtRange = nssaExtRange_list

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var type_value types.String
	if obj.Type != nil {
		type_value = types.StringValue(*obj.Type)
	}
	o.Metric = metric_value
	o.Type = type_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaTypeNssaNssaExtRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaTypeNssaNssaExtRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRange, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var suppress_obj *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject
	if o.Suppress.IsNull() {
		suppress_obj = new(VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject)
	} else {
		diags.Append(o.Suppress.As(ctx, &suppress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	suppress_object := types.ObjectNull(suppress_obj.AttributeTypes())
	if obj.Suppress != nil {
		diags.Append(suppress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Suppress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		suppress_object, diags_tmp = types.ObjectValueFrom(ctx, suppress_obj.AttributeTypes(), suppress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Advertise = advertise_object
	o.Suppress = suppress_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRangeAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaRangeSuppressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaRangeSuppress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var linkType_obj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject
	if o.LinkType.IsNull() {
		linkType_obj = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject)
	} else {
		diags.Append(o.LinkType.As(ctx, &linkType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	linkType_object := types.ObjectNull(linkType_obj.AttributeTypes())
	if obj.LinkType != nil {
		diags.Append(linkType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.LinkType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		linkType_object, diags_tmp = types.ObjectValueFrom(ctx, linkType_obj.AttributeTypes(), linkType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var passive_value types.Bool
	if obj.Passive != nil {
		passive_value = types.BoolValue(*obj.Passive)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var grDelay_value types.Int64
	if obj.GrDelay != nil {
		grDelay_value = types.Int64Value(*obj.GrDelay)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.Passive = passive_value
	o.Metric = metric_value
	o.Priority = priority_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.GrDelay = grDelay_value
	o.LinkType = linkType_object
	o.Neighbor = neighbor_list
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var broadcast_obj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject
	if o.Broadcast.IsNull() {
		broadcast_obj = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject)
	} else {
		diags.Append(o.Broadcast.As(ctx, &broadcast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	broadcast_object := types.ObjectNull(broadcast_obj.AttributeTypes())
	if obj.Broadcast != nil {
		diags.Append(broadcast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Broadcast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		broadcast_object, diags_tmp = types.ObjectValueFrom(ctx, broadcast_obj.AttributeTypes(), broadcast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2p_obj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject
	if o.P2p.IsNull() {
		p2p_obj = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject)
	} else {
		diags.Append(o.P2p.As(ctx, &p2p_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2p_object := types.ObjectNull(p2p_obj.AttributeTypes())
	if obj.P2p != nil {
		diags.Append(p2p_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2p, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2p_object, diags_tmp = types.ObjectValueFrom(ctx, p2p_obj.AttributeTypes(), p2p_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var p2mp_obj *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject
	if o.P2mp.IsNull() {
		p2mp_obj = new(VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject)
	} else {
		diags.Append(o.P2mp.As(ctx, &p2mp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	p2mp_object := types.ObjectNull(p2mp_obj.AttributeTypes())
	if obj.P2mp != nil {
		diags.Append(p2mp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.P2mp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		p2mp_object, diags_tmp = types.ObjectValueFrom(ctx, p2mp_obj.AttributeTypes(), p2mp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Broadcast = broadcast_object
	o.P2p = p2p_object
	o.P2mp = p2mp_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeBroadcastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeBroadcast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2pObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2p, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceLinkTypeP2mpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceLinkTypeP2mp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	o.Name = types.StringValue(obj.Name)

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaInterfaceBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaVirtualLink, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var bfd_obj *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborId_value types.String
	if obj.NeighborId != nil {
		neighborId_value = types.StringValue(*obj.NeighborId)
	}
	var transitAreaId_value types.String
	if obj.TransitAreaId != nil {
		transitAreaId_value = types.StringValue(*obj.TransitAreaId)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var instanceId_value types.Int64
	if obj.InstanceId != nil {
		instanceId_value = types.Int64Value(*obj.InstanceId)
	}
	var helloInterval_value types.Int64
	if obj.HelloInterval != nil {
		helloInterval_value = types.Int64Value(*obj.HelloInterval)
	}
	var deadCounts_value types.Int64
	if obj.DeadCounts != nil {
		deadCounts_value = types.Int64Value(*obj.DeadCounts)
	}
	var retransmitInterval_value types.Int64
	if obj.RetransmitInterval != nil {
		retransmitInterval_value = types.Int64Value(*obj.RetransmitInterval)
	}
	var transitDelay_value types.Int64
	if obj.TransitDelay != nil {
		transitDelay_value = types.Int64Value(*obj.TransitDelay)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	o.Name = types.StringValue(obj.Name)
	o.NeighborId = neighborId_value
	o.TransitAreaId = transitAreaId_value
	o.Enable = enable_value
	o.InstanceId = instanceId_value
	o.HelloInterval = helloInterval_value
	o.DeadCounts = deadCounts_value
	o.RetransmitInterval = retransmitInterval_value
	o.TransitDelay = transitDelay_value
	o.Authentication = authentication_value
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AreaVirtualLinkBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AreaVirtualLinkBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var esp_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject
	if o.Esp.IsNull() {
		esp_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspObject)
	} else {
		diags.Append(o.Esp.As(ctx, &esp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	esp_object := types.ObjectNull(esp_obj.AttributeTypes())
	if obj.Esp != nil {
		diags.Append(esp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Esp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		esp_object, diags_tmp = types.ObjectValueFrom(ctx, esp_obj.AttributeTypes(), esp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ah_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject
	if o.Ah.IsNull() {
		ah_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhObject)
	} else {
		diags.Append(o.Ah.As(ctx, &ah_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ah_object := types.ObjectNull(ah_obj.AttributeTypes())
	if obj.Ah != nil {
		diags.Append(ah_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ah, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ah_object, diags_tmp = types.ObjectValueFrom(ctx, ah_obj.AttributeTypes(), ah_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var spi_value types.String
	if obj.Spi != nil {
		spi_value = types.StringValue(*obj.Spi)
	}
	o.Name = types.StringValue(obj.Name)
	o.Spi = spi_value
	o.Esp = esp_object
	o.Ah = ah_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEsp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var authentication_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject
	if o.Authentication.IsNull() {
		authentication_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject)
	} else {
		diags.Append(o.Authentication.As(ctx, &authentication_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	authentication_object := types.ObjectNull(authentication_obj.AttributeTypes())
	if obj.Authentication != nil {
		diags.Append(authentication_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Authentication, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		authentication_object, diags_tmp = types.ObjectValueFrom(ctx, authentication_obj.AttributeTypes(), authentication_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var encryption_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject
	if o.Encryption.IsNull() {
		encryption_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject)
	} else {
		diags.Append(o.Encryption.As(ctx, &encryption_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	encryption_object := types.ObjectNull(encryption_obj.AttributeTypes())
	if obj.Encryption != nil {
		diags.Append(encryption_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Encryption, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		encryption_object, diags_tmp = types.ObjectValueFrom(ctx, encryption_obj.AttributeTypes(), encryption_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Authentication = authentication_object
	o.Encryption = encryption_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthentication, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var none_obj *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject
	if o.None.IsNull() {
		none_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject)
	} else {
		diags.Append(o.None.As(ctx, &none_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	none_object := types.ObjectNull(none_obj.AttributeTypes())
	if obj.None != nil {
		diags.Append(none_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.None, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		none_object, diags_tmp = types.ObjectValueFrom(ctx, none_obj.AttributeTypes(), none_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object
	o.None = none_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspAuthenticationNoneObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspAuthenticationNone, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileEspEncryptionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileEspEncryption, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var algorithm_value types.String
	if obj.Algorithm != nil {
		algorithm_value = types.StringValue(*obj.Algorithm)
	}
	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Algorithm = algorithm_value
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAh, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var md5_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object
	if o.Md5.IsNull() {
		md5_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object)
	} else {
		diags.Append(o.Md5.As(ctx, &md5_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	md5_object := types.ObjectNull(md5_obj.AttributeTypes())
	if obj.Md5 != nil {
		diags.Append(md5_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Md5, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		md5_object, diags_tmp = types.ObjectValueFrom(ctx, md5_obj.AttributeTypes(), md5_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha1_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object
	if o.Sha1.IsNull() {
		sha1_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object)
	} else {
		diags.Append(o.Sha1.As(ctx, &sha1_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha1_object := types.ObjectNull(sha1_obj.AttributeTypes())
	if obj.Sha1 != nil {
		diags.Append(sha1_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha1, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha1_object, diags_tmp = types.ObjectValueFrom(ctx, sha1_obj.AttributeTypes(), sha1_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha256_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object
	if o.Sha256.IsNull() {
		sha256_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object)
	} else {
		diags.Append(o.Sha256.As(ctx, &sha256_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha256_object := types.ObjectNull(sha256_obj.AttributeTypes())
	if obj.Sha256 != nil {
		diags.Append(sha256_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha256, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha256_object, diags_tmp = types.ObjectValueFrom(ctx, sha256_obj.AttributeTypes(), sha256_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha384_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object
	if o.Sha384.IsNull() {
		sha384_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object)
	} else {
		diags.Append(o.Sha384.As(ctx, &sha384_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha384_object := types.ObjectNull(sha384_obj.AttributeTypes())
	if obj.Sha384 != nil {
		diags.Append(sha384_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha384, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha384_object, diags_tmp = types.ObjectValueFrom(ctx, sha384_obj.AttributeTypes(), sha384_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sha512_obj *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object
	if o.Sha512.IsNull() {
		sha512_obj = new(VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object)
	} else {
		diags.Append(o.Sha512.As(ctx, &sha512_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sha512_object := types.ObjectNull(sha512_obj.AttributeTypes())
	if obj.Sha512 != nil {
		diags.Append(sha512_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Sha512, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sha512_object, diags_tmp = types.ObjectValueFrom(ctx, sha512_obj.AttributeTypes(), sha512_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Md5 = md5_object
	o.Sha1 = sha1_object
	o.Sha256 = sha256_object
	o.Sha384 = sha384_object
	o.Sha512 = sha512_object

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha1Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha1, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha256Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha256, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha384Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha384, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3AuthProfileAhSha512Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3AuthProfileAhSha512, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	o.Key = key_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3ExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3ExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var newPathType_value types.String
	if obj.NewPathType != nil {
		newPathType_value = types.StringValue(*obj.NewPathType)
	}
	var newTag_value types.String
	if obj.NewTag != nil {
		newTag_value = types.StringValue(*obj.NewTag)
	}
	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.NewPathType = newPathType_value
	o.NewTag = newTag_value
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3GlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3GlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3GracefulRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3GracefulRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var gracePeriod_value types.Int64
	if obj.GracePeriod != nil {
		gracePeriod_value = types.Int64Value(*obj.GracePeriod)
	}
	var helperEnable_value types.Bool
	if obj.HelperEnable != nil {
		helperEnable_value = types.BoolValue(*obj.HelperEnable)
	}
	var maxNeighborRestartTime_value types.Int64
	if obj.MaxNeighborRestartTime != nil {
		maxNeighborRestartTime_value = types.Int64Value(*obj.MaxNeighborRestartTime)
	}
	var strictLSAChecking_value types.Bool
	if obj.StrictLSAChecking != nil {
		strictLSAChecking_value = types.BoolValue(*obj.StrictLSAChecking)
	}
	o.Enable = enable_value
	o.GracePeriod = gracePeriod_value
	o.HelperEnable = helperEnable_value
	o.MaxNeighborRestartTime = maxNeighborRestartTime_value
	o.StrictLSAChecking = strictLSAChecking_value

	return diags
}

func (o *VirtualRouterResourceProtocolOspfv3TimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolOspfv3Timers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lsaInterval_value types.Float64
	if obj.LsaInterval != nil {
		lsaInterval_value = types.Float64Value(*obj.LsaInterval)
	}
	var spfCalculationDelay_value types.Float64
	if obj.SpfCalculationDelay != nil {
		spfCalculationDelay_value = types.Float64Value(*obj.SpfCalculationDelay)
	}
	o.LsaInterval = lsaInterval_value
	o.SpfCalculationDelay = spfCalculationDelay_value

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var filter_obj *VirtualRouterResourceProtocolRedistProfileFilterObject
	if o.Filter.IsNull() {
		filter_obj = new(VirtualRouterResourceProtocolRedistProfileFilterObject)
	} else {
		diags.Append(o.Filter.As(ctx, &filter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filter_object := types.ObjectNull(filter_obj.AttributeTypes())
	if obj.Filter != nil {
		diags.Append(filter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Filter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filter_object, diags_tmp = types.ObjectValueFrom(ctx, filter_obj.AttributeTypes(), filter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterResourceProtocolRedistProfileActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterResourceProtocolRedistProfileActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Type.IsNull() || len(obj.Type) > 0 {
			entries = obj.Type
		}

		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Destination.IsNull() || len(obj.Destination) > 0 {
			entries = obj.Destination
		}

		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ospf_obj *VirtualRouterResourceProtocolRedistProfileFilterOspfObject
	if o.Ospf.IsNull() {
		ospf_obj = new(VirtualRouterResourceProtocolRedistProfileFilterOspfObject)
	} else {
		diags.Append(o.Ospf.As(ctx, &ospf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospf_object := types.ObjectNull(ospf_obj.AttributeTypes())
	if obj.Ospf != nil {
		diags.Append(ospf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospf_object, diags_tmp = types.ObjectValueFrom(ctx, ospf_obj.AttributeTypes(), ospf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *VirtualRouterResourceProtocolRedistProfileFilterBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterResourceProtocolRedistProfileFilterBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospf = ospf_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterOspfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilterOspf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PathType.IsNull() || len(obj.PathType) > 0 {
			entries = obj.PathType
		}

		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Area.IsNull() || len(obj.Area) > 0 {
			entries = obj.Area
		}

		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Tag.IsNull() || len(obj.Tag) > 0 {
			entries = obj.Tag
		}

		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileFilterBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileFilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Community.IsNull() || len(obj.Community) > 0 {
			entries = obj.Community
		}

		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunity.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var noRedist_obj *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject
	if o.NoRedist.IsNull() {
		noRedist_obj = new(VirtualRouterResourceProtocolRedistProfileActionNoRedistObject)
	} else {
		diags.Append(o.NoRedist.As(ctx, &noRedist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	noRedist_object := types.ObjectNull(noRedist_obj.AttributeTypes())
	if obj.NoRedist != nil {
		diags.Append(noRedist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NoRedist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		noRedist_object, diags_tmp = types.ObjectValueFrom(ctx, noRedist_obj.AttributeTypes(), noRedist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redist_obj *VirtualRouterResourceProtocolRedistProfileActionRedistObject
	if o.Redist.IsNull() {
		redist_obj = new(VirtualRouterResourceProtocolRedistProfileActionRedistObject)
	} else {
		diags.Append(o.Redist.As(ctx, &redist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redist_object := types.ObjectNull(redist_obj.AttributeTypes())
	if obj.Redist != nil {
		diags.Append(redist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Redist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redist_object, diags_tmp = types.ObjectValueFrom(ctx, redist_obj.AttributeTypes(), redist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionNoRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileActionRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var filter_obj *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject
	if o.Filter.IsNull() {
		filter_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterObject)
	} else {
		diags.Append(o.Filter.As(ctx, &filter_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	filter_object := types.ObjectNull(filter_obj.AttributeTypes())
	if obj.Filter != nil {
		diags.Append(filter_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Filter, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		filter_object, diags_tmp = types.ObjectValueFrom(ctx, filter_obj.AttributeTypes(), filter_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var action_obj *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject
	if o.Action.IsNull() {
		action_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var priority_value types.Int64
	if obj.Priority != nil {
		priority_value = types.Int64Value(*obj.Priority)
	}
	o.Name = types.StringValue(obj.Name)
	o.Priority = priority_value
	o.Filter = filter_object
	o.Action = action_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6Filter, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Type.IsNull() || len(obj.Type) > 0 {
			entries = obj.Type
		}

		type_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var interface_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Interface.IsNull() || len(obj.Interface) > 0 {
			entries = obj.Interface
		}

		interface_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var destination_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Destination.IsNull() || len(obj.Destination) > 0 {
			entries = obj.Destination
		}

		destination_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var nexthop_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Nexthop.IsNull() || len(obj.Nexthop) > 0 {
			entries = obj.Nexthop
		}

		nexthop_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	var ospfv3_obj *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object
	if o.Ospfv3.IsNull() {
		ospfv3_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object)
	} else {
		diags.Append(o.Ospfv3.As(ctx, &ospfv3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ospfv3_object := types.ObjectNull(ospfv3_obj.AttributeTypes())
	if obj.Ospfv3 != nil {
		diags.Append(ospfv3_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ospfv3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ospfv3_object, diags_tmp = types.ObjectValueFrom(ctx, ospfv3_obj.AttributeTypes(), ospfv3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bgp_obj *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject
	if o.Bgp.IsNull() {
		bgp_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject)
	} else {
		diags.Append(o.Bgp.As(ctx, &bgp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bgp_object := types.ObjectNull(bgp_obj.AttributeTypes())
	if obj.Bgp != nil {
		diags.Append(bgp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bgp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bgp_object, diags_tmp = types.ObjectValueFrom(ctx, bgp_obj.AttributeTypes(), bgp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Type = type_list
	o.Interface = interface_list
	o.Destination = destination_list
	o.Nexthop = nexthop_list
	o.Ospfv3 = ospfv3_object
	o.Bgp = bgp_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterOspfv3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6FilterOspfv3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var pathType_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.PathType.IsNull() || len(obj.PathType) > 0 {
			entries = obj.PathType
		}

		pathType_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var area_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Area.IsNull() || len(obj.Area) > 0 {
			entries = obj.Area
		}

		area_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var tag_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Tag.IsNull() || len(obj.Tag) > 0 {
			entries = obj.Tag
		}

		tag_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.PathType = pathType_list
	o.Area = area_list
	o.Tag = tag_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6FilterBgpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6FilterBgp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var community_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.Community.IsNull() || len(obj.Community) > 0 {
			entries = obj.Community
		}

		community_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var extendedCommunity_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.ExtendedCommunity.IsNull() || len(obj.ExtendedCommunity) > 0 {
			entries = obj.ExtendedCommunity
		}

		extendedCommunity_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}

	o.Community = community_list
	o.ExtendedCommunity = extendedCommunity_list

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6Action, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var noRedist_obj *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject
	if o.NoRedist.IsNull() {
		noRedist_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject)
	} else {
		diags.Append(o.NoRedist.As(ctx, &noRedist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	noRedist_object := types.ObjectNull(noRedist_obj.AttributeTypes())
	if obj.NoRedist != nil {
		diags.Append(noRedist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NoRedist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		noRedist_object, diags_tmp = types.ObjectValueFrom(ctx, noRedist_obj.AttributeTypes(), noRedist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var redist_obj *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject
	if o.Redist.IsNull() {
		redist_obj = new(VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject)
	} else {
		diags.Append(o.Redist.As(ctx, &redist_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	redist_object := types.ObjectNull(redist_obj.AttributeTypes())
	if obj.Redist != nil {
		diags.Append(redist_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Redist, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		redist_object, diags_tmp = types.ObjectValueFrom(ctx, redist_obj.AttributeTypes(), redist_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.NoRedist = noRedist_object
	o.Redist = redist_object

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionNoRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6ActionNoRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRedistProfileIpv6ActionRedistObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRedistProfileIpv6ActionRedist, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRipObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var authProfile_list types.List
	{
		var authProfile_tf_entries []VirtualRouterResourceProtocolRipAuthProfileObject
		if !o.AuthProfile.IsNull() {
			diags.Append(o.AuthProfile.ElementsAs(ctx, &authProfile_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AuthProfile {
			entry := VirtualRouterResourceProtocolRipAuthProfileObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(authProfile_tf_entries) {
				entry = authProfile_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(authProfile_tf_entries) {
				authProfile_tf_entries[idx] = entry
			} else {
				authProfile_tf_entries = append(authProfile_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("auth_profile")
		authProfile_list, list_diags = types.ListValueFrom(ctx, schemaType, authProfile_tf_entries)
		diags.Append(list_diags...)
	}
	var exportRules_list types.List
	{
		var exportRules_tf_entries []VirtualRouterResourceProtocolRipExportRulesObject
		if !o.ExportRules.IsNull() {
			diags.Append(o.ExportRules.ElementsAs(ctx, &exportRules_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.ExportRules {
			entry := VirtualRouterResourceProtocolRipExportRulesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(exportRules_tf_entries) {
				entry = exportRules_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(exportRules_tf_entries) {
				exportRules_tf_entries[idx] = entry
			} else {
				exportRules_tf_entries = append(exportRules_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("export_rules")
		exportRules_list, list_diags = types.ListValueFrom(ctx, schemaType, exportRules_tf_entries)
		diags.Append(list_diags...)
	}
	var interfaces_list types.List
	{
		var interfaces_tf_entries []VirtualRouterResourceProtocolRipInterfacesObject
		if !o.Interfaces.IsNull() {
			diags.Append(o.Interfaces.ElementsAs(ctx, &interfaces_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Interface {
			entry := VirtualRouterResourceProtocolRipInterfacesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(interfaces_tf_entries) {
				entry = interfaces_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(interfaces_tf_entries) {
				interfaces_tf_entries[idx] = entry
			} else {
				interfaces_tf_entries = append(interfaces_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("interfaces")
		interfaces_list, list_diags = types.ListValueFrom(ctx, schemaType, interfaces_tf_entries)
		diags.Append(list_diags...)
	}

	var globalBfd_obj *VirtualRouterResourceProtocolRipGlobalBfdObject
	if o.GlobalBfd.IsNull() {
		globalBfd_obj = new(VirtualRouterResourceProtocolRipGlobalBfdObject)
	} else {
		diags.Append(o.GlobalBfd.As(ctx, &globalBfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	globalBfd_object := types.ObjectNull(globalBfd_obj.AttributeTypes())
	if obj.GlobalBfd != nil {
		diags.Append(globalBfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.GlobalBfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		globalBfd_object, diags_tmp = types.ObjectValueFrom(ctx, globalBfd_obj.AttributeTypes(), globalBfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var timers_obj *VirtualRouterResourceProtocolRipTimersObject
	if o.Timers.IsNull() {
		timers_obj = new(VirtualRouterResourceProtocolRipTimersObject)
	} else {
		diags.Append(o.Timers.As(ctx, &timers_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	timers_object := types.ObjectNull(timers_obj.AttributeTypes())
	if obj.Timers != nil {
		diags.Append(timers_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Timers, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		timers_object, diags_tmp = types.ObjectValueFrom(ctx, timers_obj.AttributeTypes(), timers_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowRedistDefaultRoute_value types.Bool
	if obj.AllowRedistDefaultRoute != nil {
		allowRedistDefaultRoute_value = types.BoolValue(*obj.AllowRedistDefaultRoute)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var rejectDefaultRoute_value types.Bool
	if obj.RejectDefaultRoute != nil {
		rejectDefaultRoute_value = types.BoolValue(*obj.RejectDefaultRoute)
	}
	o.AllowRedistDefaultRoute = allowRedistDefaultRoute_value
	o.AuthProfile = authProfile_list
	o.Enable = enable_value
	o.ExportRules = exportRules_list
	o.GlobalBfd = globalBfd_object
	o.Interfaces = interfaces_list
	o.RejectDefaultRoute = rejectDefaultRoute_value
	o.Timers = timers_object

	return diags
}

func (o *VirtualRouterResourceProtocolRipAuthProfileObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipAuthProfile, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var md5_list types.List
	{
		var md5_tf_entries []VirtualRouterResourceProtocolRipAuthProfileMd5Object
		if !o.Md5.IsNull() {
			diags.Append(o.Md5.ElementsAs(ctx, &md5_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Md5 {
			entry := VirtualRouterResourceProtocolRipAuthProfileMd5Object{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(md5_tf_entries) {
				entry = md5_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(md5_tf_entries) {
				md5_tf_entries[idx] = entry
			} else {
				md5_tf_entries = append(md5_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("md5")
		md5_list, list_diags = types.ListValueFrom(ctx, schemaType, md5_tf_entries)
		diags.Append(list_diags...)
	}

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Name = types.StringValue(obj.Name)
	o.Password = password_value
	o.Md5 = md5_list

	return diags
}

func (o *VirtualRouterResourceProtocolRipAuthProfileMd5Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipAuthProfileMd5, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var key_value types.String
	if obj.Key != nil {
		key_value = types.StringValue(*obj.Key)
	}
	var preferred_value types.Bool
	if obj.Preferred != nil {
		preferred_value = types.BoolValue(*obj.Preferred)
	}
	o.Name = types.StringValue(obj.Name)
	o.Key = key_value
	o.Preferred = preferred_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipExportRulesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipExportRules, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Name = types.StringValue(obj.Name)
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipGlobalBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipGlobalBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterface, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultRoute_obj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject
	if o.DefaultRoute.IsNull() {
		defaultRoute_obj = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject)
	} else {
		diags.Append(o.DefaultRoute.As(ctx, &defaultRoute_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	defaultRoute_object := types.ObjectNull(defaultRoute_obj.AttributeTypes())
	if obj.DefaultRoute != nil {
		diags.Append(defaultRoute_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DefaultRoute, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		defaultRoute_object, diags_tmp = types.ObjectValueFrom(ctx, defaultRoute_obj.AttributeTypes(), defaultRoute_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bfd_obj *VirtualRouterResourceProtocolRipInterfacesBfdObject
	if o.Bfd.IsNull() {
		bfd_obj = new(VirtualRouterResourceProtocolRipInterfacesBfdObject)
	} else {
		diags.Append(o.Bfd.As(ctx, &bfd_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bfd_object := types.ObjectNull(bfd_obj.AttributeTypes())
	if obj.Bfd != nil {
		diags.Append(bfd_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bfd, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bfd_object, diags_tmp = types.ObjectValueFrom(ctx, bfd_obj.AttributeTypes(), bfd_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var mode_value types.String
	if obj.Mode != nil {
		mode_value = types.StringValue(*obj.Mode)
	}
	o.Name = types.StringValue(obj.Name)
	o.Enable = enable_value
	o.Authentication = authentication_value
	o.Mode = mode_value
	o.DefaultRoute = defaultRoute_object
	o.Bfd = bfd_object

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRoute, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var disable_obj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject
	if o.Disable.IsNull() {
		disable_obj = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject)
	} else {
		diags.Append(o.Disable.As(ctx, &disable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	disable_object := types.ObjectNull(disable_obj.AttributeTypes())
	if obj.Disable != nil {
		diags.Append(disable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Disable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		disable_object, diags_tmp = types.ObjectValueFrom(ctx, disable_obj.AttributeTypes(), disable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Disable = disable_object
	o.Advertise = advertise_object

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteDisableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRouteDisable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesDefaultRouteAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceDefaultRouteAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var metric_value types.Int64
	if obj.Metric != nil {
		metric_value = types.Int64Value(*obj.Metric)
	}
	o.Metric = metric_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipInterfacesBfdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipInterfaceBfd, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Profile = profile_value

	return diags
}

func (o *VirtualRouterResourceProtocolRipTimersObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *virtual_router.ProtocolRipTimers, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var deleteIntervals_value types.Int64
	if obj.DeleteIntervals != nil {
		deleteIntervals_value = types.Int64Value(*obj.DeleteIntervals)
	}
	var expireIntervals_value types.Int64
	if obj.ExpireIntervals != nil {
		expireIntervals_value = types.Int64Value(*obj.ExpireIntervals)
	}
	var intervalSeconds_value types.Int64
	if obj.IntervalSeconds != nil {
		intervalSeconds_value = types.Int64Value(*obj.IntervalSeconds)
	}
	var updateIntervals_value types.Int64
	if obj.UpdateIntervals != nil {
		updateIntervals_value = types.Int64Value(*obj.UpdateIntervals)
	}
	o.DeleteIntervals = deleteIntervals_value
	o.ExpireIntervals = expireIntervals_value
	o.IntervalSeconds = intervalSeconds_value
	o.UpdateIntervals = updateIntervals_value

	return diags
}

func (o *VirtualRouterResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *VirtualRouterResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location virtual_router.Location

	{
		var terraformLocation VirtualRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &virtual_router.NgfwLocation{}
			var innerLocation VirtualRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &virtual_router.TemplateLocation{}
			var innerLocation VirtualRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &virtual_router.TemplateStackLocation{}
			var innerLocation VirtualRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *virtual_router.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *VirtualRouterResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location virtual_router.Location

	{
		var terraformLocation VirtualRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &virtual_router.NgfwLocation{}
			var innerLocation VirtualRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &virtual_router.TemplateLocation{}
			var innerLocation VirtualRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &virtual_router.TemplateStackLocation{}
			var innerLocation VirtualRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *VirtualRouterResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location virtual_router.Location

	{
		var terraformLocation VirtualRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &virtual_router.NgfwLocation{}
			var innerLocation VirtualRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &virtual_router.TemplateLocation{}
			var innerLocation VirtualRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &virtual_router.TemplateStackLocation{}
			var innerLocation VirtualRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *virtual_router.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *VirtualRouterResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state VirtualRouterResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_virtual_router_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location virtual_router.Location

	{
		var terraformLocation VirtualRouterLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &virtual_router.NgfwLocation{}
			var innerLocation VirtualRouterNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &virtual_router.TemplateLocation{}
			var innerLocation VirtualRouterTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &virtual_router.TemplateStackLocation{}
			var innerLocation VirtualRouterTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type VirtualRouterImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o VirtualRouterImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *VirtualRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}
	var location_object *VirtualRouterLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *VirtualRouterLocation `json:"location"`
		Name     *string                `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func VirtualRouterImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := VirtualRouterImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *VirtualRouterResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj VirtualRouterImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type VirtualRouterNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type VirtualRouterLocation struct {
	Ngfw          types.Object `tfsdk:"ngfw"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func VirtualRouterLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o VirtualRouterNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o VirtualRouterLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Ngfw          *VirtualRouterNgfwLocation          `json:"ngfw,omitempty"`
		Template      *VirtualRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *VirtualRouterTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var ngfw_object *VirtualRouterNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}
	var template_object *VirtualRouterTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *VirtualRouterTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Ngfw:          ngfw_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *VirtualRouterLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Ngfw          *VirtualRouterNgfwLocation          `json:"ngfw,omitempty"`
		Template      *VirtualRouterTemplateLocation      `json:"template,omitempty"`
		TemplateStack *VirtualRouterTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Ngfw = ngfw_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *VirtualRouterNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *VirtualRouterTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *VirtualRouterTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *VirtualRouterLocation) AttributeTypes() map[string]attr.Type {
	var ngfwObj VirtualRouterNgfwLocation
	var templateObj VirtualRouterTemplateLocation
	var templateStackObj VirtualRouterTemplateStackLocation
	return map[string]attr.Type{
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
