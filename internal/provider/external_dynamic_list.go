package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/objects/extdynlist"

	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &ExternalDynamicListDataSource{}
	_ datasource.DataSourceWithConfigure = &ExternalDynamicListDataSource{}
)

func NewExternalDynamicListDataSource() datasource.DataSource {
	return &ExternalDynamicListDataSource{}
}

type ExternalDynamicListDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*extdynlist.Entry, extdynlist.Location, *extdynlist.Service]
}

type ExternalDynamicListDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type ExternalDynamicListDataSourceModel struct {
	Location        ExternalDynamicListLocation              `tfsdk:"location"`
	Name            types.String                             `tfsdk:"name"`
	Type            *ExternalDynamicListDataSourceTypeObject `tfsdk:"type"`
	DisableOverride types.String                             `tfsdk:"disable_override"`
}
type ExternalDynamicListDataSourceTypeObject struct {
	Domain        *ExternalDynamicListDataSourceTypeDomainObject        `tfsdk:"domain"`
	Imei          *ExternalDynamicListDataSourceTypeImeiObject          `tfsdk:"imei"`
	Imsi          *ExternalDynamicListDataSourceTypeImsiObject          `tfsdk:"imsi"`
	Ip            *ExternalDynamicListDataSourceTypeIpObject            `tfsdk:"ip"`
	PredefinedIp  *ExternalDynamicListDataSourceTypePredefinedIpObject  `tfsdk:"predefined_ip"`
	PredefinedUrl *ExternalDynamicListDataSourceTypePredefinedUrlObject `tfsdk:"predefined_url"`
	Url           *ExternalDynamicListDataSourceTypeUrlObject           `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeDomainObject struct {
	Url                types.String                                            `tfsdk:"url"`
	Auth               *ExternalDynamicListDataSourceTypeDomainAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                            `tfsdk:"certificate_profile"`
	Description        types.String                                            `tfsdk:"description"`
	ExceptionList      types.List                                              `tfsdk:"exception_list"`
	ExpandDomain       types.Bool                                              `tfsdk:"expand_domain"`
	Recurring          *ExternalDynamicListDataSourceTypeDomainRecurringObject `tfsdk:"recurring"`
}
type ExternalDynamicListDataSourceTypeDomainAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListDataSourceTypeDomainRecurringObject struct {
	FiveMinute *ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListDataSourceTypeDomainRecurringDailyObject      `tfsdk:"daily"`
}
type ExternalDynamicListDataSourceTypeDomainRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject struct {
}
type ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject struct {
}
type ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListDataSourceTypeImeiObject struct {
	Auth               *ExternalDynamicListDataSourceTypeImeiAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                          `tfsdk:"certificate_profile"`
	Description        types.String                                          `tfsdk:"description"`
	ExceptionList      types.List                                            `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListDataSourceTypeImeiRecurringObject `tfsdk:"recurring"`
	Url                types.String                                          `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeImeiAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListDataSourceTypeImeiRecurringObject struct {
	Monthly    *ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListDataSourceTypeImeiRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject     `tfsdk:"hourly"`
}
type ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListDataSourceTypeImeiRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject struct {
}
type ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject struct {
}
type ExternalDynamicListDataSourceTypeImsiObject struct {
	Auth               *ExternalDynamicListDataSourceTypeImsiAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                          `tfsdk:"certificate_profile"`
	Description        types.String                                          `tfsdk:"description"`
	ExceptionList      types.List                                            `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListDataSourceTypeImsiRecurringObject `tfsdk:"recurring"`
	Url                types.String                                          `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeImsiAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListDataSourceTypeImsiRecurringObject struct {
	Daily      *ExternalDynamicListDataSourceTypeImsiRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject     `tfsdk:"weekly"`
}
type ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject struct {
}
type ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject struct {
	DayOfWeek types.String `tfsdk:"day_of_week"`
	At        types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeImsiRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject struct {
}
type ExternalDynamicListDataSourceTypeIpObject struct {
	Auth               *ExternalDynamicListDataSourceTypeIpAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                        `tfsdk:"certificate_profile"`
	Description        types.String                                        `tfsdk:"description"`
	ExceptionList      types.List                                          `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListDataSourceTypeIpRecurringObject `tfsdk:"recurring"`
	Url                types.String                                        `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeIpAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListDataSourceTypeIpRecurringObject struct {
	Monthly    *ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListDataSourceTypeIpRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListDataSourceTypeIpRecurringHourlyObject     `tfsdk:"hourly"`
}
type ExternalDynamicListDataSourceTypeIpRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject struct {
}
type ExternalDynamicListDataSourceTypeIpRecurringHourlyObject struct {
}
type ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListDataSourceTypePredefinedIpObject struct {
	Description   types.String `tfsdk:"description"`
	ExceptionList types.List   `tfsdk:"exception_list"`
	Url           types.String `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypePredefinedUrlObject struct {
	Description   types.String `tfsdk:"description"`
	ExceptionList types.List   `tfsdk:"exception_list"`
	Url           types.String `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeUrlObject struct {
	Auth               *ExternalDynamicListDataSourceTypeUrlAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                         `tfsdk:"certificate_profile"`
	Description        types.String                                         `tfsdk:"description"`
	ExceptionList      types.List                                           `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListDataSourceTypeUrlRecurringObject `tfsdk:"recurring"`
	Url                types.String                                         `tfsdk:"url"`
}
type ExternalDynamicListDataSourceTypeUrlRecurringObject struct {
	FiveMinute *ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListDataSourceTypeUrlRecurringDailyObject      `tfsdk:"daily"`
}
type ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListDataSourceTypeUrlRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject struct {
}
type ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject struct {
}
type ExternalDynamicListDataSourceTypeUrlAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}

func (o *ExternalDynamicListDataSourceModel) CopyToPango(ctx context.Context, obj **extdynlist.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var type_entry *extdynlist.Type
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(extdynlist.Type)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).DisableOverride = disableOverride_value
	(*obj).Type = type_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeObject) CopyToPango(ctx context.Context, obj **extdynlist.Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var imei_entry *extdynlist.TypeImei
	if o.Imei != nil {
		if *obj != nil && (*obj).Imei != nil {
			imei_entry = (*obj).Imei
		} else {
			imei_entry = new(extdynlist.TypeImei)
		}

		diags.Append(o.Imei.CopyToPango(ctx, &imei_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imsi_entry *extdynlist.TypeImsi
	if o.Imsi != nil {
		if *obj != nil && (*obj).Imsi != nil {
			imsi_entry = (*obj).Imsi
		} else {
			imsi_entry = new(extdynlist.TypeImsi)
		}

		diags.Append(o.Imsi.CopyToPango(ctx, &imsi_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *extdynlist.TypeIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(extdynlist.TypeIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedIp_entry *extdynlist.TypePredefinedIp
	if o.PredefinedIp != nil {
		if *obj != nil && (*obj).PredefinedIp != nil {
			predefinedIp_entry = (*obj).PredefinedIp
		} else {
			predefinedIp_entry = new(extdynlist.TypePredefinedIp)
		}

		diags.Append(o.PredefinedIp.CopyToPango(ctx, &predefinedIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedUrl_entry *extdynlist.TypePredefinedUrl
	if o.PredefinedUrl != nil {
		if *obj != nil && (*obj).PredefinedUrl != nil {
			predefinedUrl_entry = (*obj).PredefinedUrl
		} else {
			predefinedUrl_entry = new(extdynlist.TypePredefinedUrl)
		}

		diags.Append(o.PredefinedUrl.CopyToPango(ctx, &predefinedUrl_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var url_entry *extdynlist.TypeUrl
	if o.Url != nil {
		if *obj != nil && (*obj).Url != nil {
			url_entry = (*obj).Url
		} else {
			url_entry = new(extdynlist.TypeUrl)
		}

		diags.Append(o.Url.CopyToPango(ctx, &url_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var domain_entry *extdynlist.TypeDomain
	if o.Domain != nil {
		if *obj != nil && (*obj).Domain != nil {
			domain_entry = (*obj).Domain
		} else {
			domain_entry = new(extdynlist.TypeDomain)
		}

		diags.Append(o.Domain.CopyToPango(ctx, &domain_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.Type)
	}
	(*obj).Imei = imei_entry
	(*obj).Imsi = imsi_entry
	(*obj).Ip = ip_entry
	(*obj).PredefinedIp = predefinedIp_entry
	(*obj).PredefinedUrl = predefinedUrl_entry
	(*obj).Url = url_entry
	(*obj).Domain = domain_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypePredefinedIpObject) CopyToPango(ctx context.Context, obj **extdynlist.TypePredefinedIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypePredefinedIp)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypePredefinedUrlObject) CopyToPango(ctx context.Context, obj **extdynlist.TypePredefinedUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypePredefinedUrl)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var recurring_entry *extdynlist.TypeUrlRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeUrlRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeUrlAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeUrlAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrl)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weekly_entry *extdynlist.TypeUrlRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeUrlRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *extdynlist.TypeUrlRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeUrlRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeUrlRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeUrlRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeUrlRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeUrlRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeUrlRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeUrlRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurring)
	}
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomain, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	expandDomain_value := o.ExpandDomain.ValueBoolPointer()
	var recurring_entry *extdynlist.TypeDomainRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeDomainRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeDomainAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeDomainAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomain)
	}
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).ExpandDomain = expandDomain_value
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monthly_entry *extdynlist.TypeDomainRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeDomainRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeDomainRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeDomainRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *extdynlist.TypeDomainRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeDomainRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeDomainRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeDomainRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeDomainRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeDomainRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurring)
	}
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringMonthly)
	}
	(*obj).DayOfMonth = dayOfMonth_value
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringWeekly)
	}
	(*obj).DayOfWeek = dayOfWeek_value
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImei, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var recurring_entry *extdynlist.TypeImeiRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeImeiRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeImeiAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeImeiAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImei)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weekly_entry *extdynlist.TypeImeiRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeImeiRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *extdynlist.TypeImeiRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeImeiRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeImeiRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeImeiRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeImeiRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeImeiRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeImeiRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeImeiRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurring)
	}
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringMonthly)
	}
	(*obj).DayOfMonth = dayOfMonth_value
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImeiAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsi, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var recurring_entry *extdynlist.TypeImsiRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeImsiRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeImsiAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeImsiAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsi)
	}
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *extdynlist.TypeImsiRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeImsiRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeImsiRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeImsiRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeImsiRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeImsiRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeImsiRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeImsiRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeImsiRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeImsiRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var auth_entry *extdynlist.TypeIpAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeIpAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var recurring_entry *extdynlist.TypeIpRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeIpRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIp)
	}
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *extdynlist.TypeIpRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeIpRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeIpRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeIpRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeIpRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeIpRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeIpRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeIpRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeIpRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeIpRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceModel) CopyFromPango(ctx context.Context, obj *extdynlist.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *ExternalDynamicListDataSourceTypeObject
	if obj.Type != nil {
		type_object = new(ExternalDynamicListDataSourceTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.DisableOverride = disableOverride_value
	o.Type = type_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeObject) CopyFromPango(ctx context.Context, obj *extdynlist.Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var predefinedIp_object *ExternalDynamicListDataSourceTypePredefinedIpObject
	if obj.PredefinedIp != nil {
		predefinedIp_object = new(ExternalDynamicListDataSourceTypePredefinedIpObject)

		diags.Append(predefinedIp_object.CopyFromPango(ctx, obj.PredefinedIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedUrl_object *ExternalDynamicListDataSourceTypePredefinedUrlObject
	if obj.PredefinedUrl != nil {
		predefinedUrl_object = new(ExternalDynamicListDataSourceTypePredefinedUrlObject)

		diags.Append(predefinedUrl_object.CopyFromPango(ctx, obj.PredefinedUrl, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var url_object *ExternalDynamicListDataSourceTypeUrlObject
	if obj.Url != nil {
		url_object = new(ExternalDynamicListDataSourceTypeUrlObject)

		diags.Append(url_object.CopyFromPango(ctx, obj.Url, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var domain_object *ExternalDynamicListDataSourceTypeDomainObject
	if obj.Domain != nil {
		domain_object = new(ExternalDynamicListDataSourceTypeDomainObject)

		diags.Append(domain_object.CopyFromPango(ctx, obj.Domain, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imei_object *ExternalDynamicListDataSourceTypeImeiObject
	if obj.Imei != nil {
		imei_object = new(ExternalDynamicListDataSourceTypeImeiObject)

		diags.Append(imei_object.CopyFromPango(ctx, obj.Imei, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imsi_object *ExternalDynamicListDataSourceTypeImsiObject
	if obj.Imsi != nil {
		imsi_object = new(ExternalDynamicListDataSourceTypeImsiObject)

		diags.Append(imsi_object.CopyFromPango(ctx, obj.Imsi, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_object *ExternalDynamicListDataSourceTypeIpObject
	if obj.Ip != nil {
		ip_object = new(ExternalDynamicListDataSourceTypeIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.PredefinedIp = predefinedIp_object
	o.PredefinedUrl = predefinedUrl_object
	o.Url = url_object
	o.Domain = domain_object
	o.Imei = imei_object
	o.Imsi = imsi_object
	o.Ip = ip_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypePredefinedUrlObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypePredefinedUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Url = url_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var auth_object *ExternalDynamicListDataSourceTypeUrlAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListDataSourceTypeUrlAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var recurring_object *ExternalDynamicListDataSourceTypeUrlRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListDataSourceTypeUrlRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *ExternalDynamicListDataSourceTypeUrlRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListDataSourceTypeUrlRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeUrlAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Username = username_value
	o.Password = password_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomain, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var auth_object *ExternalDynamicListDataSourceTypeDomainAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListDataSourceTypeDomainAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var recurring_object *ExternalDynamicListDataSourceTypeDomainRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListDataSourceTypeDomainRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var expandDomain_value types.Bool
	if obj.ExpandDomain != nil {
		expandDomain_value = types.BoolValue(*obj.ExpandDomain)
	}
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.ExpandDomain = expandDomain_value
	o.Recurring = recurring_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	o.Username = username_value
	o.Password = password_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *ExternalDynamicListDataSourceTypeDomainRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListDataSourceTypeDomainRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImei, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var recurring_object *ExternalDynamicListDataSourceTypeImeiRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListDataSourceTypeImeiRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var auth_object *ExternalDynamicListDataSourceTypeImeiAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListDataSourceTypeImeiAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value
	o.Auth = auth_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hourly_object *ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *ExternalDynamicListDataSourceTypeImeiRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListDataSourceTypeImeiRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object
	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImeiAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsi, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var recurring_object *ExternalDynamicListDataSourceTypeImsiRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListDataSourceTypeImsiRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var auth_object *ExternalDynamicListDataSourceTypeImsiAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListDataSourceTypeImsiAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monthly_object *ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *ExternalDynamicListDataSourceTypeImsiRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListDataSourceTypeImsiRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Monthly = monthly_object
	o.Weekly = weekly_object
	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var recurring_object *ExternalDynamicListDataSourceTypeIpRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListDataSourceTypeIpRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var auth_object *ExternalDynamicListDataSourceTypeIpAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListDataSourceTypeIpAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *ExternalDynamicListDataSourceTypeIpRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListDataSourceTypeIpRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListDataSourceTypeIpRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListDataSourceTypeIpRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListDataSourceTypePredefinedIpObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypePredefinedIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Url = url_value

	return diags
}

func ExternalDynamicListDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": ExternalDynamicListDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"disable_override": dsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"type": ExternalDynamicListDataSourceTypeSchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceModel) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"predefined_ip": ExternalDynamicListDataSourceTypePredefinedIpSchema(),

			"predefined_url": ExternalDynamicListDataSourceTypePredefinedUrlSchema(),

			"url": ExternalDynamicListDataSourceTypeUrlSchema(),

			"domain": ExternalDynamicListDataSourceTypeDomainSchema(),

			"imei": ExternalDynamicListDataSourceTypeImeiSchema(),

			"imsi": ExternalDynamicListDataSourceTypeImsiSchema(),

			"ip": ExternalDynamicListDataSourceTypeIpSchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth": ExternalDynamicListDataSourceTypeDomainAuthSchema(),

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"expand_domain": dsschema.BoolAttribute{
				Description: "Enable/Disable expand domain",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"recurring": ExternalDynamicListDataSourceTypeDomainRecurringSchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"hourly": ExternalDynamicListDataSourceTypeDomainRecurringHourlySchema(),

			"monthly": ExternalDynamicListDataSourceTypeDomainRecurringMonthlySchema(),

			"weekly": ExternalDynamicListDataSourceTypeDomainRecurringWeeklySchema(),

			"daily": ExternalDynamicListDataSourceTypeDomainRecurringDailySchema(),

			"five_minute": ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteSchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringMonthlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"day_of_month": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeDomainAuthSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"password": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeDomainAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeDomainAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListDataSourceTypeImeiRecurringSchema(),

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth": ExternalDynamicListDataSourceTypeImeiAuthSchema(),

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": ExternalDynamicListDataSourceTypeImeiRecurringDailySchema(),

			"five_minute": ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListDataSourceTypeImeiRecurringHourlySchema(),

			"monthly": ExternalDynamicListDataSourceTypeImeiRecurringMonthlySchema(),

			"weekly": ExternalDynamicListDataSourceTypeImeiRecurringWeeklySchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiRecurringMonthlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_month": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImeiAuthSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"password": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImeiAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImeiAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"auth": ExternalDynamicListDataSourceTypeImsiAuthSchema(),

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListDataSourceTypeImsiRecurringSchema(),

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiAuthSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"password": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"daily": ExternalDynamicListDataSourceTypeImsiRecurringDailySchema(),

			"five_minute": ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListDataSourceTypeImsiRecurringHourlySchema(),

			"monthly": ExternalDynamicListDataSourceTypeImsiRecurringMonthlySchema(),

			"weekly": ExternalDynamicListDataSourceTypeImsiRecurringWeeklySchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringMonthlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_month": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeImsiRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeImsiRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeImsiRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"recurring": ExternalDynamicListDataSourceTypeIpRecurringSchema(),

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth": ExternalDynamicListDataSourceTypeIpAuthSchema(),

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"weekly": ExternalDynamicListDataSourceTypeIpRecurringWeeklySchema(),

			"daily": ExternalDynamicListDataSourceTypeIpRecurringDailySchema(),

			"five_minute": ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListDataSourceTypeIpRecurringHourlySchema(),

			"monthly": ExternalDynamicListDataSourceTypeIpRecurringMonthlySchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringMonthlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"day_of_month": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeIpAuthSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"password": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeIpAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeIpAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypePredefinedIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypePredefinedIpObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypePredefinedIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypePredefinedUrlSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypePredefinedUrlObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypePredefinedUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"exception_list": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListDataSourceTypeUrlRecurringSchema(),

			"url": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auth": ExternalDynamicListDataSourceTypeUrlAuthSchema(),

			"certificate_profile": dsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"five_minute": ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListDataSourceTypeUrlRecurringHourlySchema(),

			"monthly": ExternalDynamicListDataSourceTypeUrlRecurringMonthlySchema(),

			"weekly": ExternalDynamicListDataSourceTypeUrlRecurringWeeklySchema(),

			"daily": ExternalDynamicListDataSourceTypeUrlRecurringDailySchema(),
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringDailySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringHourlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringMonthlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_month": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlRecurringWeeklySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"at": dsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"day_of_week": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceTypeUrlAuthSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"username": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"password": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListDataSourceTypeUrlAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListDataSourceTypeUrlAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListDataSourceLocationSchema() rsschema.Attribute {
	return ExternalDynamicListLocationSchema()
}

// Metadata returns the data source type name.
func (d *ExternalDynamicListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_external_dynamic_list"
}

// Schema defines the schema for this data source.
func (d *ExternalDynamicListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = ExternalDynamicListDataSourceSchema()
}

// Configure prepares the struct.
func (d *ExternalDynamicListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*pango.Client)
	specifier, _, err := extdynlist.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewEntryObjectManager(d.client, extdynlist.NewService(d.client), specifier, extdynlist.SpecMatches)
}
func (o *ExternalDynamicListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state ExternalDynamicListDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location extdynlist.Location

	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &extdynlist.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_external_dynamic_list_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &ExternalDynamicListResource{}
	_ resource.ResourceWithConfigure   = &ExternalDynamicListResource{}
	_ resource.ResourceWithImportState = &ExternalDynamicListResource{}
)

func NewExternalDynamicListResource() resource.Resource {
	if _, found := resourceFuncMap["panos_external_dynamic_list"]; !found {
		resourceFuncMap["panos_external_dynamic_list"] = resourceFuncs{
			CreateImportId: ExternalDynamicListImportStateCreator,
		}
	}
	return &ExternalDynamicListResource{}
}

type ExternalDynamicListResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*extdynlist.Entry, extdynlist.Location, *extdynlist.Service]
}

func ExternalDynamicListResourceLocationSchema() rsschema.Attribute {
	return ExternalDynamicListLocationSchema()
}

type ExternalDynamicListResourceModel struct {
	Location        ExternalDynamicListLocation            `tfsdk:"location"`
	Name            types.String                           `tfsdk:"name"`
	DisableOverride types.String                           `tfsdk:"disable_override"`
	Type            *ExternalDynamicListResourceTypeObject `tfsdk:"type"`
}
type ExternalDynamicListResourceTypeObject struct {
	Domain        *ExternalDynamicListResourceTypeDomainObject        `tfsdk:"domain"`
	Imei          *ExternalDynamicListResourceTypeImeiObject          `tfsdk:"imei"`
	Imsi          *ExternalDynamicListResourceTypeImsiObject          `tfsdk:"imsi"`
	Ip            *ExternalDynamicListResourceTypeIpObject            `tfsdk:"ip"`
	PredefinedIp  *ExternalDynamicListResourceTypePredefinedIpObject  `tfsdk:"predefined_ip"`
	PredefinedUrl *ExternalDynamicListResourceTypePredefinedUrlObject `tfsdk:"predefined_url"`
	Url           *ExternalDynamicListResourceTypeUrlObject           `tfsdk:"url"`
}
type ExternalDynamicListResourceTypeDomainObject struct {
	Url                types.String                                          `tfsdk:"url"`
	Auth               *ExternalDynamicListResourceTypeDomainAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                          `tfsdk:"certificate_profile"`
	Description        types.String                                          `tfsdk:"description"`
	ExceptionList      types.List                                            `tfsdk:"exception_list"`
	ExpandDomain       types.Bool                                            `tfsdk:"expand_domain"`
	Recurring          *ExternalDynamicListResourceTypeDomainRecurringObject `tfsdk:"recurring"`
}
type ExternalDynamicListResourceTypeDomainRecurringObject struct {
	Hourly     *ExternalDynamicListResourceTypeDomainRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListResourceTypeDomainRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListResourceTypeDomainRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListResourceTypeDomainRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject `tfsdk:"five_minute"`
}
type ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject struct {
}
type ExternalDynamicListResourceTypeDomainRecurringHourlyObject struct {
}
type ExternalDynamicListResourceTypeDomainRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListResourceTypeDomainRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListResourceTypeDomainRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeDomainAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListResourceTypeImeiObject struct {
	Auth               *ExternalDynamicListResourceTypeImeiAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                        `tfsdk:"certificate_profile"`
	Description        types.String                                        `tfsdk:"description"`
	ExceptionList      types.List                                          `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListResourceTypeImeiRecurringObject `tfsdk:"recurring"`
	Url                types.String                                        `tfsdk:"url"`
}
type ExternalDynamicListResourceTypeImeiAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListResourceTypeImeiRecurringObject struct {
	FiveMinute *ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListResourceTypeImeiRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListResourceTypeImeiRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListResourceTypeImeiRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListResourceTypeImeiRecurringDailyObject      `tfsdk:"daily"`
}
type ExternalDynamicListResourceTypeImeiRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject struct {
}
type ExternalDynamicListResourceTypeImeiRecurringHourlyObject struct {
}
type ExternalDynamicListResourceTypeImeiRecurringMonthlyObject struct {
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
	At         types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeImeiRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListResourceTypeImsiObject struct {
	Url                types.String                                        `tfsdk:"url"`
	Auth               *ExternalDynamicListResourceTypeImsiAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                        `tfsdk:"certificate_profile"`
	Description        types.String                                        `tfsdk:"description"`
	ExceptionList      types.List                                          `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListResourceTypeImsiRecurringObject `tfsdk:"recurring"`
}
type ExternalDynamicListResourceTypeImsiAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListResourceTypeImsiRecurringObject struct {
	Hourly     *ExternalDynamicListResourceTypeImsiRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListResourceTypeImsiRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListResourceTypeImsiRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListResourceTypeImsiRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject `tfsdk:"five_minute"`
}
type ExternalDynamicListResourceTypeImsiRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject struct {
}
type ExternalDynamicListResourceTypeImsiRecurringHourlyObject struct {
}
type ExternalDynamicListResourceTypeImsiRecurringMonthlyObject struct {
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
	At         types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeImsiRecurringWeeklyObject struct {
	DayOfWeek types.String `tfsdk:"day_of_week"`
	At        types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeIpObject struct {
	Auth               *ExternalDynamicListResourceTypeIpAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                      `tfsdk:"certificate_profile"`
	Description        types.String                                      `tfsdk:"description"`
	ExceptionList      types.List                                        `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListResourceTypeIpRecurringObject `tfsdk:"recurring"`
	Url                types.String                                      `tfsdk:"url"`
}
type ExternalDynamicListResourceTypeIpRecurringObject struct {
	Daily      *ExternalDynamicListResourceTypeIpRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListResourceTypeIpRecurringHourlyObject     `tfsdk:"hourly"`
	Monthly    *ExternalDynamicListResourceTypeIpRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListResourceTypeIpRecurringWeeklyObject     `tfsdk:"weekly"`
}
type ExternalDynamicListResourceTypeIpRecurringHourlyObject struct {
}
type ExternalDynamicListResourceTypeIpRecurringMonthlyObject struct {
	At         types.String `tfsdk:"at"`
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
}
type ExternalDynamicListResourceTypeIpRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListResourceTypeIpRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject struct {
}
type ExternalDynamicListResourceTypeIpAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListResourceTypePredefinedIpObject struct {
	Description   types.String `tfsdk:"description"`
	ExceptionList types.List   `tfsdk:"exception_list"`
	Url           types.String `tfsdk:"url"`
}
type ExternalDynamicListResourceTypePredefinedUrlObject struct {
	Description   types.String `tfsdk:"description"`
	ExceptionList types.List   `tfsdk:"exception_list"`
	Url           types.String `tfsdk:"url"`
}
type ExternalDynamicListResourceTypeUrlObject struct {
	Auth               *ExternalDynamicListResourceTypeUrlAuthObject      `tfsdk:"auth"`
	CertificateProfile types.String                                       `tfsdk:"certificate_profile"`
	Description        types.String                                       `tfsdk:"description"`
	ExceptionList      types.List                                         `tfsdk:"exception_list"`
	Recurring          *ExternalDynamicListResourceTypeUrlRecurringObject `tfsdk:"recurring"`
	Url                types.String                                       `tfsdk:"url"`
}
type ExternalDynamicListResourceTypeUrlAuthObject struct {
	Password types.String `tfsdk:"password"`
	Username types.String `tfsdk:"username"`
}
type ExternalDynamicListResourceTypeUrlRecurringObject struct {
	Monthly    *ExternalDynamicListResourceTypeUrlRecurringMonthlyObject    `tfsdk:"monthly"`
	Weekly     *ExternalDynamicListResourceTypeUrlRecurringWeeklyObject     `tfsdk:"weekly"`
	Daily      *ExternalDynamicListResourceTypeUrlRecurringDailyObject      `tfsdk:"daily"`
	FiveMinute *ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject `tfsdk:"five_minute"`
	Hourly     *ExternalDynamicListResourceTypeUrlRecurringHourlyObject     `tfsdk:"hourly"`
}
type ExternalDynamicListResourceTypeUrlRecurringHourlyObject struct {
}
type ExternalDynamicListResourceTypeUrlRecurringMonthlyObject struct {
	DayOfMonth types.Int64  `tfsdk:"day_of_month"`
	At         types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeUrlRecurringWeeklyObject struct {
	At        types.String `tfsdk:"at"`
	DayOfWeek types.String `tfsdk:"day_of_week"`
}
type ExternalDynamicListResourceTypeUrlRecurringDailyObject struct {
	At types.String `tfsdk:"at"`
}
type ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject struct {
}

func (r *ExternalDynamicListResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func ExternalDynamicListResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": ExternalDynamicListResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"disable_override": rsschema.StringAttribute{
				Description: "disable object override in child device groups",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("no"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"no",
						"yes",
					}...),
				},
			},

			"type": ExternalDynamicListResourceTypeSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceModel) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"url": ExternalDynamicListResourceTypeUrlSchema(),

			"domain": ExternalDynamicListResourceTypeDomainSchema(),

			"imei": ExternalDynamicListResourceTypeImeiSchema(),

			"imsi": ExternalDynamicListResourceTypeImsiSchema(),

			"ip": ExternalDynamicListResourceTypeIpSchema(),

			"predefined_ip": ExternalDynamicListResourceTypePredefinedIpSchema(),

			"predefined_url": ExternalDynamicListResourceTypePredefinedUrlSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypePredefinedUrlSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypePredefinedUrlObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypePredefinedUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"auth": ExternalDynamicListResourceTypeUrlAuthSchema(),

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListResourceTypeUrlRecurringSchema(),

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("http://"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hourly": ExternalDynamicListResourceTypeUrlRecurringHourlySchema(),

			"monthly": ExternalDynamicListResourceTypeUrlRecurringMonthlySchema(),

			"weekly": ExternalDynamicListResourceTypeUrlRecurringWeeklySchema(),

			"daily": ExternalDynamicListResourceTypeUrlRecurringDailySchema(),

			"five_minute": ExternalDynamicListResourceTypeUrlRecurringFiveMinuteSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringFiveMinuteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlRecurringMonthlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_month": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeUrlAuthSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"password": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeUrlAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeUrlAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"expand_domain": rsschema.BoolAttribute{
				Description: "Enable/Disable expand domain",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"recurring": ExternalDynamicListResourceTypeDomainRecurringSchema(),

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("http://"),
			},

			"auth": ExternalDynamicListResourceTypeDomainAuthSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"daily": ExternalDynamicListResourceTypeDomainRecurringDailySchema(),

			"five_minute": ExternalDynamicListResourceTypeDomainRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListResourceTypeDomainRecurringHourlySchema(),

			"monthly": ExternalDynamicListResourceTypeDomainRecurringMonthlySchema(),

			"weekly": ExternalDynamicListResourceTypeDomainRecurringWeeklySchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringFiveMinuteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringMonthlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_month": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeDomainAuthSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"password": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeDomainAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeDomainAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListResourceTypeImeiRecurringSchema(),

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("http://"),
			},

			"auth": ExternalDynamicListResourceTypeImeiAuthSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hourly": ExternalDynamicListResourceTypeImeiRecurringHourlySchema(),

			"monthly": ExternalDynamicListResourceTypeImeiRecurringMonthlySchema(),

			"weekly": ExternalDynamicListResourceTypeImeiRecurringWeeklySchema(),

			"daily": ExternalDynamicListResourceTypeImeiRecurringDailySchema(),

			"five_minute": ExternalDynamicListResourceTypeImeiRecurringFiveMinuteSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringFiveMinuteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringMonthlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_month": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImeiAuthSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"password": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImeiAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImeiAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListResourceTypeImsiRecurringSchema(),

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("http://"),
			},

			"auth": ExternalDynamicListResourceTypeImsiAuthSchema(),

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiAuthSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"password": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"monthly": ExternalDynamicListResourceTypeImsiRecurringMonthlySchema(),

			"weekly": ExternalDynamicListResourceTypeImsiRecurringWeeklySchema(),

			"daily": ExternalDynamicListResourceTypeImsiRecurringDailySchema(),

			"five_minute": ExternalDynamicListResourceTypeImsiRecurringFiveMinuteSchema(),

			"hourly": ExternalDynamicListResourceTypeImsiRecurringHourlySchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringMonthlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_month": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringFiveMinuteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeImsiRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("daily"),
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeImsiRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeImsiRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"auth": ExternalDynamicListResourceTypeIpAuthSchema(),

			"certificate_profile": rsschema.StringAttribute{
				Description: "Profile for authenticating client certificates",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("None"),
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"recurring": ExternalDynamicListResourceTypeIpRecurringSchema(),

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("http://"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpAuthSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"password": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"username": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpAuthObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpAuthSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"hourly": ExternalDynamicListResourceTypeIpRecurringHourlySchema(),

			"monthly": ExternalDynamicListResourceTypeIpRecurringMonthlySchema(),

			"weekly": ExternalDynamicListResourceTypeIpRecurringWeeklySchema(),

			"daily": ExternalDynamicListResourceTypeIpRecurringDailySchema(),

			"five_minute": ExternalDynamicListResourceTypeIpRecurringFiveMinuteSchema(),
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringDailySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringDailyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringDailySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringFiveMinuteSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringFiveMinuteSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringHourlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringHourlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringHourlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringMonthlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_month": rsschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringMonthlyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringMonthlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypeIpRecurringWeeklySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("five_minute"),
				path.MatchRelative().AtParent().AtName("hourly"),
				path.MatchRelative().AtParent().AtName("monthly"),
				path.MatchRelative().AtParent().AtName("weekly"),
				path.MatchRelative().AtParent().AtName("daily"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"at": rsschema.StringAttribute{
				Description: "Time specification hh (e.g. 20)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("00"),
			},

			"day_of_week": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypeIpRecurringWeeklyObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypeIpRecurringWeeklySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func ExternalDynamicListResourceTypePredefinedIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("domain"),
				path.MatchRelative().AtParent().AtName("imei"),
				path.MatchRelative().AtParent().AtName("imsi"),
				path.MatchRelative().AtParent().AtName("ip"),
				path.MatchRelative().AtParent().AtName("predefined_ip"),
				path.MatchRelative().AtParent().AtName("predefined_url"),
				path.MatchRelative().AtParent().AtName("url"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"exception_list": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"url": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"description": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *ExternalDynamicListResourceTypePredefinedIpObject) getTypeFor(name string) attr.Type {
	schema := ExternalDynamicListResourceTypePredefinedIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *ExternalDynamicListResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_external_dynamic_list"
}

func (r *ExternalDynamicListResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = ExternalDynamicListResourceSchema()
}

// </ResourceSchema>

func (r *ExternalDynamicListResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*pango.Client)
	specifier, _, err := extdynlist.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewEntryObjectManager(r.client, extdynlist.NewService(r.client), specifier, extdynlist.SpecMatches)
}

func (o *ExternalDynamicListResourceModel) CopyToPango(ctx context.Context, obj **extdynlist.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	disableOverride_value := o.DisableOverride.ValueStringPointer()
	var type_entry *extdynlist.Type
	if o.Type != nil {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(extdynlist.Type)
		}

		diags.Append(o.Type.CopyToPango(ctx, &type_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).DisableOverride = disableOverride_value
	(*obj).Type = type_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeObject) CopyToPango(ctx context.Context, obj **extdynlist.Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var domain_entry *extdynlist.TypeDomain
	if o.Domain != nil {
		if *obj != nil && (*obj).Domain != nil {
			domain_entry = (*obj).Domain
		} else {
			domain_entry = new(extdynlist.TypeDomain)
		}

		diags.Append(o.Domain.CopyToPango(ctx, &domain_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imei_entry *extdynlist.TypeImei
	if o.Imei != nil {
		if *obj != nil && (*obj).Imei != nil {
			imei_entry = (*obj).Imei
		} else {
			imei_entry = new(extdynlist.TypeImei)
		}

		diags.Append(o.Imei.CopyToPango(ctx, &imei_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imsi_entry *extdynlist.TypeImsi
	if o.Imsi != nil {
		if *obj != nil && (*obj).Imsi != nil {
			imsi_entry = (*obj).Imsi
		} else {
			imsi_entry = new(extdynlist.TypeImsi)
		}

		diags.Append(o.Imsi.CopyToPango(ctx, &imsi_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_entry *extdynlist.TypeIp
	if o.Ip != nil {
		if *obj != nil && (*obj).Ip != nil {
			ip_entry = (*obj).Ip
		} else {
			ip_entry = new(extdynlist.TypeIp)
		}

		diags.Append(o.Ip.CopyToPango(ctx, &ip_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedIp_entry *extdynlist.TypePredefinedIp
	if o.PredefinedIp != nil {
		if *obj != nil && (*obj).PredefinedIp != nil {
			predefinedIp_entry = (*obj).PredefinedIp
		} else {
			predefinedIp_entry = new(extdynlist.TypePredefinedIp)
		}

		diags.Append(o.PredefinedIp.CopyToPango(ctx, &predefinedIp_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedUrl_entry *extdynlist.TypePredefinedUrl
	if o.PredefinedUrl != nil {
		if *obj != nil && (*obj).PredefinedUrl != nil {
			predefinedUrl_entry = (*obj).PredefinedUrl
		} else {
			predefinedUrl_entry = new(extdynlist.TypePredefinedUrl)
		}

		diags.Append(o.PredefinedUrl.CopyToPango(ctx, &predefinedUrl_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var url_entry *extdynlist.TypeUrl
	if o.Url != nil {
		if *obj != nil && (*obj).Url != nil {
			url_entry = (*obj).Url
		} else {
			url_entry = new(extdynlist.TypeUrl)
		}

		diags.Append(o.Url.CopyToPango(ctx, &url_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.Type)
	}
	(*obj).Domain = domain_entry
	(*obj).Imei = imei_entry
	(*obj).Imsi = imsi_entry
	(*obj).Ip = ip_entry
	(*obj).PredefinedIp = predefinedIp_entry
	(*obj).PredefinedUrl = predefinedUrl_entry
	(*obj).Url = url_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomain, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeDomainAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeDomainAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	expandDomain_value := o.ExpandDomain.ValueBoolPointer()
	var recurring_entry *extdynlist.TypeDomainRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeDomainRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomain)
	}
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).ExpandDomain = expandDomain_value
	(*obj).Recurring = recurring_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *extdynlist.TypeDomainRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeDomainRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeDomainRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeDomainRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeDomainRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeDomainRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeDomainRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeDomainRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeDomainRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeDomainRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListResourceTypeDomainRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeDomainRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeDomainRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImei, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var auth_entry *extdynlist.TypeImeiAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeImeiAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	var recurring_entry *extdynlist.TypeImeiRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeImeiRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImei)
	}
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	username_value := o.Username.ValueStringPointer()
	password_value := o.Password.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiAuth)
	}
	(*obj).Username = username_value
	(*obj).Password = password_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *extdynlist.TypeImeiRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeImeiRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeImeiRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeImeiRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeImeiRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeImeiRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeImeiRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeImeiRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeImeiRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeImeiRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImeiRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImeiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImeiRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsi, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *extdynlist.TypeImsiRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeImsiRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeImsiAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeImsiAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsi)
	}
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monthly_entry *extdynlist.TypeImsiRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeImsiRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeImsiRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeImsiRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *extdynlist.TypeImsiRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeImsiRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeImsiRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeImsiRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeImsiRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeImsiRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurring)
	}
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeImsiAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeImsiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeImsiAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListResourceTypeIpObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *extdynlist.TypeIpRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeIpRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeIpAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeIpAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIp)
	}
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries

	return diags
}
func (o *ExternalDynamicListResourceTypeIpAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var monthly_entry *extdynlist.TypeIpRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeIpRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeIpRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeIpRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_entry *extdynlist.TypeIpRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeIpRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeIpRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeIpRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeIpRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeIpRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurring)
	}
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeIpRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeIpRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeIpRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListResourceTypePredefinedIpObject) CopyToPango(ctx context.Context, obj **extdynlist.TypePredefinedIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypePredefinedIp)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListResourceTypePredefinedUrlObject) CopyToPango(ctx context.Context, obj **extdynlist.TypePredefinedUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}
	url_value := o.Url.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypePredefinedUrl)
	}
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries
	(*obj).Url = url_value

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var recurring_entry *extdynlist.TypeUrlRecurring
	if o.Recurring != nil {
		if *obj != nil && (*obj).Recurring != nil {
			recurring_entry = (*obj).Recurring
		} else {
			recurring_entry = new(extdynlist.TypeUrlRecurring)
		}

		diags.Append(o.Recurring.CopyToPango(ctx, &recurring_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	url_value := o.Url.ValueStringPointer()
	var auth_entry *extdynlist.TypeUrlAuth
	if o.Auth != nil {
		if *obj != nil && (*obj).Auth != nil {
			auth_entry = (*obj).Auth
		} else {
			auth_entry = new(extdynlist.TypeUrlAuth)
		}

		diags.Append(o.Auth.CopyToPango(ctx, &auth_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	certificateProfile_value := o.CertificateProfile.ValueStringPointer()
	description_value := o.Description.ValueStringPointer()
	exceptionList_pango_entries := make([]string, 0)
	diags.Append(o.ExceptionList.ElementsAs(ctx, &exceptionList_pango_entries, false)...)
	if diags.HasError() {
		return diags
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrl)
	}
	(*obj).Recurring = recurring_entry
	(*obj).Url = url_value
	(*obj).Auth = auth_entry
	(*obj).CertificateProfile = certificateProfile_value
	(*obj).Description = description_value
	(*obj).ExceptionList = exceptionList_pango_entries

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlAuthObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	password_value := o.Password.ValueStringPointer()
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlAuth)
	}
	(*obj).Password = password_value
	(*obj).Username = username_value

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_entry *extdynlist.TypeUrlRecurringDaily
	if o.Daily != nil {
		if *obj != nil && (*obj).Daily != nil {
			daily_entry = (*obj).Daily
		} else {
			daily_entry = new(extdynlist.TypeUrlRecurringDaily)
		}

		diags.Append(o.Daily.CopyToPango(ctx, &daily_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_entry *extdynlist.TypeUrlRecurringFiveMinute
	if o.FiveMinute != nil {
		if *obj != nil && (*obj).FiveMinute != nil {
			fiveMinute_entry = (*obj).FiveMinute
		} else {
			fiveMinute_entry = new(extdynlist.TypeUrlRecurringFiveMinute)
		}

		diags.Append(o.FiveMinute.CopyToPango(ctx, &fiveMinute_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_entry *extdynlist.TypeUrlRecurringHourly
	if o.Hourly != nil {
		if *obj != nil && (*obj).Hourly != nil {
			hourly_entry = (*obj).Hourly
		} else {
			hourly_entry = new(extdynlist.TypeUrlRecurringHourly)
		}

		diags.Append(o.Hourly.CopyToPango(ctx, &hourly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_entry *extdynlist.TypeUrlRecurringMonthly
	if o.Monthly != nil {
		if *obj != nil && (*obj).Monthly != nil {
			monthly_entry = (*obj).Monthly
		} else {
			monthly_entry = new(extdynlist.TypeUrlRecurringMonthly)
		}

		diags.Append(o.Monthly.CopyToPango(ctx, &monthly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_entry *extdynlist.TypeUrlRecurringWeekly
	if o.Weekly != nil {
		if *obj != nil && (*obj).Weekly != nil {
			weekly_entry = (*obj).Weekly
		} else {
			weekly_entry = new(extdynlist.TypeUrlRecurringWeekly)
		}

		diags.Append(o.Weekly.CopyToPango(ctx, &weekly_entry, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurring)
	}
	(*obj).Daily = daily_entry
	(*obj).FiveMinute = fiveMinute_entry
	(*obj).Hourly = hourly_entry
	(*obj).Monthly = monthly_entry
	(*obj).Weekly = weekly_entry

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringDailyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringDaily)
	}
	(*obj).At = at_value

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringFiveMinute)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringHourlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringHourly)
	}

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringMonthlyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfMonth_value := o.DayOfMonth.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringMonthly)
	}
	(*obj).At = at_value
	(*obj).DayOfMonth = dayOfMonth_value

	return diags
}
func (o *ExternalDynamicListResourceTypeUrlRecurringWeeklyObject) CopyToPango(ctx context.Context, obj **extdynlist.TypeUrlRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	at_value := o.At.ValueStringPointer()
	dayOfWeek_value := o.DayOfWeek.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(extdynlist.TypeUrlRecurringWeekly)
	}
	(*obj).At = at_value
	(*obj).DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListResourceModel) CopyFromPango(ctx context.Context, obj *extdynlist.Entry, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_object *ExternalDynamicListResourceTypeObject
	if obj.Type != nil {
		type_object = new(ExternalDynamicListResourceTypeObject)

		diags.Append(type_object.CopyFromPango(ctx, obj.Type, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var disableOverride_value types.String
	if obj.DisableOverride != nil {
		disableOverride_value = types.StringValue(*obj.DisableOverride)
	}
	o.Name = types.StringValue(obj.Name)
	o.DisableOverride = disableOverride_value
	o.Type = type_object

	return diags
}

func (o *ExternalDynamicListResourceTypeObject) CopyFromPango(ctx context.Context, obj *extdynlist.Type, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var url_object *ExternalDynamicListResourceTypeUrlObject
	if obj.Url != nil {
		url_object = new(ExternalDynamicListResourceTypeUrlObject)

		diags.Append(url_object.CopyFromPango(ctx, obj.Url, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var domain_object *ExternalDynamicListResourceTypeDomainObject
	if obj.Domain != nil {
		domain_object = new(ExternalDynamicListResourceTypeDomainObject)

		diags.Append(domain_object.CopyFromPango(ctx, obj.Domain, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imei_object *ExternalDynamicListResourceTypeImeiObject
	if obj.Imei != nil {
		imei_object = new(ExternalDynamicListResourceTypeImeiObject)

		diags.Append(imei_object.CopyFromPango(ctx, obj.Imei, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var imsi_object *ExternalDynamicListResourceTypeImsiObject
	if obj.Imsi != nil {
		imsi_object = new(ExternalDynamicListResourceTypeImsiObject)

		diags.Append(imsi_object.CopyFromPango(ctx, obj.Imsi, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var ip_object *ExternalDynamicListResourceTypeIpObject
	if obj.Ip != nil {
		ip_object = new(ExternalDynamicListResourceTypeIpObject)

		diags.Append(ip_object.CopyFromPango(ctx, obj.Ip, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedIp_object *ExternalDynamicListResourceTypePredefinedIpObject
	if obj.PredefinedIp != nil {
		predefinedIp_object = new(ExternalDynamicListResourceTypePredefinedIpObject)

		diags.Append(predefinedIp_object.CopyFromPango(ctx, obj.PredefinedIp, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var predefinedUrl_object *ExternalDynamicListResourceTypePredefinedUrlObject
	if obj.PredefinedUrl != nil {
		predefinedUrl_object = new(ExternalDynamicListResourceTypePredefinedUrlObject)

		diags.Append(predefinedUrl_object.CopyFromPango(ctx, obj.PredefinedUrl, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Url = url_object
	o.Domain = domain_object
	o.Imei = imei_object
	o.Imsi = imsi_object
	o.Ip = ip_object
	o.PredefinedIp = predefinedIp_object
	o.PredefinedUrl = predefinedUrl_object

	return diags
}

func (o *ExternalDynamicListResourceTypeIpObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var auth_object *ExternalDynamicListResourceTypeIpAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListResourceTypeIpAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var recurring_object *ExternalDynamicListResourceTypeIpRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListResourceTypeIpRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var fiveMinute_object *ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListResourceTypeIpRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListResourceTypeIpRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListResourceTypeIpRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListResourceTypeIpRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListResourceTypeIpRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListResourceTypeIpRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *ExternalDynamicListResourceTypeIpRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListResourceTypeIpRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object
	o.Daily = daily_object

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListResourceTypeIpRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeIpAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeIpAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListResourceTypePredefinedIpObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypePredefinedIp, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}

	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Url = url_value

	return diags
}

func (o *ExternalDynamicListResourceTypePredefinedUrlObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypePredefinedUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}

	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.ExceptionList = exceptionList_list
	o.Url = url_value
	o.Description = description_value

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrl, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var auth_object *ExternalDynamicListResourceTypeUrlAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListResourceTypeUrlAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var recurring_object *ExternalDynamicListResourceTypeUrlRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListResourceTypeUrlRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var hourly_object *ExternalDynamicListResourceTypeUrlRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListResourceTypeUrlRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListResourceTypeUrlRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListResourceTypeUrlRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListResourceTypeUrlRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListResourceTypeUrlRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *ExternalDynamicListResourceTypeUrlRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListResourceTypeUrlRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object
	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListResourceTypeUrlRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeUrlRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomain, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var recurring_object *ExternalDynamicListResourceTypeDomainRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListResourceTypeDomainRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var auth_object *ExternalDynamicListResourceTypeDomainAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListResourceTypeDomainAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var expandDomain_value types.Bool
	if obj.ExpandDomain != nil {
		expandDomain_value = types.BoolValue(*obj.ExpandDomain)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.ExceptionList = exceptionList_list
	o.ExpandDomain = expandDomain_value
	o.Recurring = recurring_object
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *ExternalDynamicListResourceTypeDomainRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListResourceTypeDomainRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListResourceTypeDomainRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListResourceTypeDomainRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListResourceTypeDomainRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListResourceTypeDomainRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListResourceTypeDomainRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListResourceTypeDomainRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListResourceTypeDomainAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeDomainAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImei, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var recurring_object *ExternalDynamicListResourceTypeImeiRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListResourceTypeImeiRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var auth_object *ExternalDynamicListResourceTypeImeiAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListResourceTypeImeiAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	o.Recurring = recurring_object
	o.Url = url_value
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var weekly_object *ExternalDynamicListResourceTypeImeiRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListResourceTypeImeiRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var daily_object *ExternalDynamicListResourceTypeImeiRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListResourceTypeImeiRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListResourceTypeImeiRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListResourceTypeImeiRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListResourceTypeImeiRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListResourceTypeImeiRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Weekly = weekly_object
	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.DayOfWeek = dayOfWeek_value
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImeiAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImeiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsi, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var exceptionList_list types.List
	{
		var list_diags diag.Diagnostics
		exceptionList_list, list_diags = types.ListValueFrom(ctx, types.StringType, obj.ExceptionList)
		diags.Append(list_diags...)
	}
	var auth_object *ExternalDynamicListResourceTypeImsiAuthObject
	if obj.Auth != nil {
		auth_object = new(ExternalDynamicListResourceTypeImsiAuthObject)

		diags.Append(auth_object.CopyFromPango(ctx, obj.Auth, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var recurring_object *ExternalDynamicListResourceTypeImsiRecurringObject
	if obj.Recurring != nil {
		recurring_object = new(ExternalDynamicListResourceTypeImsiRecurringObject)

		diags.Append(recurring_object.CopyFromPango(ctx, obj.Recurring, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	var certificateProfile_value types.String
	if obj.CertificateProfile != nil {
		certificateProfile_value = types.StringValue(*obj.CertificateProfile)
	}
	var description_value types.String
	if obj.Description != nil {
		description_value = types.StringValue(*obj.Description)
	}
	var url_value types.String
	if obj.Url != nil {
		url_value = types.StringValue(*obj.Url)
	}
	o.Auth = auth_object
	o.CertificateProfile = certificateProfile_value
	o.Description = description_value
	o.ExceptionList = exceptionList_list
	o.Recurring = recurring_object
	o.Url = url_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiAuthObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiAuth, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.Password = password_value
	o.Username = username_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurring, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics
	var daily_object *ExternalDynamicListResourceTypeImsiRecurringDailyObject
	if obj.Daily != nil {
		daily_object = new(ExternalDynamicListResourceTypeImsiRecurringDailyObject)

		diags.Append(daily_object.CopyFromPango(ctx, obj.Daily, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var fiveMinute_object *ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject
	if obj.FiveMinute != nil {
		fiveMinute_object = new(ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject)

		diags.Append(fiveMinute_object.CopyFromPango(ctx, obj.FiveMinute, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var hourly_object *ExternalDynamicListResourceTypeImsiRecurringHourlyObject
	if obj.Hourly != nil {
		hourly_object = new(ExternalDynamicListResourceTypeImsiRecurringHourlyObject)

		diags.Append(hourly_object.CopyFromPango(ctx, obj.Hourly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var monthly_object *ExternalDynamicListResourceTypeImsiRecurringMonthlyObject
	if obj.Monthly != nil {
		monthly_object = new(ExternalDynamicListResourceTypeImsiRecurringMonthlyObject)

		diags.Append(monthly_object.CopyFromPango(ctx, obj.Monthly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}
	var weekly_object *ExternalDynamicListResourceTypeImsiRecurringWeeklyObject
	if obj.Weekly != nil {
		weekly_object = new(ExternalDynamicListResourceTypeImsiRecurringWeeklyObject)

		diags.Append(weekly_object.CopyFromPango(ctx, obj.Weekly, encrypted)...)
		if diags.HasError() {
			return diags
		}
	}

	o.Daily = daily_object
	o.FiveMinute = fiveMinute_object
	o.Hourly = hourly_object
	o.Monthly = monthly_object
	o.Weekly = weekly_object

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringFiveMinuteObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringFiveMinute, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringHourlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringHourly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringMonthlyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringMonthly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfMonth_value types.Int64
	if obj.DayOfMonth != nil {
		dayOfMonth_value = types.Int64Value(*obj.DayOfMonth)
	}
	o.At = at_value
	o.DayOfMonth = dayOfMonth_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringWeeklyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringWeekly, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	var dayOfWeek_value types.String
	if obj.DayOfWeek != nil {
		dayOfWeek_value = types.StringValue(*obj.DayOfWeek)
	}
	o.At = at_value
	o.DayOfWeek = dayOfWeek_value

	return diags
}

func (o *ExternalDynamicListResourceTypeImsiRecurringDailyObject) CopyFromPango(ctx context.Context, obj *extdynlist.TypeImsiRecurringDaily, encrypted *map[string]types.String) diag.Diagnostics {
	var diags diag.Diagnostics

	var at_value types.String
	if obj.At != nil {
		at_value = types.StringValue(*obj.At)
	}
	o.At = at_value

	return diags
}

func (r *ExternalDynamicListResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state ExternalDynamicListResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_external_dynamic_list_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	// Determine the location.

	var location extdynlist.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &extdynlist.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *extdynlist.Entry

	resp.Diagnostics.Append(state.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.
	created, err := r.manager.Create(ctx, location, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, created, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}
	state.Name = types.StringValue(created.Name)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *ExternalDynamicListResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state ExternalDynamicListResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location extdynlist.Location

	if !savestate.Location.Shared.IsNull() && savestate.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if savestate.Location.DeviceGroup != nil {
		location.DeviceGroup = &extdynlist.DeviceGroupLocation{

			PanoramaDevice: savestate.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    savestate.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_external_dynamic_list_resource",
		"function":      "Read",
		"name":          savestate.Name.ValueString(),
	})

	// Perform the operation.
	object, err := o.manager.Read(ctx, location, savestate.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, object, nil)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *ExternalDynamicListResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state ExternalDynamicListResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var location extdynlist.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &extdynlist.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_external_dynamic_list_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}
	obj, err := r.manager.Read(ctx, location, plan.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, &obj, nil)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Perform the operation.
	updated, err := r.manager.Update(ctx, location, obj, obj.Name)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, updated, nil)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *ExternalDynamicListResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state ExternalDynamicListResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_external_dynamic_list_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location extdynlist.Location

	if !state.Location.Shared.IsNull() && state.Location.Shared.ValueBool() {
		location.Shared = true
	}
	if state.Location.DeviceGroup != nil {
		location.DeviceGroup = &extdynlist.DeviceGroupLocation{

			PanoramaDevice: state.Location.DeviceGroup.PanoramaDevice.ValueString(),
			DeviceGroup:    state.Location.DeviceGroup.Name.ValueString(),
		}
	}

	err := r.manager.Delete(ctx, location, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}

}

type ExternalDynamicListImportState struct {
	Location ExternalDynamicListLocation `json:"location"`
	Name     string                      `json:"name"`
}

func ExternalDynamicListImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location ExternalDynamicListLocation
	switch value := locationAttr.(type) {
	case types.Object:
		value.As(ctx, &location, basetypes.ObjectAsOptions{})
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}

	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name string
	switch value := nameAttr.(type) {
	case types.String:
		name = value.ValueString()
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := ExternalDynamicListImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (r *ExternalDynamicListResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj ExternalDynamicListImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)

}

type ExternalDynamicListDeviceGroupLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
}
type ExternalDynamicListLocation struct {
	Shared      types.Bool                              `tfsdk:"shared"`
	DeviceGroup *ExternalDynamicListDeviceGroupLocation `tfsdk:"device_group"`
}

func ExternalDynamicListLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.BoolAttribute{
				Description: "Location in Shared Panorama",
				Optional:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Bool{
					boolvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("device_group"),
						path.MatchRelative().AtParent().AtName("shared"),
					}...),
				},
			},
			"device_group": rsschema.SingleNestedAttribute{
				Description: "Located in a specific Device Group",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Panorama device name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Device Group name",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o ExternalDynamicListDeviceGroupLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *ExternalDynamicListDeviceGroupLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device"`
		Name           *string `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}
func (o ExternalDynamicListLocation) MarshalJSON() ([]byte, error) {
	obj := struct {
		Shared      *bool                                   `json:"shared"`
		DeviceGroup *ExternalDynamicListDeviceGroupLocation `json:"device_group"`
	}{
		Shared:      o.Shared.ValueBoolPointer(),
		DeviceGroup: o.DeviceGroup,
	}

	return json.Marshal(obj)
}

func (o *ExternalDynamicListLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared      *bool                                   `json:"shared"`
		DeviceGroup *ExternalDynamicListDeviceGroupLocation `json:"device_group"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Shared = types.BoolPointerValue(shadow.Shared)
	o.DeviceGroup = shadow.DeviceGroup

	return nil
}
