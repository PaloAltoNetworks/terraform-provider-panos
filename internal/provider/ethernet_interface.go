package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/interface/ethernet"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &EthernetInterfaceDataSource{}
	_ datasource.DataSourceWithConfigure = &EthernetInterfaceDataSource{}
)

func NewEthernetInterfaceDataSource() datasource.DataSource {
	return &EthernetInterfaceDataSource{}
}

type EthernetInterfaceDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ImportableEntryObjectManager[*ethernet.Entry, ethernet.Location, ethernet.ImportLocation, *ethernet.Service]
}

type EthernetInterfaceDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type EthernetInterfaceDataSourceModel struct {
	Location       types.Object `tfsdk:"location"`
	Name           types.String `tfsdk:"name"`
	Comment        types.String `tfsdk:"comment"`
	Lacp           types.Object `tfsdk:"lacp"`
	LinkDuplex     types.String `tfsdk:"link_duplex"`
	LinkSpeed      types.String `tfsdk:"link_speed"`
	LinkState      types.String `tfsdk:"link_state"`
	Poe            types.Object `tfsdk:"poe"`
	AggregateGroup types.String `tfsdk:"aggregate_group"`
	DecryptMirror  types.Object `tfsdk:"decrypt_mirror"`
	Ha             types.Object `tfsdk:"ha"`
	Layer2         types.Object `tfsdk:"layer2"`
	Layer3         types.Object `tfsdk:"layer3"`
	LogCard        types.Object `tfsdk:"log_card"`
	Tap            types.Object `tfsdk:"tap"`
	VirtualWire    types.Object `tfsdk:"virtual_wire"`
}
type EthernetInterfaceDataSourceLacpObject struct {
	PortPriority types.Int64 `tfsdk:"port_priority"`
}
type EthernetInterfaceDataSourcePoeObject struct {
	Enabled          types.Bool  `tfsdk:"enabled"`
	PoeReservedPower types.Int64 `tfsdk:"poe_reserved_power"`
}
type EthernetInterfaceDataSourceDecryptMirrorObject struct {
}
type EthernetInterfaceDataSourceHaObject struct {
}
type EthernetInterfaceDataSourceLayer2Object struct {
	Lldp           types.Object `tfsdk:"lldp"`
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceDataSourceLayer2LldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceDataSourceLayer3Object struct {
	AdjustTcpMss               types.Object `tfsdk:"adjust_tcp_mss"`
	Arp                        types.List   `tfsdk:"arp"`
	Bonjour                    types.Object `tfsdk:"bonjour"`
	ClusterInterconnect        types.Bool   `tfsdk:"cluster_interconnect"`
	DdnsConfig                 types.Object `tfsdk:"ddns_config"`
	DecryptForward             types.Bool   `tfsdk:"decrypt_forward"`
	DfIgnore                   types.Bool   `tfsdk:"df_ignore"`
	DhcpClient                 types.Object `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String `tfsdk:"interface_management_profile"`
	Ips                        types.List   `tfsdk:"ips"`
	Ipv6                       types.Object `tfsdk:"ipv6"`
	Lldp                       types.Object `tfsdk:"lldp"`
	Mtu                        types.Int64  `tfsdk:"mtu"`
	NdpProxy                   types.Object `tfsdk:"ndp_proxy"`
	NetflowProfile             types.String `tfsdk:"netflow_profile"`
	Pppoe                      types.Object `tfsdk:"pppoe"`
	SdwanLinkSettings          types.Object `tfsdk:"sdwan_link_settings"`
	TrafficInterconnect        types.Bool   `tfsdk:"traffic_interconnect"`
	UntaggedSubInterface       types.Bool   `tfsdk:"untagged_sub_interface"`
}
type EthernetInterfaceDataSourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type EthernetInterfaceDataSourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3BonjourObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	GroupId  types.Int64 `tfsdk:"group_id"`
	TtlCheck types.Bool  `tfsdk:"ttl_check"`
}
type EthernetInterfaceDataSourceLayer3DdnsConfigObject struct {
	DdnsCertProfile    types.String `tfsdk:"ddns_cert_profile"`
	DdnsEnabled        types.Bool   `tfsdk:"ddns_enabled"`
	DdnsHostname       types.String `tfsdk:"ddns_hostname"`
	DdnsIp             types.List   `tfsdk:"ddns_ip"`
	DdnsIpv6           types.List   `tfsdk:"ddns_ipv6"`
	DdnsUpdateInterval types.Int64  `tfsdk:"ddns_update_interval"`
	DdnsVendor         types.String `tfsdk:"ddns_vendor"`
	DdnsVendorConfig   types.List   `tfsdk:"ddns_vendor_config"`
}
type EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type EthernetInterfaceDataSourceLayer3DhcpClientObject struct {
	CreateDefaultRoute types.Bool   `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	SendHostname       types.Object `tfsdk:"send_hostname"`
}
type EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Hostname types.String `tfsdk:"hostname"`
}
type EthernetInterfaceDataSourceLayer3IpsObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type EthernetInterfaceDataSourceLayer3Ipv6Object struct {
	Addresses         types.List   `tfsdk:"addresses"`
	DhcpClient        types.Object `tfsdk:"dhcp_client"`
	Enabled           types.Bool   `tfsdk:"enabled"`
	Inherited         types.Object `tfsdk:"inherited"`
	InterfaceId       types.String `tfsdk:"interface_id"`
	NeighborDiscovery types.Object `tfsdk:"neighbor_discovery"`
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesObject struct {
	Name              types.String `tfsdk:"name"`
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	Prefix            types.Object `tfsdk:"prefix"`
	Anycast           types.Object `tfsdk:"anycast"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject struct {
	AcceptRaRoute      types.Bool   `tfsdk:"accept_ra_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	NeighborDiscovery  types.Object `tfsdk:"neighbor_discovery"`
	Preference         types.String `tfsdk:"preference"`
	PrefixDelegation   types.Object `tfsdk:"prefix_delegation"`
	V6Options          types.Object `tfsdk:"v6_options"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject struct {
	DadAttempts      types.Int64  `tfsdk:"dad_attempts"`
	DnsServer        types.Object `tfsdk:"dns_server"`
	DnsSuffix        types.Object `tfsdk:"dns_suffix"`
	EnableDad        types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor         types.List   `tfsdk:"neighbor"`
	NsInterval       types.Int64  `tfsdk:"ns_interval"`
	ReachableTime    types.Int64  `tfsdk:"reachable_time"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject struct {
	Enable types.Object `tfsdk:"enable"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject struct {
	PfxPoolName   types.String `tfsdk:"pfx_pool_name"`
	PrefixLen     types.Int64  `tfsdk:"prefix_len"`
	PrefixLenHint types.Bool   `tfsdk:"prefix_len_hint"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject struct {
	DuidType            types.String `tfsdk:"duid_type"`
	Enable              types.Object `tfsdk:"enable"`
	RapidCommit         types.Bool   `tfsdk:"rapid_commit"`
	SupportSrvrReconfig types.Bool   `tfsdk:"support_srvr_reconfig"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject struct {
	NonTempAddr types.Bool `tfsdk:"non_temp_addr"`
	TempAddr    types.Bool `tfsdk:"temp_addr"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedObject struct {
	AssignAddr        types.List   `tfsdk:"assign_addr"`
	Enable            types.Bool   `tfsdk:"enable"`
	NeighborDiscovery types.Object `tfsdk:"neighbor_discovery"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject struct {
	Name types.String `tfsdk:"name"`
	Type types.Object `tfsdk:"type"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject struct {
	Gua types.Object `tfsdk:"gua"`
	Ula types.Object `tfsdk:"ula"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject struct {
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	PrefixPool        types.String `tfsdk:"prefix_pool"`
	PoolType          types.Object `tfsdk:"pool_type"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject struct {
	Dynamic   types.Object `tfsdk:"dynamic"`
	DynamicId types.Object `tfsdk:"dynamic_id"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject struct {
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject struct {
	Identifier types.Int64 `tfsdk:"identifier"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject struct {
	Enable         types.Bool `tfsdk:"enable"`
	OnlinkFlag     types.Bool `tfsdk:"onlink_flag"`
	AutoConfigFlag types.Bool `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject struct {
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	Addresses         types.String `tfsdk:"addresses"`
	Prefix            types.Bool   `tfsdk:"prefix"`
	Anycast           types.Bool   `tfsdk:"anycast"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject struct {
	DadAttempts         types.Int64  `tfsdk:"dad_attempts"`
	DnsServer           types.Object `tfsdk:"dns_server"`
	DnsSuffix           types.Object `tfsdk:"dns_suffix"`
	EnableDad           types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List   `tfsdk:"neighbor"`
	NsInterval          types.Int64  `tfsdk:"ns_interval"`
	ReachableTime       types.Int64  `tfsdk:"reachable_time"`
	RouterAdvertisement types.Object `tfsdk:"router_advertisement"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject struct {
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject struct {
	DadAttempts         types.Int64  `tfsdk:"dad_attempts"`
	EnableDad           types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List   `tfsdk:"neighbor"`
	NsInterval          types.Int64  `tfsdk:"ns_interval"`
	ReachableTime       types.Int64  `tfsdk:"reachable_time"`
	RouterAdvertisement types.Object `tfsdk:"router_advertisement"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	DnsSupport             types.Object `tfsdk:"dns_support"`
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceDataSourceLayer3LldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceDataSourceLayer3NdpProxyObject struct {
	Addresses types.List `tfsdk:"addresses"`
	Enabled   types.Bool `tfsdk:"enabled"`
}
type EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
}
type EthernetInterfaceDataSourceLayer3PppoeObject struct {
	AccessConcentrator types.String `tfsdk:"access_concentrator"`
	Authentication     types.String `tfsdk:"authentication"`
	CreateDefaultRoute types.Bool   `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	Passive            types.Object `tfsdk:"passive"`
	Password           types.String `tfsdk:"password"`
	Service            types.String `tfsdk:"service"`
	StaticAddress      types.Object `tfsdk:"static_address"`
	Username           types.String `tfsdk:"username"`
}
type EthernetInterfaceDataSourceLayer3PppoePassiveObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject struct {
	Ips types.String `tfsdk:"ips"`
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject struct {
	Enable                types.Bool   `tfsdk:"enable"`
	SdwanInterfaceProfile types.String `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           types.Object `tfsdk:"upstream_nat"`
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Ddns     types.Object `tfsdk:"ddns"`
	StaticIp types.Object `tfsdk:"static_ip"`
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject struct {
}
type EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject struct {
	Fqdn      types.String `tfsdk:"fqdn"`
	IpAddress types.String `tfsdk:"ip_address"`
}
type EthernetInterfaceDataSourceLogCardObject struct {
	DefaultGateway     types.String `tfsdk:"default_gateway"`
	IpAddress          types.String `tfsdk:"ip_address"`
	Ipv6Address        types.String `tfsdk:"ipv6_address"`
	Ipv6DefaultGateway types.String `tfsdk:"ipv6_default_gateway"`
	Netmask            types.String `tfsdk:"netmask"`
}
type EthernetInterfaceDataSourceTapObject struct {
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceDataSourceVirtualWireObject struct {
	Lacp           types.Object `tfsdk:"lacp"`
	Lldp           types.Object `tfsdk:"lldp"`
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceDataSourceVirtualWireLacpObject struct {
	HighAvailability types.Object `tfsdk:"high_availability"`
}
type EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceDataSourceVirtualWireLldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}

func (o *EthernetInterfaceDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj EthernetInterfaceLocation

	var lacpObj *EthernetInterfaceDataSourceLacpObject

	var poeObj *EthernetInterfaceDataSourcePoeObject

	var decryptMirrorObj *EthernetInterfaceDataSourceDecryptMirrorObject

	var haObj *EthernetInterfaceDataSourceHaObject

	var layer2Obj *EthernetInterfaceDataSourceLayer2Object

	var layer3Obj *EthernetInterfaceDataSourceLayer3Object

	var logCardObj *EthernetInterfaceDataSourceLogCardObject

	var tapObj *EthernetInterfaceDataSourceTapObject

	var virtualWireObj *EthernetInterfaceDataSourceVirtualWireObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":    types.StringType,
		"comment": types.StringType,
		"lacp": types.ObjectType{
			AttrTypes: lacpObj.AttributeTypes(),
		},
		"link_duplex": types.StringType,
		"link_speed":  types.StringType,
		"link_state":  types.StringType,
		"poe": types.ObjectType{
			AttrTypes: poeObj.AttributeTypes(),
		},
		"aggregate_group": types.StringType,
		"decrypt_mirror": types.ObjectType{
			AttrTypes: decryptMirrorObj.AttributeTypes(),
		},
		"ha": types.ObjectType{
			AttrTypes: haObj.AttributeTypes(),
		},
		"layer2": types.ObjectType{
			AttrTypes: layer2Obj.AttributeTypes(),
		},
		"layer3": types.ObjectType{
			AttrTypes: layer3Obj.AttributeTypes(),
		},
		"log_card": types.ObjectType{
			AttrTypes: logCardObj.AttributeTypes(),
		},
		"tap": types.ObjectType{
			AttrTypes: tapObj.AttributeTypes(),
		},
		"virtual_wire": types.ObjectType{
			AttrTypes: virtualWireObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceModel) AncestorName() string {
	return ""
}

func (o EthernetInterfaceDataSourceModel) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLacpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"port_priority": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLacpObject) AncestorName() string {
	return "lacp"
}

func (o EthernetInterfaceDataSourceLacpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourcePoeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled":            types.BoolType,
		"poe_reserved_power": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourcePoeObject) AncestorName() string {
	return "poe"
}

func (o EthernetInterfaceDataSourcePoeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceDecryptMirrorObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceDecryptMirrorObject) AncestorName() string {
	return "decrypt-mirror"
}

func (o EthernetInterfaceDataSourceDecryptMirrorObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceHaObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceHaObject) AncestorName() string {
	return "ha"
}

func (o EthernetInterfaceDataSourceHaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer2Object) AttributeTypes() map[string]attr.Type {

	var lldpObj *EthernetInterfaceDataSourceLayer2LldpObject

	return map[string]attr.Type{
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer2Object) AncestorName() string {
	return "layer2"
}

func (o EthernetInterfaceDataSourceLayer2Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer2LldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer2LldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceDataSourceLayer2LldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Object) AttributeTypes() map[string]attr.Type {

	var adjustTcpMssObj *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject

	var arpObj *EthernetInterfaceDataSourceLayer3ArpObject

	var bonjourObj *EthernetInterfaceDataSourceLayer3BonjourObject

	var ddnsConfigObj *EthernetInterfaceDataSourceLayer3DdnsConfigObject

	var dhcpClientObj *EthernetInterfaceDataSourceLayer3DhcpClientObject

	var ipsObj *EthernetInterfaceDataSourceLayer3IpsObject

	var ipv6Obj *EthernetInterfaceDataSourceLayer3Ipv6Object

	var lldpObj *EthernetInterfaceDataSourceLayer3LldpObject

	var ndpProxyObj *EthernetInterfaceDataSourceLayer3NdpProxyObject

	var pppoeObj *EthernetInterfaceDataSourceLayer3PppoeObject

	var sdwanLinkSettingsObj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject

	return map[string]attr.Type{
		"adjust_tcp_mss": types.ObjectType{
			AttrTypes: adjustTcpMssObj.AttributeTypes(),
		},
		"arp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: arpObj.AttributeTypes(),
			},
		},
		"bonjour": types.ObjectType{
			AttrTypes: bonjourObj.AttributeTypes(),
		},
		"cluster_interconnect": types.BoolType,
		"ddns_config": types.ObjectType{
			AttrTypes: ddnsConfigObj.AttributeTypes(),
		},
		"decrypt_forward": types.BoolType,
		"df_ignore":       types.BoolType,
		"dhcp_client": types.ObjectType{
			AttrTypes: dhcpClientObj.AttributeTypes(),
		},
		"interface_management_profile": types.StringType,
		"ips": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ipsObj.AttributeTypes(),
			},
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"mtu": types.Int64Type,
		"ndp_proxy": types.ObjectType{
			AttrTypes: ndpProxyObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
		"pppoe": types.ObjectType{
			AttrTypes: pppoeObj.AttributeTypes(),
		},
		"sdwan_link_settings": types.ObjectType{
			AttrTypes: sdwanLinkSettingsObj.AttributeTypes(),
		},
		"traffic_interconnect":   types.BoolType,
		"untagged_sub_interface": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Object) AncestorName() string {
	return "layer3"
}

func (o EthernetInterfaceDataSourceLayer3Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":              types.BoolType,
		"ipv4_mss_adjustment": types.Int64Type,
		"ipv6_mss_adjustment": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) AncestorName() string {
	return "adjust-tcp-mss"
}

func (o EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3ArpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3ArpObject) AncestorName() string {
	return "arp"
}

func (o EthernetInterfaceDataSourceLayer3ArpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3BonjourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":    types.BoolType,
		"group_id":  types.Int64Type,
		"ttl_check": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3BonjourObject) AncestorName() string {
	return "bonjour"
}

func (o EthernetInterfaceDataSourceLayer3BonjourObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3DdnsConfigObject) AttributeTypes() map[string]attr.Type {

	var ddnsVendorConfigObj *EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
	return map[string]attr.Type{
		"ddns_cert_profile": types.StringType,
		"ddns_enabled":      types.BoolType,
		"ddns_hostname":     types.StringType,
		"ddns_ip": types.ListType{
			ElemType: types.StringType,
		},
		"ddns_ipv6": types.ListType{
			ElemType: types.StringType,
		},
		"ddns_update_interval": types.Int64Type,
		"ddns_vendor":          types.StringType,
		"ddns_vendor_config": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ddnsVendorConfigObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3DdnsConfigObject) AncestorName() string {
	return "ddns-config"
}

func (o EthernetInterfaceDataSourceLayer3DdnsConfigObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"value": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) AncestorName() string {
	return "ddns-vendor-config"
}

func (o EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) AttributeTypes() map[string]attr.Type {

	var sendHostnameObj *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject
	return map[string]attr.Type{
		"create_default_route": types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"send_hostname": types.ObjectType{
			AttrTypes: sendHostnameObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3DhcpClientObject) AncestorName() string {
	return "dhcp-client"
}

func (o EthernetInterfaceDataSourceLayer3DhcpClientObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"hostname": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) AncestorName() string {
	return "send-hostname"
}

func (o EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3IpsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"sdwan_gateway": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3IpsObject) AncestorName() string {
	return "ips"
}

func (o EthernetInterfaceDataSourceLayer3IpsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) AttributeTypes() map[string]attr.Type {

	var addressesObj *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject

	var dhcpClientObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject

	var inheritedObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject

	var neighborDiscoveryObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject
	return map[string]attr.Type{
		"addresses": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressesObj.AttributeTypes(),
			},
		},
		"dhcp_client": types.ObjectType{
			AttrTypes: dhcpClientObj.AttributeTypes(),
		},
		"enabled": types.BoolType,
		"inherited": types.ObjectType{
			AttrTypes: inheritedObj.AttributeTypes(),
		},
		"interface_id": types.StringType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6Object) AncestorName() string {
	return "ipv6"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) AttributeTypes() map[string]attr.Type {

	var prefixObj *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject

	var anycastObj *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject

	var advertiseObj *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable_on_interface": types.BoolType,
		"prefix": types.ObjectType{
			AttrTypes: prefixObj.AttributeTypes(),
		},
		"anycast": types.ObjectType{
			AttrTypes: anycastObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) AncestorName() string {
	return "addresses"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) AncestorName() string {
	return "prefix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) AncestorName() string {
	return "anycast"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":             types.BoolType,
		"valid_lifetime":     types.StringType,
		"preferred_lifetime": types.StringType,
		"onlink_flag":        types.BoolType,
		"auto_config_flag":   types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) AttributeTypes() map[string]attr.Type {

	var neighborDiscoveryObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject

	var prefixDelegationObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject

	var v6OptionsObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject
	return map[string]attr.Type{
		"accept_ra_route":      types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
		"preference": types.StringType,
		"prefix_delegation": types.ObjectType{
			AttrTypes: prefixDelegationObj.AttributeTypes(),
		},
		"v6_options": types.ObjectType{
			AttrTypes: v6OptionsObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) AncestorName() string {
	return "dhcp-client"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var dnsServerObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject

	var dnsSuffixObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject

	var neighborObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject

	return map[string]attr.Type{
		"dad_attempts": types.Int64Type,
		"dns_server": types.ObjectType{
			AttrTypes: dnsServerObj.AttributeTypes(),
		},
		"dns_suffix": types.ObjectType{
			AttrTypes: dnsSuffixObj.AttributeTypes(),
		},
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) AncestorName() string {
	return "dns-server"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object

	var manualObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	return map[string]attr.Type{
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) AncestorName() string {
	return "dns-suffix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object

	var manualObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) AttributeTypes() map[string]attr.Type {

	var suffixObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	return map[string]attr.Type{
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) AttributeTypes() map[string]attr.Type {

	var enableObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	return map[string]attr.Type{
		"enable": types.ObjectType{
			AttrTypes: enableObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) AncestorName() string {
	return "prefix-delegation"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) AttributeTypes() map[string]attr.Type {

	var noObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject

	var yesObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) AncestorName() string {
	return "enable"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) AncestorName() string {
	return "no"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"pfx_pool_name":   types.StringType,
		"prefix_len":      types.Int64Type,
		"prefix_len_hint": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) AncestorName() string {
	return "yes"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) AttributeTypes() map[string]attr.Type {

	var enableObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject

	return map[string]attr.Type{
		"duid_type": types.StringType,
		"enable": types.ObjectType{
			AttrTypes: enableObj.AttributeTypes(),
		},
		"rapid_commit":          types.BoolType,
		"support_srvr_reconfig": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) AncestorName() string {
	return "v6-options"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) AttributeTypes() map[string]attr.Type {

	var noObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject

	var yesObj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) AncestorName() string {
	return "enable"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) AncestorName() string {
	return "no"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"non_temp_addr": types.BoolType,
		"temp_addr":     types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) AncestorName() string {
	return "yes"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) AttributeTypes() map[string]attr.Type {

	var assignAddrObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject

	var neighborDiscoveryObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject
	return map[string]attr.Type{
		"assign_addr": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: assignAddrObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) AncestorName() string {
	return "inherited"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) AttributeTypes() map[string]attr.Type {

	var typeObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject
	return map[string]attr.Type{
		"name": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) AncestorName() string {
	return "assign-addr"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) AttributeTypes() map[string]attr.Type {

	var guaObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject

	var ulaObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	return map[string]attr.Type{
		"gua": types.ObjectType{
			AttrTypes: guaObj.AttributeTypes(),
		},
		"ula": types.ObjectType{
			AttrTypes: ulaObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) AncestorName() string {
	return "type"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) AttributeTypes() map[string]attr.Type {

	var poolTypeObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject

	var advertiseObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	return map[string]attr.Type{
		"enable_on_interface": types.BoolType,
		"prefix_pool":         types.StringType,
		"pool_type": types.ObjectType{
			AttrTypes: poolTypeObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) AncestorName() string {
	return "gua"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject

	var dynamicIdObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	return map[string]attr.Type{
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"dynamic_id": types.ObjectType{
			AttrTypes: dynamicIdObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) AncestorName() string {
	return "pool-type"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"identifier": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) AncestorName() string {
	return "dynamic-id"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":           types.BoolType,
		"onlink_flag":      types.BoolType,
		"auto_config_flag": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	return map[string]attr.Type{
		"enable_on_interface": types.BoolType,
		"addresses":           types.StringType,
		"prefix":              types.BoolType,
		"anycast":             types.BoolType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) AncestorName() string {
	return "ula"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":             types.BoolType,
		"valid_lifetime":     types.StringType,
		"preferred_lifetime": types.StringType,
		"onlink_flag":        types.BoolType,
		"auto_config_flag":   types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var dnsServerObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject

	var dnsSuffixObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject

	var neighborObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject

	var routerAdvertisementObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	return map[string]attr.Type{
		"dad_attempts": types.Int64Type,
		"dns_server": types.ObjectType{
			AttrTypes: dnsServerObj.AttributeTypes(),
		},
		"dns_suffix": types.ObjectType{
			AttrTypes: dnsSuffixObj.AttributeTypes(),
		},
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
		"router_advertisement": types.ObjectType{
			AttrTypes: routerAdvertisementObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) AncestorName() string {
	return "dns-server"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object

	var manualObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_pool": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	return map[string]attr.Type{
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) AncestorName() string {
	return "dns-suffix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object

	var manualObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_pool": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) AttributeTypes() map[string]attr.Type {

	var suffixObj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	return map[string]attr.Type{
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                   types.BoolType,
		"enable_consistency_check": types.BoolType,
		"hop_limit":                types.StringType,
		"lifetime":                 types.Int64Type,
		"link_mtu":                 types.StringType,
		"managed_flag":             types.BoolType,
		"max_interval":             types.Int64Type,
		"min_interval":             types.Int64Type,
		"other_flag":               types.BoolType,
		"reachable_time":           types.StringType,
		"retransmission_timer":     types.StringType,
		"router_preference":        types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) AncestorName() string {
	return "router-advertisement"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject

	var routerAdvertisementObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	return map[string]attr.Type{
		"dad_attempts":       types.Int64Type,
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
		"router_advertisement": types.ObjectType{
			AttrTypes: routerAdvertisementObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) AttributeTypes() map[string]attr.Type {

	var dnsSupportObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject

	return map[string]attr.Type{
		"dns_support": types.ObjectType{
			AttrTypes: dnsSupportObj.AttributeTypes(),
		},
		"enable":                   types.BoolType,
		"enable_consistency_check": types.BoolType,
		"hop_limit":                types.StringType,
		"lifetime":                 types.Int64Type,
		"link_mtu":                 types.StringType,
		"managed_flag":             types.BoolType,
		"max_interval":             types.Int64Type,
		"min_interval":             types.Int64Type,
		"other_flag":               types.BoolType,
		"reachable_time":           types.StringType,
		"retransmission_timer":     types.StringType,
		"router_preference":        types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) AncestorName() string {
	return "router-advertisement"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject

	var suffixObj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) AncestorName() string {
	return "dns-support"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3LldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3LldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceDataSourceLayer3LldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3NdpProxyObject) AttributeTypes() map[string]attr.Type {

	var addressesObj *EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject

	return map[string]attr.Type{
		"addresses": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressesObj.AttributeTypes(),
			},
		},
		"enabled": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3NdpProxyObject) AncestorName() string {
	return "ndp-proxy"
}

func (o EthernetInterfaceDataSourceLayer3NdpProxyObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"negate": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) AncestorName() string {
	return "addresses"
}

func (o EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceDataSourceLayer3PppoeObject) AttributeTypes() map[string]attr.Type {

	var passiveObj *EthernetInterfaceDataSourceLayer3PppoePassiveObject

	var staticAddressObj *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject

	return map[string]attr.Type{
		"access_concentrator":  types.StringType,
		"authentication":       types.StringType,
		"create_default_route": types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"passive": types.ObjectType{
			AttrTypes: passiveObj.AttributeTypes(),
		},
		"password": types.StringType,
		"service":  types.StringType,
		"static_address": types.ObjectType{
			AttrTypes: staticAddressObj.AttributeTypes(),
		},
		"username": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3PppoeObject) AncestorName() string {
	return "pppoe"
}

func (o EthernetInterfaceDataSourceLayer3PppoeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3PppoePassiveObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceLayer3PppoePassiveObject) AncestorName() string {
	return "passive"
}

func (o EthernetInterfaceDataSourceLayer3PppoePassiveObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ips": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) AncestorName() string {
	return "static-address"
}

func (o EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) AttributeTypes() map[string]attr.Type {

	var upstreamNatObj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject
	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"sdwan_interface_profile": types.StringType,
		"upstream_nat": types.ObjectType{
			AttrTypes: upstreamNatObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) AncestorName() string {
	return "sdwan-link-settings"
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) AttributeTypes() map[string]attr.Type {

	var ddnsObj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject

	var staticIpObj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"ddns": types.ObjectType{
			AttrTypes: ddnsObj.AttributeTypes(),
		},
		"static_ip": types.ObjectType{
			AttrTypes: staticIpObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) AncestorName() string {
	return "upstream-nat"
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) AncestorName() string {
	return "ddns"
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"fqdn":       types.StringType,
		"ip_address": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) AncestorName() string {
	return "static-ip"
}

func (o EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceLogCardObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"default_gateway":      types.StringType,
		"ip_address":           types.StringType,
		"ipv6_address":         types.StringType,
		"ipv6_default_gateway": types.StringType,
		"netmask":              types.StringType,
	}
}

func (o EthernetInterfaceDataSourceLogCardObject) AncestorName() string {
	return "log-card"
}

func (o EthernetInterfaceDataSourceLogCardObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceTapObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceTapObject) AncestorName() string {
	return "tap"
}

func (o EthernetInterfaceDataSourceTapObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceVirtualWireObject) AttributeTypes() map[string]attr.Type {

	var lacpObj *EthernetInterfaceDataSourceVirtualWireLacpObject

	var lldpObj *EthernetInterfaceDataSourceVirtualWireLldpObject

	return map[string]attr.Type{
		"lacp": types.ObjectType{
			AttrTypes: lacpObj.AttributeTypes(),
		},
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceVirtualWireObject) AncestorName() string {
	return "virtual-wire"
}

func (o EthernetInterfaceDataSourceVirtualWireObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceVirtualWireLacpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject
	return map[string]attr.Type{
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceDataSourceVirtualWireLacpObject) AncestorName() string {
	return "lacp"
}

func (o EthernetInterfaceDataSourceVirtualWireLacpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceVirtualWireLldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceDataSourceVirtualWireLldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceDataSourceVirtualWireLldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) EntryName() *string {
	return nil
}

func (o *EthernetInterfaceDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	var lacp_entry *ethernet.Lacp
	if !o.Lacp.IsUnknown() && !o.Lacp.IsNull() {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(ethernet.Lacp)
		}
		var object *EthernetInterfaceDataSourceLacpObject
		diags.Append(o.Lacp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &lacp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	linkDuplex_value := o.LinkDuplex.ValueStringPointer()
	linkSpeed_value := o.LinkSpeed.ValueStringPointer()
	linkState_value := o.LinkState.ValueStringPointer()
	var poe_entry *ethernet.Poe
	if !o.Poe.IsUnknown() && !o.Poe.IsNull() {
		if *obj != nil && (*obj).Poe != nil {
			poe_entry = (*obj).Poe
		} else {
			poe_entry = new(ethernet.Poe)
		}
		var object *EthernetInterfaceDataSourcePoeObject
		diags.Append(o.Poe.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &poe_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	aggregateGroup_value := o.AggregateGroup.ValueStringPointer()
	var decryptMirror_entry *ethernet.DecryptMirror
	if !o.DecryptMirror.IsUnknown() && !o.DecryptMirror.IsNull() {
		if *obj != nil && (*obj).DecryptMirror != nil {
			decryptMirror_entry = (*obj).DecryptMirror
		} else {
			decryptMirror_entry = new(ethernet.DecryptMirror)
		}
		var object *EthernetInterfaceDataSourceDecryptMirrorObject
		diags.Append(o.DecryptMirror.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &decryptMirror_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *ethernet.Ha
	if !o.Ha.IsUnknown() && !o.Ha.IsNull() {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(ethernet.Ha)
		}
		var object *EthernetInterfaceDataSourceHaObject
		diags.Append(o.Ha.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ha_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_entry *ethernet.Layer2
	if !o.Layer2.IsUnknown() && !o.Layer2.IsNull() {
		if *obj != nil && (*obj).Layer2 != nil {
			layer2_entry = (*obj).Layer2
		} else {
			layer2_entry = new(ethernet.Layer2)
		}
		var object *EthernetInterfaceDataSourceLayer2Object
		diags.Append(o.Layer2.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &layer2_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *ethernet.Layer3
	if !o.Layer3.IsUnknown() && !o.Layer3.IsNull() {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(ethernet.Layer3)
		}
		var object *EthernetInterfaceDataSourceLayer3Object
		diags.Append(o.Layer3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &layer3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var logCard_entry *ethernet.LogCard
	if !o.LogCard.IsUnknown() && !o.LogCard.IsNull() {
		if *obj != nil && (*obj).LogCard != nil {
			logCard_entry = (*obj).LogCard
		} else {
			logCard_entry = new(ethernet.LogCard)
		}
		var object *EthernetInterfaceDataSourceLogCardObject
		diags.Append(o.LogCard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &logCard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tap_entry *ethernet.Tap
	if !o.Tap.IsUnknown() && !o.Tap.IsNull() {
		if *obj != nil && (*obj).Tap != nil {
			tap_entry = (*obj).Tap
		} else {
			tap_entry = new(ethernet.Tap)
		}
		var object *EthernetInterfaceDataSourceTapObject
		diags.Append(o.Tap.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &tap_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_entry *ethernet.VirtualWire
	if !o.VirtualWire.IsUnknown() && !o.VirtualWire.IsNull() {
		if *obj != nil && (*obj).VirtualWire != nil {
			virtualWire_entry = (*obj).VirtualWire
		} else {
			virtualWire_entry = new(ethernet.VirtualWire)
		}
		var object *EthernetInterfaceDataSourceVirtualWireObject
		diags.Append(o.VirtualWire.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &virtualWire_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).Lacp = lacp_entry
	(*obj).LinkDuplex = linkDuplex_value
	(*obj).LinkSpeed = linkSpeed_value
	(*obj).LinkState = linkState_value
	(*obj).Poe = poe_entry
	(*obj).AggregateGroup = aggregateGroup_value
	(*obj).DecryptMirror = decryptMirror_entry
	(*obj).Ha = ha_entry
	(*obj).Layer2 = layer2_entry
	(*obj).Layer3 = layer3_entry
	(*obj).LogCard = logCard_entry
	(*obj).Tap = tap_entry
	(*obj).VirtualWire = virtualWire_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLacpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Lacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	portPriority_value := o.PortPriority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Lacp)
	}
	(*obj).PortPriority = portPriority_value

	return diags
}
func (o *EthernetInterfaceDataSourcePoeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Poe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	poeReservedPower_value := o.PoeReservedPower.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Poe)
	}
	(*obj).PoeEnabled = enabled_value
	(*obj).PoeRsvdPwr = poeReservedPower_value

	return diags
}
func (o *EthernetInterfaceDataSourceDecryptMirrorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.DecryptMirror, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.DecryptMirror)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceHaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Ha, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Ha)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer2Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_entry *ethernet.Layer2Lldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer2Lldp)
		}
		var object *EthernetInterfaceDataSourceLayer2LldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2)
	}
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer2LldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.Layer2LldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.Layer2LldpHighAvailability)
		}
		var object *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var adjustTcpMss_entry *ethernet.Layer3AdjustTcpMss
	if !o.AdjustTcpMss.IsUnknown() && !o.AdjustTcpMss.IsNull() {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(ethernet.Layer3AdjustTcpMss)
		}
		var object *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject
		diags.Append(o.AdjustTcpMss.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &adjustTcpMss_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var arp_tf_entries []EthernetInterfaceDataSourceLayer3ArpObject
	var arp_pango_entries []ethernet.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *ethernet.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	var bonjour_entry *ethernet.Layer3Bonjour
	if !o.Bonjour.IsUnknown() && !o.Bonjour.IsNull() {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(ethernet.Layer3Bonjour)
		}
		var object *EthernetInterfaceDataSourceLayer3BonjourObject
		diags.Append(o.Bonjour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bonjour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	clusterInterconnect_value := o.ClusterInterconnect.ValueBoolPointer()
	var ddnsConfig_entry *ethernet.Layer3DdnsConfig
	if !o.DdnsConfig.IsUnknown() && !o.DdnsConfig.IsNull() {
		if *obj != nil && (*obj).DdnsConfig != nil {
			ddnsConfig_entry = (*obj).DdnsConfig
		} else {
			ddnsConfig_entry = new(ethernet.Layer3DdnsConfig)
		}
		var object *EthernetInterfaceDataSourceLayer3DdnsConfigObject
		diags.Append(o.DdnsConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ddnsConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	decryptForward_value := o.DecryptForward.ValueBoolPointer()
	dfIgnore_value := o.DfIgnore.ValueBoolPointer()
	var dhcpClient_entry *ethernet.Layer3DhcpClient
	if !o.DhcpClient.IsUnknown() && !o.DhcpClient.IsNull() {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3DhcpClient)
		}
		var object *EthernetInterfaceDataSourceLayer3DhcpClientObject
		diags.Append(o.DhcpClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	var ips_tf_entries []EthernetInterfaceDataSourceLayer3IpsObject
	var ips_pango_entries []ethernet.Layer3Ip
	{
		d := o.Ips.ElementsAs(ctx, &ips_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ips_tf_entries {
			var entry *ethernet.Layer3Ip
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ips_pango_entries = append(ips_pango_entries, *entry)
		}
	}
	var ipv6_entry *ethernet.Layer3Ipv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(ethernet.Layer3Ipv6)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *ethernet.Layer3Lldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer3Lldp)
		}
		var object *EthernetInterfaceDataSourceLayer3LldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ndpProxy_entry *ethernet.Layer3NdpProxy
	if !o.NdpProxy.IsUnknown() && !o.NdpProxy.IsNull() {
		if *obj != nil && (*obj).NdpProxy != nil {
			ndpProxy_entry = (*obj).NdpProxy
		} else {
			ndpProxy_entry = new(ethernet.Layer3NdpProxy)
		}
		var object *EthernetInterfaceDataSourceLayer3NdpProxyObject
		diags.Append(o.NdpProxy.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ndpProxy_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var pppoe_entry *ethernet.Layer3Pppoe
	if !o.Pppoe.IsUnknown() && !o.Pppoe.IsNull() {
		if *obj != nil && (*obj).Pppoe != nil {
			pppoe_entry = (*obj).Pppoe
		} else {
			pppoe_entry = new(ethernet.Layer3Pppoe)
		}
		var object *EthernetInterfaceDataSourceLayer3PppoeObject
		diags.Append(o.Pppoe.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pppoe_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_entry *ethernet.Layer3SdwanLinkSettings
	if !o.SdwanLinkSettings.IsUnknown() && !o.SdwanLinkSettings.IsNull() {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(ethernet.Layer3SdwanLinkSettings)
		}
		var object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject
		diags.Append(o.SdwanLinkSettings.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sdwanLinkSettings_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	trafficInterconnect_value := o.TrafficInterconnect.ValueBoolPointer()
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3)
	}
	(*obj).AdjustTcpMss = adjustTcpMss_entry
	(*obj).Arp = arp_pango_entries
	(*obj).Bonjour = bonjour_entry
	(*obj).ClusterInterconnect = clusterInterconnect_value
	(*obj).DdnsConfig = ddnsConfig_entry
	(*obj).DecryptForward = decryptForward_value
	(*obj).DfIgnore = dfIgnore_value
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).Ip = ips_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).Lldp = lldp_entry
	(*obj).Mtu = mtu_value
	(*obj).NdpProxy = ndpProxy_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).Pppoe = pppoe_entry
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).TrafficInterconnect = trafficInterconnect_value
	(*obj).UntaggedSubInterface = untaggedSubInterface_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3AdjustTcpMss, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3ArpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Arp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3BonjourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Bonjour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	groupId_value := o.GroupId.ValueInt64Pointer()
	ttlCheck_value := o.TtlCheck.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Bonjour)
	}
	(*obj).Enable = enable_value
	(*obj).GroupId = groupId_value
	(*obj).TtlCheck = ttlCheck_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DdnsConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DdnsConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ddnsCertProfile_value := o.DdnsCertProfile.ValueStringPointer()
	ddnsEnabled_value := o.DdnsEnabled.ValueBoolPointer()
	ddnsHostname_value := o.DdnsHostname.ValueStringPointer()
	var ddnsIp_pango_entries []string
	if !o.DdnsIp.IsUnknown() && !o.DdnsIp.IsNull() {
		object_entries := make([]types.String, 0, len(o.DdnsIp.Elements()))
		diags.Append(o.DdnsIp.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ddnsIp_pango_entries = append(ddnsIp_pango_entries, elt.ValueString())
		}
	}
	var ddnsIpv6_pango_entries []string
	if !o.DdnsIpv6.IsUnknown() && !o.DdnsIpv6.IsNull() {
		object_entries := make([]types.String, 0, len(o.DdnsIpv6.Elements()))
		diags.Append(o.DdnsIpv6.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ddnsIpv6_pango_entries = append(ddnsIpv6_pango_entries, elt.ValueString())
		}
	}
	ddnsUpdateInterval_value := o.DdnsUpdateInterval.ValueInt64Pointer()
	ddnsVendor_value := o.DdnsVendor.ValueStringPointer()
	var ddnsVendorConfig_tf_entries []EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
	var ddnsVendorConfig_pango_entries []ethernet.Layer3DdnsConfigDdnsVendorConfig
	{
		d := o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ddnsVendorConfig_tf_entries {
			var entry *ethernet.Layer3DdnsConfigDdnsVendorConfig
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ddnsVendorConfig_pango_entries = append(ddnsVendorConfig_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DdnsConfig)
	}
	(*obj).DdnsCertProfile = ddnsCertProfile_value
	(*obj).DdnsEnabled = ddnsEnabled_value
	(*obj).DdnsHostname = ddnsHostname_value
	(*obj).DdnsIp = ddnsIp_pango_entries
	(*obj).DdnsIpv6 = ddnsIpv6_pango_entries
	(*obj).DdnsUpdateInterval = ddnsUpdateInterval_value
	(*obj).DdnsVendor = ddnsVendor_value
	(*obj).DdnsVendorConfig = ddnsVendorConfig_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DdnsConfigDdnsVendorConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DdnsConfigDdnsVendorConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var sendHostname_entry *ethernet.Layer3DhcpClientSendHostname
	if !o.SendHostname.IsUnknown() && !o.SendHostname.IsNull() {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(ethernet.Layer3DhcpClientSendHostname)
		}
		var object *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject
		diags.Append(o.SendHostname.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendHostname_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClient)
	}
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DhcpClientSendHostname, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3IpsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ip)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6AddressesObject
	var addresses_pango_entries []ethernet.Layer3Ipv6Address
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3Ipv6Address
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}
	var dhcpClient_entry *ethernet.Layer3Ipv6DhcpClient
	if !o.DhcpClient.IsUnknown() && !o.DhcpClient.IsNull() {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3Ipv6DhcpClient)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject
		diags.Append(o.DhcpClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()
	var inherited_entry *ethernet.Layer3Ipv6Inherited
	if !o.Inherited.IsUnknown() && !o.Inherited.IsNull() {
		if *obj != nil && (*obj).Inherited != nil {
			inherited_entry = (*obj).Inherited
		} else {
			inherited_entry = new(ethernet.Layer3Ipv6Inherited)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject
		diags.Append(o.Inherited.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inherited_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6NeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6NeighborDiscovery)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6)
	}
	(*obj).Address = addresses_pango_entries
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).Enabled = enabled_value
	(*obj).Inherited = inherited_entry
	(*obj).InterfaceId = interfaceId_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	var prefix_entry *ethernet.Layer3Ipv6AddressPrefix
	if !o.Prefix.IsUnknown() && !o.Prefix.IsNull() {
		if *obj != nil && (*obj).Prefix != nil {
			prefix_entry = (*obj).Prefix
		} else {
			prefix_entry = new(ethernet.Layer3Ipv6AddressPrefix)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject
		diags.Append(o.Prefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &prefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_entry *ethernet.Layer3Ipv6AddressAnycast
	if !o.Anycast.IsUnknown() && !o.Anycast.IsNull() {
		if *obj != nil && (*obj).Anycast != nil {
			anycast_entry = (*obj).Anycast
		} else {
			anycast_entry = new(ethernet.Layer3Ipv6AddressAnycast)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject
		diags.Append(o.Anycast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &anycast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *ethernet.Layer3Ipv6AddressAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6AddressAdvertise)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Address)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_entry
	(*obj).Anycast = anycast_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressPrefix)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressAnycast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressAnycast)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptRaRoute_value := o.AcceptRaRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscovery)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	preference_value := o.Preference.ValueStringPointer()
	var prefixDelegation_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegation
	if !o.PrefixDelegation.IsUnknown() && !o.PrefixDelegation.IsNull() {
		if *obj != nil && (*obj).PrefixDelegation != nil {
			prefixDelegation_entry = (*obj).PrefixDelegation
		} else {
			prefixDelegation_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegation)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject
		diags.Append(o.PrefixDelegation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &prefixDelegation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_entry *ethernet.Layer3Ipv6DhcpClientV6Options
	if !o.V6Options.IsUnknown() && !o.V6Options.IsNull() {
		if *obj != nil && (*obj).V6Options != nil {
			v6Options_entry = (*obj).V6Options
		} else {
			v6Options_entry = new(ethernet.Layer3Ipv6DhcpClientV6Options)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject
		diags.Append(o.V6Options.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &v6Options_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClient)
	}
	(*obj).AcceptRaRoute = acceptRaRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).Preference = preference_value
	(*obj).PrefixDelegation = prefixDelegation_entry
	(*obj).V6Options = v6Options_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
		diags.Append(o.DnsServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
		diags.Append(o.DnsSuffix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSuffix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable
	if !o.Enable.IsUnknown() && !o.Enable.IsNull() {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
		diags.Append(o.Enable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &enable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegation)
	}
	(*obj).Enable = enable_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	pfxPoolName_value := o.PfxPoolName.ValueStringPointer()
	prefixLen_value := o.PrefixLen.ValueInt64Pointer()
	prefixLenHint_value := o.PrefixLenHint.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
	}
	(*obj).PfxPoolName = pfxPoolName_value
	(*obj).PrefixLen = prefixLen_value
	(*obj).PrefixLenHint = prefixLenHint_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6Options, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	duidType_value := o.DuidType.ValueStringPointer()
	var enable_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnable
	if !o.Enable.IsUnknown() && !o.Enable.IsNull() {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnable)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject
		diags.Append(o.Enable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &enable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rapidCommit_value := o.RapidCommit.ValueBoolPointer()
	supportSrvrReconfig_value := o.SupportSrvrReconfig.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6Options)
	}
	(*obj).DuidType = duidType_value
	(*obj).Enable = enable_entry
	(*obj).RapidCommit = rapidCommit_value
	(*obj).SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	nonTempAddr_value := o.NonTempAddr.ValueBoolPointer()
	tempAddr_value := o.TempAddr.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes)
	}
	(*obj).NonTempAddr = nonTempAddr_value
	(*obj).TempAddr = tempAddr_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6Inherited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject
	var assignAddr_pango_entries []ethernet.Layer3Ipv6InheritedAssignAddr
	{
		d := o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range assignAddr_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedAssignAddr
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			assignAddr_pango_entries = append(assignAddr_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6InheritedNeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscovery)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Inherited)
	}
	(*obj).AssignAddr = assignAddr_pango_entries
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *ethernet.Layer3Ipv6InheritedAssignAddrType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrType)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddr)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGua
	if !o.Gua.IsUnknown() && !o.Gua.IsNull() {
		if *obj != nil && (*obj).Gua != nil {
			gua_entry = (*obj).Gua
		} else {
			gua_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGua)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
		diags.Append(o.Gua.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gua_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeUla
	if !o.Ula.IsUnknown() && !o.Ula.IsNull() {
		if *obj != nil && (*obj).Ula != nil {
			ula_entry = (*obj).Ula
		} else {
			ula_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUla)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
		diags.Append(o.Ula.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ula_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrType)
	}
	(*obj).Gua = gua_entry
	(*obj).Ula = ula_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGua, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefixPool_value := o.PrefixPool.ValueStringPointer()
	var poolType_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType
	if !o.PoolType.IsUnknown() && !o.PoolType.IsNull() {
		if *obj != nil && (*obj).PoolType != nil {
			poolType_entry = (*obj).PoolType
		} else {
			poolType_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
		diags.Append(o.PoolType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &poolType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGua)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).PrefixPool = prefixPool_value
	(*obj).PoolType = poolType_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId
	if !o.DynamicId.IsUnknown() && !o.DynamicId.IsNull() {
		if *obj != nil && (*obj).DynamicId != nil {
			dynamicId_entry = (*obj).DynamicId
		} else {
			dynamicId_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
		diags.Append(o.DynamicId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamicId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).DynamicId = dynamicId_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	identifier_value := o.Identifier.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
	}
	(*obj).Identifier = identifier_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeUla, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	addresses_value := o.Addresses.ValueStringPointer()
	prefix_value := o.Prefix.ValueBoolPointer()
	anycast_value := o.Anycast.ValueBoolPointer()
	var advertise_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUla)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Address = addresses_value
	(*obj).Prefix = prefix_value
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
		diags.Append(o.DnsServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
		diags.Append(o.DnsSuffix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSuffix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement
	if !o.RouterAdvertisement.IsUnknown() && !o.RouterAdvertisement.IsNull() {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
		diags.Append(o.RouterAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routerAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
	}
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if !o.RouterAdvertisement.IsUnknown() && !o.RouterAdvertisement.IsNull() {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
		diags.Append(o.RouterAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routerAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport
	if !o.DnsSupport.IsUnknown() && !o.DnsSupport.IsNull() {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
		}
		var object *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
		diags.Append(o.DnsSupport.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSupport_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
	var server_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3LldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.Layer3LldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.Layer3LldpHighAvailability)
		}
		var object *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3NdpProxyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3NdpProxy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_tf_entries []EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject
	var addresses_pango_entries []ethernet.Layer3NdpProxyAddress
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3NdpProxyAddress
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3NdpProxy)
	}
	(*obj).Address = addresses_pango_entries
	(*obj).Enabled = enabled_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3NdpProxyAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3NdpProxyAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3PppoeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Pppoe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessConcentrator_value := o.AccessConcentrator.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var passive_entry *ethernet.Layer3PppoePassive
	if !o.Passive.IsUnknown() && !o.Passive.IsNull() {
		if *obj != nil && (*obj).Passive != nil {
			passive_entry = (*obj).Passive
		} else {
			passive_entry = new(ethernet.Layer3PppoePassive)
		}
		var object *EthernetInterfaceDataSourceLayer3PppoePassiveObject
		diags.Append(o.Passive.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &passive_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	password_value := o.Password.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	var staticAddress_entry *ethernet.Layer3PppoeStaticAddress
	if !o.StaticAddress.IsUnknown() && !o.StaticAddress.IsNull() {
		if *obj != nil && (*obj).StaticAddress != nil {
			staticAddress_entry = (*obj).StaticAddress
		} else {
			staticAddress_entry = new(ethernet.Layer3PppoeStaticAddress)
		}
		var object *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject
		diags.Append(o.StaticAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Pppoe)
	}
	(*obj).AccessConcentrator = accessConcentrator_value
	(*obj).Authentication = authentication_value
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).Passive = passive_entry
	(*obj).Password = password_value
	(*obj).Service = service_value
	(*obj).StaticAddress = staticAddress_entry
	(*obj).Username = username_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3PppoePassiveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3PppoePassive, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3PppoePassive)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3PppoeStaticAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ips_value := o.Ips.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3PppoeStaticAddress)
	}
	(*obj).Ip = ips_value

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNat
	if !o.UpstreamNat.IsUnknown() && !o.UpstreamNat.IsNull() {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
		}
		var object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject
		diags.Append(o.UpstreamNat.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &upstreamNat_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettings)
	}
	(*obj).Enable = enable_value
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNat, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var ddns_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns
	if !o.Ddns.IsUnknown() && !o.Ddns.IsNull() {
		if *obj != nil && (*obj).Ddns != nil {
			ddns_entry = (*obj).Ddns
		} else {
			ddns_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns)
		}
		var object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
		diags.Append(o.Ddns.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ddns_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp
	if !o.StaticIp.IsUnknown() && !o.StaticIp.IsNull() {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
		}
		var object *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
		diags.Append(o.StaticIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).Ddns = ddns_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns)
	}

	return diags
}
func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	fqdn_value := o.Fqdn.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
	}
	(*obj).Fqdn = fqdn_value
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *EthernetInterfaceDataSourceLogCardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.LogCard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultGateway_value := o.DefaultGateway.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	ipv6DefaultGateway_value := o.Ipv6DefaultGateway.ValueStringPointer()
	netmask_value := o.Netmask.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.LogCard)
	}
	(*obj).DefaultGateway = defaultGateway_value
	(*obj).IpAddress = ipAddress_value
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Ipv6DefaultGateway = ipv6DefaultGateway_value
	(*obj).Netmask = netmask_value

	return diags
}
func (o *EthernetInterfaceDataSourceTapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Tap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Tap)
	}
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceDataSourceVirtualWireObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *ethernet.VirtualWireLacp
	if !o.Lacp.IsUnknown() && !o.Lacp.IsNull() {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(ethernet.VirtualWireLacp)
		}
		var object *EthernetInterfaceDataSourceVirtualWireLacpObject
		diags.Append(o.Lacp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lacp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *ethernet.VirtualWireLldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.VirtualWireLldp)
		}
		var object *EthernetInterfaceDataSourceVirtualWireLldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWire)
	}
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceDataSourceVirtualWireLacpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_entry *ethernet.VirtualWireLacpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.VirtualWireLacpHighAvailability)
		}
		var object *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLacp)
	}
	(*obj).HighAvailability = highAvailability_entry

	return diags
}
func (o *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLacpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceDataSourceVirtualWireLldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.VirtualWireLldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.VirtualWireLldpHighAvailability)
		}
		var object *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lacp_obj *EthernetInterfaceDataSourceLacpObject
	if o.Lacp.IsNull() {
		lacp_obj = new(EthernetInterfaceDataSourceLacpObject)
	} else {
		diags.Append(o.Lacp.As(ctx, &lacp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lacp_object := types.ObjectNull(lacp_obj.AttributeTypes())
	if obj.Lacp != nil {
		diags.Append(lacp_obj.CopyFromPango(ctx, client, ancestors, obj.Lacp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lacp_object, diags_tmp = types.ObjectValueFrom(ctx, lacp_obj.AttributeTypes(), lacp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var poe_obj *EthernetInterfaceDataSourcePoeObject
	if o.Poe.IsNull() {
		poe_obj = new(EthernetInterfaceDataSourcePoeObject)
	} else {
		diags.Append(o.Poe.As(ctx, &poe_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	poe_object := types.ObjectNull(poe_obj.AttributeTypes())
	if obj.Poe != nil {
		diags.Append(poe_obj.CopyFromPango(ctx, client, ancestors, obj.Poe, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		poe_object, diags_tmp = types.ObjectValueFrom(ctx, poe_obj.AttributeTypes(), poe_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var decryptMirror_obj *EthernetInterfaceDataSourceDecryptMirrorObject
	if o.DecryptMirror.IsNull() {
		decryptMirror_obj = new(EthernetInterfaceDataSourceDecryptMirrorObject)
	} else {
		diags.Append(o.DecryptMirror.As(ctx, &decryptMirror_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	decryptMirror_object := types.ObjectNull(decryptMirror_obj.AttributeTypes())
	if obj.DecryptMirror != nil {
		diags.Append(decryptMirror_obj.CopyFromPango(ctx, client, ancestors, obj.DecryptMirror, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		decryptMirror_object, diags_tmp = types.ObjectValueFrom(ctx, decryptMirror_obj.AttributeTypes(), decryptMirror_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ha_obj *EthernetInterfaceDataSourceHaObject
	if o.Ha.IsNull() {
		ha_obj = new(EthernetInterfaceDataSourceHaObject)
	} else {
		diags.Append(o.Ha.As(ctx, &ha_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ha_object := types.ObjectNull(ha_obj.AttributeTypes())
	if obj.Ha != nil {
		diags.Append(ha_obj.CopyFromPango(ctx, client, ancestors, obj.Ha, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ha_object, diags_tmp = types.ObjectValueFrom(ctx, ha_obj.AttributeTypes(), ha_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var layer2_obj *EthernetInterfaceDataSourceLayer2Object
	if o.Layer2.IsNull() {
		layer2_obj = new(EthernetInterfaceDataSourceLayer2Object)
	} else {
		diags.Append(o.Layer2.As(ctx, &layer2_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	layer2_object := types.ObjectNull(layer2_obj.AttributeTypes())
	if obj.Layer2 != nil {
		diags.Append(layer2_obj.CopyFromPango(ctx, client, ancestors, obj.Layer2, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		layer2_object, diags_tmp = types.ObjectValueFrom(ctx, layer2_obj.AttributeTypes(), layer2_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var layer3_obj *EthernetInterfaceDataSourceLayer3Object
	if o.Layer3.IsNull() {
		layer3_obj = new(EthernetInterfaceDataSourceLayer3Object)
	} else {
		diags.Append(o.Layer3.As(ctx, &layer3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	layer3_object := types.ObjectNull(layer3_obj.AttributeTypes())
	if obj.Layer3 != nil {
		diags.Append(layer3_obj.CopyFromPango(ctx, client, ancestors, obj.Layer3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		layer3_object, diags_tmp = types.ObjectValueFrom(ctx, layer3_obj.AttributeTypes(), layer3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var logCard_obj *EthernetInterfaceDataSourceLogCardObject
	if o.LogCard.IsNull() {
		logCard_obj = new(EthernetInterfaceDataSourceLogCardObject)
	} else {
		diags.Append(o.LogCard.As(ctx, &logCard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	logCard_object := types.ObjectNull(logCard_obj.AttributeTypes())
	if obj.LogCard != nil {
		diags.Append(logCard_obj.CopyFromPango(ctx, client, ancestors, obj.LogCard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		logCard_object, diags_tmp = types.ObjectValueFrom(ctx, logCard_obj.AttributeTypes(), logCard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tap_obj *EthernetInterfaceDataSourceTapObject
	if o.Tap.IsNull() {
		tap_obj = new(EthernetInterfaceDataSourceTapObject)
	} else {
		diags.Append(o.Tap.As(ctx, &tap_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tap_object := types.ObjectNull(tap_obj.AttributeTypes())
	if obj.Tap != nil {
		diags.Append(tap_obj.CopyFromPango(ctx, client, ancestors, obj.Tap, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tap_object, diags_tmp = types.ObjectValueFrom(ctx, tap_obj.AttributeTypes(), tap_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var virtualWire_obj *EthernetInterfaceDataSourceVirtualWireObject
	if o.VirtualWire.IsNull() {
		virtualWire_obj = new(EthernetInterfaceDataSourceVirtualWireObject)
	} else {
		diags.Append(o.VirtualWire.As(ctx, &virtualWire_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	virtualWire_object := types.ObjectNull(virtualWire_obj.AttributeTypes())
	if obj.VirtualWire != nil {
		diags.Append(virtualWire_obj.CopyFromPango(ctx, client, ancestors, obj.VirtualWire, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		virtualWire_object, diags_tmp = types.ObjectValueFrom(ctx, virtualWire_obj.AttributeTypes(), virtualWire_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var linkDuplex_value types.String
	if obj.LinkDuplex != nil {
		linkDuplex_value = types.StringValue(*obj.LinkDuplex)
	}
	var linkSpeed_value types.String
	if obj.LinkSpeed != nil {
		linkSpeed_value = types.StringValue(*obj.LinkSpeed)
	}
	var linkState_value types.String
	if obj.LinkState != nil {
		linkState_value = types.StringValue(*obj.LinkState)
	}
	var aggregateGroup_value types.String
	if obj.AggregateGroup != nil {
		aggregateGroup_value = types.StringValue(*obj.AggregateGroup)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.Lacp = lacp_object
	o.LinkDuplex = linkDuplex_value
	o.LinkSpeed = linkSpeed_value
	o.LinkState = linkState_value
	o.Poe = poe_object
	o.AggregateGroup = aggregateGroup_value
	o.DecryptMirror = decryptMirror_object
	o.Ha = ha_object
	o.Layer2 = layer2_object
	o.Layer3 = layer3_object
	o.LogCard = logCard_object
	o.Tap = tap_object
	o.VirtualWire = virtualWire_object

	return diags
}

func (o *EthernetInterfaceDataSourceLacpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Lacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var portPriority_value types.Int64
	if obj.PortPriority != nil {
		portPriority_value = types.Int64Value(*obj.PortPriority)
	}
	o.PortPriority = portPriority_value

	return diags
}

func (o *EthernetInterfaceDataSourcePoeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Poe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enabled_value types.Bool
	if obj.PoeEnabled != nil {
		enabled_value = types.BoolValue(*obj.PoeEnabled)
	}
	var poeReservedPower_value types.Int64
	if obj.PoeRsvdPwr != nil {
		poeReservedPower_value = types.Int64Value(*obj.PoeRsvdPwr)
	}
	o.Enabled = enabled_value
	o.PoeReservedPower = poeReservedPower_value

	return diags
}

func (o *EthernetInterfaceDataSourceDecryptMirrorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.DecryptMirror, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceHaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Ha, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer2Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lldp_obj *EthernetInterfaceDataSourceLayer2LldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceDataSourceLayer2LldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer2LldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_list types.List
	{
		var arp_tf_entries []EthernetInterfaceDataSourceLayer3ArpObject
		if !o.Arp.IsNull() {
			diags.Append(o.Arp.ElementsAs(ctx, &arp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Arp {
			entry := EthernetInterfaceDataSourceLayer3ArpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(arp_tf_entries) {
				entry = arp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(arp_tf_entries) {
				arp_tf_entries[idx] = entry
			} else {
				arp_tf_entries = append(arp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ips_list types.List
	{
		var ips_tf_entries []EthernetInterfaceDataSourceLayer3IpsObject
		if !o.Ips.IsNull() {
			diags.Append(o.Ips.ElementsAs(ctx, &ips_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Ip {
			entry := EthernetInterfaceDataSourceLayer3IpsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ips_tf_entries) {
				entry = ips_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ips_tf_entries) {
				ips_tf_entries[idx] = entry
			} else {
				ips_tf_entries = append(ips_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ips")
		ips_list, list_diags = types.ListValueFrom(ctx, schemaType, ips_tf_entries)
		diags.Append(list_diags...)
	}

	var adjustTcpMss_obj *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject
	if o.AdjustTcpMss.IsNull() {
		adjustTcpMss_obj = new(EthernetInterfaceDataSourceLayer3AdjustTcpMssObject)
	} else {
		diags.Append(o.AdjustTcpMss.As(ctx, &adjustTcpMss_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	adjustTcpMss_object := types.ObjectNull(adjustTcpMss_obj.AttributeTypes())
	if obj.AdjustTcpMss != nil {
		diags.Append(adjustTcpMss_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdjustTcpMss, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		adjustTcpMss_object, diags_tmp = types.ObjectValueFrom(ctx, adjustTcpMss_obj.AttributeTypes(), adjustTcpMss_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bonjour_obj *EthernetInterfaceDataSourceLayer3BonjourObject
	if o.Bonjour.IsNull() {
		bonjour_obj = new(EthernetInterfaceDataSourceLayer3BonjourObject)
	} else {
		diags.Append(o.Bonjour.As(ctx, &bonjour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bonjour_object := types.ObjectNull(bonjour_obj.AttributeTypes())
	if obj.Bonjour != nil {
		diags.Append(bonjour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bonjour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bonjour_object, diags_tmp = types.ObjectValueFrom(ctx, bonjour_obj.AttributeTypes(), bonjour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ddnsConfig_obj *EthernetInterfaceDataSourceLayer3DdnsConfigObject
	if o.DdnsConfig.IsNull() {
		ddnsConfig_obj = new(EthernetInterfaceDataSourceLayer3DdnsConfigObject)
	} else {
		diags.Append(o.DdnsConfig.As(ctx, &ddnsConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ddnsConfig_object := types.ObjectNull(ddnsConfig_obj.AttributeTypes())
	if obj.DdnsConfig != nil {
		diags.Append(ddnsConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DdnsConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ddnsConfig_object, diags_tmp = types.ObjectValueFrom(ctx, ddnsConfig_obj.AttributeTypes(), ddnsConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dhcpClient_obj *EthernetInterfaceDataSourceLayer3DhcpClientObject
	if o.DhcpClient.IsNull() {
		dhcpClient_obj = new(EthernetInterfaceDataSourceLayer3DhcpClientObject)
	} else {
		diags.Append(o.DhcpClient.As(ctx, &dhcpClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpClient_object := types.ObjectNull(dhcpClient_obj.AttributeTypes())
	if obj.DhcpClient != nil {
		diags.Append(dhcpClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DhcpClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpClient_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpClient_obj.AttributeTypes(), dhcpClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *EthernetInterfaceDataSourceLayer3Ipv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(EthernetInterfaceDataSourceLayer3Ipv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var lldp_obj *EthernetInterfaceDataSourceLayer3LldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceDataSourceLayer3LldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ndpProxy_obj *EthernetInterfaceDataSourceLayer3NdpProxyObject
	if o.NdpProxy.IsNull() {
		ndpProxy_obj = new(EthernetInterfaceDataSourceLayer3NdpProxyObject)
	} else {
		diags.Append(o.NdpProxy.As(ctx, &ndpProxy_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ndpProxy_object := types.ObjectNull(ndpProxy_obj.AttributeTypes())
	if obj.NdpProxy != nil {
		diags.Append(ndpProxy_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NdpProxy, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ndpProxy_object, diags_tmp = types.ObjectValueFrom(ctx, ndpProxy_obj.AttributeTypes(), ndpProxy_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pppoe_obj *EthernetInterfaceDataSourceLayer3PppoeObject
	if o.Pppoe.IsNull() {
		pppoe_obj = new(EthernetInterfaceDataSourceLayer3PppoeObject)
	} else {
		diags.Append(o.Pppoe.As(ctx, &pppoe_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pppoe_object := types.ObjectNull(pppoe_obj.AttributeTypes())
	if obj.Pppoe != nil {
		diags.Append(pppoe_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pppoe, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pppoe_object, diags_tmp = types.ObjectValueFrom(ctx, pppoe_obj.AttributeTypes(), pppoe_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sdwanLinkSettings_obj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject
	if o.SdwanLinkSettings.IsNull() {
		sdwanLinkSettings_obj = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject)
	} else {
		diags.Append(o.SdwanLinkSettings.As(ctx, &sdwanLinkSettings_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sdwanLinkSettings_object := types.ObjectNull(sdwanLinkSettings_obj.AttributeTypes())
	if obj.SdwanLinkSettings != nil {
		diags.Append(sdwanLinkSettings_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SdwanLinkSettings, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sdwanLinkSettings_object, diags_tmp = types.ObjectValueFrom(ctx, sdwanLinkSettings_obj.AttributeTypes(), sdwanLinkSettings_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clusterInterconnect_value types.Bool
	if obj.ClusterInterconnect != nil {
		clusterInterconnect_value = types.BoolValue(*obj.ClusterInterconnect)
	}
	var decryptForward_value types.Bool
	if obj.DecryptForward != nil {
		decryptForward_value = types.BoolValue(*obj.DecryptForward)
	}
	var dfIgnore_value types.Bool
	if obj.DfIgnore != nil {
		dfIgnore_value = types.BoolValue(*obj.DfIgnore)
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var trafficInterconnect_value types.Bool
	if obj.TrafficInterconnect != nil {
		trafficInterconnect_value = types.BoolValue(*obj.TrafficInterconnect)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	o.AdjustTcpMss = adjustTcpMss_object
	o.Arp = arp_list
	o.Bonjour = bonjour_object
	o.ClusterInterconnect = clusterInterconnect_value
	o.DdnsConfig = ddnsConfig_object
	o.DecryptForward = decryptForward_value
	o.DfIgnore = dfIgnore_value
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Ips = ips_list
	o.Ipv6 = ipv6_object
	o.Lldp = lldp_object
	o.Mtu = mtu_value
	o.NdpProxy = ndpProxy_object
	o.NetflowProfile = netflowProfile_value
	o.Pppoe = pppoe_object
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.TrafficInterconnect = trafficInterconnect_value
	o.UntaggedSubInterface = untaggedSubInterface_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3AdjustTcpMss, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3ArpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Arp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3BonjourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Bonjour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var groupId_value types.Int64
	if obj.GroupId != nil {
		groupId_value = types.Int64Value(*obj.GroupId)
	}
	var ttlCheck_value types.Bool
	if obj.TtlCheck != nil {
		ttlCheck_value = types.BoolValue(*obj.TtlCheck)
	}
	o.Enable = enable_value
	o.GroupId = groupId_value
	o.TtlCheck = ttlCheck_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DdnsConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DdnsConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddnsIp_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DdnsIp.IsNull() || len(obj.DdnsIp) > 0 {
			entries = obj.DdnsIp
		}

		ddnsIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsIpv6_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DdnsIpv6.IsNull() || len(obj.DdnsIpv6) > 0 {
			entries = obj.DdnsIpv6
		}

		ddnsIpv6_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsVendorConfig_list types.List
	{
		var ddnsVendorConfig_tf_entries []EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject
		if !o.DdnsVendorConfig.IsNull() {
			diags.Append(o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.DdnsVendorConfig {
			entry := EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ddnsVendorConfig_tf_entries) {
				entry = ddnsVendorConfig_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ddnsVendorConfig_tf_entries) {
				ddnsVendorConfig_tf_entries[idx] = entry
			} else {
				ddnsVendorConfig_tf_entries = append(ddnsVendorConfig_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ddns_vendor_config")
		ddnsVendorConfig_list, list_diags = types.ListValueFrom(ctx, schemaType, ddnsVendorConfig_tf_entries)
		diags.Append(list_diags...)
	}

	var ddnsCertProfile_value types.String
	if obj.DdnsCertProfile != nil {
		ddnsCertProfile_value = types.StringValue(*obj.DdnsCertProfile)
	}
	var ddnsEnabled_value types.Bool
	if obj.DdnsEnabled != nil {
		ddnsEnabled_value = types.BoolValue(*obj.DdnsEnabled)
	}
	var ddnsHostname_value types.String
	if obj.DdnsHostname != nil {
		ddnsHostname_value = types.StringValue(*obj.DdnsHostname)
	}
	var ddnsUpdateInterval_value types.Int64
	if obj.DdnsUpdateInterval != nil {
		ddnsUpdateInterval_value = types.Int64Value(*obj.DdnsUpdateInterval)
	}
	var ddnsVendor_value types.String
	if obj.DdnsVendor != nil {
		ddnsVendor_value = types.StringValue(*obj.DdnsVendor)
	}
	o.DdnsCertProfile = ddnsCertProfile_value
	o.DdnsEnabled = ddnsEnabled_value
	o.DdnsHostname = ddnsHostname_value
	o.DdnsIp = ddnsIp_list
	o.DdnsIpv6 = ddnsIpv6_list
	o.DdnsUpdateInterval = ddnsUpdateInterval_value
	o.DdnsVendor = ddnsVendor_value
	o.DdnsVendorConfig = ddnsVendorConfig_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DdnsConfigDdnsVendorConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sendHostname_obj *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject
	if o.SendHostname.IsNull() {
		sendHostname_obj = new(EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject)
	} else {
		diags.Append(o.SendHostname.As(ctx, &sendHostname_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendHostname_object := types.ObjectNull(sendHostname_obj.AttributeTypes())
	if obj.SendHostname != nil {
		diags.Append(sendHostname_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendHostname, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendHostname_object, diags_tmp = types.ObjectValueFrom(ctx, sendHostname_obj.AttributeTypes(), sendHostname_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.SendHostname = sendHostname_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DhcpClientSendHostname, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3IpsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6AddressesObject
		if !o.Addresses.IsNull() {
			diags.Append(o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := EthernetInterfaceDataSourceLayer3Ipv6AddressesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addresses_tf_entries) {
				entry = addresses_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addresses_tf_entries) {
				addresses_tf_entries[idx] = entry
			} else {
				addresses_tf_entries = append(addresses_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}

	var dhcpClient_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject
	if o.DhcpClient.IsNull() {
		dhcpClient_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject)
	} else {
		diags.Append(o.DhcpClient.As(ctx, &dhcpClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpClient_object := types.ObjectNull(dhcpClient_obj.AttributeTypes())
	if obj.DhcpClient != nil {
		diags.Append(dhcpClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DhcpClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpClient_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpClient_obj.AttributeTypes(), dhcpClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inherited_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject
	if o.Inherited.IsNull() {
		inherited_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedObject)
	} else {
		diags.Append(o.Inherited.As(ctx, &inherited_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inherited_object := types.ObjectNull(inherited_obj.AttributeTypes())
	if obj.Inherited != nil {
		diags.Append(inherited_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Inherited, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inherited_object, diags_tmp = types.ObjectValueFrom(ctx, inherited_obj.AttributeTypes(), inherited_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborDiscovery_obj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Addresses = addresses_list
	o.DhcpClient = dhcpClient_object
	o.Enabled = enabled_value
	o.Inherited = inherited_object
	o.InterfaceId = interfaceId_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefix_obj *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject
	if o.Prefix.IsNull() {
		prefix_obj = new(EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject)
	} else {
		diags.Append(o.Prefix.As(ctx, &prefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	prefix_object := types.ObjectNull(prefix_obj.AttributeTypes())
	if obj.Prefix != nil {
		diags.Append(prefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Prefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		prefix_object, diags_tmp = types.ObjectValueFrom(ctx, prefix_obj.AttributeTypes(), prefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var anycast_obj *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject
	if o.Anycast.IsNull() {
		anycast_obj = new(EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject)
	} else {
		diags.Append(o.Anycast.As(ctx, &anycast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	anycast_object := types.ObjectNull(anycast_obj.AttributeTypes())
	if obj.Anycast != nil {
		diags.Append(anycast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Anycast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		anycast_object, diags_tmp = types.ObjectValueFrom(ctx, anycast_obj.AttributeTypes(), anycast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_object
	o.Anycast = anycast_object
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressAnycast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborDiscovery_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prefixDelegation_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject
	if o.PrefixDelegation.IsNull() {
		prefixDelegation_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject)
	} else {
		diags.Append(o.PrefixDelegation.As(ctx, &prefixDelegation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	prefixDelegation_object := types.ObjectNull(prefixDelegation_obj.AttributeTypes())
	if obj.PrefixDelegation != nil {
		diags.Append(prefixDelegation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PrefixDelegation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		prefixDelegation_object, diags_tmp = types.ObjectValueFrom(ctx, prefixDelegation_obj.AttributeTypes(), prefixDelegation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var v6Options_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject
	if o.V6Options.IsNull() {
		v6Options_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject)
	} else {
		diags.Append(o.V6Options.As(ctx, &v6Options_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	v6Options_object := types.ObjectNull(v6Options_obj.AttributeTypes())
	if obj.V6Options != nil {
		diags.Append(v6Options_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.V6Options, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		v6Options_object, diags_tmp = types.ObjectValueFrom(ctx, v6Options_obj.AttributeTypes(), v6Options_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptRaRoute_value types.Bool
	if obj.AcceptRaRoute != nil {
		acceptRaRoute_value = types.BoolValue(*obj.AcceptRaRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var preference_value types.String
	if obj.Preference != nil {
		preference_value = types.StringValue(*obj.Preference)
	}
	o.AcceptRaRoute = acceptRaRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.Preference = preference_value
	o.PrefixDelegation = prefixDelegation_object
	o.V6Options = v6Options_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var dnsServer_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
	if o.DnsServer.IsNull() {
		dnsServer_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject)
	} else {
		diags.Append(o.DnsServer.As(ctx, &dnsServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsServer_object := types.ObjectNull(dnsServer_obj.AttributeTypes())
	if obj.DnsServer != nil {
		diags.Append(dnsServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsServer_object, diags_tmp = types.ObjectValueFrom(ctx, dnsServer_obj.AttributeTypes(), dnsServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
	if o.DnsSuffix.IsNull() {
		dnsSuffix_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject)
	} else {
		diags.Append(o.DnsSuffix.As(ctx, &dnsSuffix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_object := types.ObjectNull(dnsSuffix_obj.AttributeTypes())
	if obj.DnsSuffix != nil {
		diags.Append(dnsSuffix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSuffix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSuffix_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSuffix_obj.AttributeTypes(), dnsSuffix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	if o.Enable.IsNull() {
		enable_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject)
	} else {
		diags.Append(o.Enable.As(ctx, &enable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	enable_object := types.ObjectNull(enable_obj.AttributeTypes())
	if obj.Enable != nil {
		diags.Append(enable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Enable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		enable_object, diags_tmp = types.ObjectValueFrom(ctx, enable_obj.AttributeTypes(), enable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Enable = enable_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
	if o.No.IsNull() {
		no_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	if o.Yes.IsNull() {
		yes_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var pfxPoolName_value types.String
	if obj.PfxPoolName != nil {
		pfxPoolName_value = types.StringValue(*obj.PfxPoolName)
	}
	var prefixLen_value types.Int64
	if obj.PrefixLen != nil {
		prefixLen_value = types.Int64Value(*obj.PrefixLen)
	}
	var prefixLenHint_value types.Bool
	if obj.PrefixLenHint != nil {
		prefixLenHint_value = types.BoolValue(*obj.PrefixLenHint)
	}
	o.PfxPoolName = pfxPoolName_value
	o.PrefixLen = prefixLen_value
	o.PrefixLenHint = prefixLenHint_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6Options, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject
	if o.Enable.IsNull() {
		enable_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject)
	} else {
		diags.Append(o.Enable.As(ctx, &enable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	enable_object := types.ObjectNull(enable_obj.AttributeTypes())
	if obj.Enable != nil {
		diags.Append(enable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Enable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		enable_object, diags_tmp = types.ObjectValueFrom(ctx, enable_obj.AttributeTypes(), enable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var duidType_value types.String
	if obj.DuidType != nil {
		duidType_value = types.StringValue(*obj.DuidType)
	}
	var rapidCommit_value types.Bool
	if obj.RapidCommit != nil {
		rapidCommit_value = types.BoolValue(*obj.RapidCommit)
	}
	var supportSrvrReconfig_value types.Bool
	if obj.SupportSrvrReconfig != nil {
		supportSrvrReconfig_value = types.BoolValue(*obj.SupportSrvrReconfig)
	}
	o.DuidType = duidType_value
	o.Enable = enable_object
	o.RapidCommit = rapidCommit_value
	o.SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
	if o.No.IsNull() {
		no_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	if o.Yes.IsNull() {
		yes_obj = new(EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nonTempAddr_value types.Bool
	if obj.NonTempAddr != nil {
		nonTempAddr_value = types.BoolValue(*obj.NonTempAddr)
	}
	var tempAddr_value types.Bool
	if obj.TempAddr != nil {
		tempAddr_value = types.BoolValue(*obj.TempAddr)
	}
	o.NonTempAddr = nonTempAddr_value
	o.TempAddr = tempAddr_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6Inherited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_list types.List
	{
		var assignAddr_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject
		if !o.AssignAddr.IsNull() {
			diags.Append(o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AssignAddr {
			entry := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(assignAddr_tf_entries) {
				entry = assignAddr_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(assignAddr_tf_entries) {
				assignAddr_tf_entries[idx] = entry
			} else {
				assignAddr_tf_entries = append(assignAddr_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("assign_addr")
		assignAddr_list, list_diags = types.ListValueFrom(ctx, schemaType, assignAddr_tf_entries)
		diags.Append(list_diags...)
	}

	var neighborDiscovery_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.AssignAddr = assignAddr_list
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject
	if o.Type.IsNull() {
		type_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var gua_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
	if o.Gua.IsNull() {
		gua_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject)
	} else {
		diags.Append(o.Gua.As(ctx, &gua_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gua_object := types.ObjectNull(gua_obj.AttributeTypes())
	if obj.Gua != nil {
		diags.Append(gua_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Gua, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gua_object, diags_tmp = types.ObjectValueFrom(ctx, gua_obj.AttributeTypes(), gua_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ula_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	if o.Ula.IsNull() {
		ula_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject)
	} else {
		diags.Append(o.Ula.As(ctx, &ula_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ula_object := types.ObjectNull(ula_obj.AttributeTypes())
	if obj.Ula != nil {
		diags.Append(ula_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ula, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ula_object, diags_tmp = types.ObjectValueFrom(ctx, ula_obj.AttributeTypes(), ula_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Gua = gua_object
	o.Ula = ula_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGua, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var poolType_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
	if o.PoolType.IsNull() {
		poolType_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject)
	} else {
		diags.Append(o.PoolType.As(ctx, &poolType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	poolType_object := types.ObjectNull(poolType_obj.AttributeTypes())
	if obj.PoolType != nil {
		diags.Append(poolType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PoolType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		poolType_object, diags_tmp = types.ObjectValueFrom(ctx, poolType_obj.AttributeTypes(), poolType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.PrefixPool = prefixPool_value
	o.PoolType = poolType_object
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dynamic_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dynamicId_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	if o.DynamicId.IsNull() {
		dynamicId_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject)
	} else {
		diags.Append(o.DynamicId.As(ctx, &dynamicId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamicId_object := types.ObjectNull(dynamicId_obj.AttributeTypes())
	if obj.DynamicId != nil {
		diags.Append(dynamicId_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DynamicId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamicId_object, diags_tmp = types.ObjectValueFrom(ctx, dynamicId_obj.AttributeTypes(), dynamicId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dynamic = dynamic_object
	o.DynamicId = dynamicId_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var identifier_value types.Int64
	if obj.Identifier != nil {
		identifier_value = types.Int64Value(*obj.Identifier)
	}
	o.Identifier = identifier_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeUla, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var addresses_value types.String
	if obj.Address != nil {
		addresses_value = types.StringValue(*obj.Address)
	}
	var prefix_value types.Bool
	if obj.Prefix != nil {
		prefix_value = types.BoolValue(*obj.Prefix)
	}
	var anycast_value types.Bool
	if obj.Anycast != nil {
		anycast_value = types.BoolValue(*obj.Anycast)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.Addresses = addresses_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var dnsServer_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
	if o.DnsServer.IsNull() {
		dnsServer_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject)
	} else {
		diags.Append(o.DnsServer.As(ctx, &dnsServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsServer_object := types.ObjectNull(dnsServer_obj.AttributeTypes())
	if obj.DnsServer != nil {
		diags.Append(dnsServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsServer_object, diags_tmp = types.ObjectValueFrom(ctx, dnsServer_obj.AttributeTypes(), dnsServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
	if o.DnsSuffix.IsNull() {
		dnsSuffix_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject)
	} else {
		diags.Append(o.DnsSuffix.As(ctx, &dnsSuffix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_object := types.ObjectNull(dnsSuffix_obj.AttributeTypes())
	if obj.DnsSuffix != nil {
		diags.Append(dnsSuffix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSuffix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSuffix_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSuffix_obj.AttributeTypes(), dnsSuffix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routerAdvertisement_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	if o.RouterAdvertisement.IsNull() {
		routerAdvertisement_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject)
	} else {
		diags.Append(o.RouterAdvertisement.As(ctx, &routerAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routerAdvertisement_object := types.ObjectNull(routerAdvertisement_obj.AttributeTypes())
	if obj.RouterAdvertisement != nil {
		diags.Append(routerAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouterAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routerAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, routerAdvertisement_obj.AttributeTypes(), routerAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var routerAdvertisement_obj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if o.RouterAdvertisement.IsNull() {
		routerAdvertisement_obj = new(EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)
	} else {
		diags.Append(o.RouterAdvertisement.As(ctx, &routerAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routerAdvertisement_object := types.ObjectNull(routerAdvertisement_obj.AttributeTypes())
	if obj.RouterAdvertisement != nil {
		diags.Append(routerAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouterAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routerAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, routerAdvertisement_obj.AttributeTypes(), routerAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dnsSupport_obj *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
	if o.DnsSupport.IsNull() {
		dnsSupport_obj = new(EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject)
	} else {
		diags.Append(o.DnsSupport.As(ctx, &dnsSupport_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSupport_object := types.ObjectNull(dnsSupport_obj.AttributeTypes())
	if obj.DnsSupport != nil {
		diags.Append(dnsSupport_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSupport, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSupport_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSupport_obj.AttributeTypes(), dnsSupport_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Server = server_list
	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3LldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3NdpProxyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3NdpProxy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject
		if !o.Addresses.IsNull() {
			diags.Append(o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addresses_tf_entries) {
				entry = addresses_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addresses_tf_entries) {
				addresses_tf_entries[idx] = entry
			} else {
				addresses_tf_entries = append(addresses_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Addresses = addresses_list
	o.Enabled = enabled_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3NdpProxyAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3PppoeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Pppoe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passive_obj *EthernetInterfaceDataSourceLayer3PppoePassiveObject
	if o.Passive.IsNull() {
		passive_obj = new(EthernetInterfaceDataSourceLayer3PppoePassiveObject)
	} else {
		diags.Append(o.Passive.As(ctx, &passive_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	passive_object := types.ObjectNull(passive_obj.AttributeTypes())
	if obj.Passive != nil {
		diags.Append(passive_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Passive, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		passive_object, diags_tmp = types.ObjectValueFrom(ctx, passive_obj.AttributeTypes(), passive_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticAddress_obj *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject
	if o.StaticAddress.IsNull() {
		staticAddress_obj = new(EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject)
	} else {
		diags.Append(o.StaticAddress.As(ctx, &staticAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticAddress_object := types.ObjectNull(staticAddress_obj.AttributeTypes())
	if obj.StaticAddress != nil {
		diags.Append(staticAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticAddress_object, diags_tmp = types.ObjectValueFrom(ctx, staticAddress_obj.AttributeTypes(), staticAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var accessConcentrator_value types.String
	if obj.AccessConcentrator != nil {
		accessConcentrator_value = types.StringValue(*obj.AccessConcentrator)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.AccessConcentrator = accessConcentrator_value
	o.Authentication = authentication_value
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.Passive = passive_object
	o.Password = password_value
	o.Service = service_value
	o.StaticAddress = staticAddress_object
	o.Username = username_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3PppoePassiveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3PppoePassive, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3PppoeStaticAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ips_value types.String
	if obj.Ip != nil {
		ips_value = types.StringValue(*obj.Ip)
	}
	o.Ips = ips_value

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var upstreamNat_obj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject
	if o.UpstreamNat.IsNull() {
		upstreamNat_obj = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject)
	} else {
		diags.Append(o.UpstreamNat.As(ctx, &upstreamNat_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	upstreamNat_object := types.ObjectNull(upstreamNat_obj.AttributeTypes())
	if obj.UpstreamNat != nil {
		diags.Append(upstreamNat_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.UpstreamNat, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		upstreamNat_object, diags_tmp = types.ObjectValueFrom(ctx, upstreamNat_obj.AttributeTypes(), upstreamNat_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNat, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ddns_obj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
	if o.Ddns.IsNull() {
		ddns_obj = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject)
	} else {
		diags.Append(o.Ddns.As(ctx, &ddns_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ddns_object := types.ObjectNull(ddns_obj.AttributeTypes())
	if obj.Ddns != nil {
		diags.Append(ddns_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ddns, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ddns_object, diags_tmp = types.ObjectValueFrom(ctx, ddns_obj.AttributeTypes(), ddns_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticIp_obj *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	if o.StaticIp.IsNull() {
		staticIp_obj = new(EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject)
	} else {
		diags.Append(o.StaticIp.As(ctx, &staticIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticIp_object := types.ObjectNull(staticIp_obj.AttributeTypes())
	if obj.StaticIp != nil {
		diags.Append(staticIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticIp_object, diags_tmp = types.ObjectValueFrom(ctx, staticIp_obj.AttributeTypes(), staticIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Ddns = ddns_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.Fqdn = fqdn_value
	o.IpAddress = ipAddress_value

	return diags
}

func (o *EthernetInterfaceDataSourceLogCardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.LogCard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultGateway_value types.String
	if obj.DefaultGateway != nil {
		defaultGateway_value = types.StringValue(*obj.DefaultGateway)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var ipv6DefaultGateway_value types.String
	if obj.Ipv6DefaultGateway != nil {
		ipv6DefaultGateway_value = types.StringValue(*obj.Ipv6DefaultGateway)
	}
	var netmask_value types.String
	if obj.Netmask != nil {
		netmask_value = types.StringValue(*obj.Netmask)
	}
	o.DefaultGateway = defaultGateway_value
	o.IpAddress = ipAddress_value
	o.Ipv6Address = ipv6Address_value
	o.Ipv6DefaultGateway = ipv6DefaultGateway_value
	o.Netmask = netmask_value

	return diags
}

func (o *EthernetInterfaceDataSourceTapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Tap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceDataSourceVirtualWireObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lacp_obj *EthernetInterfaceDataSourceVirtualWireLacpObject
	if o.Lacp.IsNull() {
		lacp_obj = new(EthernetInterfaceDataSourceVirtualWireLacpObject)
	} else {
		diags.Append(o.Lacp.As(ctx, &lacp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lacp_object := types.ObjectNull(lacp_obj.AttributeTypes())
	if obj.Lacp != nil {
		diags.Append(lacp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lacp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lacp_object, diags_tmp = types.ObjectValueFrom(ctx, lacp_obj.AttributeTypes(), lacp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var lldp_obj *EthernetInterfaceDataSourceVirtualWireLldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceDataSourceVirtualWireLldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceDataSourceVirtualWireLacpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.HighAvailability = highAvailability_object

	return diags
}

func (o *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLacpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceDataSourceVirtualWireLldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func EthernetInterfaceDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": EthernetInterfaceDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lacp": EthernetInterfaceDataSourceLacpSchema(),

			"link_duplex": dsschema.StringAttribute{
				Description: "Interface link duplex",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_speed": dsschema.StringAttribute{
				Description: "Interface link speed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_state": dsschema.StringAttribute{
				Description: "Interface link state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"poe": EthernetInterfaceDataSourcePoeSchema(),

			"aggregate_group": dsschema.StringAttribute{
				Description: "Aggregate interface group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"decrypt_mirror": EthernetInterfaceDataSourceDecryptMirrorSchema(),

			"ha": EthernetInterfaceDataSourceHaSchema(),

			"layer2": EthernetInterfaceDataSourceLayer2Schema(),

			"layer3": EthernetInterfaceDataSourceLayer3Schema(),

			"log_card": EthernetInterfaceDataSourceLogCardSchema(),

			"tap": EthernetInterfaceDataSourceTapSchema(),

			"virtual_wire": EthernetInterfaceDataSourceVirtualWireSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceModel) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLacpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"port_priority": dsschema.Int64Attribute{
				Description: "port priority in LACP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLacpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourcePoeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enabled": dsschema.BoolAttribute{
				Description: "PoE Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"poe_reserved_power": dsschema.Int64Attribute{
				Description: "Reserved Power",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourcePoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourcePoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceDecryptMirrorSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceDecryptMirrorObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceDecryptMirrorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceHaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceHaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer2Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lldp": EthernetInterfaceDataSourceLayer2LldpSchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer2Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer2LldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceDataSourceLayer2LldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer2LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer2LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer2LldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer2LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer2LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"adjust_tcp_mss": EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema(),

			"arp": dsschema.ListNestedAttribute{
				Description:  "ARP configuration",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3ArpSchema(),
			},

			"bonjour": EthernetInterfaceDataSourceLayer3BonjourSchema(),

			"cluster_interconnect": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_config": EthernetInterfaceDataSourceLayer3DdnsConfigSchema(),

			"decrypt_forward": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"df_ignore": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dhcp_client": EthernetInterfaceDataSourceLayer3DhcpClientSchema(),

			"interface_management_profile": dsschema.StringAttribute{
				Description: "Interface management profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ips": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3IpsSchema(),
			},

			"ipv6": EthernetInterfaceDataSourceLayer3Ipv6Schema(),

			"lldp": EthernetInterfaceDataSourceLayer3LldpSchema(),

			"mtu": dsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": EthernetInterfaceDataSourceLayer3NdpProxySchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pppoe": EthernetInterfaceDataSourceLayer3PppoeSchema(),

			"sdwan_link_settings": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema(),

			"traffic_interconnect": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"untagged_sub_interface": dsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Set if TCP MSS value should be reduced based on mtu",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": dsschema.Int64Attribute{
				Description: "IPv4 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_mss_adjustment": dsschema.Int64Attribute{
				Description: "IPv6 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3ArpSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3BonjourSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_id": dsschema.Int64Attribute{
				Description: "default 0: NO-Group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ttl_check": dsschema.BoolAttribute{
				Description: "Set to check and update TTL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DdnsConfigSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ddns_cert_profile": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_enabled": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_hostname": dsschema.StringAttribute{
				Description: "ddns hostname variable or real address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_ip": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_ipv6": dsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_update_interval": dsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor": dsschema.StringAttribute{
				Description: "Vendor and product type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor_config": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DdnsConfigObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DdnsConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DdnsConfigDdnsVendorConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DhcpClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"create_default_route": dsschema.BoolAttribute{
				Description: "Automatically create default route pointing to default gateway provided by server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_hostname": EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": dsschema.StringAttribute{
				Description: "Set Interface Hostname",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3IpsSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": dsschema.StringAttribute{
				Description: "Gateway IPv4 Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3IpsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3IpsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"addresses": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema(),
			},

			"dhcp_client": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientSchema(),

			"enabled": dsschema.BoolAttribute{
				Description: "Enable IPv6 on the interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherited": EthernetInterfaceDataSourceLayer3Ipv6InheritedSchema(),

			"interface_id": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixSchema(),

			"anycast": EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastSchema(),

			"advertise": EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesAnycastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": dsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred_lifetime": dsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6AddressesAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"accept_ra_route": dsschema.BoolAttribute{
				Description: "Accept Router Advertised Default Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable DHCPv6 Client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema(),

			"preference": dsschema.StringAttribute{
				Description: "Select Low/Medium/High",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_delegation": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema(),

			"v6_options": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_server": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema(),

			"yes": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"pfx_pool_name": dsschema.StringAttribute{
				Description: "Configure unique Prefix Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len": dsschema.Int64Attribute{
				Description: "Hint DHCP Prefix Length (bits)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len_hint": dsschema.BoolAttribute{
				Description: "Send prefix length hint to server",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"duid_type": dsschema.StringAttribute{
				Description: "Select DUID-LLT/DUID-LL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema(),

			"rapid_commit": dsschema.BoolAttribute{
				Description: "Enable Rapid Commit",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"support_srvr_reconfig": dsschema.BoolAttribute{
				Description: "Enable DHCPv6 Server Re-Configuration Support",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"no": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema(),

			"yes": EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"non_temp_addr": dsschema.BoolAttribute{
				Description: "Request Non-Temporary Address Type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"temp_addr": dsschema.BoolAttribute{
				Description: "Request Temporary Address Type",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"assign_addr": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema(),
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable Inherited Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"gua": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema(),

			"ula": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "Enable on Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pool_type": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema(),

			"advertise": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dynamic": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema(),

			"dynamic_id": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"identifier": dsschema.Int64Attribute{
				Description: "Range [0-4095] must be unqiue for this prefix-pool",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"enable_on_interface": dsschema.BoolAttribute{
				Description: "Configure this address on Interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"addresses": dsschema.StringAttribute{
				Description: "Configure ULA (Unique Local Address)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": dsschema.BoolAttribute{
				Description: "Use this as prefix to form full address with interface id/EUI-64",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": dsschema.BoolAttribute{
				Description: "Anycast Address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": dsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"preferred_lifetime": dsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": dsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": dsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dns_server": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dhcpv6": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"prefix_pool": dsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": dsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": dsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": dsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": dsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": dsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_interval": dsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": dsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmission_timer": dsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_preference": dsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dad_attempts": dsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_dad": dsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": dsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": dsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": dsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_advertisement": EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": dsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"dns_support": EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema(),

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": dsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": dsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"link_mtu": dsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"managed_flag": dsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": dsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"min_interval": dsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"other_flag": dsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": dsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"retransmission_timer": dsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"router_preference": dsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema(),
			},

			"suffix": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": dsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3LldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceDataSourceLayer3LldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3LldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3NdpProxySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"addresses": dsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     true,
				Sensitive:    false,
				NestedObject: EthernetInterfaceDataSourceLayer3NdpProxyAddressesSchema(),
			},

			"enabled": dsschema.BoolAttribute{
				Description: "Enable proxy NDP on the interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3NdpProxyObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3NdpProxySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3NdpProxyAddressesSchema() dsschema.NestedAttributeObject {
	return dsschema.NestedAttributeObject{
		Attributes: map[string]dsschema.Attribute{

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": dsschema.BoolAttribute{
				Description: "put the prefix or address on a block list",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3NdpProxyAddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3NdpProxyAddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3PppoeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"access_concentrator": dsschema.StringAttribute{
				Description: "desired access concentrator",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": dsschema.StringAttribute{
				Description: "authentication protocol",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"create_default_route": dsschema.BoolAttribute{
				Description: "automatically create default route pointing to peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": dsschema.Int64Attribute{
				Description: "metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": EthernetInterfaceDataSourceLayer3PppoePassiveSchema(),

			"password": dsschema.StringAttribute{
				Description: "password for ppp autentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"service": dsschema.StringAttribute{
				Description: "desired service",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_address": EthernetInterfaceDataSourceLayer3PppoeStaticAddressSchema(),

			"username": dsschema.StringAttribute{
				Description: "username for ppp authentication",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3PppoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3PppoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3PppoePassiveSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3PppoePassiveObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3PppoePassiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3PppoeStaticAddressSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"ips": dsschema.StringAttribute{
				Description: "static ip address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3PppoeStaticAddressObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3PppoeStaticAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable sdwan on this ethernet interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": dsschema.StringAttribute{
				Description: "Sdwan link characteristics",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"upstream_nat": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "Enable upstream NAT IP config",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema(),

			"static_ip": EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"fqdn": dsschema.StringAttribute{
				Description: "Upstream NAT address FQDN name configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address": dsschema.StringAttribute{
				Description: "Upstream NAT IP address",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLogCardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"default_gateway": dsschema.StringAttribute{
				Description: "log forwarding card default gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address": dsschema.StringAttribute{
				Description: "IP address for the log card forwarding interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_address": dsschema.StringAttribute{
				Description: "IPv6 address for the log card forwarding interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_default_gateway": dsschema.StringAttribute{
				Description: "log forwarding IPv6 card default gateway",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"netmask": dsschema.StringAttribute{
				Description: "IP netmask for the log card forwarding interface",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceLogCardObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceLogCardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceTapSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceTapObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceTapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceVirtualWireSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"lacp": EthernetInterfaceDataSourceVirtualWireLacpSchema(),

			"lldp": EthernetInterfaceDataSourceVirtualWireLldpSchema(),

			"netflow_profile": dsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceVirtualWireObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceVirtualWireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceVirtualWireLacpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"high_availability": EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilitySchema(),
		},
	}
}

func (o *EthernetInterfaceDataSourceVirtualWireLacpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceVirtualWireLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Allow LACP traffic to traverse this device in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceVirtualWireLacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceVirtualWireLldpSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"enable": dsschema.BoolAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema(),

			"profile": dsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceVirtualWireLldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceVirtualWireLldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"passive_pre_negotiation": dsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceDataSourceVirtualWireLldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceDataSourceLocationSchema() rsschema.Attribute {
	return EthernetInterfaceLocationSchema()
}

// Metadata returns the data source type name.
func (d *EthernetInterfaceDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ethernet_interface"
}

// Schema defines the schema for this data source.
func (d *EthernetInterfaceDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = EthernetInterfaceDataSourceSchema()
}

// Configure prepares the struct.
func (d *EthernetInterfaceDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := ethernet.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewImportableEntryObjectManager(d.client, ethernet.NewService(d.client), batchSize, specifier, ethernet.SpecMatches)
}
func (o *EthernetInterfaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state EthernetInterfaceDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ethernet.Location

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &ethernet.SharedLocation{}
			var innerLocation EthernetInterfaceSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ethernet.TemplateLocation{}
			var innerLocation EthernetInterfaceTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ethernet.TemplateStackLocation{}
			var innerLocation EthernetInterfaceTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &ethernet.NgfwLocation{}
			var innerLocation EthernetInterfaceNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &EthernetInterfaceResource{}
	_ resource.ResourceWithConfigure   = &EthernetInterfaceResource{}
	_ resource.ResourceWithImportState = &EthernetInterfaceResource{}
)

func NewEthernetInterfaceResource() resource.Resource {
	if _, found := resourceFuncMap["panos_ethernet_interface"]; !found {
		resourceFuncMap["panos_ethernet_interface"] = resourceFuncs{
			CreateImportId: EthernetInterfaceImportStateCreator,
		}
	}
	return &EthernetInterfaceResource{}
}

type EthernetInterfaceResource struct {
	client  *pango.Client
	manager *sdkmanager.ImportableEntryObjectManager[*ethernet.Entry, ethernet.Location, ethernet.ImportLocation, *ethernet.Service]
}

func EthernetInterfaceResourceLocationSchema() rsschema.Attribute {
	return EthernetInterfaceLocationSchema()
}

type EthernetInterfaceResourceModel struct {
	Location       types.Object `tfsdk:"location"`
	Name           types.String `tfsdk:"name"`
	Comment        types.String `tfsdk:"comment"`
	Lacp           types.Object `tfsdk:"lacp"`
	LinkDuplex     types.String `tfsdk:"link_duplex"`
	LinkSpeed      types.String `tfsdk:"link_speed"`
	LinkState      types.String `tfsdk:"link_state"`
	Poe            types.Object `tfsdk:"poe"`
	AggregateGroup types.String `tfsdk:"aggregate_group"`
	DecryptMirror  types.Object `tfsdk:"decrypt_mirror"`
	Ha             types.Object `tfsdk:"ha"`
	Layer2         types.Object `tfsdk:"layer2"`
	Layer3         types.Object `tfsdk:"layer3"`
	LogCard        types.Object `tfsdk:"log_card"`
	Tap            types.Object `tfsdk:"tap"`
	VirtualWire    types.Object `tfsdk:"virtual_wire"`
}
type EthernetInterfaceResourceLacpObject struct {
	PortPriority types.Int64 `tfsdk:"port_priority"`
}
type EthernetInterfaceResourcePoeObject struct {
	Enabled          types.Bool  `tfsdk:"enabled"`
	PoeReservedPower types.Int64 `tfsdk:"poe_reserved_power"`
}
type EthernetInterfaceResourceDecryptMirrorObject struct {
}
type EthernetInterfaceResourceHaObject struct {
}
type EthernetInterfaceResourceLayer2Object struct {
	Lldp           types.Object `tfsdk:"lldp"`
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceResourceLayer2LldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceResourceLayer2LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceResourceLayer3Object struct {
	AdjustTcpMss               types.Object `tfsdk:"adjust_tcp_mss"`
	Arp                        types.List   `tfsdk:"arp"`
	Bonjour                    types.Object `tfsdk:"bonjour"`
	ClusterInterconnect        types.Bool   `tfsdk:"cluster_interconnect"`
	DdnsConfig                 types.Object `tfsdk:"ddns_config"`
	DecryptForward             types.Bool   `tfsdk:"decrypt_forward"`
	DfIgnore                   types.Bool   `tfsdk:"df_ignore"`
	DhcpClient                 types.Object `tfsdk:"dhcp_client"`
	InterfaceManagementProfile types.String `tfsdk:"interface_management_profile"`
	Ips                        types.List   `tfsdk:"ips"`
	Ipv6                       types.Object `tfsdk:"ipv6"`
	Lldp                       types.Object `tfsdk:"lldp"`
	Mtu                        types.Int64  `tfsdk:"mtu"`
	NdpProxy                   types.Object `tfsdk:"ndp_proxy"`
	NetflowProfile             types.String `tfsdk:"netflow_profile"`
	Pppoe                      types.Object `tfsdk:"pppoe"`
	SdwanLinkSettings          types.Object `tfsdk:"sdwan_link_settings"`
	TrafficInterconnect        types.Bool   `tfsdk:"traffic_interconnect"`
	UntaggedSubInterface       types.Bool   `tfsdk:"untagged_sub_interface"`
}
type EthernetInterfaceResourceLayer3AdjustTcpMssObject struct {
	Enable            types.Bool  `tfsdk:"enable"`
	Ipv4MssAdjustment types.Int64 `tfsdk:"ipv4_mss_adjustment"`
	Ipv6MssAdjustment types.Int64 `tfsdk:"ipv6_mss_adjustment"`
}
type EthernetInterfaceResourceLayer3ArpObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3BonjourObject struct {
	Enable   types.Bool  `tfsdk:"enable"`
	GroupId  types.Int64 `tfsdk:"group_id"`
	TtlCheck types.Bool  `tfsdk:"ttl_check"`
}
type EthernetInterfaceResourceLayer3DdnsConfigObject struct {
	DdnsCertProfile    types.String `tfsdk:"ddns_cert_profile"`
	DdnsEnabled        types.Bool   `tfsdk:"ddns_enabled"`
	DdnsHostname       types.String `tfsdk:"ddns_hostname"`
	DdnsIp             types.List   `tfsdk:"ddns_ip"`
	DdnsIpv6           types.List   `tfsdk:"ddns_ipv6"`
	DdnsUpdateInterval types.Int64  `tfsdk:"ddns_update_interval"`
	DdnsVendor         types.String `tfsdk:"ddns_vendor"`
	DdnsVendorConfig   types.List   `tfsdk:"ddns_vendor_config"`
}
type EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}
type EthernetInterfaceResourceLayer3DhcpClientObject struct {
	CreateDefaultRoute types.Bool   `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	SendHostname       types.Object `tfsdk:"send_hostname"`
}
type EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Hostname types.String `tfsdk:"hostname"`
}
type EthernetInterfaceResourceLayer3IpsObject struct {
	Name         types.String `tfsdk:"name"`
	SdwanGateway types.String `tfsdk:"sdwan_gateway"`
}
type EthernetInterfaceResourceLayer3Ipv6Object struct {
	Addresses         types.List   `tfsdk:"addresses"`
	DhcpClient        types.Object `tfsdk:"dhcp_client"`
	Enabled           types.Bool   `tfsdk:"enabled"`
	Inherited         types.Object `tfsdk:"inherited"`
	InterfaceId       types.String `tfsdk:"interface_id"`
	NeighborDiscovery types.Object `tfsdk:"neighbor_discovery"`
}
type EthernetInterfaceResourceLayer3Ipv6AddressesObject struct {
	Name              types.String `tfsdk:"name"`
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	Prefix            types.Object `tfsdk:"prefix"`
	Anycast           types.Object `tfsdk:"anycast"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject struct {
}
type EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject struct {
}
type EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientObject struct {
	AcceptRaRoute      types.Bool   `tfsdk:"accept_ra_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	NeighborDiscovery  types.Object `tfsdk:"neighbor_discovery"`
	Preference         types.String `tfsdk:"preference"`
	PrefixDelegation   types.Object `tfsdk:"prefix_delegation"`
	V6Options          types.Object `tfsdk:"v6_options"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject struct {
	DadAttempts      types.Int64  `tfsdk:"dad_attempts"`
	DnsServer        types.Object `tfsdk:"dns_server"`
	DnsSuffix        types.Object `tfsdk:"dns_suffix"`
	EnableDad        types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor         types.List   `tfsdk:"neighbor"`
	NsInterval       types.Int64  `tfsdk:"ns_interval"`
	ReachableTime    types.Int64  `tfsdk:"reachable_time"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject struct {
	Enable types.Object `tfsdk:"enable"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject struct {
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject struct {
	PfxPoolName   types.String `tfsdk:"pfx_pool_name"`
	PrefixLen     types.Int64  `tfsdk:"prefix_len"`
	PrefixLenHint types.Bool   `tfsdk:"prefix_len_hint"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject struct {
	DuidType            types.String `tfsdk:"duid_type"`
	Enable              types.Object `tfsdk:"enable"`
	RapidCommit         types.Bool   `tfsdk:"rapid_commit"`
	SupportSrvrReconfig types.Bool   `tfsdk:"support_srvr_reconfig"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject struct {
	No  types.Object `tfsdk:"no"`
	Yes types.Object `tfsdk:"yes"`
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject struct {
}
type EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject struct {
	NonTempAddr types.Bool `tfsdk:"non_temp_addr"`
	TempAddr    types.Bool `tfsdk:"temp_addr"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedObject struct {
	AssignAddr        types.List   `tfsdk:"assign_addr"`
	Enable            types.Bool   `tfsdk:"enable"`
	NeighborDiscovery types.Object `tfsdk:"neighbor_discovery"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject struct {
	Name types.String `tfsdk:"name"`
	Type types.Object `tfsdk:"type"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject struct {
	Gua types.Object `tfsdk:"gua"`
	Ula types.Object `tfsdk:"ula"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject struct {
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	PrefixPool        types.String `tfsdk:"prefix_pool"`
	PoolType          types.Object `tfsdk:"pool_type"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject struct {
	Dynamic   types.Object `tfsdk:"dynamic"`
	DynamicId types.Object `tfsdk:"dynamic_id"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject struct {
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject struct {
	Identifier types.Int64 `tfsdk:"identifier"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject struct {
	Enable         types.Bool `tfsdk:"enable"`
	OnlinkFlag     types.Bool `tfsdk:"onlink_flag"`
	AutoConfigFlag types.Bool `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject struct {
	EnableOnInterface types.Bool   `tfsdk:"enable_on_interface"`
	Addresses         types.String `tfsdk:"addresses"`
	Prefix            types.Bool   `tfsdk:"prefix"`
	Anycast           types.Bool   `tfsdk:"anycast"`
	Advertise         types.Object `tfsdk:"advertise"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject struct {
	Enable            types.Bool   `tfsdk:"enable"`
	ValidLifetime     types.String `tfsdk:"valid_lifetime"`
	PreferredLifetime types.String `tfsdk:"preferred_lifetime"`
	OnlinkFlag        types.Bool   `tfsdk:"onlink_flag"`
	AutoConfigFlag    types.Bool   `tfsdk:"auto_config_flag"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject struct {
	DadAttempts         types.Int64  `tfsdk:"dad_attempts"`
	DnsServer           types.Object `tfsdk:"dns_server"`
	DnsSuffix           types.Object `tfsdk:"dns_suffix"`
	EnableDad           types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List   `tfsdk:"neighbor"`
	NsInterval          types.Int64  `tfsdk:"ns_interval"`
	ReachableTime       types.Int64  `tfsdk:"reachable_time"`
	RouterAdvertisement types.Object `tfsdk:"router_advertisement"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject struct {
	Server types.List `tfsdk:"server"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject struct {
	Enable types.Bool   `tfsdk:"enable"`
	Source types.Object `tfsdk:"source"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject struct {
	Dhcpv6 types.Object `tfsdk:"dhcpv6"`
	Manual types.Object `tfsdk:"manual"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object struct {
	PrefixPool types.String `tfsdk:"prefix_pool"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject struct {
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject struct {
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject struct {
	DadAttempts         types.Int64  `tfsdk:"dad_attempts"`
	EnableDad           types.Bool   `tfsdk:"enable_dad"`
	EnableNdpMonitor    types.Bool   `tfsdk:"enable_ndp_monitor"`
	Neighbor            types.List   `tfsdk:"neighbor"`
	NsInterval          types.Int64  `tfsdk:"ns_interval"`
	ReachableTime       types.Int64  `tfsdk:"reachable_time"`
	RouterAdvertisement types.Object `tfsdk:"router_advertisement"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject struct {
	Name      types.String `tfsdk:"name"`
	HwAddress types.String `tfsdk:"hw_address"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject struct {
	DnsSupport             types.Object `tfsdk:"dns_support"`
	Enable                 types.Bool   `tfsdk:"enable"`
	EnableConsistencyCheck types.Bool   `tfsdk:"enable_consistency_check"`
	HopLimit               types.String `tfsdk:"hop_limit"`
	Lifetime               types.Int64  `tfsdk:"lifetime"`
	LinkMtu                types.String `tfsdk:"link_mtu"`
	ManagedFlag            types.Bool   `tfsdk:"managed_flag"`
	MaxInterval            types.Int64  `tfsdk:"max_interval"`
	MinInterval            types.Int64  `tfsdk:"min_interval"`
	OtherFlag              types.Bool   `tfsdk:"other_flag"`
	ReachableTime          types.String `tfsdk:"reachable_time"`
	RetransmissionTimer    types.String `tfsdk:"retransmission_timer"`
	RouterPreference       types.String `tfsdk:"router_preference"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject struct {
	Enable types.Bool `tfsdk:"enable"`
	Server types.List `tfsdk:"server"`
	Suffix types.List `tfsdk:"suffix"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject struct {
	Name     types.String `tfsdk:"name"`
	Lifetime types.Int64  `tfsdk:"lifetime"`
}
type EthernetInterfaceResourceLayer3LldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceResourceLayer3LldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceResourceLayer3NdpProxyObject struct {
	Addresses types.List `tfsdk:"addresses"`
	Enabled   types.Bool `tfsdk:"enabled"`
}
type EthernetInterfaceResourceLayer3NdpProxyAddressesObject struct {
	Name   types.String `tfsdk:"name"`
	Negate types.Bool   `tfsdk:"negate"`
}
type EthernetInterfaceResourceLayer3PppoeObject struct {
	AccessConcentrator types.String `tfsdk:"access_concentrator"`
	Authentication     types.String `tfsdk:"authentication"`
	CreateDefaultRoute types.Bool   `tfsdk:"create_default_route"`
	DefaultRouteMetric types.Int64  `tfsdk:"default_route_metric"`
	Enable             types.Bool   `tfsdk:"enable"`
	Passive            types.Object `tfsdk:"passive"`
	Password           types.String `tfsdk:"password"`
	Service            types.String `tfsdk:"service"`
	StaticAddress      types.Object `tfsdk:"static_address"`
	Username           types.String `tfsdk:"username"`
}
type EthernetInterfaceResourceLayer3PppoePassiveObject struct {
	Enable types.Bool `tfsdk:"enable"`
}
type EthernetInterfaceResourceLayer3PppoeStaticAddressObject struct {
	Ips types.String `tfsdk:"ips"`
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsObject struct {
	Enable                types.Bool   `tfsdk:"enable"`
	SdwanInterfaceProfile types.String `tfsdk:"sdwan_interface_profile"`
	UpstreamNat           types.Object `tfsdk:"upstream_nat"`
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject struct {
	Enable   types.Bool   `tfsdk:"enable"`
	Ddns     types.Object `tfsdk:"ddns"`
	StaticIp types.Object `tfsdk:"static_ip"`
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject struct {
}
type EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject struct {
	Fqdn      types.String `tfsdk:"fqdn"`
	IpAddress types.String `tfsdk:"ip_address"`
}
type EthernetInterfaceResourceLogCardObject struct {
	DefaultGateway     types.String `tfsdk:"default_gateway"`
	IpAddress          types.String `tfsdk:"ip_address"`
	Ipv6Address        types.String `tfsdk:"ipv6_address"`
	Ipv6DefaultGateway types.String `tfsdk:"ipv6_default_gateway"`
	Netmask            types.String `tfsdk:"netmask"`
}
type EthernetInterfaceResourceTapObject struct {
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceResourceVirtualWireObject struct {
	Lacp           types.Object `tfsdk:"lacp"`
	Lldp           types.Object `tfsdk:"lldp"`
	NetflowProfile types.String `tfsdk:"netflow_profile"`
}
type EthernetInterfaceResourceVirtualWireLacpObject struct {
	HighAvailability types.Object `tfsdk:"high_availability"`
}
type EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}
type EthernetInterfaceResourceVirtualWireLldpObject struct {
	Enable           types.Bool   `tfsdk:"enable"`
	HighAvailability types.Object `tfsdk:"high_availability"`
	Profile          types.String `tfsdk:"profile"`
}
type EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject struct {
	PassivePreNegotiation types.Bool `tfsdk:"passive_pre_negotiation"`
}

func (o *EthernetInterfaceResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func EthernetInterfaceResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": EthernetInterfaceResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"comment": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"lacp": EthernetInterfaceResourceLacpSchema(),

			"link_duplex": rsschema.StringAttribute{
				Description: "Interface link duplex",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"auto",
						"half",
						"full",
					}...),
				},
			},

			"link_speed": rsschema.StringAttribute{
				Description: "Interface link speed",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"auto",
						"10",
						"100",
						"1000",
						"10000",
						"40000",
						"100000",
					}...),
				},
			},

			"link_state": rsschema.StringAttribute{
				Description: "Interface link state",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("auto"),

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"auto",
						"up",
						"down",
					}...),
				},
			},

			"poe": EthernetInterfaceResourcePoeSchema(),

			"aggregate_group": rsschema.StringAttribute{
				Description: "Aggregate interface group",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("aggregate_group"),
						path.MatchRelative().AtParent().AtName("decrypt_mirror"),
						path.MatchRelative().AtParent().AtName("ha"),
						path.MatchRelative().AtParent().AtName("layer2"),
						path.MatchRelative().AtParent().AtName("layer3"),
						path.MatchRelative().AtParent().AtName("log_card"),
						path.MatchRelative().AtParent().AtName("tap"),
						path.MatchRelative().AtParent().AtName("virtual_wire"),
					}...),
				},
			},

			"decrypt_mirror": EthernetInterfaceResourceDecryptMirrorSchema(),

			"ha": EthernetInterfaceResourceHaSchema(),

			"layer2": EthernetInterfaceResourceLayer2Schema(),

			"layer3": EthernetInterfaceResourceLayer3Schema(),

			"log_card": EthernetInterfaceResourceLogCardSchema(),

			"tap": EthernetInterfaceResourceTapSchema(),

			"virtual_wire": EthernetInterfaceResourceVirtualWireSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceModel) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLacpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"port_priority": rsschema.Int64Attribute{
				Description: "port priority in LACP",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(32768),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLacpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourcePoeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enabled": rsschema.BoolAttribute{
				Description: "PoE Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"poe_reserved_power": rsschema.Int64Attribute{
				Description: "Reserved Power",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(0),
			},
		},
	}
}

func (o *EthernetInterfaceResourcePoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourcePoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceDecryptMirrorSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceDecryptMirrorObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceDecryptMirrorSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceHaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceHaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceHaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer2Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lldp": EthernetInterfaceResourceLayer2LldpSchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer2Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer2Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer2LldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceResourceLayer2LldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer2LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer2LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer2LldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer2LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"adjust_tcp_mss": EthernetInterfaceResourceLayer3AdjustTcpMssSchema(),

			"arp": rsschema.ListNestedAttribute{
				Description:  "ARP configuration",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3ArpSchema(),
			},

			"bonjour": EthernetInterfaceResourceLayer3BonjourSchema(),

			"cluster_interconnect": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_config": EthernetInterfaceResourceLayer3DdnsConfigSchema(),

			"decrypt_forward": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"df_ignore": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"dhcp_client": EthernetInterfaceResourceLayer3DhcpClientSchema(),

			"interface_management_profile": rsschema.StringAttribute{
				Description: "Interface management profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ips": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3IpsSchema(),
			},

			"ipv6": EthernetInterfaceResourceLayer3Ipv6Schema(),

			"lldp": EthernetInterfaceResourceLayer3LldpSchema(),

			"mtu": rsschema.Int64Attribute{
				Description: "Maximum Transfer Unit, up to 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ndp_proxy": EthernetInterfaceResourceLayer3NdpProxySchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pppoe": EthernetInterfaceResourceLayer3PppoeSchema(),

			"sdwan_link_settings": EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema(),

			"traffic_interconnect": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"untagged_sub_interface": rsschema.BoolAttribute{
				Description: "Enable untagged sub-interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3AdjustTcpMssSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Set if TCP MSS value should be reduced based on mtu",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv4_mss_adjustment": rsschema.Int64Attribute{
				Description: "IPv4 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(40),
			},

			"ipv6_mss_adjustment": rsschema.Int64Attribute{
				Description: "IPv6 MSS adjustment size (in bytes)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(60),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3AdjustTcpMssSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3ArpSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3ArpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3ArpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3BonjourSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Set to support Bonjour service",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"group_id": rsschema.Int64Attribute{
				Description: "default 0: NO-Group",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(40),
			},

			"ttl_check": rsschema.BoolAttribute{
				Description: "Set to check and update TTL",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3BonjourObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3BonjourSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DdnsConfigSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ddns_cert_profile": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_enabled": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_hostname": rsschema.StringAttribute{
				Description: "ddns hostname variable or real address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_ip": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_ipv6": rsschema.ListAttribute{
				Description: "",
				Required:    false,
				Optional:    true,
				Computed:    false,
				Sensitive:   false,
				ElementType: types.StringType,
			},

			"ddns_update_interval": rsschema.Int64Attribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"ddns_vendor": rsschema.StringAttribute{
				Description: "Vendor and product type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns_vendor_config": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DdnsConfigObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DdnsConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"value": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DhcpClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"create_default_route": rsschema.BoolAttribute{
				Description: "Automatically create default route pointing to default gateway provided by server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_hostname": EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hostname": rsschema.StringAttribute{
				Description: "Set Interface Hostname",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("system-hostname"),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3DhcpClientSendHostnameSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3IpsSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"sdwan_gateway": rsschema.StringAttribute{
				Description: "Gateway IPv4 Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3IpsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3IpsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"addresses": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6AddressesSchema(),
			},

			"dhcp_client": EthernetInterfaceResourceLayer3Ipv6DhcpClientSchema(),

			"enabled": rsschema.BoolAttribute{
				Description: "Enable IPv6 on the interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"inherited": EthernetInterfaceResourceLayer3Ipv6InheritedSchema(),

			"interface_id": rsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("EUI-64"),
			},

			"neighbor_discovery": EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "configure this address on interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": EthernetInterfaceResourceLayer3Ipv6AddressesPrefixSchema(),

			"anycast": EthernetInterfaceResourceLayer3Ipv6AddressesAnycastSchema(),

			"advertise": EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesPrefixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesAnycastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes:  map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesAnycastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": rsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2592000"),
			},

			"preferred_lifetime": rsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("604800"),
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"accept_ra_route": rsschema.BoolAttribute{
				Description: "Accept Router Advertised Default Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "Metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable DHCPv6 Client",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema(),

			"preference": rsschema.StringAttribute{
				Description: "Select Low/Medium/High",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("high"),
			},

			"prefix_delegation": EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema(),

			"v6_options": EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"dns_server": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no": EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema(),

			"yes": EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"pfx_pool_name": rsschema.StringAttribute{
				Description: "Configure unique Prefix Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_len": rsschema.Int64Attribute{
				Description: "Hint DHCP Prefix Length (bits)",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(48),
			},

			"prefix_len_hint": rsschema.BoolAttribute{
				Description: "Send prefix length hint to server",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"duid_type": rsschema.StringAttribute{
				Description: "Select DUID-LLT/DUID-LL",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("duid-type-llt"),
			},

			"enable": EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema(),

			"rapid_commit": rsschema.BoolAttribute{
				Description: "Enable Rapid Commit",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"support_srvr_reconfig": rsschema.BoolAttribute{
				Description: "Enable DHCPv6 Server Re-Configuration Support",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"no": EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema(),

			"yes": EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("no"),
				path.MatchRelative().AtParent().AtName("yes"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"non_temp_addr": rsschema.BoolAttribute{
				Description: "Request Non-Temporary Address Type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"temp_addr": rsschema.BoolAttribute{
				Description: "Request Temporary Address Type",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"assign_addr": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema(),
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable Inherited Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor_discovery": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"type": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"gua": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema(),

			"ula": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "Enable on Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"pool_type": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema(),

			"advertise": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dynamic": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema(),

			"dynamic_id": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dynamic"),
				path.MatchRelative().AtParent().AtName("dynamic_id"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"identifier": rsschema.Int64Attribute{
				Description: "Range [0-4095] must be unqiue for this prefix-pool",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("gua"),
				path.MatchRelative().AtParent().AtName("ula"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"enable_on_interface": rsschema.BoolAttribute{
				Description: "Configure this address on Interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"addresses": rsschema.StringAttribute{
				Description: "Configure ULA (Unique Local Address)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"prefix": rsschema.BoolAttribute{
				Description: "Use this as prefix to form full address with interface id/EUI-64",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"anycast": rsschema.BoolAttribute{
				Description: "Anycast Address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"advertise": EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "enable advertising this prefix in router advertisements",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"valid_lifetime": rsschema.StringAttribute{
				Description: "Valid Lifetime (in seconds) of the prefix advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("2592000"),
			},

			"preferred_lifetime": rsschema.StringAttribute{
				Description: "Preferred Lifetime (in seconds) of the prefix advertised in Router advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("604800"),
			},

			"onlink_flag": rsschema.BoolAttribute{
				Description: "Set the On-Link Flag (L-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"auto_config_flag": rsschema.BoolAttribute{
				Description: "Set the Auto Address Configuration Flag (A-bit) of the prefix in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"dns_server": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema(),

			"dns_suffix": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema(),

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"router_advertisement": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema(),

			"manual": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) Lifetime in Seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"source": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dhcpv6": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema(),

			"manual": EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"prefix_pool": rsschema.StringAttribute{
				Description: "Prefix-Pool Name",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("dhcpv6"),
				path.MatchRelative().AtParent().AtName("manual"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "(4-3600) lifetime in seconds",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": rsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": rsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("64"),
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1800),
			},

			"link_mtu": rsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"managed_flag": rsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": rsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(600),
			},

			"min_interval": rsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"other_flag": rsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": rsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"retransmission_timer": rsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"router_preference": rsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Medium"),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dad_attempts": rsschema.Int64Attribute{
				Description: "Number of consecutive neighbor solicitation messages sent for duplicate address detection",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"enable_dad": rsschema.BoolAttribute{
				Description: "Enable Duplicate ADdress Detection (DAD)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_ndp_monitor": rsschema.BoolAttribute{
				Description: "Enable NDP Monitoring",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"neighbor": rsschema.ListNestedAttribute{
				Description:  "Static entries in neighbor cache",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema(),
			},

			"ns_interval": rsschema.Int64Attribute{
				Description: "Interval (in seconds) between consecutive neighbor solicitation messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},

			"reachable_time": rsschema.Int64Attribute{
				Description: "Time (in seconds) that the Reachable status for a neighbor can be maintained",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(30),
			},

			"router_advertisement": EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoverySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"hw_address": rsschema.StringAttribute{
				Description: "MAC address (format xx:xx:xx:xx:xx:xx)",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"dns_support": EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema(),

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable_consistency_check": rsschema.BoolAttribute{
				Description: "check consistency of RA messages from other routers.",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"hop_limit": rsschema.StringAttribute{
				Description: "Current Hop Limit advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("64"),
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1800),
			},

			"link_mtu": rsschema.StringAttribute{
				Description: "value of MTU option in Router Advertisement messages, upto 9216 in Jumbo-Frame mode, up to 1500 otherwise",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"managed_flag": rsschema.BoolAttribute{
				Description: "Set the Managed Configuration Flag (M-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"max_interval": rsschema.Int64Attribute{
				Description: "Maximum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(600),
			},

			"min_interval": rsschema.Int64Attribute{
				Description: "Minimum interval (seconds) between consecutive unsolicited Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(200),
			},

			"other_flag": rsschema.BoolAttribute{
				Description: "Set the Other Stateful Configuration Flag (O-bit) in Router Advertisement messages",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"reachable_time": rsschema.StringAttribute{
				Description: "Reachable Time (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"retransmission_timer": rsschema.StringAttribute{
				Description: "Retransmission Timer (in milliseconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("unspecified"),
			},

			"router_preference": rsschema.StringAttribute{
				Description: "Router Preference",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("Medium"),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"server": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema(),
			},

			"suffix": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema(),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"lifetime": rsschema.Int64Attribute{
				Description: "Router Lifetime (in seconds) advertised in Router Advertisement messages",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1200),
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3LldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceResourceLayer3LldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3LldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3LldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3LldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3LldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3NdpProxySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"addresses": rsschema.ListNestedAttribute{
				Description:  "",
				Required:     false,
				Optional:     true,
				Computed:     false,
				Sensitive:    false,
				NestedObject: EthernetInterfaceResourceLayer3NdpProxyAddressesSchema(),
			},

			"enabled": rsschema.BoolAttribute{
				Description: "Enable proxy NDP on the interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3NdpProxyObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3NdpProxySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3NdpProxyAddressesSchema() rsschema.NestedAttributeObject {
	return rsschema.NestedAttributeObject{
		Attributes: map[string]rsschema.Attribute{

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"negate": rsschema.BoolAttribute{
				Description: "put the prefix or address on a block list",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3NdpProxyAddressesObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3NdpProxyAddressesSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3PppoeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"access_concentrator": rsschema.StringAttribute{
				Description: "desired access concentrator",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"authentication": rsschema.StringAttribute{
				Description: "authentication protocol",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"create_default_route": rsschema.BoolAttribute{
				Description: "automatically create default route pointing to peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_route_metric": rsschema.Int64Attribute{
				Description: "metric of the default route created",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(10),
			},

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"passive": EthernetInterfaceResourceLayer3PppoePassiveSchema(),

			"password": rsschema.StringAttribute{
				Description: "password for ppp autentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"service": rsschema.StringAttribute{
				Description: "desired service",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"static_address": EthernetInterfaceResourceLayer3PppoeStaticAddressSchema(),

			"username": rsschema.StringAttribute{
				Description: "username for ppp authentication",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3PppoeObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3PppoeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3PppoePassiveSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3PppoePassiveObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3PppoePassiveSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3PppoeStaticAddressSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"ips": rsschema.StringAttribute{
				Description: "static ip address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3PppoeStaticAddressObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3PppoeStaticAddressSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable sdwan on this ethernet interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"sdwan_interface_profile": rsschema.StringAttribute{
				Description: "Sdwan link characteristics",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"upstream_nat": EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "Enable upstream NAT IP config",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ddns": EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema(),

			"static_ip": EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema(),
		},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ddns"),
				path.MatchRelative().AtParent().AtName("static_ip"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"fqdn": rsschema.StringAttribute{
				Description: "Upstream NAT address FQDN name configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("fqdn"),
						path.MatchRelative().AtParent().AtName("ip_address"),
					}...),
				},
			},

			"ip_address": rsschema.StringAttribute{
				Description: "Upstream NAT IP address",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceLogCardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"default_gateway": rsschema.StringAttribute{
				Description: "log forwarding card default gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ip_address": rsschema.StringAttribute{
				Description: "IP address for the log card forwarding interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_address": rsschema.StringAttribute{
				Description: "IPv6 address for the log card forwarding interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ipv6_default_gateway": rsschema.StringAttribute{
				Description: "log forwarding IPv6 card default gateway",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"netmask": rsschema.StringAttribute{
				Description: "IP netmask for the log card forwarding interface",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceLogCardObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceLogCardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceTapSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceTapObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceTapSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceVirtualWireSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"lacp": EthernetInterfaceResourceVirtualWireLacpSchema(),

			"lldp": EthernetInterfaceResourceVirtualWireLldpSchema(),

			"netflow_profile": rsschema.StringAttribute{
				Description: "Netflow Server Profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceVirtualWireObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceVirtualWireSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceVirtualWireLacpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"high_availability": EthernetInterfaceResourceVirtualWireLacpHighAvailabilitySchema(),
		},
	}
}

func (o *EthernetInterfaceResourceVirtualWireLacpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceVirtualWireLacpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceVirtualWireLacpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Allow LACP traffic to traverse this device in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceVirtualWireLacpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceVirtualWireLldpSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"enable": rsschema.BoolAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"high_availability": EthernetInterfaceResourceVirtualWireLldpHighAvailabilitySchema(),

			"profile": rsschema.StringAttribute{
				Description: "LLDP profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceVirtualWireLldpObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceVirtualWireLldpSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func EthernetInterfaceResourceVirtualWireLldpHighAvailabilitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"passive_pre_negotiation": rsschema.BoolAttribute{
				Description: "Enable LLDP pre-negotiation in HA passive state",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) getTypeFor(name string) attr.Type {
	schema := EthernetInterfaceResourceVirtualWireLldpHighAvailabilitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *EthernetInterfaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_ethernet_interface"
}

func (o *EthernetInterfaceResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = EthernetInterfaceResourceSchema()
}

// </ResourceSchema>

func (o *EthernetInterfaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := ethernet.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}

	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewImportableEntryObjectManager(o.client, ethernet.NewService(o.client), batchSize, specifier, ethernet.SpecMatches)
}

func (o *EthernetInterfaceResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj EthernetInterfaceLocation

	var lacpObj *EthernetInterfaceResourceLacpObject

	var poeObj *EthernetInterfaceResourcePoeObject

	var decryptMirrorObj *EthernetInterfaceResourceDecryptMirrorObject

	var haObj *EthernetInterfaceResourceHaObject

	var layer2Obj *EthernetInterfaceResourceLayer2Object

	var layer3Obj *EthernetInterfaceResourceLayer3Object

	var logCardObj *EthernetInterfaceResourceLogCardObject

	var tapObj *EthernetInterfaceResourceTapObject

	var virtualWireObj *EthernetInterfaceResourceVirtualWireObject
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name":    types.StringType,
		"comment": types.StringType,
		"lacp": types.ObjectType{
			AttrTypes: lacpObj.AttributeTypes(),
		},
		"link_duplex": types.StringType,
		"link_speed":  types.StringType,
		"link_state":  types.StringType,
		"poe": types.ObjectType{
			AttrTypes: poeObj.AttributeTypes(),
		},
		"aggregate_group": types.StringType,
		"decrypt_mirror": types.ObjectType{
			AttrTypes: decryptMirrorObj.AttributeTypes(),
		},
		"ha": types.ObjectType{
			AttrTypes: haObj.AttributeTypes(),
		},
		"layer2": types.ObjectType{
			AttrTypes: layer2Obj.AttributeTypes(),
		},
		"layer3": types.ObjectType{
			AttrTypes: layer3Obj.AttributeTypes(),
		},
		"log_card": types.ObjectType{
			AttrTypes: logCardObj.AttributeTypes(),
		},
		"tap": types.ObjectType{
			AttrTypes: tapObj.AttributeTypes(),
		},
		"virtual_wire": types.ObjectType{
			AttrTypes: virtualWireObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceModel) AncestorName() string {
	return ""
}

func (o EthernetInterfaceResourceModel) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLacpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"port_priority": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLacpObject) AncestorName() string {
	return "lacp"
}

func (o EthernetInterfaceResourceLacpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourcePoeObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enabled":            types.BoolType,
		"poe_reserved_power": types.Int64Type,
	}
}

func (o EthernetInterfaceResourcePoeObject) AncestorName() string {
	return "poe"
}

func (o EthernetInterfaceResourcePoeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceDecryptMirrorObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceDecryptMirrorObject) AncestorName() string {
	return "decrypt-mirror"
}

func (o EthernetInterfaceResourceDecryptMirrorObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceHaObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceHaObject) AncestorName() string {
	return "ha"
}

func (o EthernetInterfaceResourceHaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer2Object) AttributeTypes() map[string]attr.Type {

	var lldpObj *EthernetInterfaceResourceLayer2LldpObject

	return map[string]attr.Type{
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer2Object) AncestorName() string {
	return "layer2"
}

func (o EthernetInterfaceResourceLayer2Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer2LldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer2LldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceResourceLayer2LldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Object) AttributeTypes() map[string]attr.Type {

	var adjustTcpMssObj *EthernetInterfaceResourceLayer3AdjustTcpMssObject

	var arpObj *EthernetInterfaceResourceLayer3ArpObject

	var bonjourObj *EthernetInterfaceResourceLayer3BonjourObject

	var ddnsConfigObj *EthernetInterfaceResourceLayer3DdnsConfigObject

	var dhcpClientObj *EthernetInterfaceResourceLayer3DhcpClientObject

	var ipsObj *EthernetInterfaceResourceLayer3IpsObject

	var ipv6Obj *EthernetInterfaceResourceLayer3Ipv6Object

	var lldpObj *EthernetInterfaceResourceLayer3LldpObject

	var ndpProxyObj *EthernetInterfaceResourceLayer3NdpProxyObject

	var pppoeObj *EthernetInterfaceResourceLayer3PppoeObject

	var sdwanLinkSettingsObj *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject

	return map[string]attr.Type{
		"adjust_tcp_mss": types.ObjectType{
			AttrTypes: adjustTcpMssObj.AttributeTypes(),
		},
		"arp": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: arpObj.AttributeTypes(),
			},
		},
		"bonjour": types.ObjectType{
			AttrTypes: bonjourObj.AttributeTypes(),
		},
		"cluster_interconnect": types.BoolType,
		"ddns_config": types.ObjectType{
			AttrTypes: ddnsConfigObj.AttributeTypes(),
		},
		"decrypt_forward": types.BoolType,
		"df_ignore":       types.BoolType,
		"dhcp_client": types.ObjectType{
			AttrTypes: dhcpClientObj.AttributeTypes(),
		},
		"interface_management_profile": types.StringType,
		"ips": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ipsObj.AttributeTypes(),
			},
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"mtu": types.Int64Type,
		"ndp_proxy": types.ObjectType{
			AttrTypes: ndpProxyObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
		"pppoe": types.ObjectType{
			AttrTypes: pppoeObj.AttributeTypes(),
		},
		"sdwan_link_settings": types.ObjectType{
			AttrTypes: sdwanLinkSettingsObj.AttributeTypes(),
		},
		"traffic_interconnect":   types.BoolType,
		"untagged_sub_interface": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Object) AncestorName() string {
	return "layer3"
}

func (o EthernetInterfaceResourceLayer3Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":              types.BoolType,
		"ipv4_mss_adjustment": types.Int64Type,
		"ipv6_mss_adjustment": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3AdjustTcpMssObject) AncestorName() string {
	return "adjust-tcp-mss"
}

func (o EthernetInterfaceResourceLayer3AdjustTcpMssObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3ArpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3ArpObject) AncestorName() string {
	return "arp"
}

func (o EthernetInterfaceResourceLayer3ArpObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3BonjourObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":    types.BoolType,
		"group_id":  types.Int64Type,
		"ttl_check": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3BonjourObject) AncestorName() string {
	return "bonjour"
}

func (o EthernetInterfaceResourceLayer3BonjourObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3DdnsConfigObject) AttributeTypes() map[string]attr.Type {

	var ddnsVendorConfigObj *EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
	return map[string]attr.Type{
		"ddns_cert_profile": types.StringType,
		"ddns_enabled":      types.BoolType,
		"ddns_hostname":     types.StringType,
		"ddns_ip": types.ListType{
			ElemType: types.StringType,
		},
		"ddns_ipv6": types.ListType{
			ElemType: types.StringType,
		},
		"ddns_update_interval": types.Int64Type,
		"ddns_vendor":          types.StringType,
		"ddns_vendor_config": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: ddnsVendorConfigObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3DdnsConfigObject) AncestorName() string {
	return "ddns-config"
}

func (o EthernetInterfaceResourceLayer3DdnsConfigObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":  types.StringType,
		"value": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) AncestorName() string {
	return "ddns-vendor-config"
}

func (o EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3DhcpClientObject) AttributeTypes() map[string]attr.Type {

	var sendHostnameObj *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject
	return map[string]attr.Type{
		"create_default_route": types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"send_hostname": types.ObjectType{
			AttrTypes: sendHostnameObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3DhcpClientObject) AncestorName() string {
	return "dhcp-client"
}

func (o EthernetInterfaceResourceLayer3DhcpClientObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":   types.BoolType,
		"hostname": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) AncestorName() string {
	return "send-hostname"
}

func (o EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3IpsObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":          types.StringType,
		"sdwan_gateway": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3IpsObject) AncestorName() string {
	return "ips"
}

func (o EthernetInterfaceResourceLayer3IpsObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6Object) AttributeTypes() map[string]attr.Type {

	var addressesObj *EthernetInterfaceResourceLayer3Ipv6AddressesObject

	var dhcpClientObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject

	var inheritedObj *EthernetInterfaceResourceLayer3Ipv6InheritedObject

	var neighborDiscoveryObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject
	return map[string]attr.Type{
		"addresses": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressesObj.AttributeTypes(),
			},
		},
		"dhcp_client": types.ObjectType{
			AttrTypes: dhcpClientObj.AttributeTypes(),
		},
		"enabled": types.BoolType,
		"inherited": types.ObjectType{
			AttrTypes: inheritedObj.AttributeTypes(),
		},
		"interface_id": types.StringType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6Object) AncestorName() string {
	return "ipv6"
}

func (o EthernetInterfaceResourceLayer3Ipv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) AttributeTypes() map[string]attr.Type {

	var prefixObj *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject

	var anycastObj *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject

	var advertiseObj *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject
	return map[string]attr.Type{
		"name":                types.StringType,
		"enable_on_interface": types.BoolType,
		"prefix": types.ObjectType{
			AttrTypes: prefixObj.AttributeTypes(),
		},
		"anycast": types.ObjectType{
			AttrTypes: anycastObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesObject) AncestorName() string {
	return "addresses"
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) AncestorName() string {
	return "prefix"
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) AncestorName() string {
	return "anycast"
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":             types.BoolType,
		"valid_lifetime":     types.StringType,
		"preferred_lifetime": types.StringType,
		"onlink_flag":        types.BoolType,
		"auto_config_flag":   types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) AttributeTypes() map[string]attr.Type {

	var neighborDiscoveryObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject

	var prefixDelegationObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject

	var v6OptionsObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject
	return map[string]attr.Type{
		"accept_ra_route":      types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
		"preference": types.StringType,
		"prefix_delegation": types.ObjectType{
			AttrTypes: prefixDelegationObj.AttributeTypes(),
		},
		"v6_options": types.ObjectType{
			AttrTypes: v6OptionsObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) AncestorName() string {
	return "dhcp-client"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var dnsServerObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject

	var dnsSuffixObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject

	var neighborObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject

	return map[string]attr.Type{
		"dad_attempts": types.Int64Type,
		"dns_server": types.ObjectType{
			AttrTypes: dnsServerObj.AttributeTypes(),
		},
		"dns_suffix": types.ObjectType{
			AttrTypes: dnsSuffixObj.AttributeTypes(),
		},
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) AncestorName() string {
	return "dns-server"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object

	var manualObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	return map[string]attr.Type{
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) AncestorName() string {
	return "dns-suffix"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object

	var manualObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) AttributeTypes() map[string]attr.Type {

	var suffixObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	return map[string]attr.Type{
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) AttributeTypes() map[string]attr.Type {

	var enableObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	return map[string]attr.Type{
		"enable": types.ObjectType{
			AttrTypes: enableObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) AncestorName() string {
	return "prefix-delegation"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) AttributeTypes() map[string]attr.Type {

	var noObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject

	var yesObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) AncestorName() string {
	return "enable"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) AncestorName() string {
	return "no"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"pfx_pool_name":   types.StringType,
		"prefix_len":      types.Int64Type,
		"prefix_len_hint": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) AncestorName() string {
	return "yes"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) AttributeTypes() map[string]attr.Type {

	var enableObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject

	return map[string]attr.Type{
		"duid_type": types.StringType,
		"enable": types.ObjectType{
			AttrTypes: enableObj.AttributeTypes(),
		},
		"rapid_commit":          types.BoolType,
		"support_srvr_reconfig": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) AncestorName() string {
	return "v6-options"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) AttributeTypes() map[string]attr.Type {

	var noObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject

	var yesObj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	return map[string]attr.Type{
		"no": types.ObjectType{
			AttrTypes: noObj.AttributeTypes(),
		},
		"yes": types.ObjectType{
			AttrTypes: yesObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) AncestorName() string {
	return "enable"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) AncestorName() string {
	return "no"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"non_temp_addr": types.BoolType,
		"temp_addr":     types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) AncestorName() string {
	return "yes"
}

func (o EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedObject) AttributeTypes() map[string]attr.Type {

	var assignAddrObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject

	var neighborDiscoveryObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject
	return map[string]attr.Type{
		"assign_addr": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: assignAddrObj.AttributeTypes(),
			},
		},
		"enable": types.BoolType,
		"neighbor_discovery": types.ObjectType{
			AttrTypes: neighborDiscoveryObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedObject) AncestorName() string {
	return "inherited"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) AttributeTypes() map[string]attr.Type {

	var typeObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject
	return map[string]attr.Type{
		"name": types.StringType,
		"type": types.ObjectType{
			AttrTypes: typeObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) AncestorName() string {
	return "assign-addr"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) AttributeTypes() map[string]attr.Type {

	var guaObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject

	var ulaObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	return map[string]attr.Type{
		"gua": types.ObjectType{
			AttrTypes: guaObj.AttributeTypes(),
		},
		"ula": types.ObjectType{
			AttrTypes: ulaObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) AncestorName() string {
	return "type"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) AttributeTypes() map[string]attr.Type {

	var poolTypeObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject

	var advertiseObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	return map[string]attr.Type{
		"enable_on_interface": types.BoolType,
		"prefix_pool":         types.StringType,
		"pool_type": types.ObjectType{
			AttrTypes: poolTypeObj.AttributeTypes(),
		},
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) AncestorName() string {
	return "gua"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) AttributeTypes() map[string]attr.Type {

	var dynamicObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject

	var dynamicIdObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	return map[string]attr.Type{
		"dynamic": types.ObjectType{
			AttrTypes: dynamicObj.AttributeTypes(),
		},
		"dynamic_id": types.ObjectType{
			AttrTypes: dynamicIdObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) AncestorName() string {
	return "pool-type"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) AncestorName() string {
	return "dynamic"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"identifier": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) AncestorName() string {
	return "dynamic-id"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":           types.BoolType,
		"onlink_flag":      types.BoolType,
		"auto_config_flag": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) AttributeTypes() map[string]attr.Type {

	var advertiseObj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	return map[string]attr.Type{
		"enable_on_interface": types.BoolType,
		"addresses":           types.StringType,
		"prefix":              types.BoolType,
		"anycast":             types.BoolType,
		"advertise": types.ObjectType{
			AttrTypes: advertiseObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) AncestorName() string {
	return "ula"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":             types.BoolType,
		"valid_lifetime":     types.StringType,
		"preferred_lifetime": types.StringType,
		"onlink_flag":        types.BoolType,
		"auto_config_flag":   types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) AncestorName() string {
	return "advertise"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var dnsServerObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject

	var dnsSuffixObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject

	var neighborObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject

	var routerAdvertisementObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	return map[string]attr.Type{
		"dad_attempts": types.Int64Type,
		"dns_server": types.ObjectType{
			AttrTypes: dnsServerObj.AttributeTypes(),
		},
		"dns_suffix": types.ObjectType{
			AttrTypes: dnsSuffixObj.AttributeTypes(),
		},
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
		"router_advertisement": types.ObjectType{
			AttrTypes: routerAdvertisementObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) AncestorName() string {
	return "dns-server"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object

	var manualObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_pool": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	return map[string]attr.Type{
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) AttributeTypes() map[string]attr.Type {

	var sourceObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"source": types.ObjectType{
			AttrTypes: sourceObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) AncestorName() string {
	return "dns-suffix"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) AttributeTypes() map[string]attr.Type {

	var dhcpv6Obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object

	var manualObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	return map[string]attr.Type{
		"dhcpv6": types.ObjectType{
			AttrTypes: dhcpv6Obj.AttributeTypes(),
		},
		"manual": types.ObjectType{
			AttrTypes: manualObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) AncestorName() string {
	return "source"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"prefix_pool": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) AncestorName() string {
	return "dhcpv6"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) AttributeTypes() map[string]attr.Type {

	var suffixObj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	return map[string]attr.Type{
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) AncestorName() string {
	return "manual"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable":                   types.BoolType,
		"enable_consistency_check": types.BoolType,
		"hop_limit":                types.StringType,
		"lifetime":                 types.Int64Type,
		"link_mtu":                 types.StringType,
		"managed_flag":             types.BoolType,
		"max_interval":             types.Int64Type,
		"min_interval":             types.Int64Type,
		"other_flag":               types.BoolType,
		"reachable_time":           types.StringType,
		"retransmission_timer":     types.StringType,
		"router_preference":        types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) AncestorName() string {
	return "router-advertisement"
}

func (o EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) AttributeTypes() map[string]attr.Type {

	var neighborObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject

	var routerAdvertisementObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	return map[string]attr.Type{
		"dad_attempts":       types.Int64Type,
		"enable_dad":         types.BoolType,
		"enable_ndp_monitor": types.BoolType,
		"neighbor": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: neighborObj.AttributeTypes(),
			},
		},
		"ns_interval":    types.Int64Type,
		"reachable_time": types.Int64Type,
		"router_advertisement": types.ObjectType{
			AttrTypes: routerAdvertisementObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) AncestorName() string {
	return "neighbor-discovery"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":       types.StringType,
		"hw_address": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) AncestorName() string {
	return "neighbor"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) AttributeTypes() map[string]attr.Type {

	var dnsSupportObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject

	return map[string]attr.Type{
		"dns_support": types.ObjectType{
			AttrTypes: dnsSupportObj.AttributeTypes(),
		},
		"enable":                   types.BoolType,
		"enable_consistency_check": types.BoolType,
		"hop_limit":                types.StringType,
		"lifetime":                 types.Int64Type,
		"link_mtu":                 types.StringType,
		"managed_flag":             types.BoolType,
		"max_interval":             types.Int64Type,
		"min_interval":             types.Int64Type,
		"other_flag":               types.BoolType,
		"reachable_time":           types.StringType,
		"retransmission_timer":     types.StringType,
		"router_preference":        types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) AncestorName() string {
	return "router-advertisement"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) AttributeTypes() map[string]attr.Type {

	var serverObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject

	var suffixObj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"server": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: serverObj.AttributeTypes(),
			},
		},
		"suffix": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: suffixObj.AttributeTypes(),
			},
		},
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) AncestorName() string {
	return "dns-support"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) AncestorName() string {
	return "server"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":     types.StringType,
		"lifetime": types.Int64Type,
	}
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) AncestorName() string {
	return "suffix"
}

func (o EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3LldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3LldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceResourceLayer3LldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3NdpProxyObject) AttributeTypes() map[string]attr.Type {

	var addressesObj *EthernetInterfaceResourceLayer3NdpProxyAddressesObject

	return map[string]attr.Type{
		"addresses": types.ListType{
			ElemType: types.ObjectType{
				AttrTypes: addressesObj.AttributeTypes(),
			},
		},
		"enabled": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3NdpProxyObject) AncestorName() string {
	return "ndp-proxy"
}

func (o EthernetInterfaceResourceLayer3NdpProxyObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3NdpProxyAddressesObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"name":   types.StringType,
		"negate": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3NdpProxyAddressesObject) AncestorName() string {
	return "addresses"
}

func (o EthernetInterfaceResourceLayer3NdpProxyAddressesObject) EntryName() *string {
	return o.Name.ValueStringPointer()
}
func (o *EthernetInterfaceResourceLayer3PppoeObject) AttributeTypes() map[string]attr.Type {

	var passiveObj *EthernetInterfaceResourceLayer3PppoePassiveObject

	var staticAddressObj *EthernetInterfaceResourceLayer3PppoeStaticAddressObject

	return map[string]attr.Type{
		"access_concentrator":  types.StringType,
		"authentication":       types.StringType,
		"create_default_route": types.BoolType,
		"default_route_metric": types.Int64Type,
		"enable":               types.BoolType,
		"passive": types.ObjectType{
			AttrTypes: passiveObj.AttributeTypes(),
		},
		"password": types.StringType,
		"service":  types.StringType,
		"static_address": types.ObjectType{
			AttrTypes: staticAddressObj.AttributeTypes(),
		},
		"username": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3PppoeObject) AncestorName() string {
	return "pppoe"
}

func (o EthernetInterfaceResourceLayer3PppoeObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3PppoePassiveObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"enable": types.BoolType,
	}
}

func (o EthernetInterfaceResourceLayer3PppoePassiveObject) AncestorName() string {
	return "passive"
}

func (o EthernetInterfaceResourceLayer3PppoePassiveObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3PppoeStaticAddressObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"ips": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3PppoeStaticAddressObject) AncestorName() string {
	return "static-address"
}

func (o EthernetInterfaceResourceLayer3PppoeStaticAddressObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) AttributeTypes() map[string]attr.Type {

	var upstreamNatObj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject
	return map[string]attr.Type{
		"enable":                  types.BoolType,
		"sdwan_interface_profile": types.StringType,
		"upstream_nat": types.ObjectType{
			AttrTypes: upstreamNatObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) AncestorName() string {
	return "sdwan-link-settings"
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) AttributeTypes() map[string]attr.Type {

	var ddnsObj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject

	var staticIpObj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	return map[string]attr.Type{
		"enable": types.BoolType,
		"ddns": types.ObjectType{
			AttrTypes: ddnsObj.AttributeTypes(),
		},
		"static_ip": types.ObjectType{
			AttrTypes: staticIpObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) AncestorName() string {
	return "upstream-nat"
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) AncestorName() string {
	return "ddns"
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"fqdn":       types.StringType,
		"ip_address": types.StringType,
	}
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) AncestorName() string {
	return "static-ip"
}

func (o EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceLogCardObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"default_gateway":      types.StringType,
		"ip_address":           types.StringType,
		"ipv6_address":         types.StringType,
		"ipv6_default_gateway": types.StringType,
		"netmask":              types.StringType,
	}
}

func (o EthernetInterfaceResourceLogCardObject) AncestorName() string {
	return "log-card"
}

func (o EthernetInterfaceResourceLogCardObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceTapObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceTapObject) AncestorName() string {
	return "tap"
}

func (o EthernetInterfaceResourceTapObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceVirtualWireObject) AttributeTypes() map[string]attr.Type {

	var lacpObj *EthernetInterfaceResourceVirtualWireLacpObject

	var lldpObj *EthernetInterfaceResourceVirtualWireLldpObject

	return map[string]attr.Type{
		"lacp": types.ObjectType{
			AttrTypes: lacpObj.AttributeTypes(),
		},
		"lldp": types.ObjectType{
			AttrTypes: lldpObj.AttributeTypes(),
		},
		"netflow_profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceVirtualWireObject) AncestorName() string {
	return "virtual-wire"
}

func (o EthernetInterfaceResourceVirtualWireObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceVirtualWireLacpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject
	return map[string]attr.Type{
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
	}
}

func (o EthernetInterfaceResourceVirtualWireLacpObject) AncestorName() string {
	return "lacp"
}

func (o EthernetInterfaceResourceVirtualWireLacpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceVirtualWireLldpObject) AttributeTypes() map[string]attr.Type {

	var highAvailabilityObj *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject

	return map[string]attr.Type{
		"enable": types.BoolType,
		"high_availability": types.ObjectType{
			AttrTypes: highAvailabilityObj.AttributeTypes(),
		},
		"profile": types.StringType,
	}
}

func (o EthernetInterfaceResourceVirtualWireLldpObject) AncestorName() string {
	return "lldp"
}

func (o EthernetInterfaceResourceVirtualWireLldpObject) EntryName() *string {
	return nil
}
func (o *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"passive_pre_negotiation": types.BoolType,
	}
}

func (o EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) AncestorName() string {
	return "high-availability"
}

func (o EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) EntryName() *string {
	return nil
}

func (o *EthernetInterfaceResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	comment_value := o.Comment.ValueStringPointer()
	var lacp_entry *ethernet.Lacp
	if !o.Lacp.IsUnknown() && !o.Lacp.IsNull() {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(ethernet.Lacp)
		}
		var object *EthernetInterfaceResourceLacpObject
		diags.Append(o.Lacp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &lacp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	linkDuplex_value := o.LinkDuplex.ValueStringPointer()
	linkSpeed_value := o.LinkSpeed.ValueStringPointer()
	linkState_value := o.LinkState.ValueStringPointer()
	var poe_entry *ethernet.Poe
	if !o.Poe.IsUnknown() && !o.Poe.IsNull() {
		if *obj != nil && (*obj).Poe != nil {
			poe_entry = (*obj).Poe
		} else {
			poe_entry = new(ethernet.Poe)
		}
		var object *EthernetInterfaceResourcePoeObject
		diags.Append(o.Poe.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &poe_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	aggregateGroup_value := o.AggregateGroup.ValueStringPointer()
	var decryptMirror_entry *ethernet.DecryptMirror
	if !o.DecryptMirror.IsUnknown() && !o.DecryptMirror.IsNull() {
		if *obj != nil && (*obj).DecryptMirror != nil {
			decryptMirror_entry = (*obj).DecryptMirror
		} else {
			decryptMirror_entry = new(ethernet.DecryptMirror)
		}
		var object *EthernetInterfaceResourceDecryptMirrorObject
		diags.Append(o.DecryptMirror.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &decryptMirror_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ha_entry *ethernet.Ha
	if !o.Ha.IsUnknown() && !o.Ha.IsNull() {
		if *obj != nil && (*obj).Ha != nil {
			ha_entry = (*obj).Ha
		} else {
			ha_entry = new(ethernet.Ha)
		}
		var object *EthernetInterfaceResourceHaObject
		diags.Append(o.Ha.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ha_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer2_entry *ethernet.Layer2
	if !o.Layer2.IsUnknown() && !o.Layer2.IsNull() {
		if *obj != nil && (*obj).Layer2 != nil {
			layer2_entry = (*obj).Layer2
		} else {
			layer2_entry = new(ethernet.Layer2)
		}
		var object *EthernetInterfaceResourceLayer2Object
		diags.Append(o.Layer2.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &layer2_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var layer3_entry *ethernet.Layer3
	if !o.Layer3.IsUnknown() && !o.Layer3.IsNull() {
		if *obj != nil && (*obj).Layer3 != nil {
			layer3_entry = (*obj).Layer3
		} else {
			layer3_entry = new(ethernet.Layer3)
		}
		var object *EthernetInterfaceResourceLayer3Object
		diags.Append(o.Layer3.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &layer3_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var logCard_entry *ethernet.LogCard
	if !o.LogCard.IsUnknown() && !o.LogCard.IsNull() {
		if *obj != nil && (*obj).LogCard != nil {
			logCard_entry = (*obj).LogCard
		} else {
			logCard_entry = new(ethernet.LogCard)
		}
		var object *EthernetInterfaceResourceLogCardObject
		diags.Append(o.LogCard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &logCard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var tap_entry *ethernet.Tap
	if !o.Tap.IsUnknown() && !o.Tap.IsNull() {
		if *obj != nil && (*obj).Tap != nil {
			tap_entry = (*obj).Tap
		} else {
			tap_entry = new(ethernet.Tap)
		}
		var object *EthernetInterfaceResourceTapObject
		diags.Append(o.Tap.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &tap_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var virtualWire_entry *ethernet.VirtualWire
	if !o.VirtualWire.IsUnknown() && !o.VirtualWire.IsNull() {
		if *obj != nil && (*obj).VirtualWire != nil {
			virtualWire_entry = (*obj).VirtualWire
		} else {
			virtualWire_entry = new(ethernet.VirtualWire)
		}
		var object *EthernetInterfaceResourceVirtualWireObject
		diags.Append(o.VirtualWire.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &virtualWire_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Comment = comment_value
	(*obj).Lacp = lacp_entry
	(*obj).LinkDuplex = linkDuplex_value
	(*obj).LinkSpeed = linkSpeed_value
	(*obj).LinkState = linkState_value
	(*obj).Poe = poe_entry
	(*obj).AggregateGroup = aggregateGroup_value
	(*obj).DecryptMirror = decryptMirror_entry
	(*obj).Ha = ha_entry
	(*obj).Layer2 = layer2_entry
	(*obj).Layer3 = layer3_entry
	(*obj).LogCard = logCard_entry
	(*obj).Tap = tap_entry
	(*obj).VirtualWire = virtualWire_entry

	return diags
}
func (o *EthernetInterfaceResourceLacpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Lacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	portPriority_value := o.PortPriority.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Lacp)
	}
	(*obj).PortPriority = portPriority_value

	return diags
}
func (o *EthernetInterfaceResourcePoeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Poe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enabled_value := o.Enabled.ValueBoolPointer()
	poeReservedPower_value := o.PoeReservedPower.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Poe)
	}
	(*obj).PoeEnabled = enabled_value
	(*obj).PoeRsvdPwr = poeReservedPower_value

	return diags
}
func (o *EthernetInterfaceResourceDecryptMirrorObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.DecryptMirror, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.DecryptMirror)
	}

	return diags
}
func (o *EthernetInterfaceResourceHaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Ha, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Ha)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer2Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var lldp_entry *ethernet.Layer2Lldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer2Lldp)
		}
		var object *EthernetInterfaceResourceLayer2LldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2)
	}
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceResourceLayer2LldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.Layer2LldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.Layer2LldpHighAvailability)
		}
		var object *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer2LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer2LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var adjustTcpMss_entry *ethernet.Layer3AdjustTcpMss
	if !o.AdjustTcpMss.IsUnknown() && !o.AdjustTcpMss.IsNull() {
		if *obj != nil && (*obj).AdjustTcpMss != nil {
			adjustTcpMss_entry = (*obj).AdjustTcpMss
		} else {
			adjustTcpMss_entry = new(ethernet.Layer3AdjustTcpMss)
		}
		var object *EthernetInterfaceResourceLayer3AdjustTcpMssObject
		diags.Append(o.AdjustTcpMss.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &adjustTcpMss_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var arp_tf_entries []EthernetInterfaceResourceLayer3ArpObject
	var arp_pango_entries []ethernet.Layer3Arp
	{
		d := o.Arp.ElementsAs(ctx, &arp_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range arp_tf_entries {
			var entry *ethernet.Layer3Arp
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			arp_pango_entries = append(arp_pango_entries, *entry)
		}
	}
	var bonjour_entry *ethernet.Layer3Bonjour
	if !o.Bonjour.IsUnknown() && !o.Bonjour.IsNull() {
		if *obj != nil && (*obj).Bonjour != nil {
			bonjour_entry = (*obj).Bonjour
		} else {
			bonjour_entry = new(ethernet.Layer3Bonjour)
		}
		var object *EthernetInterfaceResourceLayer3BonjourObject
		diags.Append(o.Bonjour.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &bonjour_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	clusterInterconnect_value := o.ClusterInterconnect.ValueBoolPointer()
	var ddnsConfig_entry *ethernet.Layer3DdnsConfig
	if !o.DdnsConfig.IsUnknown() && !o.DdnsConfig.IsNull() {
		if *obj != nil && (*obj).DdnsConfig != nil {
			ddnsConfig_entry = (*obj).DdnsConfig
		} else {
			ddnsConfig_entry = new(ethernet.Layer3DdnsConfig)
		}
		var object *EthernetInterfaceResourceLayer3DdnsConfigObject
		diags.Append(o.DdnsConfig.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ddnsConfig_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	decryptForward_value := o.DecryptForward.ValueBoolPointer()
	dfIgnore_value := o.DfIgnore.ValueBoolPointer()
	var dhcpClient_entry *ethernet.Layer3DhcpClient
	if !o.DhcpClient.IsUnknown() && !o.DhcpClient.IsNull() {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3DhcpClient)
		}
		var object *EthernetInterfaceResourceLayer3DhcpClientObject
		diags.Append(o.DhcpClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceManagementProfile_value := o.InterfaceManagementProfile.ValueStringPointer()
	var ips_tf_entries []EthernetInterfaceResourceLayer3IpsObject
	var ips_pango_entries []ethernet.Layer3Ip
	{
		d := o.Ips.ElementsAs(ctx, &ips_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ips_tf_entries {
			var entry *ethernet.Layer3Ip
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ips_pango_entries = append(ips_pango_entries, *entry)
		}
	}
	var ipv6_entry *ethernet.Layer3Ipv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(ethernet.Layer3Ipv6)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *ethernet.Layer3Lldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.Layer3Lldp)
		}
		var object *EthernetInterfaceResourceLayer3LldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	mtu_value := o.Mtu.ValueInt64Pointer()
	var ndpProxy_entry *ethernet.Layer3NdpProxy
	if !o.NdpProxy.IsUnknown() && !o.NdpProxy.IsNull() {
		if *obj != nil && (*obj).NdpProxy != nil {
			ndpProxy_entry = (*obj).NdpProxy
		} else {
			ndpProxy_entry = new(ethernet.Layer3NdpProxy)
		}
		var object *EthernetInterfaceResourceLayer3NdpProxyObject
		diags.Append(o.NdpProxy.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ndpProxy_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()
	var pppoe_entry *ethernet.Layer3Pppoe
	if !o.Pppoe.IsUnknown() && !o.Pppoe.IsNull() {
		if *obj != nil && (*obj).Pppoe != nil {
			pppoe_entry = (*obj).Pppoe
		} else {
			pppoe_entry = new(ethernet.Layer3Pppoe)
		}
		var object *EthernetInterfaceResourceLayer3PppoeObject
		diags.Append(o.Pppoe.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &pppoe_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var sdwanLinkSettings_entry *ethernet.Layer3SdwanLinkSettings
	if !o.SdwanLinkSettings.IsUnknown() && !o.SdwanLinkSettings.IsNull() {
		if *obj != nil && (*obj).SdwanLinkSettings != nil {
			sdwanLinkSettings_entry = (*obj).SdwanLinkSettings
		} else {
			sdwanLinkSettings_entry = new(ethernet.Layer3SdwanLinkSettings)
		}
		var object *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject
		diags.Append(o.SdwanLinkSettings.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sdwanLinkSettings_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	trafficInterconnect_value := o.TrafficInterconnect.ValueBoolPointer()
	untaggedSubInterface_value := o.UntaggedSubInterface.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3)
	}
	(*obj).AdjustTcpMss = adjustTcpMss_entry
	(*obj).Arp = arp_pango_entries
	(*obj).Bonjour = bonjour_entry
	(*obj).ClusterInterconnect = clusterInterconnect_value
	(*obj).DdnsConfig = ddnsConfig_entry
	(*obj).DecryptForward = decryptForward_value
	(*obj).DfIgnore = dfIgnore_value
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).InterfaceManagementProfile = interfaceManagementProfile_value
	(*obj).Ip = ips_pango_entries
	(*obj).Ipv6 = ipv6_entry
	(*obj).Lldp = lldp_entry
	(*obj).Mtu = mtu_value
	(*obj).NdpProxy = ndpProxy_entry
	(*obj).NetflowProfile = netflowProfile_value
	(*obj).Pppoe = pppoe_entry
	(*obj).SdwanLinkSettings = sdwanLinkSettings_entry
	(*obj).TrafficInterconnect = trafficInterconnect_value
	(*obj).UntaggedSubInterface = untaggedSubInterface_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3AdjustTcpMss, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	ipv4MssAdjustment_value := o.Ipv4MssAdjustment.ValueInt64Pointer()
	ipv6MssAdjustment_value := o.Ipv6MssAdjustment.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3AdjustTcpMss)
	}
	(*obj).Enable = enable_value
	(*obj).Ipv4MssAdjustment = ipv4MssAdjustment_value
	(*obj).Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3ArpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Arp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Arp)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3BonjourObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Bonjour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	groupId_value := o.GroupId.ValueInt64Pointer()
	ttlCheck_value := o.TtlCheck.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Bonjour)
	}
	(*obj).Enable = enable_value
	(*obj).GroupId = groupId_value
	(*obj).TtlCheck = ttlCheck_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3DdnsConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DdnsConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ddnsCertProfile_value := o.DdnsCertProfile.ValueStringPointer()
	ddnsEnabled_value := o.DdnsEnabled.ValueBoolPointer()
	ddnsHostname_value := o.DdnsHostname.ValueStringPointer()
	var ddnsIp_pango_entries []string
	if !o.DdnsIp.IsUnknown() && !o.DdnsIp.IsNull() {
		object_entries := make([]types.String, 0, len(o.DdnsIp.Elements()))
		diags.Append(o.DdnsIp.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ddnsIp_pango_entries = append(ddnsIp_pango_entries, elt.ValueString())
		}
	}
	var ddnsIpv6_pango_entries []string
	if !o.DdnsIpv6.IsUnknown() && !o.DdnsIpv6.IsNull() {
		object_entries := make([]types.String, 0, len(o.DdnsIpv6.Elements()))
		diags.Append(o.DdnsIpv6.ElementsAs(ctx, &object_entries, false)...)
		if diags.HasError() {
			diags.AddError("Explicit Error", "Failed something")
			return diags
		}

		for _, elt := range object_entries {
			ddnsIpv6_pango_entries = append(ddnsIpv6_pango_entries, elt.ValueString())
		}
	}
	ddnsUpdateInterval_value := o.DdnsUpdateInterval.ValueInt64Pointer()
	ddnsVendor_value := o.DdnsVendor.ValueStringPointer()
	var ddnsVendorConfig_tf_entries []EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
	var ddnsVendorConfig_pango_entries []ethernet.Layer3DdnsConfigDdnsVendorConfig
	{
		d := o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range ddnsVendorConfig_tf_entries {
			var entry *ethernet.Layer3DdnsConfigDdnsVendorConfig
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			ddnsVendorConfig_pango_entries = append(ddnsVendorConfig_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DdnsConfig)
	}
	(*obj).DdnsCertProfile = ddnsCertProfile_value
	(*obj).DdnsEnabled = ddnsEnabled_value
	(*obj).DdnsHostname = ddnsHostname_value
	(*obj).DdnsIp = ddnsIp_pango_entries
	(*obj).DdnsIpv6 = ddnsIpv6_pango_entries
	(*obj).DdnsUpdateInterval = ddnsUpdateInterval_value
	(*obj).DdnsVendor = ddnsVendor_value
	(*obj).DdnsVendorConfig = ddnsVendorConfig_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DdnsConfigDdnsVendorConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	value_value := o.Value.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DdnsConfigDdnsVendorConfig)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Value = value_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3DhcpClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var sendHostname_entry *ethernet.Layer3DhcpClientSendHostname
	if !o.SendHostname.IsUnknown() && !o.SendHostname.IsNull() {
		if *obj != nil && (*obj).SendHostname != nil {
			sendHostname_entry = (*obj).SendHostname
		} else {
			sendHostname_entry = new(ethernet.Layer3DhcpClientSendHostname)
		}
		var object *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject
		diags.Append(o.SendHostname.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendHostname_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClient)
	}
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).SendHostname = sendHostname_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3DhcpClientSendHostname, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	hostname_value := o.Hostname.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3DhcpClientSendHostname)
	}
	(*obj).Enable = enable_value
	(*obj).Hostname = hostname_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3IpsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	sdwanGateway_value := o.SdwanGateway.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ip)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).SdwanGateway = sdwanGateway_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_tf_entries []EthernetInterfaceResourceLayer3Ipv6AddressesObject
	var addresses_pango_entries []ethernet.Layer3Ipv6Address
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3Ipv6Address
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}
	var dhcpClient_entry *ethernet.Layer3Ipv6DhcpClient
	if !o.DhcpClient.IsUnknown() && !o.DhcpClient.IsNull() {
		if *obj != nil && (*obj).DhcpClient != nil {
			dhcpClient_entry = (*obj).DhcpClient
		} else {
			dhcpClient_entry = new(ethernet.Layer3Ipv6DhcpClient)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject
		diags.Append(o.DhcpClient.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpClient_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()
	var inherited_entry *ethernet.Layer3Ipv6Inherited
	if !o.Inherited.IsUnknown() && !o.Inherited.IsNull() {
		if *obj != nil && (*obj).Inherited != nil {
			inherited_entry = (*obj).Inherited
		} else {
			inherited_entry = new(ethernet.Layer3Ipv6Inherited)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedObject
		diags.Append(o.Inherited.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &inherited_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	interfaceId_value := o.InterfaceId.ValueStringPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6NeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6NeighborDiscovery)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6)
	}
	(*obj).Address = addresses_pango_entries
	(*obj).DhcpClient = dhcpClient_entry
	(*obj).Enabled = enabled_value
	(*obj).Inherited = inherited_entry
	(*obj).InterfaceId = interfaceId_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	var prefix_entry *ethernet.Layer3Ipv6AddressPrefix
	if !o.Prefix.IsUnknown() && !o.Prefix.IsNull() {
		if *obj != nil && (*obj).Prefix != nil {
			prefix_entry = (*obj).Prefix
		} else {
			prefix_entry = new(ethernet.Layer3Ipv6AddressPrefix)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject
		diags.Append(o.Prefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &prefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var anycast_entry *ethernet.Layer3Ipv6AddressAnycast
	if !o.Anycast.IsUnknown() && !o.Anycast.IsNull() {
		if *obj != nil && (*obj).Anycast != nil {
			anycast_entry = (*obj).Anycast
		} else {
			anycast_entry = new(ethernet.Layer3Ipv6AddressAnycast)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject
		diags.Append(o.Anycast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &anycast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *ethernet.Layer3Ipv6AddressAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6AddressAdvertise)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Address)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Prefix = prefix_entry
	(*obj).Anycast = anycast_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressPrefix)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressAnycast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressAnycast)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6AddressAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6AddressAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	acceptRaRoute_value := o.AcceptRaRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscovery)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	preference_value := o.Preference.ValueStringPointer()
	var prefixDelegation_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegation
	if !o.PrefixDelegation.IsUnknown() && !o.PrefixDelegation.IsNull() {
		if *obj != nil && (*obj).PrefixDelegation != nil {
			prefixDelegation_entry = (*obj).PrefixDelegation
		} else {
			prefixDelegation_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegation)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject
		diags.Append(o.PrefixDelegation.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &prefixDelegation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var v6Options_entry *ethernet.Layer3Ipv6DhcpClientV6Options
	if !o.V6Options.IsUnknown() && !o.V6Options.IsNull() {
		if *obj != nil && (*obj).V6Options != nil {
			v6Options_entry = (*obj).V6Options
		} else {
			v6Options_entry = new(ethernet.Layer3Ipv6DhcpClientV6Options)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject
		diags.Append(o.V6Options.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &v6Options_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClient)
	}
	(*obj).AcceptRaRoute = acceptRaRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry
	(*obj).Preference = preference_value
	(*obj).PrefixDelegation = prefixDelegation_entry
	(*obj).V6Options = v6Options_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
		diags.Append(o.DnsServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
		diags.Append(o.DnsSuffix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSuffix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var enable_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable
	if !o.Enable.IsUnknown() && !o.Enable.IsNull() {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
		diags.Append(o.Enable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &enable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegation)
	}
	(*obj).Enable = enable_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	pfxPoolName_value := o.PfxPoolName.ValueStringPointer()
	prefixLen_value := o.PrefixLen.ValueInt64Pointer()
	prefixLenHint_value := o.PrefixLenHint.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes)
	}
	(*obj).PfxPoolName = pfxPoolName_value
	(*obj).PrefixLen = prefixLen_value
	(*obj).PrefixLenHint = prefixLenHint_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6Options, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	duidType_value := o.DuidType.ValueStringPointer()
	var enable_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnable
	if !o.Enable.IsUnknown() && !o.Enable.IsNull() {
		if *obj != nil && (*obj).Enable != nil {
			enable_entry = (*obj).Enable
		} else {
			enable_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnable)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject
		diags.Append(o.Enable.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &enable_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	rapidCommit_value := o.RapidCommit.ValueBoolPointer()
	supportSrvrReconfig_value := o.SupportSrvrReconfig.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6Options)
	}
	(*obj).DuidType = duidType_value
	(*obj).Enable = enable_entry
	(*obj).RapidCommit = rapidCommit_value
	(*obj).SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var no_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo
	if !o.No.IsUnknown() && !o.No.IsNull() {
		if *obj != nil && (*obj).No != nil {
			no_entry = (*obj).No
		} else {
			no_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
		diags.Append(o.No.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &no_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var yes_entry *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes
	if !o.Yes.IsUnknown() && !o.Yes.IsNull() {
		if *obj != nil && (*obj).Yes != nil {
			yes_entry = (*obj).Yes
		} else {
			yes_entry = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
		diags.Append(o.Yes.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &yes_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnable)
	}
	(*obj).No = no_entry
	(*obj).Yes = yes_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	nonTempAddr_value := o.NonTempAddr.ValueBoolPointer()
	tempAddr_value := o.TempAddr.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes)
	}
	(*obj).NonTempAddr = nonTempAddr_value
	(*obj).TempAddr = tempAddr_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6Inherited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject
	var assignAddr_pango_entries []ethernet.Layer3Ipv6InheritedAssignAddr
	{
		d := o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range assignAddr_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedAssignAddr
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			assignAddr_pango_entries = append(assignAddr_pango_entries, *entry)
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	var neighborDiscovery_entry *ethernet.Layer3Ipv6InheritedNeighborDiscovery
	if !o.NeighborDiscovery.IsUnknown() && !o.NeighborDiscovery.IsNull() {
		if *obj != nil && (*obj).NeighborDiscovery != nil {
			neighborDiscovery_entry = (*obj).NeighborDiscovery
		} else {
			neighborDiscovery_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscovery)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject
		diags.Append(o.NeighborDiscovery.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &neighborDiscovery_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6Inherited)
	}
	(*obj).AssignAddr = assignAddr_pango_entries
	(*obj).Enable = enable_value
	(*obj).NeighborDiscovery = neighborDiscovery_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var type_entry *ethernet.Layer3Ipv6InheritedAssignAddrType
	if !o.Type.IsUnknown() && !o.Type.IsNull() {
		if *obj != nil && (*obj).Type != nil {
			type_entry = (*obj).Type
		} else {
			type_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrType)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject
		diags.Append(o.Type.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &type_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddr)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Type = type_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var gua_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGua
	if !o.Gua.IsUnknown() && !o.Gua.IsNull() {
		if *obj != nil && (*obj).Gua != nil {
			gua_entry = (*obj).Gua
		} else {
			gua_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGua)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
		diags.Append(o.Gua.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &gua_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ula_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeUla
	if !o.Ula.IsUnknown() && !o.Ula.IsNull() {
		if *obj != nil && (*obj).Ula != nil {
			ula_entry = (*obj).Ula
		} else {
			ula_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUla)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
		diags.Append(o.Ula.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ula_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrType)
	}
	(*obj).Gua = gua_entry
	(*obj).Ula = ula_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGua, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	prefixPool_value := o.PrefixPool.ValueStringPointer()
	var poolType_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType
	if !o.PoolType.IsUnknown() && !o.PoolType.IsNull() {
		if *obj != nil && (*obj).PoolType != nil {
			poolType_entry = (*obj).PoolType
		} else {
			poolType_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
		diags.Append(o.PoolType.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &poolType_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var advertise_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGua)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).PrefixPool = prefixPool_value
	(*obj).PoolType = poolType_entry
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dynamic_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic
	if !o.Dynamic.IsUnknown() && !o.Dynamic.IsNull() {
		if *obj != nil && (*obj).Dynamic != nil {
			dynamic_entry = (*obj).Dynamic
		} else {
			dynamic_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
		diags.Append(o.Dynamic.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamic_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dynamicId_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId
	if !o.DynamicId.IsUnknown() && !o.DynamicId.IsNull() {
		if *obj != nil && (*obj).DynamicId != nil {
			dynamicId_entry = (*obj).DynamicId
		} else {
			dynamicId_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
		diags.Append(o.DynamicId.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dynamicId_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType)
	}
	(*obj).Dynamic = dynamic_entry
	(*obj).DynamicId = dynamicId_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	identifier_value := o.Identifier.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId)
	}
	(*obj).Identifier = identifier_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeUla, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enableOnInterface_value := o.EnableOnInterface.ValueBoolPointer()
	addresses_value := o.Addresses.ValueStringPointer()
	prefix_value := o.Prefix.ValueBoolPointer()
	anycast_value := o.Anycast.ValueBoolPointer()
	var advertise_entry *ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise
	if !o.Advertise.IsUnknown() && !o.Advertise.IsNull() {
		if *obj != nil && (*obj).Advertise != nil {
			advertise_entry = (*obj).Advertise
		} else {
			advertise_entry = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
		diags.Append(o.Advertise.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &advertise_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUla)
	}
	(*obj).EnableOnInterface = enableOnInterface_value
	(*obj).Address = addresses_value
	(*obj).Prefix = prefix_value
	(*obj).Anycast = anycast_value
	(*obj).Advertise = advertise_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	validLifetime_value := o.ValidLifetime.ValueStringPointer()
	preferredLifetime_value := o.PreferredLifetime.ValueStringPointer()
	onlinkFlag_value := o.OnlinkFlag.ValueBoolPointer()
	autoConfigFlag_value := o.AutoConfigFlag.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise)
	}
	(*obj).Enable = enable_value
	(*obj).ValidLifetime = validLifetime_value
	(*obj).PreferredLifetime = preferredLifetime_value
	(*obj).OnlinkFlag = onlinkFlag_value
	(*obj).AutoConfigFlag = autoConfigFlag_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	var dnsServer_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer
	if !o.DnsServer.IsUnknown() && !o.DnsServer.IsNull() {
		if *obj != nil && (*obj).DnsServer != nil {
			dnsServer_entry = (*obj).DnsServer
		} else {
			dnsServer_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
		diags.Append(o.DnsServer.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsServer_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var dnsSuffix_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix
	if !o.DnsSuffix.IsUnknown() && !o.DnsSuffix.IsNull() {
		if *obj != nil && (*obj).DnsSuffix != nil {
			dnsSuffix_entry = (*obj).DnsSuffix
		} else {
			dnsSuffix_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
		diags.Append(o.DnsSuffix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSuffix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement
	if !o.RouterAdvertisement.IsUnknown() && !o.RouterAdvertisement.IsNull() {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
		diags.Append(o.RouterAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routerAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).DnsServer = dnsServer_entry
	(*obj).DnsSuffix = dnsSuffix_entry
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
	var server_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual)
	}
	(*obj).Server = server_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var source_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource
	if !o.Source.IsUnknown() && !o.Source.IsNull() {
		if *obj != nil && (*obj).Source != nil {
			source_entry = (*obj).Source
		} else {
			source_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
		diags.Append(o.Source.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &source_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix)
	}
	(*obj).Enable = enable_value
	(*obj).Source = source_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dhcpv6_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6
	if !o.Dhcpv6.IsUnknown() && !o.Dhcpv6.IsNull() {
		if *obj != nil && (*obj).Dhcpv6 != nil {
			dhcpv6_entry = (*obj).Dhcpv6
		} else {
			dhcpv6_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
		diags.Append(o.Dhcpv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dhcpv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var manual_entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual
	if !o.Manual.IsUnknown() && !o.Manual.IsNull() {
		if *obj != nil && (*obj).Manual != nil {
			manual_entry = (*obj).Manual
		} else {
			manual_entry = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
		diags.Append(o.Manual.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &manual_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource)
	}
	(*obj).Dhcpv6 = dhcpv6_entry
	(*obj).Manual = manual_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	prefixPool_value := o.PrefixPool.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6)
	}
	(*obj).PrefixPool = prefixPool_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual)
	}
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement)
	}
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	dadAttempts_value := o.DadAttempts.ValueInt64Pointer()
	enableDad_value := o.EnableDad.ValueBoolPointer()
	enableNdpMonitor_value := o.EnableNdpMonitor.ValueBoolPointer()
	var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
	var neighbor_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
	{
		d := o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range neighbor_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			neighbor_pango_entries = append(neighbor_pango_entries, *entry)
		}
	}
	nsInterval_value := o.NsInterval.ValueInt64Pointer()
	reachableTime_value := o.ReachableTime.ValueInt64Pointer()
	var routerAdvertisement_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement
	if !o.RouterAdvertisement.IsUnknown() && !o.RouterAdvertisement.IsNull() {
		if *obj != nil && (*obj).RouterAdvertisement != nil {
			routerAdvertisement_entry = (*obj).RouterAdvertisement
		} else {
			routerAdvertisement_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
		diags.Append(o.RouterAdvertisement.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &routerAdvertisement_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscovery)
	}
	(*obj).DadAttempts = dadAttempts_value
	(*obj).EnableDad = enableDad_value
	(*obj).EnableNdpMonitor = enableNdpMonitor_value
	(*obj).Neighbor = neighbor_pango_entries
	(*obj).NsInterval = nsInterval_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RouterAdvertisement = routerAdvertisement_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	hwAddress_value := o.HwAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryNeighbor)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).HwAddress = hwAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var dnsSupport_entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport
	if !o.DnsSupport.IsUnknown() && !o.DnsSupport.IsNull() {
		if *obj != nil && (*obj).DnsSupport != nil {
			dnsSupport_entry = (*obj).DnsSupport
		} else {
			dnsSupport_entry = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
		}
		var object *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
		diags.Append(o.DnsSupport.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &dnsSupport_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	enable_value := o.Enable.ValueBoolPointer()
	enableConsistencyCheck_value := o.EnableConsistencyCheck.ValueBoolPointer()
	hopLimit_value := o.HopLimit.ValueStringPointer()
	lifetime_value := o.Lifetime.ValueInt64Pointer()
	linkMtu_value := o.LinkMtu.ValueStringPointer()
	managedFlag_value := o.ManagedFlag.ValueBoolPointer()
	maxInterval_value := o.MaxInterval.ValueInt64Pointer()
	minInterval_value := o.MinInterval.ValueInt64Pointer()
	otherFlag_value := o.OtherFlag.ValueBoolPointer()
	reachableTime_value := o.ReachableTime.ValueStringPointer()
	retransmissionTimer_value := o.RetransmissionTimer.ValueStringPointer()
	routerPreference_value := o.RouterPreference.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement)
	}
	(*obj).DnsSupport = dnsSupport_entry
	(*obj).Enable = enable_value
	(*obj).EnableConsistencyCheck = enableConsistencyCheck_value
	(*obj).HopLimit = hopLimit_value
	(*obj).Lifetime = lifetime_value
	(*obj).LinkMtu = linkMtu_value
	(*obj).ManagedFlag = managedFlag_value
	(*obj).MaxInterval = maxInterval_value
	(*obj).MinInterval = minInterval_value
	(*obj).OtherFlag = otherFlag_value
	(*obj).ReachableTime = reachableTime_value
	(*obj).RetransmissionTimer = retransmissionTimer_value
	(*obj).RouterPreference = routerPreference_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
	var server_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
	{
		d := o.Server.ElementsAs(ctx, &server_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range server_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			server_pango_entries = append(server_pango_entries, *entry)
		}
	}
	var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
	var suffix_pango_entries []ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
	{
		d := o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range suffix_tf_entries {
			var entry *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			suffix_pango_entries = append(suffix_pango_entries, *entry)
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport)
	}
	(*obj).Enable = enable_value
	(*obj).Server = server_pango_entries
	(*obj).Suffix = suffix_pango_entries

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	lifetime_value := o.Lifetime.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Lifetime = lifetime_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3LldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.Layer3LldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.Layer3LldpHighAvailability)
		}
		var object *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Lldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3LldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3NdpProxyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3NdpProxy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_tf_entries []EthernetInterfaceResourceLayer3NdpProxyAddressesObject
	var addresses_pango_entries []ethernet.Layer3NdpProxyAddress
	{
		d := o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)
		diags.Append(d...)
		if diags.HasError() {
			return diags
		}
		for _, elt := range addresses_tf_entries {
			var entry *ethernet.Layer3NdpProxyAddress
			diags.Append(elt.CopyToPango(ctx, client, append(ancestors, elt), &entry, ev)...)
			if diags.HasError() {
				return diags
			}
			addresses_pango_entries = append(addresses_pango_entries, *entry)
		}
	}
	enabled_value := o.Enabled.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3NdpProxy)
	}
	(*obj).Address = addresses_pango_entries
	(*obj).Enabled = enabled_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3NdpProxyAddressesObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3NdpProxyAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	negate_value := o.Negate.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3NdpProxyAddress)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Negate = negate_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3PppoeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3Pppoe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	accessConcentrator_value := o.AccessConcentrator.ValueStringPointer()
	authentication_value := o.Authentication.ValueStringPointer()
	createDefaultRoute_value := o.CreateDefaultRoute.ValueBoolPointer()
	defaultRouteMetric_value := o.DefaultRouteMetric.ValueInt64Pointer()
	enable_value := o.Enable.ValueBoolPointer()
	var passive_entry *ethernet.Layer3PppoePassive
	if !o.Passive.IsUnknown() && !o.Passive.IsNull() {
		if *obj != nil && (*obj).Passive != nil {
			passive_entry = (*obj).Passive
		} else {
			passive_entry = new(ethernet.Layer3PppoePassive)
		}
		var object *EthernetInterfaceResourceLayer3PppoePassiveObject
		diags.Append(o.Passive.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &passive_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	password_value := o.Password.ValueStringPointer()
	service_value := o.Service.ValueStringPointer()
	var staticAddress_entry *ethernet.Layer3PppoeStaticAddress
	if !o.StaticAddress.IsUnknown() && !o.StaticAddress.IsNull() {
		if *obj != nil && (*obj).StaticAddress != nil {
			staticAddress_entry = (*obj).StaticAddress
		} else {
			staticAddress_entry = new(ethernet.Layer3PppoeStaticAddress)
		}
		var object *EthernetInterfaceResourceLayer3PppoeStaticAddressObject
		diags.Append(o.StaticAddress.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticAddress_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	username_value := o.Username.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3Pppoe)
	}
	(*obj).AccessConcentrator = accessConcentrator_value
	(*obj).Authentication = authentication_value
	(*obj).CreateDefaultRoute = createDefaultRoute_value
	(*obj).DefaultRouteMetric = defaultRouteMetric_value
	(*obj).Enable = enable_value
	(*obj).Passive = passive_entry
	(*obj).Password = password_value
	(*obj).Service = service_value
	(*obj).StaticAddress = staticAddress_entry
	(*obj).Username = username_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3PppoePassiveObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3PppoePassive, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3PppoePassive)
	}
	(*obj).Enable = enable_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3PppoeStaticAddressObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3PppoeStaticAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	ips_value := o.Ips.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3PppoeStaticAddress)
	}
	(*obj).Ip = ips_value

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	sdwanInterfaceProfile_value := o.SdwanInterfaceProfile.ValueStringPointer()
	var upstreamNat_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNat
	if !o.UpstreamNat.IsUnknown() && !o.UpstreamNat.IsNull() {
		if *obj != nil && (*obj).UpstreamNat != nil {
			upstreamNat_entry = (*obj).UpstreamNat
		} else {
			upstreamNat_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
		}
		var object *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject
		diags.Append(o.UpstreamNat.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &upstreamNat_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettings)
	}
	(*obj).Enable = enable_value
	(*obj).SdwanInterfaceProfile = sdwanInterfaceProfile_value
	(*obj).UpstreamNat = upstreamNat_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNat, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var ddns_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns
	if !o.Ddns.IsUnknown() && !o.Ddns.IsNull() {
		if *obj != nil && (*obj).Ddns != nil {
			ddns_entry = (*obj).Ddns
		} else {
			ddns_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns)
		}
		var object *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
		diags.Append(o.Ddns.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &ddns_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var staticIp_entry *ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp
	if !o.StaticIp.IsUnknown() && !o.StaticIp.IsNull() {
		if *obj != nil && (*obj).StaticIp != nil {
			staticIp_entry = (*obj).StaticIp
		} else {
			staticIp_entry = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
		}
		var object *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
		diags.Append(o.StaticIp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &staticIp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNat)
	}
	(*obj).Enable = enable_value
	(*obj).Ddns = ddns_entry
	(*obj).StaticIp = staticIp_entry

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns)
	}

	return diags
}
func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	fqdn_value := o.Fqdn.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp)
	}
	(*obj).Fqdn = fqdn_value
	(*obj).IpAddress = ipAddress_value

	return diags
}
func (o *EthernetInterfaceResourceLogCardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.LogCard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	defaultGateway_value := o.DefaultGateway.ValueStringPointer()
	ipAddress_value := o.IpAddress.ValueStringPointer()
	ipv6Address_value := o.Ipv6Address.ValueStringPointer()
	ipv6DefaultGateway_value := o.Ipv6DefaultGateway.ValueStringPointer()
	netmask_value := o.Netmask.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.LogCard)
	}
	(*obj).DefaultGateway = defaultGateway_value
	(*obj).IpAddress = ipAddress_value
	(*obj).Ipv6Address = ipv6Address_value
	(*obj).Ipv6DefaultGateway = ipv6DefaultGateway_value
	(*obj).Netmask = netmask_value

	return diags
}
func (o *EthernetInterfaceResourceTapObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.Tap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.Tap)
	}
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceResourceVirtualWireObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var lacp_entry *ethernet.VirtualWireLacp
	if !o.Lacp.IsUnknown() && !o.Lacp.IsNull() {
		if *obj != nil && (*obj).Lacp != nil {
			lacp_entry = (*obj).Lacp
		} else {
			lacp_entry = new(ethernet.VirtualWireLacp)
		}
		var object *EthernetInterfaceResourceVirtualWireLacpObject
		diags.Append(o.Lacp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lacp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var lldp_entry *ethernet.VirtualWireLldp
	if !o.Lldp.IsUnknown() && !o.Lldp.IsNull() {
		if *obj != nil && (*obj).Lldp != nil {
			lldp_entry = (*obj).Lldp
		} else {
			lldp_entry = new(ethernet.VirtualWireLldp)
		}
		var object *EthernetInterfaceResourceVirtualWireLldpObject
		diags.Append(o.Lldp.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &lldp_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	netflowProfile_value := o.NetflowProfile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWire)
	}
	(*obj).Lacp = lacp_entry
	(*obj).Lldp = lldp_entry
	(*obj).NetflowProfile = netflowProfile_value

	return diags
}
func (o *EthernetInterfaceResourceVirtualWireLacpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var highAvailability_entry *ethernet.VirtualWireLacpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.VirtualWireLacpHighAvailability)
		}
		var object *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLacp)
	}
	(*obj).HighAvailability = highAvailability_entry

	return diags
}
func (o *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLacpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLacpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}
func (o *EthernetInterfaceResourceVirtualWireLldpObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	enable_value := o.Enable.ValueBoolPointer()
	var highAvailability_entry *ethernet.VirtualWireLldpHighAvailability
	if !o.HighAvailability.IsUnknown() && !o.HighAvailability.IsNull() {
		if *obj != nil && (*obj).HighAvailability != nil {
			highAvailability_entry = (*obj).HighAvailability
		} else {
			highAvailability_entry = new(ethernet.VirtualWireLldpHighAvailability)
		}
		var object *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject
		diags.Append(o.HighAvailability.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &highAvailability_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	profile_value := o.Profile.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLldp)
	}
	(*obj).Enable = enable_value
	(*obj).HighAvailability = highAvailability_entry
	(*obj).Profile = profile_value

	return diags
}
func (o *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **ethernet.VirtualWireLldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	passivePreNegotiation_value := o.PassivePreNegotiation.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(ethernet.VirtualWireLldpHighAvailability)
	}
	(*obj).PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lacp_obj *EthernetInterfaceResourceLacpObject
	if o.Lacp.IsNull() {
		lacp_obj = new(EthernetInterfaceResourceLacpObject)
	} else {
		diags.Append(o.Lacp.As(ctx, &lacp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lacp_object := types.ObjectNull(lacp_obj.AttributeTypes())
	if obj.Lacp != nil {
		diags.Append(lacp_obj.CopyFromPango(ctx, client, ancestors, obj.Lacp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lacp_object, diags_tmp = types.ObjectValueFrom(ctx, lacp_obj.AttributeTypes(), lacp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var poe_obj *EthernetInterfaceResourcePoeObject
	if o.Poe.IsNull() {
		poe_obj = new(EthernetInterfaceResourcePoeObject)
	} else {
		diags.Append(o.Poe.As(ctx, &poe_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	poe_object := types.ObjectNull(poe_obj.AttributeTypes())
	if obj.Poe != nil {
		diags.Append(poe_obj.CopyFromPango(ctx, client, ancestors, obj.Poe, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		poe_object, diags_tmp = types.ObjectValueFrom(ctx, poe_obj.AttributeTypes(), poe_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var decryptMirror_obj *EthernetInterfaceResourceDecryptMirrorObject
	if o.DecryptMirror.IsNull() {
		decryptMirror_obj = new(EthernetInterfaceResourceDecryptMirrorObject)
	} else {
		diags.Append(o.DecryptMirror.As(ctx, &decryptMirror_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	decryptMirror_object := types.ObjectNull(decryptMirror_obj.AttributeTypes())
	if obj.DecryptMirror != nil {
		diags.Append(decryptMirror_obj.CopyFromPango(ctx, client, ancestors, obj.DecryptMirror, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		decryptMirror_object, diags_tmp = types.ObjectValueFrom(ctx, decryptMirror_obj.AttributeTypes(), decryptMirror_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ha_obj *EthernetInterfaceResourceHaObject
	if o.Ha.IsNull() {
		ha_obj = new(EthernetInterfaceResourceHaObject)
	} else {
		diags.Append(o.Ha.As(ctx, &ha_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ha_object := types.ObjectNull(ha_obj.AttributeTypes())
	if obj.Ha != nil {
		diags.Append(ha_obj.CopyFromPango(ctx, client, ancestors, obj.Ha, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ha_object, diags_tmp = types.ObjectValueFrom(ctx, ha_obj.AttributeTypes(), ha_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var layer2_obj *EthernetInterfaceResourceLayer2Object
	if o.Layer2.IsNull() {
		layer2_obj = new(EthernetInterfaceResourceLayer2Object)
	} else {
		diags.Append(o.Layer2.As(ctx, &layer2_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	layer2_object := types.ObjectNull(layer2_obj.AttributeTypes())
	if obj.Layer2 != nil {
		diags.Append(layer2_obj.CopyFromPango(ctx, client, ancestors, obj.Layer2, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		layer2_object, diags_tmp = types.ObjectValueFrom(ctx, layer2_obj.AttributeTypes(), layer2_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var layer3_obj *EthernetInterfaceResourceLayer3Object
	if o.Layer3.IsNull() {
		layer3_obj = new(EthernetInterfaceResourceLayer3Object)
	} else {
		diags.Append(o.Layer3.As(ctx, &layer3_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	layer3_object := types.ObjectNull(layer3_obj.AttributeTypes())
	if obj.Layer3 != nil {
		diags.Append(layer3_obj.CopyFromPango(ctx, client, ancestors, obj.Layer3, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		layer3_object, diags_tmp = types.ObjectValueFrom(ctx, layer3_obj.AttributeTypes(), layer3_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var logCard_obj *EthernetInterfaceResourceLogCardObject
	if o.LogCard.IsNull() {
		logCard_obj = new(EthernetInterfaceResourceLogCardObject)
	} else {
		diags.Append(o.LogCard.As(ctx, &logCard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	logCard_object := types.ObjectNull(logCard_obj.AttributeTypes())
	if obj.LogCard != nil {
		diags.Append(logCard_obj.CopyFromPango(ctx, client, ancestors, obj.LogCard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		logCard_object, diags_tmp = types.ObjectValueFrom(ctx, logCard_obj.AttributeTypes(), logCard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var tap_obj *EthernetInterfaceResourceTapObject
	if o.Tap.IsNull() {
		tap_obj = new(EthernetInterfaceResourceTapObject)
	} else {
		diags.Append(o.Tap.As(ctx, &tap_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	tap_object := types.ObjectNull(tap_obj.AttributeTypes())
	if obj.Tap != nil {
		diags.Append(tap_obj.CopyFromPango(ctx, client, ancestors, obj.Tap, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		tap_object, diags_tmp = types.ObjectValueFrom(ctx, tap_obj.AttributeTypes(), tap_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var virtualWire_obj *EthernetInterfaceResourceVirtualWireObject
	if o.VirtualWire.IsNull() {
		virtualWire_obj = new(EthernetInterfaceResourceVirtualWireObject)
	} else {
		diags.Append(o.VirtualWire.As(ctx, &virtualWire_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	virtualWire_object := types.ObjectNull(virtualWire_obj.AttributeTypes())
	if obj.VirtualWire != nil {
		diags.Append(virtualWire_obj.CopyFromPango(ctx, client, ancestors, obj.VirtualWire, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		virtualWire_object, diags_tmp = types.ObjectValueFrom(ctx, virtualWire_obj.AttributeTypes(), virtualWire_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var comment_value types.String
	if obj.Comment != nil {
		comment_value = types.StringValue(*obj.Comment)
	}
	var linkDuplex_value types.String
	if obj.LinkDuplex != nil {
		linkDuplex_value = types.StringValue(*obj.LinkDuplex)
	}
	var linkSpeed_value types.String
	if obj.LinkSpeed != nil {
		linkSpeed_value = types.StringValue(*obj.LinkSpeed)
	}
	var linkState_value types.String
	if obj.LinkState != nil {
		linkState_value = types.StringValue(*obj.LinkState)
	}
	var aggregateGroup_value types.String
	if obj.AggregateGroup != nil {
		aggregateGroup_value = types.StringValue(*obj.AggregateGroup)
	}
	o.Name = types.StringValue(obj.Name)
	o.Comment = comment_value
	o.Lacp = lacp_object
	o.LinkDuplex = linkDuplex_value
	o.LinkSpeed = linkSpeed_value
	o.LinkState = linkState_value
	o.Poe = poe_object
	o.AggregateGroup = aggregateGroup_value
	o.DecryptMirror = decryptMirror_object
	o.Ha = ha_object
	o.Layer2 = layer2_object
	o.Layer3 = layer3_object
	o.LogCard = logCard_object
	o.Tap = tap_object
	o.VirtualWire = virtualWire_object

	return diags
}

func (o *EthernetInterfaceResourceLacpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Lacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var portPriority_value types.Int64
	if obj.PortPriority != nil {
		portPriority_value = types.Int64Value(*obj.PortPriority)
	}
	o.PortPriority = portPriority_value

	return diags
}

func (o *EthernetInterfaceResourcePoeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Poe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enabled_value types.Bool
	if obj.PoeEnabled != nil {
		enabled_value = types.BoolValue(*obj.PoeEnabled)
	}
	var poeReservedPower_value types.Int64
	if obj.PoeRsvdPwr != nil {
		poeReservedPower_value = types.Int64Value(*obj.PoeRsvdPwr)
	}
	o.Enabled = enabled_value
	o.PoeReservedPower = poeReservedPower_value

	return diags
}

func (o *EthernetInterfaceResourceDecryptMirrorObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.DecryptMirror, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceHaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Ha, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer2Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lldp_obj *EthernetInterfaceResourceLayer2LldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceResourceLayer2LldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceResourceLayer2LldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceResourceLayer2LldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceResourceLayer2LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer2LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var arp_list types.List
	{
		var arp_tf_entries []EthernetInterfaceResourceLayer3ArpObject
		if !o.Arp.IsNull() {
			diags.Append(o.Arp.ElementsAs(ctx, &arp_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Arp {
			entry := EthernetInterfaceResourceLayer3ArpObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(arp_tf_entries) {
				entry = arp_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(arp_tf_entries) {
				arp_tf_entries[idx] = entry
			} else {
				arp_tf_entries = append(arp_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("arp")
		arp_list, list_diags = types.ListValueFrom(ctx, schemaType, arp_tf_entries)
		diags.Append(list_diags...)
	}
	var ips_list types.List
	{
		var ips_tf_entries []EthernetInterfaceResourceLayer3IpsObject
		if !o.Ips.IsNull() {
			diags.Append(o.Ips.ElementsAs(ctx, &ips_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Ip {
			entry := EthernetInterfaceResourceLayer3IpsObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ips_tf_entries) {
				entry = ips_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ips_tf_entries) {
				ips_tf_entries[idx] = entry
			} else {
				ips_tf_entries = append(ips_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ips")
		ips_list, list_diags = types.ListValueFrom(ctx, schemaType, ips_tf_entries)
		diags.Append(list_diags...)
	}

	var adjustTcpMss_obj *EthernetInterfaceResourceLayer3AdjustTcpMssObject
	if o.AdjustTcpMss.IsNull() {
		adjustTcpMss_obj = new(EthernetInterfaceResourceLayer3AdjustTcpMssObject)
	} else {
		diags.Append(o.AdjustTcpMss.As(ctx, &adjustTcpMss_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	adjustTcpMss_object := types.ObjectNull(adjustTcpMss_obj.AttributeTypes())
	if obj.AdjustTcpMss != nil {
		diags.Append(adjustTcpMss_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AdjustTcpMss, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		adjustTcpMss_object, diags_tmp = types.ObjectValueFrom(ctx, adjustTcpMss_obj.AttributeTypes(), adjustTcpMss_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var bonjour_obj *EthernetInterfaceResourceLayer3BonjourObject
	if o.Bonjour.IsNull() {
		bonjour_obj = new(EthernetInterfaceResourceLayer3BonjourObject)
	} else {
		diags.Append(o.Bonjour.As(ctx, &bonjour_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	bonjour_object := types.ObjectNull(bonjour_obj.AttributeTypes())
	if obj.Bonjour != nil {
		diags.Append(bonjour_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Bonjour, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		bonjour_object, diags_tmp = types.ObjectValueFrom(ctx, bonjour_obj.AttributeTypes(), bonjour_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ddnsConfig_obj *EthernetInterfaceResourceLayer3DdnsConfigObject
	if o.DdnsConfig.IsNull() {
		ddnsConfig_obj = new(EthernetInterfaceResourceLayer3DdnsConfigObject)
	} else {
		diags.Append(o.DdnsConfig.As(ctx, &ddnsConfig_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ddnsConfig_object := types.ObjectNull(ddnsConfig_obj.AttributeTypes())
	if obj.DdnsConfig != nil {
		diags.Append(ddnsConfig_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DdnsConfig, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ddnsConfig_object, diags_tmp = types.ObjectValueFrom(ctx, ddnsConfig_obj.AttributeTypes(), ddnsConfig_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dhcpClient_obj *EthernetInterfaceResourceLayer3DhcpClientObject
	if o.DhcpClient.IsNull() {
		dhcpClient_obj = new(EthernetInterfaceResourceLayer3DhcpClientObject)
	} else {
		diags.Append(o.DhcpClient.As(ctx, &dhcpClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpClient_object := types.ObjectNull(dhcpClient_obj.AttributeTypes())
	if obj.DhcpClient != nil {
		diags.Append(dhcpClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DhcpClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpClient_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpClient_obj.AttributeTypes(), dhcpClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *EthernetInterfaceResourceLayer3Ipv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(EthernetInterfaceResourceLayer3Ipv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var lldp_obj *EthernetInterfaceResourceLayer3LldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceResourceLayer3LldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ndpProxy_obj *EthernetInterfaceResourceLayer3NdpProxyObject
	if o.NdpProxy.IsNull() {
		ndpProxy_obj = new(EthernetInterfaceResourceLayer3NdpProxyObject)
	} else {
		diags.Append(o.NdpProxy.As(ctx, &ndpProxy_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ndpProxy_object := types.ObjectNull(ndpProxy_obj.AttributeTypes())
	if obj.NdpProxy != nil {
		diags.Append(ndpProxy_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NdpProxy, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ndpProxy_object, diags_tmp = types.ObjectValueFrom(ctx, ndpProxy_obj.AttributeTypes(), ndpProxy_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var pppoe_obj *EthernetInterfaceResourceLayer3PppoeObject
	if o.Pppoe.IsNull() {
		pppoe_obj = new(EthernetInterfaceResourceLayer3PppoeObject)
	} else {
		diags.Append(o.Pppoe.As(ctx, &pppoe_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	pppoe_object := types.ObjectNull(pppoe_obj.AttributeTypes())
	if obj.Pppoe != nil {
		diags.Append(pppoe_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Pppoe, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		pppoe_object, diags_tmp = types.ObjectValueFrom(ctx, pppoe_obj.AttributeTypes(), pppoe_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sdwanLinkSettings_obj *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject
	if o.SdwanLinkSettings.IsNull() {
		sdwanLinkSettings_obj = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsObject)
	} else {
		diags.Append(o.SdwanLinkSettings.As(ctx, &sdwanLinkSettings_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sdwanLinkSettings_object := types.ObjectNull(sdwanLinkSettings_obj.AttributeTypes())
	if obj.SdwanLinkSettings != nil {
		diags.Append(sdwanLinkSettings_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SdwanLinkSettings, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sdwanLinkSettings_object, diags_tmp = types.ObjectValueFrom(ctx, sdwanLinkSettings_obj.AttributeTypes(), sdwanLinkSettings_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var clusterInterconnect_value types.Bool
	if obj.ClusterInterconnect != nil {
		clusterInterconnect_value = types.BoolValue(*obj.ClusterInterconnect)
	}
	var decryptForward_value types.Bool
	if obj.DecryptForward != nil {
		decryptForward_value = types.BoolValue(*obj.DecryptForward)
	}
	var dfIgnore_value types.Bool
	if obj.DfIgnore != nil {
		dfIgnore_value = types.BoolValue(*obj.DfIgnore)
	}
	var interfaceManagementProfile_value types.String
	if obj.InterfaceManagementProfile != nil {
		interfaceManagementProfile_value = types.StringValue(*obj.InterfaceManagementProfile)
	}
	var mtu_value types.Int64
	if obj.Mtu != nil {
		mtu_value = types.Int64Value(*obj.Mtu)
	}
	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	var trafficInterconnect_value types.Bool
	if obj.TrafficInterconnect != nil {
		trafficInterconnect_value = types.BoolValue(*obj.TrafficInterconnect)
	}
	var untaggedSubInterface_value types.Bool
	if obj.UntaggedSubInterface != nil {
		untaggedSubInterface_value = types.BoolValue(*obj.UntaggedSubInterface)
	}
	o.AdjustTcpMss = adjustTcpMss_object
	o.Arp = arp_list
	o.Bonjour = bonjour_object
	o.ClusterInterconnect = clusterInterconnect_value
	o.DdnsConfig = ddnsConfig_object
	o.DecryptForward = decryptForward_value
	o.DfIgnore = dfIgnore_value
	o.DhcpClient = dhcpClient_object
	o.InterfaceManagementProfile = interfaceManagementProfile_value
	o.Ips = ips_list
	o.Ipv6 = ipv6_object
	o.Lldp = lldp_object
	o.Mtu = mtu_value
	o.NdpProxy = ndpProxy_object
	o.NetflowProfile = netflowProfile_value
	o.Pppoe = pppoe_object
	o.SdwanLinkSettings = sdwanLinkSettings_object
	o.TrafficInterconnect = trafficInterconnect_value
	o.UntaggedSubInterface = untaggedSubInterface_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3AdjustTcpMssObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3AdjustTcpMss, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var ipv4MssAdjustment_value types.Int64
	if obj.Ipv4MssAdjustment != nil {
		ipv4MssAdjustment_value = types.Int64Value(*obj.Ipv4MssAdjustment)
	}
	var ipv6MssAdjustment_value types.Int64
	if obj.Ipv6MssAdjustment != nil {
		ipv6MssAdjustment_value = types.Int64Value(*obj.Ipv6MssAdjustment)
	}
	o.Enable = enable_value
	o.Ipv4MssAdjustment = ipv4MssAdjustment_value
	o.Ipv6MssAdjustment = ipv6MssAdjustment_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3ArpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Arp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3BonjourObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Bonjour, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var groupId_value types.Int64
	if obj.GroupId != nil {
		groupId_value = types.Int64Value(*obj.GroupId)
	}
	var ttlCheck_value types.Bool
	if obj.TtlCheck != nil {
		ttlCheck_value = types.BoolValue(*obj.TtlCheck)
	}
	o.Enable = enable_value
	o.GroupId = groupId_value
	o.TtlCheck = ttlCheck_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3DdnsConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DdnsConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ddnsIp_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DdnsIp.IsNull() || len(obj.DdnsIp) > 0 {
			entries = obj.DdnsIp
		}

		ddnsIp_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsIpv6_list types.List
	{
		var list_diags diag.Diagnostics

		entries := make([]string, 0)
		if o.DdnsIpv6.IsNull() || len(obj.DdnsIpv6) > 0 {
			entries = obj.DdnsIpv6
		}

		ddnsIpv6_list, list_diags = types.ListValueFrom(ctx, types.StringType, entries)
		diags.Append(list_diags...)
		if diags.HasError() {
			return diags
		}
	}
	var ddnsVendorConfig_list types.List
	{
		var ddnsVendorConfig_tf_entries []EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject
		if !o.DdnsVendorConfig.IsNull() {
			diags.Append(o.DdnsVendorConfig.ElementsAs(ctx, &ddnsVendorConfig_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.DdnsVendorConfig {
			entry := EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(ddnsVendorConfig_tf_entries) {
				entry = ddnsVendorConfig_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(ddnsVendorConfig_tf_entries) {
				ddnsVendorConfig_tf_entries[idx] = entry
			} else {
				ddnsVendorConfig_tf_entries = append(ddnsVendorConfig_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("ddns_vendor_config")
		ddnsVendorConfig_list, list_diags = types.ListValueFrom(ctx, schemaType, ddnsVendorConfig_tf_entries)
		diags.Append(list_diags...)
	}

	var ddnsCertProfile_value types.String
	if obj.DdnsCertProfile != nil {
		ddnsCertProfile_value = types.StringValue(*obj.DdnsCertProfile)
	}
	var ddnsEnabled_value types.Bool
	if obj.DdnsEnabled != nil {
		ddnsEnabled_value = types.BoolValue(*obj.DdnsEnabled)
	}
	var ddnsHostname_value types.String
	if obj.DdnsHostname != nil {
		ddnsHostname_value = types.StringValue(*obj.DdnsHostname)
	}
	var ddnsUpdateInterval_value types.Int64
	if obj.DdnsUpdateInterval != nil {
		ddnsUpdateInterval_value = types.Int64Value(*obj.DdnsUpdateInterval)
	}
	var ddnsVendor_value types.String
	if obj.DdnsVendor != nil {
		ddnsVendor_value = types.StringValue(*obj.DdnsVendor)
	}
	o.DdnsCertProfile = ddnsCertProfile_value
	o.DdnsEnabled = ddnsEnabled_value
	o.DdnsHostname = ddnsHostname_value
	o.DdnsIp = ddnsIp_list
	o.DdnsIpv6 = ddnsIpv6_list
	o.DdnsUpdateInterval = ddnsUpdateInterval_value
	o.DdnsVendor = ddnsVendor_value
	o.DdnsVendorConfig = ddnsVendorConfig_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3DdnsConfigDdnsVendorConfigObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DdnsConfigDdnsVendorConfig, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var value_value types.String
	if obj.Value != nil {
		value_value = types.StringValue(*obj.Value)
	}
	o.Name = types.StringValue(obj.Name)
	o.Value = value_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3DhcpClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sendHostname_obj *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject
	if o.SendHostname.IsNull() {
		sendHostname_obj = new(EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject)
	} else {
		diags.Append(o.SendHostname.As(ctx, &sendHostname_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendHostname_object := types.ObjectNull(sendHostname_obj.AttributeTypes())
	if obj.SendHostname != nil {
		diags.Append(sendHostname_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendHostname, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendHostname_object, diags_tmp = types.ObjectValueFrom(ctx, sendHostname_obj.AttributeTypes(), sendHostname_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.SendHostname = sendHostname_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3DhcpClientSendHostnameObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3DhcpClientSendHostname, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	o.Enable = enable_value
	o.Hostname = hostname_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3IpsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ip, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var sdwanGateway_value types.String
	if obj.SdwanGateway != nil {
		sdwanGateway_value = types.StringValue(*obj.SdwanGateway)
	}
	o.Name = types.StringValue(obj.Name)
	o.SdwanGateway = sdwanGateway_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceResourceLayer3Ipv6AddressesObject
		if !o.Addresses.IsNull() {
			diags.Append(o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := EthernetInterfaceResourceLayer3Ipv6AddressesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addresses_tf_entries) {
				entry = addresses_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addresses_tf_entries) {
				addresses_tf_entries[idx] = entry
			} else {
				addresses_tf_entries = append(addresses_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}

	var dhcpClient_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject
	if o.DhcpClient.IsNull() {
		dhcpClient_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientObject)
	} else {
		diags.Append(o.DhcpClient.As(ctx, &dhcpClient_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpClient_object := types.ObjectNull(dhcpClient_obj.AttributeTypes())
	if obj.DhcpClient != nil {
		diags.Append(dhcpClient_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DhcpClient, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpClient_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpClient_obj.AttributeTypes(), dhcpClient_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var inherited_obj *EthernetInterfaceResourceLayer3Ipv6InheritedObject
	if o.Inherited.IsNull() {
		inherited_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedObject)
	} else {
		diags.Append(o.Inherited.As(ctx, &inherited_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	inherited_object := types.ObjectNull(inherited_obj.AttributeTypes())
	if obj.Inherited != nil {
		diags.Append(inherited_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Inherited, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		inherited_object, diags_tmp = types.ObjectValueFrom(ctx, inherited_obj.AttributeTypes(), inherited_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var neighborDiscovery_obj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	var interfaceId_value types.String
	if obj.InterfaceId != nil {
		interfaceId_value = types.StringValue(*obj.InterfaceId)
	}
	o.Addresses = addresses_list
	o.DhcpClient = dhcpClient_object
	o.Enabled = enabled_value
	o.Inherited = inherited_object
	o.InterfaceId = interfaceId_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6Address, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefix_obj *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject
	if o.Prefix.IsNull() {
		prefix_obj = new(EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject)
	} else {
		diags.Append(o.Prefix.As(ctx, &prefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	prefix_object := types.ObjectNull(prefix_obj.AttributeTypes())
	if obj.Prefix != nil {
		diags.Append(prefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Prefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		prefix_object, diags_tmp = types.ObjectValueFrom(ctx, prefix_obj.AttributeTypes(), prefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var anycast_obj *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject
	if o.Anycast.IsNull() {
		anycast_obj = new(EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject)
	} else {
		diags.Append(o.Anycast.As(ctx, &anycast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	anycast_object := types.ObjectNull(anycast_obj.AttributeTypes())
	if obj.Anycast != nil {
		diags.Append(anycast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Anycast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		anycast_object, diags_tmp = types.ObjectValueFrom(ctx, anycast_obj.AttributeTypes(), anycast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	o.Name = types.StringValue(obj.Name)
	o.EnableOnInterface = enableOnInterface_value
	o.Prefix = prefix_object
	o.Anycast = anycast_object
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAnycastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressAnycast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6AddressesAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6AddressAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClient, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var neighborDiscovery_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var prefixDelegation_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject
	if o.PrefixDelegation.IsNull() {
		prefixDelegation_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject)
	} else {
		diags.Append(o.PrefixDelegation.As(ctx, &prefixDelegation_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	prefixDelegation_object := types.ObjectNull(prefixDelegation_obj.AttributeTypes())
	if obj.PrefixDelegation != nil {
		diags.Append(prefixDelegation_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PrefixDelegation, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		prefixDelegation_object, diags_tmp = types.ObjectValueFrom(ctx, prefixDelegation_obj.AttributeTypes(), prefixDelegation_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var v6Options_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject
	if o.V6Options.IsNull() {
		v6Options_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject)
	} else {
		diags.Append(o.V6Options.As(ctx, &v6Options_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	v6Options_object := types.ObjectNull(v6Options_obj.AttributeTypes())
	if obj.V6Options != nil {
		diags.Append(v6Options_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.V6Options, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		v6Options_object, diags_tmp = types.ObjectValueFrom(ctx, v6Options_obj.AttributeTypes(), v6Options_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var acceptRaRoute_value types.Bool
	if obj.AcceptRaRoute != nil {
		acceptRaRoute_value = types.BoolValue(*obj.AcceptRaRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var preference_value types.String
	if obj.Preference != nil {
		preference_value = types.StringValue(*obj.Preference)
	}
	o.AcceptRaRoute = acceptRaRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object
	o.Preference = preference_value
	o.PrefixDelegation = prefixDelegation_object
	o.V6Options = v6Options_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var dnsServer_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject
	if o.DnsServer.IsNull() {
		dnsServer_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject)
	} else {
		diags.Append(o.DnsServer.As(ctx, &dnsServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsServer_object := types.ObjectNull(dnsServer_obj.AttributeTypes())
	if obj.DnsServer != nil {
		diags.Append(dnsServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsServer_object, diags_tmp = types.ObjectValueFrom(ctx, dnsServer_obj.AttributeTypes(), dnsServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject
	if o.DnsSuffix.IsNull() {
		dnsSuffix_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject)
	} else {
		diags.Append(o.DnsSuffix.As(ctx, &dnsSuffix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_object := types.ObjectNull(dnsSuffix_obj.AttributeTypes())
	if obj.DnsSuffix != nil {
		diags.Append(dnsSuffix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSuffix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSuffix_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSuffix_obj.AttributeTypes(), dnsSuffix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject
	if o.Enable.IsNull() {
		enable_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject)
	} else {
		diags.Append(o.Enable.As(ctx, &enable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	enable_object := types.ObjectNull(enable_obj.AttributeTypes())
	if obj.Enable != nil {
		diags.Append(enable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Enable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		enable_object, diags_tmp = types.ObjectValueFrom(ctx, enable_obj.AttributeTypes(), enable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Enable = enable_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject
	if o.No.IsNull() {
		no_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject
	if o.Yes.IsNull() {
		yes_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientPrefixDelegationEnableYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientPrefixDelegationEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var pfxPoolName_value types.String
	if obj.PfxPoolName != nil {
		pfxPoolName_value = types.StringValue(*obj.PfxPoolName)
	}
	var prefixLen_value types.Int64
	if obj.PrefixLen != nil {
		prefixLen_value = types.Int64Value(*obj.PrefixLen)
	}
	var prefixLenHint_value types.Bool
	if obj.PrefixLenHint != nil {
		prefixLenHint_value = types.BoolValue(*obj.PrefixLenHint)
	}
	o.PfxPoolName = pfxPoolName_value
	o.PrefixLen = prefixLen_value
	o.PrefixLenHint = prefixLenHint_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6Options, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject
	if o.Enable.IsNull() {
		enable_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject)
	} else {
		diags.Append(o.Enable.As(ctx, &enable_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	enable_object := types.ObjectNull(enable_obj.AttributeTypes())
	if obj.Enable != nil {
		diags.Append(enable_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Enable, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		enable_object, diags_tmp = types.ObjectValueFrom(ctx, enable_obj.AttributeTypes(), enable_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var duidType_value types.String
	if obj.DuidType != nil {
		duidType_value = types.StringValue(*obj.DuidType)
	}
	var rapidCommit_value types.Bool
	if obj.RapidCommit != nil {
		rapidCommit_value = types.BoolValue(*obj.RapidCommit)
	}
	var supportSrvrReconfig_value types.Bool
	if obj.SupportSrvrReconfig != nil {
		supportSrvrReconfig_value = types.BoolValue(*obj.SupportSrvrReconfig)
	}
	o.DuidType = duidType_value
	o.Enable = enable_object
	o.RapidCommit = rapidCommit_value
	o.SupportSrvrReconfig = supportSrvrReconfig_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnable, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var no_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject
	if o.No.IsNull() {
		no_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject)
	} else {
		diags.Append(o.No.As(ctx, &no_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	no_object := types.ObjectNull(no_obj.AttributeTypes())
	if obj.No != nil {
		diags.Append(no_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.No, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		no_object, diags_tmp = types.ObjectValueFrom(ctx, no_obj.AttributeTypes(), no_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var yes_obj *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject
	if o.Yes.IsNull() {
		yes_obj = new(EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject)
	} else {
		diags.Append(o.Yes.As(ctx, &yes_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	yes_object := types.ObjectNull(yes_obj.AttributeTypes())
	if obj.Yes != nil {
		diags.Append(yes_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Yes, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		yes_object, diags_tmp = types.ObjectValueFrom(ctx, yes_obj.AttributeTypes(), yes_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.No = no_object
	o.Yes = yes_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableNoObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableNo, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6DhcpClientV6OptionsEnableYesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6DhcpClientV6OptionsEnableYes, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var nonTempAddr_value types.Bool
	if obj.NonTempAddr != nil {
		nonTempAddr_value = types.BoolValue(*obj.NonTempAddr)
	}
	var tempAddr_value types.Bool
	if obj.TempAddr != nil {
		tempAddr_value = types.BoolValue(*obj.TempAddr)
	}
	o.NonTempAddr = nonTempAddr_value
	o.TempAddr = tempAddr_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6Inherited, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var assignAddr_list types.List
	{
		var assignAddr_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject
		if !o.AssignAddr.IsNull() {
			diags.Append(o.AssignAddr.ElementsAs(ctx, &assignAddr_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.AssignAddr {
			entry := EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(assignAddr_tf_entries) {
				entry = assignAddr_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(assignAddr_tf_entries) {
				assignAddr_tf_entries[idx] = entry
			} else {
				assignAddr_tf_entries = append(assignAddr_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("assign_addr")
		assignAddr_list, list_diags = types.ListValueFrom(ctx, schemaType, assignAddr_tf_entries)
		diags.Append(list_diags...)
	}

	var neighborDiscovery_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject
	if o.NeighborDiscovery.IsNull() {
		neighborDiscovery_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject)
	} else {
		diags.Append(o.NeighborDiscovery.As(ctx, &neighborDiscovery_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	neighborDiscovery_object := types.ObjectNull(neighborDiscovery_obj.AttributeTypes())
	if obj.NeighborDiscovery != nil {
		diags.Append(neighborDiscovery_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NeighborDiscovery, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		neighborDiscovery_object, diags_tmp = types.ObjectValueFrom(ctx, neighborDiscovery_obj.AttributeTypes(), neighborDiscovery_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.AssignAddr = assignAddr_list
	o.Enable = enable_value
	o.NeighborDiscovery = neighborDiscovery_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddr, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var type_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject
	if o.Type.IsNull() {
		type_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject)
	} else {
		diags.Append(o.Type.As(ctx, &type_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	type_object := types.ObjectNull(type_obj.AttributeTypes())
	if obj.Type != nil {
		diags.Append(type_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Type, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		type_object, diags_tmp = types.ObjectValueFrom(ctx, type_obj.AttributeTypes(), type_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Type = type_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var gua_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject
	if o.Gua.IsNull() {
		gua_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject)
	} else {
		diags.Append(o.Gua.As(ctx, &gua_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	gua_object := types.ObjectNull(gua_obj.AttributeTypes())
	if obj.Gua != nil {
		diags.Append(gua_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Gua, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		gua_object, diags_tmp = types.ObjectValueFrom(ctx, gua_obj.AttributeTypes(), gua_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ula_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject
	if o.Ula.IsNull() {
		ula_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject)
	} else {
		diags.Append(o.Ula.As(ctx, &ula_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ula_object := types.ObjectNull(ula_obj.AttributeTypes())
	if obj.Ula != nil {
		diags.Append(ula_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ula, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ula_object, diags_tmp = types.ObjectValueFrom(ctx, ula_obj.AttributeTypes(), ula_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Gua = gua_object
	o.Ula = ula_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGua, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var poolType_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject
	if o.PoolType.IsNull() {
		poolType_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject)
	} else {
		diags.Append(o.PoolType.As(ctx, &poolType_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	poolType_object := types.ObjectNull(poolType_obj.AttributeTypes())
	if obj.PoolType != nil {
		diags.Append(poolType_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.PoolType, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		poolType_object, diags_tmp = types.ObjectValueFrom(ctx, poolType_obj.AttributeTypes(), poolType_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var advertise_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.PrefixPool = prefixPool_value
	o.PoolType = poolType_object
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolType, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dynamic_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject
	if o.Dynamic.IsNull() {
		dynamic_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject)
	} else {
		diags.Append(o.Dynamic.As(ctx, &dynamic_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamic_object := types.ObjectNull(dynamic_obj.AttributeTypes())
	if obj.Dynamic != nil {
		diags.Append(dynamic_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dynamic, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamic_object, diags_tmp = types.ObjectValueFrom(ctx, dynamic_obj.AttributeTypes(), dynamic_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dynamicId_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject
	if o.DynamicId.IsNull() {
		dynamicId_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject)
	} else {
		diags.Append(o.DynamicId.As(ctx, &dynamicId_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dynamicId_object := types.ObjectNull(dynamicId_obj.AttributeTypes())
	if obj.DynamicId != nil {
		diags.Append(dynamicId_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DynamicId, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dynamicId_object, diags_tmp = types.ObjectValueFrom(ctx, dynamicId_obj.AttributeTypes(), dynamicId_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dynamic = dynamic_object
	o.DynamicId = dynamicId_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamic, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicIdObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaPoolTypeDynamicId, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var identifier_value types.Int64
	if obj.Identifier != nil {
		identifier_value = types.Int64Value(*obj.Identifier)
	}
	o.Identifier = identifier_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeGuaAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeGuaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeUla, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var advertise_obj *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject
	if o.Advertise.IsNull() {
		advertise_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject)
	} else {
		diags.Append(o.Advertise.As(ctx, &advertise_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	advertise_object := types.ObjectNull(advertise_obj.AttributeTypes())
	if obj.Advertise != nil {
		diags.Append(advertise_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Advertise, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		advertise_object, diags_tmp = types.ObjectValueFrom(ctx, advertise_obj.AttributeTypes(), advertise_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enableOnInterface_value types.Bool
	if obj.EnableOnInterface != nil {
		enableOnInterface_value = types.BoolValue(*obj.EnableOnInterface)
	}
	var addresses_value types.String
	if obj.Address != nil {
		addresses_value = types.StringValue(*obj.Address)
	}
	var prefix_value types.Bool
	if obj.Prefix != nil {
		prefix_value = types.BoolValue(*obj.Prefix)
	}
	var anycast_value types.Bool
	if obj.Anycast != nil {
		anycast_value = types.BoolValue(*obj.Anycast)
	}
	o.EnableOnInterface = enableOnInterface_value
	o.Addresses = addresses_value
	o.Prefix = prefix_value
	o.Anycast = anycast_value
	o.Advertise = advertise_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedAssignAddrTypeUlaAdvertiseObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedAssignAddrTypeUlaAdvertise, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var validLifetime_value types.String
	if obj.ValidLifetime != nil {
		validLifetime_value = types.StringValue(*obj.ValidLifetime)
	}
	var preferredLifetime_value types.String
	if obj.PreferredLifetime != nil {
		preferredLifetime_value = types.StringValue(*obj.PreferredLifetime)
	}
	var onlinkFlag_value types.Bool
	if obj.OnlinkFlag != nil {
		onlinkFlag_value = types.BoolValue(*obj.OnlinkFlag)
	}
	var autoConfigFlag_value types.Bool
	if obj.AutoConfigFlag != nil {
		autoConfigFlag_value = types.BoolValue(*obj.AutoConfigFlag)
	}
	o.Enable = enable_value
	o.ValidLifetime = validLifetime_value
	o.PreferredLifetime = preferredLifetime_value
	o.OnlinkFlag = onlinkFlag_value
	o.AutoConfigFlag = autoConfigFlag_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var dnsServer_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject
	if o.DnsServer.IsNull() {
		dnsServer_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject)
	} else {
		diags.Append(o.DnsServer.As(ctx, &dnsServer_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsServer_object := types.ObjectNull(dnsServer_obj.AttributeTypes())
	if obj.DnsServer != nil {
		diags.Append(dnsServer_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsServer, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsServer_object, diags_tmp = types.ObjectValueFrom(ctx, dnsServer_obj.AttributeTypes(), dnsServer_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dnsSuffix_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject
	if o.DnsSuffix.IsNull() {
		dnsSuffix_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject)
	} else {
		diags.Append(o.DnsSuffix.As(ctx, &dnsSuffix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSuffix_object := types.ObjectNull(dnsSuffix_obj.AttributeTypes())
	if obj.DnsSuffix != nil {
		diags.Append(dnsSuffix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSuffix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSuffix_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSuffix_obj.AttributeTypes(), dnsSuffix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var routerAdvertisement_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject
	if o.RouterAdvertisement.IsNull() {
		routerAdvertisement_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject)
	} else {
		diags.Append(o.RouterAdvertisement.As(ctx, &routerAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routerAdvertisement_object := types.ObjectNull(routerAdvertisement_obj.AttributeTypes())
	if obj.RouterAdvertisement != nil {
		diags.Append(routerAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouterAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routerAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, routerAdvertisement_obj.AttributeTypes(), routerAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.DnsServer = dnsServer_object
	o.DnsSuffix = dnsSuffix_object
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}

	o.Server = server_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsServerSourceManualServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var source_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject
	if o.Source.IsNull() {
		source_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject)
	} else {
		diags.Append(o.Source.As(ctx, &source_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	source_object := types.ObjectNull(source_obj.AttributeTypes())
	if obj.Source != nil {
		diags.Append(source_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Source, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		source_object, diags_tmp = types.ObjectValueFrom(ctx, source_obj.AttributeTypes(), source_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Source = source_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSource, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dhcpv6_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object
	if o.Dhcpv6.IsNull() {
		dhcpv6_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object)
	} else {
		diags.Append(o.Dhcpv6.As(ctx, &dhcpv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dhcpv6_object := types.ObjectNull(dhcpv6_obj.AttributeTypes())
	if obj.Dhcpv6 != nil {
		diags.Append(dhcpv6_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Dhcpv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dhcpv6_object, diags_tmp = types.ObjectValueFrom(ctx, dhcpv6_obj.AttributeTypes(), dhcpv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var manual_obj *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject
	if o.Manual.IsNull() {
		manual_obj = new(EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject)
	} else {
		diags.Append(o.Manual.As(ctx, &manual_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	manual_object := types.ObjectNull(manual_obj.AttributeTypes())
	if obj.Manual != nil {
		diags.Append(manual_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Manual, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		manual_object, diags_tmp = types.ObjectValueFrom(ctx, manual_obj.AttributeTypes(), manual_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Dhcpv6 = dhcpv6_object
	o.Manual = manual_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceDhcpv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var prefixPool_value types.String
	if obj.PrefixPool != nil {
		prefixPool_value = types.StringValue(*obj.PrefixPool)
	}
	o.PrefixPool = prefixPool_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManual, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryDnsSuffixSourceManualSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6InheritedNeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6InheritedNeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscovery, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var neighbor_list types.List
	{
		var neighbor_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject
		if !o.Neighbor.IsNull() {
			diags.Append(o.Neighbor.ElementsAs(ctx, &neighbor_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Neighbor {
			entry := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(neighbor_tf_entries) {
				entry = neighbor_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(neighbor_tf_entries) {
				neighbor_tf_entries[idx] = entry
			} else {
				neighbor_tf_entries = append(neighbor_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("neighbor")
		neighbor_list, list_diags = types.ListValueFrom(ctx, schemaType, neighbor_tf_entries)
		diags.Append(list_diags...)
	}

	var routerAdvertisement_obj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject
	if o.RouterAdvertisement.IsNull() {
		routerAdvertisement_obj = new(EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject)
	} else {
		diags.Append(o.RouterAdvertisement.As(ctx, &routerAdvertisement_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	routerAdvertisement_object := types.ObjectNull(routerAdvertisement_obj.AttributeTypes())
	if obj.RouterAdvertisement != nil {
		diags.Append(routerAdvertisement_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RouterAdvertisement, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		routerAdvertisement_object, diags_tmp = types.ObjectValueFrom(ctx, routerAdvertisement_obj.AttributeTypes(), routerAdvertisement_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var dadAttempts_value types.Int64
	if obj.DadAttempts != nil {
		dadAttempts_value = types.Int64Value(*obj.DadAttempts)
	}
	var enableDad_value types.Bool
	if obj.EnableDad != nil {
		enableDad_value = types.BoolValue(*obj.EnableDad)
	}
	var enableNdpMonitor_value types.Bool
	if obj.EnableNdpMonitor != nil {
		enableNdpMonitor_value = types.BoolValue(*obj.EnableNdpMonitor)
	}
	var nsInterval_value types.Int64
	if obj.NsInterval != nil {
		nsInterval_value = types.Int64Value(*obj.NsInterval)
	}
	var reachableTime_value types.Int64
	if obj.ReachableTime != nil {
		reachableTime_value = types.Int64Value(*obj.ReachableTime)
	}
	o.DadAttempts = dadAttempts_value
	o.EnableDad = enableDad_value
	o.EnableNdpMonitor = enableNdpMonitor_value
	o.Neighbor = neighbor_list
	o.NsInterval = nsInterval_value
	o.ReachableTime = reachableTime_value
	o.RouterAdvertisement = routerAdvertisement_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryNeighborObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryNeighbor, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var hwAddress_value types.String
	if obj.HwAddress != nil {
		hwAddress_value = types.StringValue(*obj.HwAddress)
	}
	o.Name = types.StringValue(obj.Name)
	o.HwAddress = hwAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisement, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var dnsSupport_obj *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject
	if o.DnsSupport.IsNull() {
		dnsSupport_obj = new(EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject)
	} else {
		diags.Append(o.DnsSupport.As(ctx, &dnsSupport_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	dnsSupport_object := types.ObjectNull(dnsSupport_obj.AttributeTypes())
	if obj.DnsSupport != nil {
		diags.Append(dnsSupport_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.DnsSupport, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		dnsSupport_object, diags_tmp = types.ObjectValueFrom(ctx, dnsSupport_obj.AttributeTypes(), dnsSupport_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var enableConsistencyCheck_value types.Bool
	if obj.EnableConsistencyCheck != nil {
		enableConsistencyCheck_value = types.BoolValue(*obj.EnableConsistencyCheck)
	}
	var hopLimit_value types.String
	if obj.HopLimit != nil {
		hopLimit_value = types.StringValue(*obj.HopLimit)
	}
	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	var linkMtu_value types.String
	if obj.LinkMtu != nil {
		linkMtu_value = types.StringValue(*obj.LinkMtu)
	}
	var managedFlag_value types.Bool
	if obj.ManagedFlag != nil {
		managedFlag_value = types.BoolValue(*obj.ManagedFlag)
	}
	var maxInterval_value types.Int64
	if obj.MaxInterval != nil {
		maxInterval_value = types.Int64Value(*obj.MaxInterval)
	}
	var minInterval_value types.Int64
	if obj.MinInterval != nil {
		minInterval_value = types.Int64Value(*obj.MinInterval)
	}
	var otherFlag_value types.Bool
	if obj.OtherFlag != nil {
		otherFlag_value = types.BoolValue(*obj.OtherFlag)
	}
	var reachableTime_value types.String
	if obj.ReachableTime != nil {
		reachableTime_value = types.StringValue(*obj.ReachableTime)
	}
	var retransmissionTimer_value types.String
	if obj.RetransmissionTimer != nil {
		retransmissionTimer_value = types.StringValue(*obj.RetransmissionTimer)
	}
	var routerPreference_value types.String
	if obj.RouterPreference != nil {
		routerPreference_value = types.StringValue(*obj.RouterPreference)
	}
	o.DnsSupport = dnsSupport_object
	o.Enable = enable_value
	o.EnableConsistencyCheck = enableConsistencyCheck_value
	o.HopLimit = hopLimit_value
	o.Lifetime = lifetime_value
	o.LinkMtu = linkMtu_value
	o.ManagedFlag = managedFlag_value
	o.MaxInterval = maxInterval_value
	o.MinInterval = minInterval_value
	o.OtherFlag = otherFlag_value
	o.ReachableTime = reachableTime_value
	o.RetransmissionTimer = retransmissionTimer_value
	o.RouterPreference = routerPreference_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupport, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var server_list types.List
	{
		var server_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject
		if !o.Server.IsNull() {
			diags.Append(o.Server.ElementsAs(ctx, &server_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Server {
			entry := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(server_tf_entries) {
				entry = server_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(server_tf_entries) {
				server_tf_entries[idx] = entry
			} else {
				server_tf_entries = append(server_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("server")
		server_list, list_diags = types.ListValueFrom(ctx, schemaType, server_tf_entries)
		diags.Append(list_diags...)
	}
	var suffix_list types.List
	{
		var suffix_tf_entries []EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject
		if !o.Suffix.IsNull() {
			diags.Append(o.Suffix.ElementsAs(ctx, &suffix_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Suffix {
			entry := EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(suffix_tf_entries) {
				entry = suffix_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(suffix_tf_entries) {
				suffix_tf_entries[idx] = entry
			} else {
				suffix_tf_entries = append(suffix_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("suffix")
		suffix_list, list_diags = types.ListValueFrom(ctx, schemaType, suffix_tf_entries)
		diags.Append(list_diags...)
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Server = server_list
	o.Suffix = suffix_list

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServerObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportServer, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Ipv6NeighborDiscoveryRouterAdvertisementDnsSupportSuffix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lifetime_value types.Int64
	if obj.Lifetime != nil {
		lifetime_value = types.Int64Value(*obj.Lifetime)
	}
	o.Name = types.StringValue(obj.Name)
	o.Lifetime = lifetime_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3LldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Lldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceResourceLayer3LldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3LldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3LldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3NdpProxyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3NdpProxy, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addresses_list types.List
	{
		var addresses_tf_entries []EthernetInterfaceResourceLayer3NdpProxyAddressesObject
		if !o.Addresses.IsNull() {
			diags.Append(o.Addresses.ElementsAs(ctx, &addresses_tf_entries, false)...)
			if diags.HasError() {
				return diags
			}
		}

		for idx, elt := range obj.Address {
			entry := EthernetInterfaceResourceLayer3NdpProxyAddressesObject{
				Name: types.StringValue(elt.Name),
			}
			if idx < len(addresses_tf_entries) {
				entry = addresses_tf_entries[idx]
			}

			diags.Append(entry.CopyFromPango(ctx, client, append(ancestors, entry), &elt, ev)...)
			if diags.HasError() {
				return diags
			}

			if idx < len(addresses_tf_entries) {
				addresses_tf_entries[idx] = entry
			} else {
				addresses_tf_entries = append(addresses_tf_entries, entry)
			}
		}
		var list_diags diag.Diagnostics
		schemaType := o.getTypeFor("addresses")
		addresses_list, list_diags = types.ListValueFrom(ctx, schemaType, addresses_tf_entries)
		diags.Append(list_diags...)
	}

	var enabled_value types.Bool
	if obj.Enabled != nil {
		enabled_value = types.BoolValue(*obj.Enabled)
	}
	o.Addresses = addresses_list
	o.Enabled = enabled_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3NdpProxyAddressesObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3NdpProxyAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var negate_value types.Bool
	if obj.Negate != nil {
		negate_value = types.BoolValue(*obj.Negate)
	}
	o.Name = types.StringValue(obj.Name)
	o.Negate = negate_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3PppoeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3Pppoe, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passive_obj *EthernetInterfaceResourceLayer3PppoePassiveObject
	if o.Passive.IsNull() {
		passive_obj = new(EthernetInterfaceResourceLayer3PppoePassiveObject)
	} else {
		diags.Append(o.Passive.As(ctx, &passive_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	passive_object := types.ObjectNull(passive_obj.AttributeTypes())
	if obj.Passive != nil {
		diags.Append(passive_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Passive, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		passive_object, diags_tmp = types.ObjectValueFrom(ctx, passive_obj.AttributeTypes(), passive_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticAddress_obj *EthernetInterfaceResourceLayer3PppoeStaticAddressObject
	if o.StaticAddress.IsNull() {
		staticAddress_obj = new(EthernetInterfaceResourceLayer3PppoeStaticAddressObject)
	} else {
		diags.Append(o.StaticAddress.As(ctx, &staticAddress_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticAddress_object := types.ObjectNull(staticAddress_obj.AttributeTypes())
	if obj.StaticAddress != nil {
		diags.Append(staticAddress_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticAddress, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticAddress_object, diags_tmp = types.ObjectValueFrom(ctx, staticAddress_obj.AttributeTypes(), staticAddress_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var accessConcentrator_value types.String
	if obj.AccessConcentrator != nil {
		accessConcentrator_value = types.StringValue(*obj.AccessConcentrator)
	}
	var authentication_value types.String
	if obj.Authentication != nil {
		authentication_value = types.StringValue(*obj.Authentication)
	}
	var createDefaultRoute_value types.Bool
	if obj.CreateDefaultRoute != nil {
		createDefaultRoute_value = types.BoolValue(*obj.CreateDefaultRoute)
	}
	var defaultRouteMetric_value types.Int64
	if obj.DefaultRouteMetric != nil {
		defaultRouteMetric_value = types.Int64Value(*obj.DefaultRouteMetric)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var password_value types.String
	if obj.Password != nil {
		password_value = types.StringValue(*obj.Password)
	}
	var service_value types.String
	if obj.Service != nil {
		service_value = types.StringValue(*obj.Service)
	}
	var username_value types.String
	if obj.Username != nil {
		username_value = types.StringValue(*obj.Username)
	}
	o.AccessConcentrator = accessConcentrator_value
	o.Authentication = authentication_value
	o.CreateDefaultRoute = createDefaultRoute_value
	o.DefaultRouteMetric = defaultRouteMetric_value
	o.Enable = enable_value
	o.Passive = passive_object
	o.Password = password_value
	o.Service = service_value
	o.StaticAddress = staticAddress_object
	o.Username = username_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3PppoePassiveObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3PppoePassive, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3PppoeStaticAddressObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3PppoeStaticAddress, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ips_value types.String
	if obj.Ip != nil {
		ips_value = types.StringValue(*obj.Ip)
	}
	o.Ips = ips_value

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettings, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var upstreamNat_obj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject
	if o.UpstreamNat.IsNull() {
		upstreamNat_obj = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject)
	} else {
		diags.Append(o.UpstreamNat.As(ctx, &upstreamNat_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	upstreamNat_object := types.ObjectNull(upstreamNat_obj.AttributeTypes())
	if obj.UpstreamNat != nil {
		diags.Append(upstreamNat_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.UpstreamNat, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		upstreamNat_object, diags_tmp = types.ObjectValueFrom(ctx, upstreamNat_obj.AttributeTypes(), upstreamNat_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var sdwanInterfaceProfile_value types.String
	if obj.SdwanInterfaceProfile != nil {
		sdwanInterfaceProfile_value = types.StringValue(*obj.SdwanInterfaceProfile)
	}
	o.Enable = enable_value
	o.SdwanInterfaceProfile = sdwanInterfaceProfile_value
	o.UpstreamNat = upstreamNat_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNat, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ddns_obj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject
	if o.Ddns.IsNull() {
		ddns_obj = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject)
	} else {
		diags.Append(o.Ddns.As(ctx, &ddns_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ddns_object := types.ObjectNull(ddns_obj.AttributeTypes())
	if obj.Ddns != nil {
		diags.Append(ddns_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Ddns, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ddns_object, diags_tmp = types.ObjectValueFrom(ctx, ddns_obj.AttributeTypes(), ddns_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var staticIp_obj *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject
	if o.StaticIp.IsNull() {
		staticIp_obj = new(EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject)
	} else {
		diags.Append(o.StaticIp.As(ctx, &staticIp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	staticIp_object := types.ObjectNull(staticIp_obj.AttributeTypes())
	if obj.StaticIp != nil {
		diags.Append(staticIp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.StaticIp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		staticIp_object, diags_tmp = types.ObjectValueFrom(ctx, staticIp_obj.AttributeTypes(), staticIp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	o.Enable = enable_value
	o.Ddns = ddns_object
	o.StaticIp = staticIp_object

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatDdnsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNatDdns, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *EthernetInterfaceResourceLayer3SdwanLinkSettingsUpstreamNatStaticIpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Layer3SdwanLinkSettingsUpstreamNatStaticIp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var fqdn_value types.String
	if obj.Fqdn != nil {
		fqdn_value = types.StringValue(*obj.Fqdn)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	o.Fqdn = fqdn_value
	o.IpAddress = ipAddress_value

	return diags
}

func (o *EthernetInterfaceResourceLogCardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.LogCard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var defaultGateway_value types.String
	if obj.DefaultGateway != nil {
		defaultGateway_value = types.StringValue(*obj.DefaultGateway)
	}
	var ipAddress_value types.String
	if obj.IpAddress != nil {
		ipAddress_value = types.StringValue(*obj.IpAddress)
	}
	var ipv6Address_value types.String
	if obj.Ipv6Address != nil {
		ipv6Address_value = types.StringValue(*obj.Ipv6Address)
	}
	var ipv6DefaultGateway_value types.String
	if obj.Ipv6DefaultGateway != nil {
		ipv6DefaultGateway_value = types.StringValue(*obj.Ipv6DefaultGateway)
	}
	var netmask_value types.String
	if obj.Netmask != nil {
		netmask_value = types.StringValue(*obj.Netmask)
	}
	o.DefaultGateway = defaultGateway_value
	o.IpAddress = ipAddress_value
	o.Ipv6Address = ipv6Address_value
	o.Ipv6DefaultGateway = ipv6DefaultGateway_value
	o.Netmask = netmask_value

	return diags
}

func (o *EthernetInterfaceResourceTapObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.Tap, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceResourceVirtualWireObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWire, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var lacp_obj *EthernetInterfaceResourceVirtualWireLacpObject
	if o.Lacp.IsNull() {
		lacp_obj = new(EthernetInterfaceResourceVirtualWireLacpObject)
	} else {
		diags.Append(o.Lacp.As(ctx, &lacp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lacp_object := types.ObjectNull(lacp_obj.AttributeTypes())
	if obj.Lacp != nil {
		diags.Append(lacp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lacp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lacp_object, diags_tmp = types.ObjectValueFrom(ctx, lacp_obj.AttributeTypes(), lacp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var lldp_obj *EthernetInterfaceResourceVirtualWireLldpObject
	if o.Lldp.IsNull() {
		lldp_obj = new(EthernetInterfaceResourceVirtualWireLldpObject)
	} else {
		diags.Append(o.Lldp.As(ctx, &lldp_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	lldp_object := types.ObjectNull(lldp_obj.AttributeTypes())
	if obj.Lldp != nil {
		diags.Append(lldp_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Lldp, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		lldp_object, diags_tmp = types.ObjectValueFrom(ctx, lldp_obj.AttributeTypes(), lldp_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var netflowProfile_value types.String
	if obj.NetflowProfile != nil {
		netflowProfile_value = types.StringValue(*obj.NetflowProfile)
	}
	o.Lacp = lacp_object
	o.Lldp = lldp_object
	o.NetflowProfile = netflowProfile_value

	return diags
}

func (o *EthernetInterfaceResourceVirtualWireLacpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLacp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.HighAvailability = highAvailability_object

	return diags
}

func (o *EthernetInterfaceResourceVirtualWireLacpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLacpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceResourceVirtualWireLldpObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLldp, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var highAvailability_obj *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject
	if o.HighAvailability.IsNull() {
		highAvailability_obj = new(EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject)
	} else {
		diags.Append(o.HighAvailability.As(ctx, &highAvailability_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	highAvailability_object := types.ObjectNull(highAvailability_obj.AttributeTypes())
	if obj.HighAvailability != nil {
		diags.Append(highAvailability_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.HighAvailability, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		highAvailability_object, diags_tmp = types.ObjectValueFrom(ctx, highAvailability_obj.AttributeTypes(), highAvailability_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var profile_value types.String
	if obj.Profile != nil {
		profile_value = types.StringValue(*obj.Profile)
	}
	o.Enable = enable_value
	o.HighAvailability = highAvailability_object
	o.Profile = profile_value

	return diags
}

func (o *EthernetInterfaceResourceVirtualWireLldpHighAvailabilityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *ethernet.VirtualWireLldpHighAvailability, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var passivePreNegotiation_value types.Bool
	if obj.PassivePreNegotiation != nil {
		passivePreNegotiation_value = types.BoolValue(*obj.PassivePreNegotiation)
	}
	o.PassivePreNegotiation = passivePreNegotiation_value

	return diags
}

func (o *EthernetInterfaceResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *EthernetInterfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location ethernet.Location

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &ethernet.SharedLocation{}
			var innerLocation EthernetInterfaceSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ethernet.TemplateLocation{}
			var innerLocation EthernetInterfaceTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ethernet.TemplateStackLocation{}
			var innerLocation EthernetInterfaceTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &ethernet.NgfwLocation{}
			var innerLocation EthernetInterfaceNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *ethernet.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var importLocation ethernet.ImportLocation

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if location.Template != nil {
			{
				var terraformInnerLocation EthernetInterfaceTemplateLocation
				resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &terraformInnerLocation, basetypes.ObjectAsOptions{})...)
				if resp.Diagnostics.HasError() {
					return
				}
				importLocation = ethernet.NewLayer3TemplateVsysImportLocation(ethernet.Layer3TemplateVsysImportLocationSpec{
					Vsys: terraformInnerLocation.Vsys.ValueString(),
				})
			}
		}
	}

	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	if importLocation != nil {
		err = o.manager.ImportToLocations(ctx, location, []ethernet.ImportLocation{importLocation}, obj.Name)
		if err != nil {
			resp.Diagnostics.AddError("Failed to import resource into location", err.Error())
			return
		}
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *EthernetInterfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ethernet.Location

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &ethernet.SharedLocation{}
			var innerLocation EthernetInterfaceSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ethernet.TemplateLocation{}
			var innerLocation EthernetInterfaceTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ethernet.TemplateStackLocation{}
			var innerLocation EthernetInterfaceTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &ethernet.NgfwLocation{}
			var innerLocation EthernetInterfaceNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *EthernetInterfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location ethernet.Location

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &ethernet.SharedLocation{}
			var innerLocation EthernetInterfaceSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ethernet.TemplateLocation{}
			var innerLocation EthernetInterfaceTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ethernet.TemplateStackLocation{}
			var innerLocation EthernetInterfaceTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &ethernet.NgfwLocation{}
			var innerLocation EthernetInterfaceNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *ethernet.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *EthernetInterfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state EthernetInterfaceResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_ethernet_interface_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location ethernet.Location

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Shared.IsNull() {
			location.Shared = &ethernet.SharedLocation{}
			var innerLocation EthernetInterfaceSharedLocation
			resp.Diagnostics.Append(terraformLocation.Shared.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &ethernet.TemplateLocation{}
			var innerLocation EthernetInterfaceTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &ethernet.TemplateStackLocation{}
			var innerLocation EthernetInterfaceTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &ethernet.NgfwLocation{}
			var innerLocation EthernetInterfaceNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var importLocation ethernet.ImportLocation

	{
		var terraformLocation EthernetInterfaceLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if location.Template != nil {
			{
				var terraformInnerLocation EthernetInterfaceTemplateLocation
				resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &terraformInnerLocation, basetypes.ObjectAsOptions{})...)
				if resp.Diagnostics.HasError() {
					return
				}
				importLocation = ethernet.NewLayer3TemplateVsysImportLocation(ethernet.Layer3TemplateVsysImportLocationSpec{
					Vsys: terraformInnerLocation.Vsys.ValueString(),
				})
			}
		}
	}

	if importLocation != nil {
		err = o.manager.UnimportFromLocations(ctx, location, []ethernet.ImportLocation{importLocation}, state.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, []ethernet.ImportLocation{importLocation}, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type EthernetInterfaceImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o EthernetInterfaceImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *EthernetInterfaceLocation `json:"location"`
		Name     *string                    `json:"name"`
	}
	var location_object *EthernetInterfaceLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *EthernetInterfaceLocation `json:"location"`
		Name     *string                    `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func EthernetInterfaceImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := EthernetInterfaceImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *EthernetInterfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj EthernetInterfaceImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type EthernetInterfaceSharedLocation struct {
}
type EthernetInterfaceTemplateLocation struct {
	Vsys           types.String `tfsdk:"vsys"`
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type EthernetInterfaceLocation struct {
	Shared        types.Object `tfsdk:"shared"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
	Ngfw          types.Object `tfsdk:"ngfw"`
}

func EthernetInterfaceLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"shared": rsschema.SingleNestedAttribute{
				Description: "Panorama shared object",
				Optional:    true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("shared"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
						path.MatchRelative().AtParent().AtName("ngfw"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"vsys": rsschema.StringAttribute{
						Description: "",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("vsys1"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o EthernetInterfaceSharedLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
	}

	obj := shadow{}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceSharedLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}

	return nil
}
func (o EthernetInterfaceTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `tfsdk:"vsys"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
		Vsys:           o.Vsys.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
		Vsys           *string `tfsdk:"vsys"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)
	o.Vsys = types.StringPointerValue(shadow.Vsys)

	return nil
}
func (o EthernetInterfaceTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o EthernetInterfaceNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o EthernetInterfaceLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Shared        *EthernetInterfaceSharedLocation        `json:"shared,omitempty"`
		Template      *EthernetInterfaceTemplateLocation      `json:"template,omitempty"`
		TemplateStack *EthernetInterfaceTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *EthernetInterfaceNgfwLocation          `json:"ngfw,omitempty"`
	}
	var shared_object *EthernetInterfaceSharedLocation
	{
		diags := o.Shared.As(context.TODO(), &shared_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal shared into JSON document", diags.Errors())
		}
	}
	var template_object *EthernetInterfaceTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *EthernetInterfaceTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}
	var ngfw_object *EthernetInterfaceNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Shared:        shared_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
		Ngfw:          ngfw_object,
	}

	return json.Marshal(obj)
}

func (o *EthernetInterfaceLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Shared        *EthernetInterfaceSharedLocation        `json:"shared,omitempty"`
		Template      *EthernetInterfaceTemplateLocation      `json:"template,omitempty"`
		TemplateStack *EthernetInterfaceTemplateStackLocation `json:"template_stack,omitempty"`
		Ngfw          *EthernetInterfaceNgfwLocation          `json:"ngfw,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var shared_object types.Object
	{
		var diags_tmp diag.Diagnostics
		shared_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Shared.AttributeTypes(), shadow.Shared)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into shared", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	o.Shared = shared_object
	o.Template = template_object
	o.TemplateStack = templateStack_object
	o.Ngfw = ngfw_object

	return nil
}

func (o *EthernetInterfaceSharedLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}
func (o *EthernetInterfaceTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"vsys":            types.StringType,
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *EthernetInterfaceTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *EthernetInterfaceNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *EthernetInterfaceLocation) AttributeTypes() map[string]attr.Type {
	var sharedObj EthernetInterfaceSharedLocation
	var templateObj EthernetInterfaceTemplateLocation
	var templateStackObj EthernetInterfaceTemplateStackLocation
	var ngfwObj EthernetInterfaceNgfwLocation
	return map[string]attr.Type{
		"shared": types.ObjectType{
			AttrTypes: sharedObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
	}
}
