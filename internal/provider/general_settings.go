package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/device/services/general"

	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &GeneralSettingsDataSource{}
	_ datasource.DataSourceWithConfigure = &GeneralSettingsDataSource{}
)

func NewGeneralSettingsDataSource() datasource.DataSource {
	return &GeneralSettingsDataSource{}
}

type GeneralSettingsDataSource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*general.Config, general.Location, *general.Service]
}

type GeneralSettingsDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type GeneralSettingsDataSourceModel struct {
	Location             types.Object                                `tfsdk:"location"`
	Domain               types.String                                `tfsdk:"domain"`
	GeoLocation          *GeneralSettingsDataSourceGeoLocationObject `tfsdk:"geo_location"`
	Hostname             types.String                                `tfsdk:"hostname"`
	LoginBanner          types.String                                `tfsdk:"login_banner"`
	SslTlsServiceProfile types.String                                `tfsdk:"ssl_tls_service_profile"`
	Timezone             types.String                                `tfsdk:"timezone"`
}
type GeneralSettingsDataSourceGeoLocationObject struct {
	Latitude  types.String `tfsdk:"latitude"`
	Longitude types.String `tfsdk:"longitude"`
}

func (o *GeneralSettingsDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GeneralSettingsLocation

	var geoLocationObj *GeneralSettingsDataSourceGeoLocationObject

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"domain": types.StringType,
		"geo_location": types.ObjectType{
			AttrTypes: geoLocationObj.AttributeTypes(),
		},
		"hostname":                types.StringType,
		"login_banner":            types.StringType,
		"ssl_tls_service_profile": types.StringType,
		"timezone":                types.StringType,
	}
}

func (o GeneralSettingsDataSourceModel) AncestorName() string {
	return ""
}

func (o GeneralSettingsDataSourceModel) EntryName() *string {
	return nil
}
func (o *GeneralSettingsDataSourceGeoLocationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"latitude":  types.StringType,
		"longitude": types.StringType,
	}
}

func (o GeneralSettingsDataSourceGeoLocationObject) AncestorName() string {
	return "geo-location"
}

func (o GeneralSettingsDataSourceGeoLocationObject) EntryName() *string {
	return nil
}

func (o *GeneralSettingsDataSourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **general.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	domain_value := o.Domain.ValueStringPointer()
	var geoLocation_entry *general.GeoLocation
	if o.GeoLocation != nil {
		if *obj != nil && (*obj).GeoLocation != nil {
			geoLocation_entry = (*obj).GeoLocation
		} else {
			geoLocation_entry = new(general.GeoLocation)
		}
		// ModelOrObject: Model
		diags.Append(o.GeoLocation.CopyToPango(ctx, ancestors, &geoLocation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	hostname_value := o.Hostname.ValueStringPointer()
	loginBanner_value := o.LoginBanner.ValueStringPointer()
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()
	timezone_value := o.Timezone.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(general.Config)
	}
	(*obj).Domain = domain_value
	(*obj).GeoLocation = geoLocation_entry
	(*obj).Hostname = hostname_value
	(*obj).LoginBanner = loginBanner_value
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value
	(*obj).Timezone = timezone_value

	return diags
}
func (o *GeneralSettingsDataSourceGeoLocationObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **general.GeoLocation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	latitude_value := o.Latitude.ValueStringPointer()
	longitude_value := o.Longitude.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(general.GeoLocation)
	}
	(*obj).Latitude = latitude_value
	(*obj).Longitude = longitude_value

	return diags
}

func (o *GeneralSettingsDataSourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *general.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var geoLocation_object *GeneralSettingsDataSourceGeoLocationObject
	if obj.GeoLocation != nil {
		geoLocation_object = new(GeneralSettingsDataSourceGeoLocationObject)
		diags.Append(geoLocation_object.CopyFromPango(ctx, ancestors, obj.GeoLocation, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var domain_value types.String
	if obj.Domain != nil {
		domain_value = types.StringValue(*obj.Domain)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	var loginBanner_value types.String
	if obj.LoginBanner != nil {
		loginBanner_value = types.StringValue(*obj.LoginBanner)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	var timezone_value types.String
	if obj.Timezone != nil {
		timezone_value = types.StringValue(*obj.Timezone)
	}
	o.Domain = domain_value
	o.GeoLocation = geoLocation_object
	o.Hostname = hostname_value
	o.LoginBanner = loginBanner_value
	o.SslTlsServiceProfile = sslTlsServiceProfile_value
	o.Timezone = timezone_value

	return diags
}

func (o *GeneralSettingsDataSourceGeoLocationObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *general.GeoLocation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var latitude_value types.String
	if obj.Latitude != nil {
		latitude_value = types.StringValue(*obj.Latitude)
	}
	var longitude_value types.String
	if obj.Longitude != nil {
		longitude_value = types.StringValue(*obj.Longitude)
	}
	o.Latitude = latitude_value
	o.Longitude = longitude_value

	return diags
}

func (o *GeneralSettingsDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func GeneralSettingsDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": GeneralSettingsDataSourceLocationSchema(),

			"domain": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"geo_location": GeneralSettingsDataSourceGeoLocationSchema(),

			"hostname": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"login_banner": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssl_tls_service_profile": dsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timezone": dsschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GeneralSettingsDataSourceModel) getTypeFor(name string) attr.Type {
	schema := GeneralSettingsDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GeneralSettingsDataSourceGeoLocationSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"latitude": dsschema.StringAttribute{
				Description: "latitude coordinate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"longitude": dsschema.StringAttribute{
				Description: "longitude coordinate",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GeneralSettingsDataSourceGeoLocationObject) getTypeFor(name string) attr.Type {
	schema := GeneralSettingsDataSourceGeoLocationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GeneralSettingsDataSourceLocationSchema() rsschema.Attribute {
	return GeneralSettingsLocationSchema()
}

// Metadata returns the data source type name.
func (d *GeneralSettingsDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_general_settings"
}

// Schema defines the schema for this data source.
func (d *GeneralSettingsDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = GeneralSettingsDataSourceSchema()
}

// Configure prepares the struct.
func (d *GeneralSettingsDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := general.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	d.manager = sdkmanager.NewConfigObjectManager(d.client, general.NewService(d.client), specifier)
}
func (o *GeneralSettingsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var savestate, state GeneralSettingsDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location general.Location

	{
		var terraformLocation GeneralSettingsLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &general.SystemLocation{}
			var innerLocation GeneralSettingsSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.Device = innerLocation.Device.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &general.TemplateLocation{}
			var innerLocation GeneralSettingsTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &general.TemplateStackLocation{}
			var innerLocation GeneralSettingsTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_general_settings_resource",
		"function":      "Read",
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &GeneralSettingsResource{}
	_ resource.ResourceWithConfigure   = &GeneralSettingsResource{}
	_ resource.ResourceWithImportState = &GeneralSettingsResource{}
)

func NewGeneralSettingsResource() resource.Resource {
	return &GeneralSettingsResource{}
}

type GeneralSettingsResource struct {
	client  *pango.Client
	manager *sdkmanager.ConfigObjectManager[*general.Config, general.Location, *general.Service]
}

func GeneralSettingsResourceLocationSchema() rsschema.Attribute {
	return GeneralSettingsLocationSchema()
}

type GeneralSettingsResourceModel struct {
	Location             types.Object                              `tfsdk:"location"`
	Domain               types.String                              `tfsdk:"domain"`
	GeoLocation          *GeneralSettingsResourceGeoLocationObject `tfsdk:"geo_location"`
	Hostname             types.String                              `tfsdk:"hostname"`
	LoginBanner          types.String                              `tfsdk:"login_banner"`
	SslTlsServiceProfile types.String                              `tfsdk:"ssl_tls_service_profile"`
	Timezone             types.String                              `tfsdk:"timezone"`
}
type GeneralSettingsResourceGeoLocationObject struct {
	Latitude  types.String `tfsdk:"latitude"`
	Longitude types.String `tfsdk:"longitude"`
}

func (r *GeneralSettingsResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func GeneralSettingsResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": GeneralSettingsResourceLocationSchema(),

			"domain": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"geo_location": GeneralSettingsResourceGeoLocationSchema(),

			"hostname": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"login_banner": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"ssl_tls_service_profile": rsschema.StringAttribute{
				Description: "SSL TLS service profile",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"timezone": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.String{
					stringvalidator.OneOf([]string{
						"Africa/Abidjan",
						"Africa/Accra",
						"Africa/Addis_Ababa",
						"Africa/Algiers",
						"Africa/Asmara",
						"Africa/Asmera",
						"Africa/Bamako",
						"Africa/Bangui",
						"Africa/Banjul",
						"Africa/Bissau",
						"Africa/Blantyre",
						"Africa/Brazzaville",
						"Africa/Bujumbura",
						"Africa/Cairo",
						"Africa/Casablanca",
						"Africa/Ceuta",
						"Africa/Conakry",
						"Africa/Dakar",
						"Africa/Dar_es_Salaam",
						"Africa/Djibouti",
						"Africa/Douala",
						"Africa/El_Aaiun",
						"Africa/Freetown",
						"Africa/Gaborone",
						"Africa/Harare",
						"Africa/Johannesburg",
						"Africa/Kampala",
						"Africa/Khartoum",
						"Africa/Kigali",
						"Africa/Kinshasa",
						"Africa/Lagos",
						"Africa/Libreville",
						"Africa/Lome",
						"Africa/Luanda",
						"Africa/Lubumbashi",
						"Africa/Lusaka",
						"Africa/Malabo",
						"Africa/Maputo",
						"Africa/Maseru",
						"Africa/Mbabane",
						"Africa/Mogadishu",
						"Africa/Monrovia",
						"Africa/Nairobi",
						"Africa/Ndjamena",
						"Africa/Niamey",
						"Africa/Nouakchott",
						"Africa/Ouagadougou",
						"Africa/Porto-Novo",
						"Africa/Sao_Tome",
						"Africa/Timbuktu",
						"Africa/Tripoli",
						"Africa/Tunis",
						"Africa/Windhoek",
						"America/Adak",
						"America/Anchorage",
						"America/Anguilla",
						"America/Antigua",
						"America/Araguaina",
						"America/Argentina/Buenos_Aires",
						"America/Argentina/Catamarca",
						"America/Argentina/ComodRivadavia",
						"America/Argentina/Cordoba",
						"America/Argentina/Jujuy",
						"America/Argentina/La_Rioja",
						"America/Argentina/Mendoza",
						"America/Argentina/Rio_Gallegos",
						"America/Argentina/Salta",
						"America/Argentina/San_Juan",
						"America/Argentina/San_Luis",
						"America/Argentina/Tucuman",
						"America/Argentina/Ushuaia",
						"America/Aruba",
						"America/Asuncion",
						"America/Atikokan",
						"America/Atka",
						"America/Bahia",
						"America/Barbados",
						"America/Belem",
						"America/Belize",
						"America/Blanc-Sablon",
						"America/Boa_Vista",
						"America/Bogota",
						"America/Boise",
						"America/Buenos_Aires",
						"America/Cambridge_Bay",
						"America/Campo_Grande",
						"America/Cancun",
						"America/Caracas",
						"America/Catamarca",
						"America/Cayenne",
						"America/Cayman",
						"America/Chicago",
						"America/Chihuahua",
						"America/Coral_Harbour",
						"America/Cordoba",
						"America/Costa_Rica",
						"America/Cuiaba",
						"America/Curacao",
						"America/Danmarkshavn",
						"America/Dawson",
						"America/Dawson_Creek",
						"America/Denver",
						"America/Detroit",
						"America/Dominica",
						"America/Edmonton",
						"America/Eirunepe",
						"America/El_Salvador",
						"America/Ensenada",
						"America/Fortaleza",
						"America/Fort_Wayne",
						"America/Glace_Bay",
						"America/Godthab",
						"America/Goose_Bay",
						"America/Grand_Turk",
						"America/Grenada",
						"America/Guadeloupe",
						"America/Guatemala",
						"America/Guayaquil",
						"America/Guyana",
						"America/Halifax",
						"America/Havana",
						"America/Hermosillo",
						"America/Indiana/Indianapolis",
						"America/Indiana/Knox",
						"America/Indiana/Marengo",
						"America/Indiana/Petersburg",
						"America/Indianapolis",
						"America/Indiana/Tell_City",
						"America/Indiana/Vevay",
						"America/Indiana/Vincennes",
						"America/Indiana/Winamac",
						"America/Inuvik",
						"America/Iqaluit",
						"America/Jamaica",
						"America/Jujuy",
						"America/Juneau",
						"America/Kentucky/Louisville",
						"America/Kentucky/Monticello",
						"America/Knox_IN",
						"America/La_Paz",
						"America/Lima",
						"America/Los_Angeles",
						"America/Louisville",
						"America/Maceio",
						"America/Managua",
						"America/Manaus",
						"America/Marigot",
						"America/Martinique",
						"America/Mazatlan",
						"America/Mendoza",
						"America/Menominee",
						"America/Merida",
						"America/Mexico_City",
						"America/Miquelon",
						"America/Moncton",
						"America/Monterrey",
						"America/Montevideo",
						"America/Montreal",
						"America/Montserrat",
						"America/Nassau",
						"America/New_York",
						"America/Nipigon",
						"America/Nome",
						"America/Noronha",
						"America/North_Dakota/Center",
						"America/North_Dakota/New_Salem",
						"America/Panama",
						"America/Pangnirtung",
						"America/Paramaribo",
						"America/Phoenix",
						"America/Port-au-Prince",
						"America/Porto_Acre",
						"America/Port_of_Spain",
						"America/Porto_Velho",
						"America/Puerto_Rico",
						"America/Rainy_River",
						"America/Rankin_Inlet",
						"America/Recife",
						"America/Regina",
						"America/Resolute",
						"America/Rio_Branco",
						"America/Rosario",
						"America/Santarem",
						"America/Santiago",
						"America/Santo_Domingo",
						"America/Sao_Paulo",
						"America/Scoresbysund",
						"America/Shiprock",
						"America/St_Barthelemy",
						"America/St_Johns",
						"America/St_Kitts",
						"America/St_Lucia",
						"America/St_Thomas",
						"America/St_Vincent",
						"America/Swift_Current",
						"America/Tegucigalpa",
						"America/Thule",
						"America/Thunder_Bay",
						"America/Tijuana",
						"America/Toronto",
						"America/Tortola",
						"America/Vancouver",
						"America/Virgin",
						"America/Whitehorse",
						"America/Winnipeg",
						"America/Yakutat",
						"America/Yellowknife",
						"Antarctica/Casey",
						"Antarctica/Davis",
						"Antarctica/DumontDUrville",
						"Antarctica/Mawson",
						"Antarctica/McMurdo",
						"Antarctica/Palmer",
						"Antarctica/Rothera",
						"Antarctica/South_Pole",
						"Antarctica/Syowa",
						"Antarctica/Vostok",
						"Arctic/Longyearbyen",
						"Asia/Aden",
						"Asia/Almaty",
						"Asia/Amman",
						"Asia/Anadyr",
						"Asia/Aqtau",
						"Asia/Aqtobe",
						"Asia/Ashgabat",
						"Asia/Ashkhabad",
						"Asia/Baghdad",
						"Asia/Bahrain",
						"Asia/Baku",
						"Asia/Bangkok",
						"Asia/Beirut",
						"Asia/Bishkek",
						"Asia/Brunei",
						"Asia/Calcutta",
						"Asia/Choibalsan",
						"Asia/Chongqing",
						"Asia/Chungking",
						"Asia/Colombo",
						"Asia/Dacca",
						"Asia/Damascus",
						"Asia/Dhaka",
						"Asia/Dili",
						"Asia/Dubai",
						"Asia/Dushanbe",
						"Asia/Gaza",
						"Asia/Harbin",
						"Asia/Ho_Chi_Minh",
						"Asia/Hong_Kong",
						"Asia/Hovd",
						"Asia/Irkutsk",
						"Asia/Istanbul",
						"Asia/Jakarta",
						"Asia/Jayapura",
						"Asia/Jerusalem",
						"Asia/Kabul",
						"Asia/Kamchatka",
						"Asia/Karachi",
						"Asia/Kashgar",
						"Asia/Kathmandu",
						"Asia/Katmandu",
						"Asia/Kolkata",
						"Asia/Krasnoyarsk",
						"Asia/Kuala_Lumpur",
						"Asia/Kuching",
						"Asia/Kuwait",
						"Asia/Macao",
						"Asia/Macau",
						"Asia/Magadan",
						"Asia/Makassar",
						"Asia/Manila",
						"Asia/Muscat",
						"Asia/Nicosia",
						"Asia/Novokuznetsk",
						"Asia/Novosibirsk",
						"Asia/Omsk",
						"Asia/Oral",
						"Asia/Phnom_Penh",
						"Asia/Pontianak",
						"Asia/Pyongyang",
						"Asia/Qatar",
						"Asia/Qyzylorda",
						"Asia/Rangoon",
						"Asia/Riyadh",
						"Asia/Riyadh87",
						"Asia/Riyadh88",
						"Asia/Riyadh89",
						"Asia/Saigon",
						"Asia/Sakhalin",
						"Asia/Samarkand",
						"Asia/Seoul",
						"Asia/Shanghai",
						"Asia/Singapore",
						"Asia/Taipei",
						"Asia/Tashkent",
						"Asia/Tbilisi",
						"Asia/Tehran",
						"Asia/Tel_Aviv",
						"Asia/Thimbu",
						"Asia/Thimphu",
						"Asia/Tokyo",
						"Asia/Ujung_Pandang",
						"Asia/Ulaanbaatar",
						"Asia/Ulan_Bator",
						"Asia/Urumqi",
						"Asia/Vientiane",
						"Asia/Vladivostok",
						"Asia/Yakutsk",
						"Asia/Yekaterinburg",
						"Asia/Yerevan",
						"Atlantic/Azores",
						"Atlantic/Bermuda",
						"Atlantic/Canary",
						"Atlantic/Cape_Verde",
						"Atlantic/Faeroe",
						"Atlantic/Faroe",
						"Atlantic/Jan_Mayen",
						"Atlantic/Madeira",
						"Atlantic/Reykjavik",
						"Atlantic/South_Georgia",
						"Atlantic/Stanley",
						"Atlantic/St_Helena",
						"Australia/ACT",
						"Australia/Adelaide",
						"Australia/Brisbane",
						"Australia/Broken_Hill",
						"Australia/Canberra",
						"Australia/Currie",
						"Australia/Darwin",
						"Australia/Eucla",
						"Australia/Hobart",
						"Australia/LHI",
						"Australia/Lindeman",
						"Australia/Lord_Howe",
						"Australia/Melbourne",
						"Australia/North",
						"Australia/NSW",
						"Australia/Perth",
						"Australia/Queensland",
						"Australia/South",
						"Australia/Sydney",
						"Australia/Tasmania",
						"Australia/Victoria",
						"Australia/West",
						"Australia/Yancowinna",
						"Brazil/Acre",
						"Brazil/DeNoronha",
						"Brazil/East",
						"Brazil/West",
						"Canada/Atlantic",
						"Canada/Central",
						"Canada/Eastern",
						"Canada/East-Saskatchewan",
						"Canada/Mountain",
						"Canada/Newfoundland",
						"Canada/Pacific",
						"Canada/Saskatchewan",
						"Canada/Yukon",
						"CET",
						"Chile/Continental",
						"Chile/EasterIsland",
						"CST6CDT",
						"Cuba",
						"EET",
						"Egypt",
						"Eire",
						"EST",
						"EST5EDT",
						"Etc/GMT",
						"Etc/GMT0",
						"Etc/GMT-0",
						"Etc/GMT+0",
						"Etc/GMT-1",
						"Etc/GMT+1",
						"Etc/GMT-10",
						"Etc/GMT+10",
						"Etc/GMT-11",
						"Etc/GMT+11",
						"Etc/GMT-12",
						"Etc/GMT+12",
						"Etc/GMT-13",
						"Etc/GMT-14",
						"Etc/GMT-2",
						"Etc/GMT+2",
						"Etc/GMT-3",
						"Etc/GMT+3",
						"Etc/GMT-4",
						"Etc/GMT+4",
						"Etc/GMT-5",
						"Etc/GMT+5",
						"Etc/GMT-6",
						"Etc/GMT+6",
						"Etc/GMT-7",
						"Etc/GMT+7",
						"Etc/GMT-8",
						"Etc/GMT+8",
						"Etc/GMT-9",
						"Etc/GMT+9",
						"Etc/Greenwich",
						"Etc/UCT",
						"Etc/Universal",
						"Etc/UTC",
						"Etc/Zulu",
						"Europe/Amsterdam",
						"Europe/Andorra",
						"Europe/Athens",
						"Europe/Belfast",
						"Europe/Belgrade",
						"Europe/Berlin",
						"Europe/Bratislava",
						"Europe/Brussels",
						"Europe/Bucharest",
						"Europe/Budapest",
						"Europe/Chisinau",
						"Europe/Copenhagen",
						"Europe/Dublin",
						"Europe/Gibraltar",
						"Europe/Guernsey",
						"Europe/Helsinki",
						"Europe/Isle_of_Man",
						"Europe/Istanbul",
						"Europe/Jersey",
						"Europe/Kaliningrad",
						"Europe/Kiev",
						"Europe/Lisbon",
						"Europe/Ljubljana",
						"Europe/London",
						"Europe/Luxembourg",
						"Europe/Madrid",
						"Europe/Malta",
						"Europe/Mariehamn",
						"Europe/Minsk",
						"Europe/Monaco",
						"Europe/Moscow",
						"Europe/Nicosia",
						"Europe/Oslo",
						"Europe/Paris",
						"Europe/Podgorica",
						"Europe/Prague",
						"Europe/Riga",
						"Europe/Rome",
						"Europe/Samara",
						"Europe/San_Marino",
						"Europe/Sarajevo",
						"Europe/Simferopol",
						"Europe/Skopje",
						"Europe/Sofia",
						"Europe/Stockholm",
						"Europe/Tallinn",
						"Europe/Tirane",
						"Europe/Tiraspol",
						"Europe/Uzhgorod",
						"Europe/Vaduz",
						"Europe/Vatican",
						"Europe/Vienna",
						"Europe/Vilnius",
						"Europe/Volgograd",
						"Europe/Warsaw",
						"Europe/Zagreb",
						"Europe/Zaporozhye",
						"Europe/Zurich",
						"Factory",
						"GB",
						"GB-Eire",
						"GMT",
						"GMT0",
						"GMT-0",
						"GMT+0",
						"Greenwich",
						"Hongkong",
						"HST",
						"Iceland",
						"Indian/Antananarivo",
						"Indian/Chagos",
						"Indian/Christmas",
						"Indian/Cocos",
						"Indian/Comoro",
						"Indian/Kerguelen",
						"Indian/Mahe",
						"Indian/Maldives",
						"Indian/Mauritius",
						"Indian/Mayotte",
						"Indian/Reunion",
						"Iran",
						"Israel",
						"Jamaica",
						"Japan",
						"Kwajalein",
						"Libya",
						"MET",
						"Mexico/BajaNorte",
						"Mexico/BajaSur",
						"Mexico/General",
						"Mideast/Riyadh87",
						"Mideast/Riyadh88",
						"Mideast/Riyadh89",
						"MST",
						"MST7MDT",
						"Navajo",
						"NZ",
						"NZ-CHAT",
						"Pacific/Apia",
						"Pacific/Auckland",
						"Pacific/Chatham",
						"Pacific/Easter",
						"Pacific/Efate",
						"Pacific/Enderbury",
						"Pacific/Fakaofo",
						"Pacific/Fiji",
						"Pacific/Funafuti",
						"Pacific/Galapagos",
						"Pacific/Gambier",
						"Pacific/Guadalcanal",
						"Pacific/Guam",
						"Pacific/Honolulu",
						"Pacific/Johnston",
						"Pacific/Kiritimati",
						"Pacific/Kosrae",
						"Pacific/Kwajalein",
						"Pacific/Majuro",
						"Pacific/Marquesas",
						"Pacific/Midway",
						"Pacific/Nauru",
						"Pacific/Niue",
						"Pacific/Norfolk",
						"Pacific/Noumea",
						"Pacific/Pago_Pago",
						"Pacific/Palau",
						"Pacific/Pitcairn",
						"Pacific/Ponape",
						"Pacific/Port_Moresby",
						"Pacific/Rarotonga",
						"Pacific/Saipan",
						"Pacific/Samoa",
						"Pacific/Tahiti",
						"Pacific/Tarawa",
						"Pacific/Tongatapu",
						"Pacific/Truk",
						"Pacific/Wake",
						"Pacific/Wallis",
						"Pacific/Yap",
						"Poland",
						"Portugal",
						"PRC",
						"PST8PDT",
						"ROC",
						"ROK",
						"Singapore",
						"Turkey",
						"UCT",
						"Universal",
						"US/Alaska",
						"US/Aleutian",
						"US/Arizona",
						"US/Central",
						"US/Eastern",
						"US/East-Indiana",
						"US/Hawaii",
						"US/Indiana-Starke",
						"US/Michigan",
						"US/Mountain",
						"US/Pacific",
						"US/Samoa",
						"UTC",
						"WET",
						"W-SU",
						"Zulu",
					}...),
				},
			},
		},
	}
}

func (o *GeneralSettingsResourceModel) getTypeFor(name string) attr.Type {
	schema := GeneralSettingsResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func GeneralSettingsResourceGeoLocationSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"latitude": rsschema.StringAttribute{
				Description: "latitude coordinate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"longitude": rsschema.StringAttribute{
				Description: "longitude coordinate",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *GeneralSettingsResourceGeoLocationObject) getTypeFor(name string) attr.Type {
	schema := GeneralSettingsResourceGeoLocationSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *GeneralSettingsResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_general_settings"
}

func (r *GeneralSettingsResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = GeneralSettingsResourceSchema()
}

// </ResourceSchema>

func (r *GeneralSettingsResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
	specifier, _, err := general.Versioning(r.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	r.manager = sdkmanager.NewConfigObjectManager(r.client, general.NewService(r.client), specifier)
}

func (o *GeneralSettingsResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj GeneralSettingsLocation

	var geoLocationObj *GeneralSettingsResourceGeoLocationObject

	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"domain": types.StringType,
		"geo_location": types.ObjectType{
			AttrTypes: geoLocationObj.AttributeTypes(),
		},
		"hostname":                types.StringType,
		"login_banner":            types.StringType,
		"ssl_tls_service_profile": types.StringType,
		"timezone":                types.StringType,
	}
}

func (o GeneralSettingsResourceModel) AncestorName() string {
	return ""
}

func (o GeneralSettingsResourceModel) EntryName() *string {
	return nil
}
func (o *GeneralSettingsResourceGeoLocationObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"latitude":  types.StringType,
		"longitude": types.StringType,
	}
}

func (o GeneralSettingsResourceGeoLocationObject) AncestorName() string {
	return "geo-location"
}

func (o GeneralSettingsResourceGeoLocationObject) EntryName() *string {
	return nil
}

func (o *GeneralSettingsResourceModel) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **general.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	domain_value := o.Domain.ValueStringPointer()
	var geoLocation_entry *general.GeoLocation
	if o.GeoLocation != nil {
		if *obj != nil && (*obj).GeoLocation != nil {
			geoLocation_entry = (*obj).GeoLocation
		} else {
			geoLocation_entry = new(general.GeoLocation)
		}
		// ModelOrObject: Model
		diags.Append(o.GeoLocation.CopyToPango(ctx, ancestors, &geoLocation_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	hostname_value := o.Hostname.ValueStringPointer()
	loginBanner_value := o.LoginBanner.ValueStringPointer()
	sslTlsServiceProfile_value := o.SslTlsServiceProfile.ValueStringPointer()
	timezone_value := o.Timezone.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(general.Config)
	}
	(*obj).Domain = domain_value
	(*obj).GeoLocation = geoLocation_entry
	(*obj).Hostname = hostname_value
	(*obj).LoginBanner = loginBanner_value
	(*obj).SslTlsServiceProfile = sslTlsServiceProfile_value
	(*obj).Timezone = timezone_value

	return diags
}
func (o *GeneralSettingsResourceGeoLocationObject) CopyToPango(ctx context.Context, ancestors []Ancestor, obj **general.GeoLocation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	latitude_value := o.Latitude.ValueStringPointer()
	longitude_value := o.Longitude.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(general.GeoLocation)
	}
	(*obj).Latitude = latitude_value
	(*obj).Longitude = longitude_value

	return diags
}

func (o *GeneralSettingsResourceModel) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *general.Config, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var geoLocation_object *GeneralSettingsResourceGeoLocationObject
	if obj.GeoLocation != nil {
		geoLocation_object = new(GeneralSettingsResourceGeoLocationObject)
		diags.Append(geoLocation_object.CopyFromPango(ctx, ancestors, obj.GeoLocation, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	var domain_value types.String
	if obj.Domain != nil {
		domain_value = types.StringValue(*obj.Domain)
	}
	var hostname_value types.String
	if obj.Hostname != nil {
		hostname_value = types.StringValue(*obj.Hostname)
	}
	var loginBanner_value types.String
	if obj.LoginBanner != nil {
		loginBanner_value = types.StringValue(*obj.LoginBanner)
	}
	var sslTlsServiceProfile_value types.String
	if obj.SslTlsServiceProfile != nil {
		sslTlsServiceProfile_value = types.StringValue(*obj.SslTlsServiceProfile)
	}
	var timezone_value types.String
	if obj.Timezone != nil {
		timezone_value = types.StringValue(*obj.Timezone)
	}
	o.Domain = domain_value
	o.GeoLocation = geoLocation_object
	o.Hostname = hostname_value
	o.LoginBanner = loginBanner_value
	o.SslTlsServiceProfile = sslTlsServiceProfile_value
	o.Timezone = timezone_value

	return diags
}

func (o *GeneralSettingsResourceGeoLocationObject) CopyFromPango(ctx context.Context, ancestors []Ancestor, obj *general.GeoLocation, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var latitude_value types.String
	if obj.Latitude != nil {
		latitude_value = types.StringValue(*obj.Latitude)
	}
	var longitude_value types.String
	if obj.Longitude != nil {
		longitude_value = types.StringValue(*obj.Longitude)
	}
	o.Latitude = latitude_value
	o.Longitude = longitude_value

	return diags
}

func (o *GeneralSettingsResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (r *GeneralSettingsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state GeneralSettingsResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_general_settings_resource",
		"function":      "Create",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location general.Location

	{
		var terraformLocation GeneralSettingsLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &general.SystemLocation{}
			var innerLocation GeneralSettingsSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.Device = innerLocation.Device.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &general.TemplateLocation{}
			var innerLocation GeneralSettingsTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &general.TemplateStackLocation{}
			var innerLocation GeneralSettingsTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *general.Config
	resp.Diagnostics.Append(state.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := r.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *GeneralSettingsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var savestate, state GeneralSettingsResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location general.Location

	{
		var terraformLocation GeneralSettingsLocation
		resp.Diagnostics.Append(savestate.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &general.SystemLocation{}
			var innerLocation GeneralSettingsSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.Device = innerLocation.Device.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &general.TemplateLocation{}
			var innerLocation GeneralSettingsTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &general.TemplateStackLocation{}
			var innerLocation GeneralSettingsTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_general_settings_resource",
		"function":      "Read",
	})

	components, err := savestate.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components)
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = savestate.Timeouts
	*/

	state.Location = savestate.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *GeneralSettingsResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state GeneralSettingsResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location general.Location

	{
		var terraformLocation GeneralSettingsLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &general.SystemLocation{}
			var innerLocation GeneralSettingsSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.Device = innerLocation.Device.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &general.TemplateLocation{}
			var innerLocation GeneralSettingsTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &general.TemplateStackLocation{}
			var innerLocation GeneralSettingsTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_general_settings_resource",
		"function":      "Update",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	obj, err := r.manager.Read(ctx, location, components)
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	updated, err := r.manager.Update(ctx, location, components, obj)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	// Save the location.
	state.Location = plan.Location

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := state.CopyFromPango(ctx, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (r *GeneralSettingsResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state GeneralSettingsResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_general_settings_resource",
		"function":      "Delete",
	})

	// Verify mode.
	if r.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location general.Location

	{
		var terraformLocation GeneralSettingsLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.System.IsNull() {
			location.System = &general.SystemLocation{}
			var innerLocation GeneralSettingsSystemLocation
			resp.Diagnostics.Append(terraformLocation.System.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.System.Device = innerLocation.Device.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &general.TemplateLocation{}
			var innerLocation GeneralSettingsTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &general.TemplateStackLocation{}
			var innerLocation GeneralSettingsTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	existing, err := r.manager.Read(ctx, location, components)
	if err != nil {
		resp.Diagnostics.AddError("Error while deleting resource", err.Error())
		return
	}

	var obj general.Config
	obj.Misc = existing.Misc

	err = r.manager.Delete(ctx, location, &obj)
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

func (r *GeneralSettingsResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type GeneralSettingsSystemLocation struct {
	Device types.String `tfsdk:"device"`
}
type GeneralSettingsTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GeneralSettingsTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type GeneralSettingsLocation struct {
	System        types.Object `tfsdk:"system"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func GeneralSettingsLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"system": rsschema.SingleNestedAttribute{
				Description: "System-level configuration",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"device": rsschema.StringAttribute{
						Description: "Device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("system"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o GeneralSettingsSystemLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Device *string `json:"device,omitempty"`
	}

	obj := shadow{
		Device: o.Device.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GeneralSettingsSystemLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Device *string `json:"device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.Device = types.StringPointerValue(shadow.Device)

	return nil
}
func (o GeneralSettingsTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GeneralSettingsTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GeneralSettingsTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *GeneralSettingsTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o GeneralSettingsLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		System        *GeneralSettingsSystemLocation        `json:"system,omitempty"`
		Template      *GeneralSettingsTemplateLocation      `json:"template,omitempty"`
		TemplateStack *GeneralSettingsTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var system_object *GeneralSettingsSystemLocation
	{
		diags := o.System.As(context.TODO(), &system_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal system into JSON document", diags.Errors())
		}
	}
	var template_object *GeneralSettingsTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *GeneralSettingsTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		System:        system_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *GeneralSettingsLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		System        *GeneralSettingsSystemLocation        `json:"system,omitempty"`
		Template      *GeneralSettingsTemplateLocation      `json:"template,omitempty"`
		TemplateStack *GeneralSettingsTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var system_object types.Object
	{
		var diags_tmp diag.Diagnostics
		system_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.System.AttributeTypes(), shadow.System)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into system", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.System = system_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *GeneralSettingsSystemLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"device": types.StringType,
	}
}
func (o *GeneralSettingsTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GeneralSettingsTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *GeneralSettingsLocation) AttributeTypes() map[string]attr.Type {
	var systemObj GeneralSettingsSystemLocation
	var templateObj GeneralSettingsTemplateLocation
	var templateStackObj GeneralSettingsTemplateStackLocation
	return map[string]attr.Type{
		"system": types.ObjectType{
			AttrTypes: systemObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
