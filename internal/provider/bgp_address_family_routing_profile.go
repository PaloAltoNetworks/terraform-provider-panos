package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/PaloAltoNetworks/pango"
	"github.com/PaloAltoNetworks/pango/network/routing-profile/bgp/addressfamily"
	pangoutil "github.com/PaloAltoNetworks/pango/util"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	sdkmanager "github.com/PaloAltoNetworks/terraform-provider-panos/internal/manager"
)

// Generate Terraform Data Source object.
var (
	_ datasource.DataSource              = &BgpAddressFamilyRoutingProfileDataSource{}
	_ datasource.DataSourceWithConfigure = &BgpAddressFamilyRoutingProfileDataSource{}
)

func NewBgpAddressFamilyRoutingProfileDataSource() datasource.DataSource {
	return &BgpAddressFamilyRoutingProfileDataSource{}
}

type BgpAddressFamilyRoutingProfileDataSource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*addressfamily.Entry, addressfamily.Location, *addressfamily.Service]
}

type BgpAddressFamilyRoutingProfileDataSourceFilter struct {
	// TODO: Generate Data Source filter via function
}

type BgpAddressFamilyRoutingProfileDataSourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Ipv4     types.Object `tfsdk:"ipv4"`
	Ipv6     types.Object `tfsdk:"ipv6"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4Object struct {
	Multicast types.Object `tfsdk:"multicast"`
	Unicast   types.Object `tfsdk:"unicast"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6Object struct {
	Unicast types.Object `tfsdk:"unicast"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject struct {
}

func (o *BgpAddressFamilyRoutingProfileDataSourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj BgpAddressFamilyRoutingProfileLocation

	var ipv4Obj *BgpAddressFamilyRoutingProfileDataSourceIpv4Object

	var ipv6Obj *BgpAddressFamilyRoutingProfileDataSourceIpv6Object
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceModel) AncestorName() string {
	return ""
}

func (o BgpAddressFamilyRoutingProfileDataSourceModel) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4Object) AttributeTypes() map[string]attr.Type {

	var multicastObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject

	var unicastObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject
	return map[string]attr.Type{
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"unicast": types.ObjectType{
			AttrTypes: unicastObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4Object) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) AncestorName() string {
	return "multicast"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) AncestorName() string {
	return "unicast"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6Object) AttributeTypes() map[string]attr.Type {

	var unicastObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject
	return map[string]attr.Type{
		"unicast": types.ObjectType{
			AttrTypes: unicastObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6Object) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) AncestorName() string {
	return "unicast"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) EntryName() *string {
	return nil
}

func (o *BgpAddressFamilyRoutingProfileDataSourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *addressfamily.Ipv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(addressfamily.Ipv4)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *addressfamily.Ipv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(addressfamily.Ipv6)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var multicast_entry *addressfamily.Ipv4Multicast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(addressfamily.Ipv4Multicast)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var unicast_entry *addressfamily.Ipv4Unicast
	if !o.Unicast.IsUnknown() && !o.Unicast.IsNull() {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(addressfamily.Ipv4Unicast)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject
		diags.Append(o.Unicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &unicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4)
	}
	(*obj).Multicast = multicast_entry
	(*obj).Unicast = unicast_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv4MulticastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv4MulticastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv4MulticastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv4MulticastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv4MulticastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv4MulticastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv4MulticastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv4MulticastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv4MulticastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv4MulticastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv4MulticastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv4MulticastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv4MulticastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv4MulticastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4Multicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv4MulticastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv4MulticastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv4MulticastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv4MulticastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv4MulticastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv4MulticastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv4MulticastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv4MulticastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv4MulticastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv4MulticastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4MulticastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4MulticastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv4MulticastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv4MulticastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4MulticastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4MulticastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv4MulticastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv4MulticastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv4MulticastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv4MulticastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv4MulticastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv4MulticastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv4MulticastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv4MulticastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityStandard)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv4UnicastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv4UnicastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv4UnicastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv4UnicastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv4UnicastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv4UnicastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv4UnicastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv4UnicastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv4UnicastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv4UnicastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv4UnicastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv4UnicastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv4UnicastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv4UnicastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4Unicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv4UnicastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv4UnicastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv4UnicastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv4UnicastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv4UnicastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv4UnicastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv4UnicastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv4UnicastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv4UnicastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv4UnicastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4UnicastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4UnicastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv4UnicastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv4UnicastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4UnicastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4UnicastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv4UnicastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv4UnicastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv4UnicastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv4UnicastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv4UnicastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv4UnicastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv4UnicastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv4UnicastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityStandard)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *addressfamily.Ipv6Unicast
	if !o.Unicast.IsUnknown() && !o.Unicast.IsNull() {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(addressfamily.Ipv6Unicast)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject
		diags.Append(o.Unicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &unicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6)
	}
	(*obj).Unicast = unicast_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv6UnicastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv6UnicastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv6UnicastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv6UnicastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv6UnicastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv6UnicastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv6UnicastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv6UnicastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv6UnicastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv6UnicastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv6UnicastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv6UnicastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv6UnicastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv6UnicastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6Unicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv6UnicastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv6UnicastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv6UnicastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv6UnicastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv6UnicastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv6UnicastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv6UnicastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv6UnicastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv6UnicastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv6UnicastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv6UnicastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv6UnicastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv6UnicastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv6UnicastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv6UnicastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv6UnicastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv6UnicastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv6UnicastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv6UnicastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv6UnicastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv6UnicastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv6UnicastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv6UnicastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv6UnicastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityStandard)
	}

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, ancestors, obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, ancestors, obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var multicast_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var unicast_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject
	if o.Unicast.IsNull() {
		unicast_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject)
	} else {
		diags.Append(o.Unicast.As(ctx, &unicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	unicast_object := types.ObjectNull(unicast_obj.AttributeTypes())
	if obj.Unicast != nil {
		diags.Append(unicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Unicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		unicast_object, diags_tmp = types.ObjectValueFrom(ctx, unicast_obj.AttributeTypes(), unicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Multicast = multicast_object
	o.Unicast = unicast_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject
	if o.Unicast.IsNull() {
		unicast_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject)
	} else {
		diags.Append(o.Unicast.As(ctx, &unicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	unicast_object := types.ObjectNull(unicast_obj.AttributeTypes())
	if obj.Unicast != nil {
		diags.Append(unicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Unicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		unicast_object, diags_tmp = types.ObjectValueFrom(ctx, unicast_obj.AttributeTypes(), unicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Unicast = unicast_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileDataSourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func BgpAddressFamilyRoutingProfileDataSourceSchema() dsschema.Schema {
	return dsschema.Schema{
		Attributes: map[string]dsschema.Attribute{

			"location": BgpAddressFamilyRoutingProfileDataSourceLocationSchema(),

			"name": dsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ipv4": BgpAddressFamilyRoutingProfileDataSourceIpv4Schema(),

			"ipv6": BgpAddressFamilyRoutingProfileDataSourceIpv6Schema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceModel) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"multicast": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSchema(),

			"unicast": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4Object) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInSchema(),

			"as_override": dsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": dsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": dsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsSchema(),

			"route_reflector_client": dsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": dsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"tx_all_paths": dsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": dsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"occurrence": dsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionSchema(),

			"max_prefixes": dsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"orf_prefix_list": dsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4MulticastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInSchema(),

			"as_override": dsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": dsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": dsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsSchema(),

			"route_reflector_client": dsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": dsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"tx_all_paths": dsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": dsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"occurrence": dsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionSchema(),

			"max_prefixes": dsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"orf_prefix_list": dsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv4UnicastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6Schema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"unicast": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6Object) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInSchema(),

			"as_override": dsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": dsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": dsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": dsschema.BoolAttribute{
				Description: "Enable",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsSchema(),

			"route_reflector_client": dsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": dsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"tx_all_paths": dsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": dsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"occurrence": dsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"origin": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionSchema(),

			"max_prefixes": dsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"threshold": dsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{

			"interval": dsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"orf_prefix_list": dsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunitySchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]dsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardSchema() dsschema.SingleNestedAttribute {
	return dsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    true,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]dsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileDataSourceIpv6UnicastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case dsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case dsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileDataSourceLocationSchema() rsschema.Attribute {
	return BgpAddressFamilyRoutingProfileLocationSchema()
}

// Metadata returns the data source type name.
func (d *BgpAddressFamilyRoutingProfileDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_bgp_address_family_routing_profile"
}

// Schema defines the schema for this data source.
func (d *BgpAddressFamilyRoutingProfileDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = BgpAddressFamilyRoutingProfileDataSourceSchema()
}

// Configure prepares the struct.
func (d *BgpAddressFamilyRoutingProfileDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	d.client = providerData.Client
	specifier, _, err := addressfamily.Versioning(d.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	d.manager = sdkmanager.NewEntryObjectManager[*addressfamily.Entry, addressfamily.Location, *addressfamily.Service](d.client, addressfamily.NewService(d.client), batchSize, specifier, addressfamily.SpecMatches)
}
func (o *BgpAddressFamilyRoutingProfileDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {

	var state BgpAddressFamilyRoutingProfileDataSourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location addressfamily.Location

	{
		var terraformLocation BgpAddressFamilyRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &addressfamily.NgfwLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &addressfamily.TemplateLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &addressfamily.TemplateStackLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_bgp_address_family_routing_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.Diagnostics.AddError("Error reading data", err.Error())
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}

// Generate Terraform Resource object
var (
	_ resource.Resource                = &BgpAddressFamilyRoutingProfileResource{}
	_ resource.ResourceWithConfigure   = &BgpAddressFamilyRoutingProfileResource{}
	_ resource.ResourceWithImportState = &BgpAddressFamilyRoutingProfileResource{}
)

func NewBgpAddressFamilyRoutingProfileResource() resource.Resource {
	if _, found := resourceFuncMap["panos_bgp_address_family_routing_profile"]; !found {
		resourceFuncMap["panos_bgp_address_family_routing_profile"] = resourceFuncs{
			CreateImportId: BgpAddressFamilyRoutingProfileImportStateCreator,
		}
	}
	return &BgpAddressFamilyRoutingProfileResource{}
}

type BgpAddressFamilyRoutingProfileResource struct {
	client  *pango.Client
	manager *sdkmanager.EntryObjectManager[*addressfamily.Entry, addressfamily.Location, *addressfamily.Service]
}

func BgpAddressFamilyRoutingProfileResourceLocationSchema() rsschema.Attribute {
	return BgpAddressFamilyRoutingProfileLocationSchema()
}

type BgpAddressFamilyRoutingProfileResourceModel struct {
	Location types.Object `tfsdk:"location"`
	Name     types.String `tfsdk:"name"`
	Ipv4     types.Object `tfsdk:"ipv4"`
	Ipv6     types.Object `tfsdk:"ipv6"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4Object struct {
	Multicast types.Object `tfsdk:"multicast"`
	Unicast   types.Object `tfsdk:"unicast"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6Object struct {
	Unicast types.Object `tfsdk:"unicast"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject struct {
	AddPath                    types.Object `tfsdk:"add_path"`
	AllowasIn                  types.Object `tfsdk:"allowas_in"`
	AsOverride                 types.Bool   `tfsdk:"as_override"`
	DefaultOriginate           types.Bool   `tfsdk:"default_originate"`
	DefaultOriginateMap        types.String `tfsdk:"default_originate_map"`
	Enable                     types.Bool   `tfsdk:"enable"`
	MaximumPrefix              types.Object `tfsdk:"maximum_prefix"`
	NextHop                    types.Object `tfsdk:"next_hop"`
	Orf                        types.Object `tfsdk:"orf"`
	RemovePrivateAs            types.Object `tfsdk:"remove_private_as"`
	RouteReflectorClient       types.Bool   `tfsdk:"route_reflector_client"`
	SendCommunity              types.Object `tfsdk:"send_community"`
	SoftReconfigWithStoredInfo types.Bool   `tfsdk:"soft_reconfig_with_stored_info"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject struct {
	TxAllPaths      types.Bool `tfsdk:"tx_all_paths"`
	TxBestpathPerAs types.Bool `tfsdk:"tx_bestpath_per_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject struct {
	Occurrence types.Int64  `tfsdk:"occurrence"`
	Origin     types.Object `tfsdk:"origin"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject struct {
	Action      types.Object `tfsdk:"action"`
	MaxPrefixes types.Int64  `tfsdk:"max_prefixes"`
	Threshold   types.Int64  `tfsdk:"threshold"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject struct {
	Restart     types.Object `tfsdk:"restart"`
	WarningOnly types.Object `tfsdk:"warning_only"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject struct {
	Interval types.Int64 `tfsdk:"interval"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject struct {
	Self      types.Object `tfsdk:"self"`
	SelfForce types.Object `tfsdk:"self_force"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject struct {
	OrfPrefixList types.String `tfsdk:"orf_prefix_list"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject struct {
	All       types.Object `tfsdk:"all"`
	ReplaceAs types.Object `tfsdk:"replace_as"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject struct {
	All      types.Object `tfsdk:"all"`
	Both     types.Object `tfsdk:"both"`
	Extended types.Object `tfsdk:"extended"`
	Large    types.Object `tfsdk:"large"`
	Standard types.Object `tfsdk:"standard"`
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject struct {
}
type BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject struct {
}

func (o *BgpAddressFamilyRoutingProfileResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func BgpAddressFamilyRoutingProfileResourceSchema() rsschema.Schema {
	return rsschema.Schema{
		Attributes: map[string]rsschema.Attribute{

			"location": BgpAddressFamilyRoutingProfileResourceLocationSchema(),

			"name": rsschema.StringAttribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"ipv4": BgpAddressFamilyRoutingProfileResourceIpv4Schema(),

			"ipv6": BgpAddressFamilyRoutingProfileResourceIpv6Schema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceModel) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("ipv4"),
				path.MatchRelative().AtParent().AtName("ipv6"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"multicast": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSchema(),

			"unicast": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4Object) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInSchema(),

			"as_override": rsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": rsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": rsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsSchema(),

			"route_reflector_client": rsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": rsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"tx_all_paths": rsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": rsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"occurrence": rsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("occurrence"),
						path.MatchRelative().AtParent().AtName("origin"),
					}...),
				},
			},

			"origin": BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionSchema(),

			"max_prefixes": rsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1000),
			},

			"threshold": rsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interval": rsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"orf_prefix_list": rsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInSchema(),

			"as_override": rsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": rsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": rsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsSchema(),

			"route_reflector_client": rsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": rsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"tx_all_paths": rsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": rsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"occurrence": rsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("occurrence"),
						path.MatchRelative().AtParent().AtName("origin"),
					}...),
				},
			},

			"origin": BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionSchema(),

			"max_prefixes": rsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1000),
			},

			"threshold": rsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interval": rsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"orf_prefix_list": rsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6Schema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"unicast": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6Object) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6Schema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"add_path": BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathSchema(),

			"allowas_in": BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInSchema(),

			"as_override": rsschema.BoolAttribute{
				Description: "Override ASNs in outbound updates if AS-Path equals Remote-AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate": rsschema.BoolAttribute{
				Description: "Originate Default Route",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"default_originate_map": rsschema.StringAttribute{
				Description: "Route-Map used in Default Originate Configuration",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"enable": rsschema.BoolAttribute{
				Description: "Enable",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"maximum_prefix": BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixSchema(),

			"next_hop": BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSchema(),

			"orf": BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfSchema(),

			"remove_private_as": BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsSchema(),

			"route_reflector_client": rsschema.BoolAttribute{
				Description: "Route Reflector Client",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"send_community": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunitySchema(),

			"soft_reconfig_with_stored_info": rsschema.BoolAttribute{
				Description: "Soft reconfiguration of peer with stored routes",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"tx_all_paths": rsschema.BoolAttribute{
				Description: "Advertise all paths to peer",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},

			"tx_bestpath_per_as": rsschema.BoolAttribute{
				Description: "Advertise the bestpath per each neighboring AS",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"occurrence": rsschema.Int64Attribute{
				Description: "Number of occurrences of AS number",
				Computed:    false,
				Required:    false,
				Optional:    true,
				Sensitive:   false,

				Validators: []validator.Int64{
					int64validator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("occurrence"),
						path.MatchRelative().AtParent().AtName("origin"),
					}...),
				},
			},

			"origin": BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("occurrence"),
				path.MatchRelative().AtParent().AtName("origin"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"action": BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionSchema(),

			"max_prefixes": rsschema.Int64Attribute{
				Description: "Max allowed prefixes from this peer",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1000),
			},

			"threshold": rsschema.Int64Attribute{
				Description: "Threshold value (%) at which to generate a warning msg",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(100),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"restart": BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartSchema(),

			"warning_only": BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlySchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{

			"interval": rsschema.Int64Attribute{
				Description: "Restart interval in minutes",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     int64default.StaticInt64(1),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("restart"),
				path.MatchRelative().AtParent().AtName("warning_only"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"self": BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfSchema(),

			"self_force": BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("self"),
				path.MatchRelative().AtParent().AtName("self_force"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"orf_prefix_list": rsschema.StringAttribute{
				Description: "Advertise Prefix-List ORF Capability",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
				Default:     stringdefault.StaticString("none"),
			},
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllSchema(),

			"replace_as": BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("replace_as"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunitySchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,
		Attributes: map[string]rsschema.Attribute{

			"all": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllSchema(),

			"both": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothSchema(),

			"extended": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedSchema(),

			"large": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeSchema(),

			"standard": BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardSchema(),
		},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunitySchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardSchema() rsschema.SingleNestedAttribute {
	return rsschema.SingleNestedAttribute{
		Description: "",
		Required:    false,
		Computed:    false,
		Optional:    true,
		Sensitive:   false,

		Validators: []validator.Object{
			objectvalidator.ExactlyOneOf(path.Expressions{
				path.MatchRelative().AtParent().AtName("all"),
				path.MatchRelative().AtParent().AtName("both"),
				path.MatchRelative().AtParent().AtName("extended"),
				path.MatchRelative().AtParent().AtName("large"),
				path.MatchRelative().AtParent().AtName("standard"),
			}...),
		},
		Attributes: map[string]rsschema.Attribute{},
	}
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) getTypeFor(name string) attr.Type {
	schema := BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case rsschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case rsschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (o *BgpAddressFamilyRoutingProfileResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_bgp_address_family_routing_profile"
}

func (o *BgpAddressFamilyRoutingProfileResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = BgpAddressFamilyRoutingProfileResourceSchema()
}

// </ResourceSchema>

func (o *BgpAddressFamilyRoutingProfileResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	o.client = providerData.Client
	specifier, _, err := addressfamily.Versioning(o.client.Versioning())
	if err != nil {
		resp.Diagnostics.AddError("Failed to configure SDK client", err.Error())
		return
	}
	batchSize := providerData.MultiConfigBatchSize
	o.manager = sdkmanager.NewEntryObjectManager[*addressfamily.Entry, addressfamily.Location, *addressfamily.Service](o.client, addressfamily.NewService(o.client), batchSize, specifier, addressfamily.SpecMatches)
}

func (o *BgpAddressFamilyRoutingProfileResourceModel) AttributeTypes() map[string]attr.Type {

	var locationObj BgpAddressFamilyRoutingProfileLocation

	var ipv4Obj *BgpAddressFamilyRoutingProfileResourceIpv4Object

	var ipv6Obj *BgpAddressFamilyRoutingProfileResourceIpv6Object
	return map[string]attr.Type{
		"location": types.ObjectType{
			AttrTypes: locationObj.AttributeTypes(),
		},
		"name": types.StringType,
		"ipv4": types.ObjectType{
			AttrTypes: ipv4Obj.AttributeTypes(),
		},
		"ipv6": types.ObjectType{
			AttrTypes: ipv6Obj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceModel) AncestorName() string {
	return ""
}

func (o BgpAddressFamilyRoutingProfileResourceModel) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4Object) AttributeTypes() map[string]attr.Type {

	var multicastObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject

	var unicastObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject
	return map[string]attr.Type{
		"multicast": types.ObjectType{
			AttrTypes: multicastObj.AttributeTypes(),
		},
		"unicast": types.ObjectType{
			AttrTypes: unicastObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4Object) AncestorName() string {
	return "ipv4"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4Object) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) AncestorName() string {
	return "multicast"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) AncestorName() string {
	return "unicast"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6Object) AttributeTypes() map[string]attr.Type {

	var unicastObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject
	return map[string]attr.Type{
		"unicast": types.ObjectType{
			AttrTypes: unicastObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6Object) AncestorName() string {
	return "ipv6"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6Object) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) AttributeTypes() map[string]attr.Type {

	var addPathObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject

	var allowasInObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject

	var maximumPrefixObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject

	var nextHopObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject

	var orfObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject

	var removePrivateAsObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject

	var sendCommunityObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject

	return map[string]attr.Type{
		"add_path": types.ObjectType{
			AttrTypes: addPathObj.AttributeTypes(),
		},
		"allowas_in": types.ObjectType{
			AttrTypes: allowasInObj.AttributeTypes(),
		},
		"as_override":           types.BoolType,
		"default_originate":     types.BoolType,
		"default_originate_map": types.StringType,
		"enable":                types.BoolType,
		"maximum_prefix": types.ObjectType{
			AttrTypes: maximumPrefixObj.AttributeTypes(),
		},
		"next_hop": types.ObjectType{
			AttrTypes: nextHopObj.AttributeTypes(),
		},
		"orf": types.ObjectType{
			AttrTypes: orfObj.AttributeTypes(),
		},
		"remove_private_as": types.ObjectType{
			AttrTypes: removePrivateAsObj.AttributeTypes(),
		},
		"route_reflector_client": types.BoolType,
		"send_community": types.ObjectType{
			AttrTypes: sendCommunityObj.AttributeTypes(),
		},
		"soft_reconfig_with_stored_info": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) AncestorName() string {
	return "unicast"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"tx_all_paths":       types.BoolType,
		"tx_bestpath_per_as": types.BoolType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) AncestorName() string {
	return "add-path"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) AttributeTypes() map[string]attr.Type {

	var originObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject
	return map[string]attr.Type{
		"occurrence": types.Int64Type,
		"origin": types.ObjectType{
			AttrTypes: originObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) AncestorName() string {
	return "allowas-in"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) AncestorName() string {
	return "origin"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) AttributeTypes() map[string]attr.Type {

	var actionObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject

	return map[string]attr.Type{
		"action": types.ObjectType{
			AttrTypes: actionObj.AttributeTypes(),
		},
		"max_prefixes": types.Int64Type,
		"threshold":    types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) AncestorName() string {
	return "maximum-prefix"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) AttributeTypes() map[string]attr.Type {

	var restartObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject

	var warningOnlyObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
	return map[string]attr.Type{
		"restart": types.ObjectType{
			AttrTypes: restartObj.AttributeTypes(),
		},
		"warning_only": types.ObjectType{
			AttrTypes: warningOnlyObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) AncestorName() string {
	return "action"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"interval": types.Int64Type,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) AncestorName() string {
	return "restart"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) AncestorName() string {
	return "warning-only"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) AttributeTypes() map[string]attr.Type {

	var selfObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject

	var selfForceObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject
	return map[string]attr.Type{
		"self": types.ObjectType{
			AttrTypes: selfObj.AttributeTypes(),
		},
		"self_force": types.ObjectType{
			AttrTypes: selfForceObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) AncestorName() string {
	return "next-hop"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) AncestorName() string {
	return "self"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) AncestorName() string {
	return "self-force"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) AttributeTypes() map[string]attr.Type {

	return map[string]attr.Type{
		"orf_prefix_list": types.StringType,
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) AncestorName() string {
	return "orf"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject

	var replaceAsObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"replace_as": types.ObjectType{
			AttrTypes: replaceAsObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) AncestorName() string {
	return "remove-private-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) AncestorName() string {
	return "replace-as"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) AttributeTypes() map[string]attr.Type {

	var allObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject

	var bothObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject

	var extendedObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject

	var largeObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject

	var standardObj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject
	return map[string]attr.Type{
		"all": types.ObjectType{
			AttrTypes: allObj.AttributeTypes(),
		},
		"both": types.ObjectType{
			AttrTypes: bothObj.AttributeTypes(),
		},
		"extended": types.ObjectType{
			AttrTypes: extendedObj.AttributeTypes(),
		},
		"large": types.ObjectType{
			AttrTypes: largeObj.AttributeTypes(),
		},
		"standard": types.ObjectType{
			AttrTypes: standardObj.AttributeTypes(),
		},
	}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) AncestorName() string {
	return "send-community"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) AncestorName() string {
	return "all"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) AncestorName() string {
	return "both"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) AncestorName() string {
	return "extended"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) AncestorName() string {
	return "large"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) EntryName() *string {
	return nil
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{}
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) AncestorName() string {
	return "standard"
}

func (o BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) EntryName() *string {
	return nil
}

func (o *BgpAddressFamilyRoutingProfileResourceModel) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var ipv4_entry *addressfamily.Ipv4
	if !o.Ipv4.IsUnknown() && !o.Ipv4.IsNull() {
		if *obj != nil && (*obj).Ipv4 != nil {
			ipv4_entry = (*obj).Ipv4
		} else {
			ipv4_entry = new(addressfamily.Ipv4)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4Object
		diags.Append(o.Ipv4.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ipv4_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var ipv6_entry *addressfamily.Ipv6
	if !o.Ipv6.IsUnknown() && !o.Ipv6.IsNull() {
		if *obj != nil && (*obj).Ipv6 != nil {
			ipv6_entry = (*obj).Ipv6
		} else {
			ipv6_entry = new(addressfamily.Ipv6)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6Object
		diags.Append(o.Ipv6.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, ancestors, &ipv6_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Entry)
	}
	(*obj).Name = o.Name.ValueString()
	(*obj).Ipv4 = ipv4_entry
	(*obj).Ipv6 = ipv6_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var multicast_entry *addressfamily.Ipv4Multicast
	if !o.Multicast.IsUnknown() && !o.Multicast.IsNull() {
		if *obj != nil && (*obj).Multicast != nil {
			multicast_entry = (*obj).Multicast
		} else {
			multicast_entry = new(addressfamily.Ipv4Multicast)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject
		diags.Append(o.Multicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &multicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var unicast_entry *addressfamily.Ipv4Unicast
	if !o.Unicast.IsUnknown() && !o.Unicast.IsNull() {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(addressfamily.Ipv4Unicast)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject
		diags.Append(o.Unicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &unicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4)
	}
	(*obj).Multicast = multicast_entry
	(*obj).Unicast = unicast_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv4MulticastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv4MulticastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv4MulticastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv4MulticastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv4MulticastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv4MulticastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv4MulticastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv4MulticastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv4MulticastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv4MulticastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv4MulticastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv4MulticastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv4MulticastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv4MulticastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4Multicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv4MulticastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv4MulticastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv4MulticastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv4MulticastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv4MulticastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv4MulticastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv4MulticastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv4MulticastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv4MulticastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv4MulticastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4MulticastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4MulticastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv4MulticastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv4MulticastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4MulticastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4MulticastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv4MulticastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv4MulticastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv4MulticastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv4MulticastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv4MulticastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv4MulticastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv4MulticastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv4MulticastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4MulticastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4MulticastSendCommunityStandard)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv4UnicastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv4UnicastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv4UnicastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv4UnicastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv4UnicastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv4UnicastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv4UnicastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv4UnicastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv4UnicastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv4UnicastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv4UnicastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv4UnicastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv4UnicastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv4UnicastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4Unicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv4UnicastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv4UnicastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv4UnicastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv4UnicastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv4UnicastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv4UnicastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv4UnicastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv4UnicastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv4UnicastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv4UnicastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4UnicastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4UnicastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv4UnicastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv4UnicastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv4UnicastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv4UnicastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv4UnicastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv4UnicastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv4UnicastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv4UnicastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv4UnicastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv4UnicastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv4UnicastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv4UnicastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv4UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv4UnicastSendCommunityStandard)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6Object) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var unicast_entry *addressfamily.Ipv6Unicast
	if !o.Unicast.IsUnknown() && !o.Unicast.IsNull() {
		if *obj != nil && (*obj).Unicast != nil {
			unicast_entry = (*obj).Unicast
		} else {
			unicast_entry = new(addressfamily.Ipv6Unicast)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject
		diags.Append(o.Unicast.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &unicast_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6)
	}
	(*obj).Unicast = unicast_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var addPath_entry *addressfamily.Ipv6UnicastAddPath
	if !o.AddPath.IsUnknown() && !o.AddPath.IsNull() {
		if *obj != nil && (*obj).AddPath != nil {
			addPath_entry = (*obj).AddPath
		} else {
			addPath_entry = new(addressfamily.Ipv6UnicastAddPath)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject
		diags.Append(o.AddPath.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &addPath_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var allowasIn_entry *addressfamily.Ipv6UnicastAllowasIn
	if !o.AllowasIn.IsUnknown() && !o.AllowasIn.IsNull() {
		if *obj != nil && (*obj).AllowasIn != nil {
			allowasIn_entry = (*obj).AllowasIn
		} else {
			allowasIn_entry = new(addressfamily.Ipv6UnicastAllowasIn)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject
		diags.Append(o.AllowasIn.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &allowasIn_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	asOverride_value := o.AsOverride.ValueBoolPointer()
	defaultOriginate_value := o.DefaultOriginate.ValueBoolPointer()
	defaultOriginateMap_value := o.DefaultOriginateMap.ValueStringPointer()
	enable_value := o.Enable.ValueBoolPointer()
	var maximumPrefix_entry *addressfamily.Ipv6UnicastMaximumPrefix
	if !o.MaximumPrefix.IsUnknown() && !o.MaximumPrefix.IsNull() {
		if *obj != nil && (*obj).MaximumPrefix != nil {
			maximumPrefix_entry = (*obj).MaximumPrefix
		} else {
			maximumPrefix_entry = new(addressfamily.Ipv6UnicastMaximumPrefix)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject
		diags.Append(o.MaximumPrefix.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &maximumPrefix_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var nextHop_entry *addressfamily.Ipv6UnicastNextHop
	if !o.NextHop.IsUnknown() && !o.NextHop.IsNull() {
		if *obj != nil && (*obj).NextHop != nil {
			nextHop_entry = (*obj).NextHop
		} else {
			nextHop_entry = new(addressfamily.Ipv6UnicastNextHop)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject
		diags.Append(o.NextHop.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &nextHop_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var orf_entry *addressfamily.Ipv6UnicastOrf
	if !o.Orf.IsUnknown() && !o.Orf.IsNull() {
		if *obj != nil && (*obj).Orf != nil {
			orf_entry = (*obj).Orf
		} else {
			orf_entry = new(addressfamily.Ipv6UnicastOrf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject
		diags.Append(o.Orf.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &orf_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var removePrivateAs_entry *addressfamily.Ipv6UnicastRemovePrivateAS
	if !o.RemovePrivateAs.IsUnknown() && !o.RemovePrivateAs.IsNull() {
		if *obj != nil && (*obj).RemovePrivateAS != nil {
			removePrivateAs_entry = (*obj).RemovePrivateAS
		} else {
			removePrivateAs_entry = new(addressfamily.Ipv6UnicastRemovePrivateAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject
		diags.Append(o.RemovePrivateAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &removePrivateAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	routeReflectorClient_value := o.RouteReflectorClient.ValueBoolPointer()
	var sendCommunity_entry *addressfamily.Ipv6UnicastSendCommunity
	if !o.SendCommunity.IsUnknown() && !o.SendCommunity.IsNull() {
		if *obj != nil && (*obj).SendCommunity != nil {
			sendCommunity_entry = (*obj).SendCommunity
		} else {
			sendCommunity_entry = new(addressfamily.Ipv6UnicastSendCommunity)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject
		diags.Append(o.SendCommunity.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &sendCommunity_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	softReconfigWithStoredInfo_value := o.SoftReconfigWithStoredInfo.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6Unicast)
	}
	(*obj).AddPath = addPath_entry
	(*obj).AllowasIn = allowasIn_entry
	(*obj).AsOverride = asOverride_value
	(*obj).DefaultOriginate = defaultOriginate_value
	(*obj).DefaultOriginateMap = defaultOriginateMap_value
	(*obj).Enable = enable_value
	(*obj).MaximumPrefix = maximumPrefix_entry
	(*obj).NextHop = nextHop_entry
	(*obj).Orf = orf_entry
	(*obj).RemovePrivateAS = removePrivateAs_entry
	(*obj).RouteReflectorClient = routeReflectorClient_value
	(*obj).SendCommunity = sendCommunity_entry
	(*obj).SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	txAllPaths_value := o.TxAllPaths.ValueBoolPointer()
	txBestpathPerAs_value := o.TxBestpathPerAs.ValueBoolPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAddPath)
	}
	(*obj).TxAllPaths = txAllPaths_value
	(*obj).TxBestpathPerAS = txBestpathPerAs_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	occurrence_value := o.Occurrence.ValueInt64Pointer()
	var origin_entry *addressfamily.Ipv6UnicastAllowasInOrigin
	if !o.Origin.IsUnknown() && !o.Origin.IsNull() {
		if *obj != nil && (*obj).Origin != nil {
			origin_entry = (*obj).Origin
		} else {
			origin_entry = new(addressfamily.Ipv6UnicastAllowasInOrigin)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject
		diags.Append(o.Origin.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &origin_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAllowasIn)
	}
	(*obj).Occurrence = occurrence_value
	(*obj).Origin = origin_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastAllowasInOrigin)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var action_entry *addressfamily.Ipv6UnicastMaximumPrefixAction
	if !o.Action.IsUnknown() && !o.Action.IsNull() {
		if *obj != nil && (*obj).Action != nil {
			action_entry = (*obj).Action
		} else {
			action_entry = new(addressfamily.Ipv6UnicastMaximumPrefixAction)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject
		diags.Append(o.Action.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &action_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	maxPrefixes_value := o.MaxPrefixes.ValueInt64Pointer()
	threshold_value := o.Threshold.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefix)
	}
	(*obj).Action = action_entry
	(*obj).NumPrefixes = maxPrefixes_value
	(*obj).Threshold = threshold_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var restart_entry *addressfamily.Ipv6UnicastMaximumPrefixActionRestart
	if !o.Restart.IsUnknown() && !o.Restart.IsNull() {
		if *obj != nil && (*obj).Restart != nil {
			restart_entry = (*obj).Restart
		} else {
			restart_entry = new(addressfamily.Ipv6UnicastMaximumPrefixActionRestart)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject
		diags.Append(o.Restart.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &restart_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var warningOnly_entry *addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly
	if !o.WarningOnly.IsUnknown() && !o.WarningOnly.IsNull() {
		if *obj != nil && (*obj).WarningOnly != nil {
			warningOnly_entry = (*obj).WarningOnly
		} else {
			warningOnly_entry = new(addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
		diags.Append(o.WarningOnly.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &warningOnly_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixAction)
	}
	(*obj).Restart = restart_entry
	(*obj).WarningOnly = warningOnly_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	interval_value := o.Interval.ValueInt64Pointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixActionRestart)
	}
	(*obj).Interval = interval_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var self_entry *addressfamily.Ipv6UnicastNextHopSelf
	if !o.Self.IsUnknown() && !o.Self.IsNull() {
		if *obj != nil && (*obj).Self != nil {
			self_entry = (*obj).Self
		} else {
			self_entry = new(addressfamily.Ipv6UnicastNextHopSelf)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject
		diags.Append(o.Self.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &self_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var selfForce_entry *addressfamily.Ipv6UnicastNextHopSelfForce
	if !o.SelfForce.IsUnknown() && !o.SelfForce.IsNull() {
		if *obj != nil && (*obj).SelfForce != nil {
			selfForce_entry = (*obj).SelfForce
		} else {
			selfForce_entry = new(addressfamily.Ipv6UnicastNextHopSelfForce)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject
		diags.Append(o.SelfForce.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &selfForce_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHop)
	}
	(*obj).Self = self_entry
	(*obj).SelfForce = selfForce_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHopSelf)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastNextHopSelfForce)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	orfPrefixList_value := o.OrfPrefixList.ValueStringPointer()

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastOrf)
	}
	(*obj).OrfPrefixList = orfPrefixList_value

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv6UnicastRemovePrivateASAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv6UnicastRemovePrivateASAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var replaceAs_entry *addressfamily.Ipv6UnicastRemovePrivateASReplaceAS
	if !o.ReplaceAs.IsUnknown() && !o.ReplaceAs.IsNull() {
		if *obj != nil && (*obj).ReplaceAS != nil {
			replaceAs_entry = (*obj).ReplaceAS
		} else {
			replaceAs_entry = new(addressfamily.Ipv6UnicastRemovePrivateASReplaceAS)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject
		diags.Append(o.ReplaceAs.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &replaceAs_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateAS)
	}
	(*obj).All = all_entry
	(*obj).ReplaceAS = replaceAs_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateASAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastRemovePrivateASReplaceAS)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics
	var all_entry *addressfamily.Ipv6UnicastSendCommunityAll
	if !o.All.IsUnknown() && !o.All.IsNull() {
		if *obj != nil && (*obj).All != nil {
			all_entry = (*obj).All
		} else {
			all_entry = new(addressfamily.Ipv6UnicastSendCommunityAll)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject
		diags.Append(o.All.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &all_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var both_entry *addressfamily.Ipv6UnicastSendCommunityBoth
	if !o.Both.IsUnknown() && !o.Both.IsNull() {
		if *obj != nil && (*obj).Both != nil {
			both_entry = (*obj).Both
		} else {
			both_entry = new(addressfamily.Ipv6UnicastSendCommunityBoth)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject
		diags.Append(o.Both.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &both_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var extended_entry *addressfamily.Ipv6UnicastSendCommunityExtended
	if !o.Extended.IsUnknown() && !o.Extended.IsNull() {
		if *obj != nil && (*obj).Extended != nil {
			extended_entry = (*obj).Extended
		} else {
			extended_entry = new(addressfamily.Ipv6UnicastSendCommunityExtended)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject
		diags.Append(o.Extended.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &extended_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var large_entry *addressfamily.Ipv6UnicastSendCommunityLarge
	if !o.Large.IsUnknown() && !o.Large.IsNull() {
		if *obj != nil && (*obj).Large != nil {
			large_entry = (*obj).Large
		} else {
			large_entry = new(addressfamily.Ipv6UnicastSendCommunityLarge)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject
		diags.Append(o.Large.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &large_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}
	var standard_entry *addressfamily.Ipv6UnicastSendCommunityStandard
	if !o.Standard.IsUnknown() && !o.Standard.IsNull() {
		if *obj != nil && (*obj).Standard != nil {
			standard_entry = (*obj).Standard
		} else {
			standard_entry = new(addressfamily.Ipv6UnicastSendCommunityStandard)
		}
		var object *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject
		diags.Append(o.Standard.As(ctx, &object, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
		diags.Append(object.CopyToPango(ctx, client, append(ancestors, o), &standard_entry, ev)...)
		if diags.HasError() {
			return diags
		}
	}

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunity)
	}
	(*obj).All = all_entry
	(*obj).Both = both_entry
	(*obj).Extended = extended_entry
	(*obj).Large = large_entry
	(*obj).Standard = standard_entry

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityAll)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityBoth)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityExtended)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityLarge)
	}

	return diags
}
func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) CopyToPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj **addressfamily.Ipv6UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	if (*obj) == nil {
		*obj = new(addressfamily.Ipv6UnicastSendCommunityStandard)
	}

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceModel) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Entry, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var ipv4_obj *BgpAddressFamilyRoutingProfileResourceIpv4Object
	if o.Ipv4.IsNull() {
		ipv4_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4Object)
	} else {
		diags.Append(o.Ipv4.As(ctx, &ipv4_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv4_object := types.ObjectNull(ipv4_obj.AttributeTypes())
	if obj.Ipv4 != nil {
		diags.Append(ipv4_obj.CopyFromPango(ctx, client, ancestors, obj.Ipv4, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv4_object, diags_tmp = types.ObjectValueFrom(ctx, ipv4_obj.AttributeTypes(), ipv4_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var ipv6_obj *BgpAddressFamilyRoutingProfileResourceIpv6Object
	if o.Ipv6.IsNull() {
		ipv6_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6Object)
	} else {
		diags.Append(o.Ipv6.As(ctx, &ipv6_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	ipv6_object := types.ObjectNull(ipv6_obj.AttributeTypes())
	if obj.Ipv6 != nil {
		diags.Append(ipv6_obj.CopyFromPango(ctx, client, ancestors, obj.Ipv6, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		ipv6_object, diags_tmp = types.ObjectValueFrom(ctx, ipv6_obj.AttributeTypes(), ipv6_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Name = types.StringValue(obj.Name)
	o.Ipv4 = ipv4_object
	o.Ipv6 = ipv6_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var multicast_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject
	if o.Multicast.IsNull() {
		multicast_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject)
	} else {
		diags.Append(o.Multicast.As(ctx, &multicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	multicast_object := types.ObjectNull(multicast_obj.AttributeTypes())
	if obj.Multicast != nil {
		diags.Append(multicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Multicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		multicast_object, diags_tmp = types.ObjectValueFrom(ctx, multicast_obj.AttributeTypes(), multicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var unicast_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject
	if o.Unicast.IsNull() {
		unicast_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject)
	} else {
		diags.Append(o.Unicast.As(ctx, &unicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	unicast_object := types.ObjectNull(unicast_obj.AttributeTypes())
	if obj.Unicast != nil {
		diags.Append(unicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Unicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		unicast_object, diags_tmp = types.ObjectValueFrom(ctx, unicast_obj.AttributeTypes(), unicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Multicast = multicast_object
	o.Unicast = unicast_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4Multicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4MulticastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4MulticastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv4UnicastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv4UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6Object) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var unicast_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject
	if o.Unicast.IsNull() {
		unicast_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject)
	} else {
		diags.Append(o.Unicast.As(ctx, &unicast_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	unicast_object := types.ObjectNull(unicast_obj.AttributeTypes())
	if obj.Unicast != nil {
		diags.Append(unicast_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Unicast, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		unicast_object, diags_tmp = types.ObjectValueFrom(ctx, unicast_obj.AttributeTypes(), unicast_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Unicast = unicast_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6Unicast, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var addPath_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject
	if o.AddPath.IsNull() {
		addPath_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject)
	} else {
		diags.Append(o.AddPath.As(ctx, &addPath_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	addPath_object := types.ObjectNull(addPath_obj.AttributeTypes())
	if obj.AddPath != nil {
		diags.Append(addPath_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AddPath, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		addPath_object, diags_tmp = types.ObjectValueFrom(ctx, addPath_obj.AttributeTypes(), addPath_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var allowasIn_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject
	if o.AllowasIn.IsNull() {
		allowasIn_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject)
	} else {
		diags.Append(o.AllowasIn.As(ctx, &allowasIn_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	allowasIn_object := types.ObjectNull(allowasIn_obj.AttributeTypes())
	if obj.AllowasIn != nil {
		diags.Append(allowasIn_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.AllowasIn, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		allowasIn_object, diags_tmp = types.ObjectValueFrom(ctx, allowasIn_obj.AttributeTypes(), allowasIn_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maximumPrefix_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject
	if o.MaximumPrefix.IsNull() {
		maximumPrefix_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject)
	} else {
		diags.Append(o.MaximumPrefix.As(ctx, &maximumPrefix_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	maximumPrefix_object := types.ObjectNull(maximumPrefix_obj.AttributeTypes())
	if obj.MaximumPrefix != nil {
		diags.Append(maximumPrefix_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.MaximumPrefix, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		maximumPrefix_object, diags_tmp = types.ObjectValueFrom(ctx, maximumPrefix_obj.AttributeTypes(), maximumPrefix_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var nextHop_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject
	if o.NextHop.IsNull() {
		nextHop_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject)
	} else {
		diags.Append(o.NextHop.As(ctx, &nextHop_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	nextHop_object := types.ObjectNull(nextHop_obj.AttributeTypes())
	if obj.NextHop != nil {
		diags.Append(nextHop_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.NextHop, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		nextHop_object, diags_tmp = types.ObjectValueFrom(ctx, nextHop_obj.AttributeTypes(), nextHop_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var orf_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject
	if o.Orf.IsNull() {
		orf_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject)
	} else {
		diags.Append(o.Orf.As(ctx, &orf_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	orf_object := types.ObjectNull(orf_obj.AttributeTypes())
	if obj.Orf != nil {
		diags.Append(orf_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Orf, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		orf_object, diags_tmp = types.ObjectValueFrom(ctx, orf_obj.AttributeTypes(), orf_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var removePrivateAs_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject
	if o.RemovePrivateAs.IsNull() {
		removePrivateAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject)
	} else {
		diags.Append(o.RemovePrivateAs.As(ctx, &removePrivateAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	removePrivateAs_object := types.ObjectNull(removePrivateAs_obj.AttributeTypes())
	if obj.RemovePrivateAS != nil {
		diags.Append(removePrivateAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.RemovePrivateAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		removePrivateAs_object, diags_tmp = types.ObjectValueFrom(ctx, removePrivateAs_obj.AttributeTypes(), removePrivateAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var sendCommunity_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject
	if o.SendCommunity.IsNull() {
		sendCommunity_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject)
	} else {
		diags.Append(o.SendCommunity.As(ctx, &sendCommunity_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	sendCommunity_object := types.ObjectNull(sendCommunity_obj.AttributeTypes())
	if obj.SendCommunity != nil {
		diags.Append(sendCommunity_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SendCommunity, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		sendCommunity_object, diags_tmp = types.ObjectValueFrom(ctx, sendCommunity_obj.AttributeTypes(), sendCommunity_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var asOverride_value types.Bool
	if obj.AsOverride != nil {
		asOverride_value = types.BoolValue(*obj.AsOverride)
	}
	var defaultOriginate_value types.Bool
	if obj.DefaultOriginate != nil {
		defaultOriginate_value = types.BoolValue(*obj.DefaultOriginate)
	}
	var defaultOriginateMap_value types.String
	if obj.DefaultOriginateMap != nil {
		defaultOriginateMap_value = types.StringValue(*obj.DefaultOriginateMap)
	}
	var enable_value types.Bool
	if obj.Enable != nil {
		enable_value = types.BoolValue(*obj.Enable)
	}
	var routeReflectorClient_value types.Bool
	if obj.RouteReflectorClient != nil {
		routeReflectorClient_value = types.BoolValue(*obj.RouteReflectorClient)
	}
	var softReconfigWithStoredInfo_value types.Bool
	if obj.SoftReconfigWithStoredInfo != nil {
		softReconfigWithStoredInfo_value = types.BoolValue(*obj.SoftReconfigWithStoredInfo)
	}
	o.AddPath = addPath_object
	o.AllowasIn = allowasIn_object
	o.AsOverride = asOverride_value
	o.DefaultOriginate = defaultOriginate_value
	o.DefaultOriginateMap = defaultOriginateMap_value
	o.Enable = enable_value
	o.MaximumPrefix = maximumPrefix_object
	o.NextHop = nextHop_object
	o.Orf = orf_object
	o.RemovePrivateAs = removePrivateAs_object
	o.RouteReflectorClient = routeReflectorClient_value
	o.SendCommunity = sendCommunity_object
	o.SoftReconfigWithStoredInfo = softReconfigWithStoredInfo_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAddPathObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAddPath, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var txAllPaths_value types.Bool
	if obj.TxAllPaths != nil {
		txAllPaths_value = types.BoolValue(*obj.TxAllPaths)
	}
	var txBestpathPerAs_value types.Bool
	if obj.TxBestpathPerAS != nil {
		txBestpathPerAs_value = types.BoolValue(*obj.TxBestpathPerAS)
	}
	o.TxAllPaths = txAllPaths_value
	o.TxBestpathPerAs = txBestpathPerAs_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAllowasIn, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var origin_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject
	if o.Origin.IsNull() {
		origin_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject)
	} else {
		diags.Append(o.Origin.As(ctx, &origin_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	origin_object := types.ObjectNull(origin_obj.AttributeTypes())
	if obj.Origin != nil {
		diags.Append(origin_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Origin, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		origin_object, diags_tmp = types.ObjectValueFrom(ctx, origin_obj.AttributeTypes(), origin_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var occurrence_value types.Int64
	if obj.Occurrence != nil {
		occurrence_value = types.Int64Value(*obj.Occurrence)
	}
	o.Occurrence = occurrence_value
	o.Origin = origin_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastAllowasInOriginObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastAllowasInOrigin, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefix, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var action_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject
	if o.Action.IsNull() {
		action_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject)
	} else {
		diags.Append(o.Action.As(ctx, &action_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	action_object := types.ObjectNull(action_obj.AttributeTypes())
	if obj.Action != nil {
		diags.Append(action_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Action, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		action_object, diags_tmp = types.ObjectValueFrom(ctx, action_obj.AttributeTypes(), action_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var maxPrefixes_value types.Int64
	if obj.NumPrefixes != nil {
		maxPrefixes_value = types.Int64Value(*obj.NumPrefixes)
	}
	var threshold_value types.Int64
	if obj.Threshold != nil {
		threshold_value = types.Int64Value(*obj.Threshold)
	}
	o.Action = action_object
	o.MaxPrefixes = maxPrefixes_value
	o.Threshold = threshold_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixAction, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var restart_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject
	if o.Restart.IsNull() {
		restart_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject)
	} else {
		diags.Append(o.Restart.As(ctx, &restart_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	restart_object := types.ObjectNull(restart_obj.AttributeTypes())
	if obj.Restart != nil {
		diags.Append(restart_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Restart, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		restart_object, diags_tmp = types.ObjectValueFrom(ctx, restart_obj.AttributeTypes(), restart_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var warningOnly_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject
	if o.WarningOnly.IsNull() {
		warningOnly_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject)
	} else {
		diags.Append(o.WarningOnly.As(ctx, &warningOnly_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	warningOnly_object := types.ObjectNull(warningOnly_obj.AttributeTypes())
	if obj.WarningOnly != nil {
		diags.Append(warningOnly_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.WarningOnly, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		warningOnly_object, diags_tmp = types.ObjectValueFrom(ctx, warningOnly_obj.AttributeTypes(), warningOnly_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Restart = restart_object
	o.WarningOnly = warningOnly_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionRestartObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixActionRestart, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var interval_value types.Int64
	if obj.Interval != nil {
		interval_value = types.Int64Value(*obj.Interval)
	}
	o.Interval = interval_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastMaximumPrefixActionWarningOnlyObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastMaximumPrefixActionWarningOnly, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHop, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var self_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject
	if o.Self.IsNull() {
		self_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject)
	} else {
		diags.Append(o.Self.As(ctx, &self_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	self_object := types.ObjectNull(self_obj.AttributeTypes())
	if obj.Self != nil {
		diags.Append(self_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Self, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		self_object, diags_tmp = types.ObjectValueFrom(ctx, self_obj.AttributeTypes(), self_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var selfForce_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject
	if o.SelfForce.IsNull() {
		selfForce_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject)
	} else {
		diags.Append(o.SelfForce.As(ctx, &selfForce_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	selfForce_object := types.ObjectNull(selfForce_obj.AttributeTypes())
	if obj.SelfForce != nil {
		diags.Append(selfForce_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.SelfForce, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		selfForce_object, diags_tmp = types.ObjectValueFrom(ctx, selfForce_obj.AttributeTypes(), selfForce_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.Self = self_object
	o.SelfForce = selfForce_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHopSelf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastNextHopSelfForceObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastNextHopSelfForce, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastOrfObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastOrf, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var orfPrefixList_value types.String
	if obj.OrfPrefixList != nil {
		orfPrefixList_value = types.StringValue(*obj.OrfPrefixList)
	}
	o.OrfPrefixList = orfPrefixList_value

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var replaceAs_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject
	if o.ReplaceAs.IsNull() {
		replaceAs_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject)
	} else {
		diags.Append(o.ReplaceAs.As(ctx, &replaceAs_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	replaceAs_object := types.ObjectNull(replaceAs_obj.AttributeTypes())
	if obj.ReplaceAS != nil {
		diags.Append(replaceAs_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.ReplaceAS, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		replaceAs_object, diags_tmp = types.ObjectValueFrom(ctx, replaceAs_obj.AttributeTypes(), replaceAs_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.ReplaceAs = replaceAs_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateASAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastRemovePrivateAsReplaceAsObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastRemovePrivateASReplaceAS, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunity, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	var all_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject
	if o.All.IsNull() {
		all_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject)
	} else {
		diags.Append(o.All.As(ctx, &all_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	all_object := types.ObjectNull(all_obj.AttributeTypes())
	if obj.All != nil {
		diags.Append(all_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.All, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		all_object, diags_tmp = types.ObjectValueFrom(ctx, all_obj.AttributeTypes(), all_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var both_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject
	if o.Both.IsNull() {
		both_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject)
	} else {
		diags.Append(o.Both.As(ctx, &both_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	both_object := types.ObjectNull(both_obj.AttributeTypes())
	if obj.Both != nil {
		diags.Append(both_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Both, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		both_object, diags_tmp = types.ObjectValueFrom(ctx, both_obj.AttributeTypes(), both_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var extended_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject
	if o.Extended.IsNull() {
		extended_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject)
	} else {
		diags.Append(o.Extended.As(ctx, &extended_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	extended_object := types.ObjectNull(extended_obj.AttributeTypes())
	if obj.Extended != nil {
		diags.Append(extended_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Extended, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		extended_object, diags_tmp = types.ObjectValueFrom(ctx, extended_obj.AttributeTypes(), extended_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var large_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject
	if o.Large.IsNull() {
		large_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject)
	} else {
		diags.Append(o.Large.As(ctx, &large_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	large_object := types.ObjectNull(large_obj.AttributeTypes())
	if obj.Large != nil {
		diags.Append(large_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Large, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		large_object, diags_tmp = types.ObjectValueFrom(ctx, large_obj.AttributeTypes(), large_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	var standard_obj *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject
	if o.Standard.IsNull() {
		standard_obj = new(BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject)
	} else {
		diags.Append(o.Standard.As(ctx, &standard_obj, basetypes.ObjectAsOptions{})...)
		if diags.HasError() {
			return diags
		}
	}
	standard_object := types.ObjectNull(standard_obj.AttributeTypes())
	if obj.Standard != nil {
		diags.Append(standard_obj.CopyFromPango(ctx, client, append(ancestors, o), obj.Standard, ev)...)
		if diags.HasError() {
			return diags
		}
		var diags_tmp diag.Diagnostics
		standard_object, diags_tmp = types.ObjectValueFrom(ctx, standard_obj.AttributeTypes(), standard_obj)
		diags.Append(diags_tmp...)
		if diags.HasError() {
			return diags
		}
	}

	o.All = all_object
	o.Both = both_object
	o.Extended = extended_object
	o.Large = large_object
	o.Standard = standard_object

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityAllObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityAll, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityBothObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityBoth, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityExtendedObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityExtended, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityLargeObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityLarge, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceIpv6UnicastSendCommunityStandardObject) CopyFromPango(ctx context.Context, client pangoutil.PangoClient, ancestors []Ancestor, obj *addressfamily.Ipv6UnicastSendCommunityStandard, ev *EncryptedValuesManager) diag.Diagnostics {
	var diags diag.Diagnostics

	return diags
}

func (o *BgpAddressFamilyRoutingProfileResourceModel) resourceXpathParentComponents() ([]string, error) {
	var components []string
	return components, nil
}

func (o *BgpAddressFamilyRoutingProfileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state BgpAddressFamilyRoutingProfileResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name": "panos_bgp_address_family_routing_profile_resource",
		"function":      "Create",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var encryptedValues []byte
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	// Determine the location.

	var location addressfamily.Location

	{
		var terraformLocation BgpAddressFamilyRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &addressfamily.NgfwLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &addressfamily.TemplateLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &addressfamily.TemplateStackLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	if err := location.IsValid(); err != nil {
		resp.Diagnostics.AddError("Invalid location", err.Error())
		return
	}

	// Load the desired config.
	var obj *addressfamily.Entry
	resp.Diagnostics.Append(state.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	/*
		// Timeout handling.
		ctx, cancel := context.WithTimeout(ctx, GetTimeout(state.Timeouts.Create))
		defer cancel()
	*/

	// Perform the operation.

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	created, err := o.manager.Create(ctx, location, components, obj)
	if err != nil {
		resp.Diagnostics.AddError("Error in create", err.Error())
		return
	}

	resp.Diagnostics.Append(state.CopyFromPango(ctx, o.client, nil, created, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
func (o *BgpAddressFamilyRoutingProfileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	var state BgpAddressFamilyRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, true)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location addressfamily.Location

	{
		var terraformLocation BgpAddressFamilyRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &addressfamily.NgfwLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &addressfamily.TemplateLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &addressfamily.TemplateStackLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"resource_name": "panos_bgp_address_family_routing_profile_resource",
		"function":      "Read",
		"name":          state.Name.ValueString(),
	})

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	object, err := o.manager.Read(ctx, location, components, state.Name.ValueString())
	if err != nil {
		if errors.Is(err, sdkmanager.ErrObjectNotFound) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading entry", err.Error())
		}
		return
	}

	copy_diags := state.CopyFromPango(ctx, o.client, nil, object, ev)
	resp.Diagnostics.Append(copy_diags...)

	/*
			// Keep the timeouts.
		    // TODO: This won't work for state import.
			state.Timeouts = state.Timeouts
	*/

	state.Location = state.Location

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)

}
func (o *BgpAddressFamilyRoutingProfileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	var plan, state BgpAddressFamilyRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	encryptedValues, diags := req.Private.GetKey(ctx, "encrypted_values")
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
	ev, err := NewEncryptedValuesManager(encryptedValues, false)
	if err != nil {
		resp.Diagnostics.AddError("Failed to read encrypted values from private state", err.Error())
		return
	}

	var location addressfamily.Location

	{
		var terraformLocation BgpAddressFamilyRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &addressfamily.NgfwLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &addressfamily.TemplateLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &addressfamily.TemplateStackLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"resource_name": "panos_bgp_address_family_routing_profile_resource",
		"function":      "Update",
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	var obj *addressfamily.Entry
	if state.Name.ValueString() != plan.Name.ValueString() {
		obj, err = o.manager.Read(ctx, location, components, state.Name.ValueString())
	} else {
		obj, err = o.manager.Read(ctx, location, components, plan.Name.ValueString())
	}
	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	resp.Diagnostics.Append(plan.CopyToPango(ctx, o.client, nil, &obj, ev)...)
	if resp.Diagnostics.HasError() {
		return
	}

	components, err = plan.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}

	// If name differs between plan and state, we need to set old name for the object
	// before calling SDK Update() function to properly handle rename + edit cycle.
	var newName string
	if state.Name.ValueString() != plan.Name.ValueString() {
		newName = plan.Name.ValueString()
		obj.Name = state.Name.ValueString()
	}

	updated, err := o.manager.Update(ctx, location, components, obj, newName)

	if err != nil {
		resp.Diagnostics.AddError("Error in update", err.Error())
		return
	}

	/*
		// Keep the timeouts.
		state.Timeouts = plan.Timeouts
	*/

	copy_diags := plan.CopyFromPango(ctx, o.client, nil, updated, ev)
	resp.Diagnostics.Append(copy_diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	payload, err := json.Marshal(ev)
	if err != nil {
		resp.Diagnostics.AddError("Failed to marshal encrypted values state", err.Error())
		return
	}
	resp.Private.SetKey(ctx, "encrypted_values", payload)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)

}
func (o *BgpAddressFamilyRoutingProfileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	var state BgpAddressFamilyRoutingProfileResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"resource_name": "panos_bgp_address_family_routing_profile_resource",
		"function":      "Delete",
		"name":          state.Name.ValueString(),
	})

	// Verify mode.
	if o.client.Hostname == "" {
		resp.Diagnostics.AddError("Invalid mode error", InspectionModeError)
		return
	}

	var location addressfamily.Location

	{
		var terraformLocation BgpAddressFamilyRoutingProfileLocation
		resp.Diagnostics.Append(state.Location.As(ctx, &terraformLocation, basetypes.ObjectAsOptions{})...)
		if resp.Diagnostics.HasError() {
			return
		}

		if !terraformLocation.Ngfw.IsNull() {
			location.Ngfw = &addressfamily.NgfwLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileNgfwLocation
			resp.Diagnostics.Append(terraformLocation.Ngfw.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Ngfw.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.Template.IsNull() {
			location.Template = &addressfamily.TemplateLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateLocation
			resp.Diagnostics.Append(terraformLocation.Template.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.Template.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.Template.Template = innerLocation.Name.ValueString()
			location.Template.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}

		if !terraformLocation.TemplateStack.IsNull() {
			location.TemplateStack = &addressfamily.TemplateStackLocation{}
			var innerLocation BgpAddressFamilyRoutingProfileTemplateStackLocation
			resp.Diagnostics.Append(terraformLocation.TemplateStack.As(ctx, &innerLocation, basetypes.ObjectAsOptions{})...)
			if resp.Diagnostics.HasError() {
				return
			}
			location.TemplateStack.PanoramaDevice = innerLocation.PanoramaDevice.ValueString()
			location.TemplateStack.TemplateStack = innerLocation.Name.ValueString()
			location.TemplateStack.NgfwDevice = innerLocation.NgfwDevice.ValueString()
		}
	}

	components, err := state.resourceXpathParentComponents()
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource xpath", err.Error())
		return
	}
	err = o.manager.Delete(ctx, location, components, []string{state.Name.ValueString()})
	if err != nil && !errors.Is(err, sdkmanager.ErrObjectNotFound) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
		return
	}

}

type BgpAddressFamilyRoutingProfileImportState struct {
	Location types.Object `json:"location"`
	Name     types.String `json:"name"`
}

func (o BgpAddressFamilyRoutingProfileImportState) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Location *BgpAddressFamilyRoutingProfileLocation `json:"location"`
		Name     *string                                 `json:"name"`
	}
	var location_object *BgpAddressFamilyRoutingProfileLocation
	{
		diags := o.Location.As(context.TODO(), &location_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal location into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Location: location_object,
		Name:     o.Name.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *BgpAddressFamilyRoutingProfileImportState) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Location *BgpAddressFamilyRoutingProfileLocation `json:"location"`
		Name     *string                                 `json:"name"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var location_object types.Object
	{
		var diags_tmp diag.Diagnostics
		location_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Location.AttributeTypes(), shadow.Location)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into location", diags_tmp.Errors())
		}
	}
	o.Location = location_object
	o.Name = types.StringPointerValue(shadow.Name)

	return nil
}

func BgpAddressFamilyRoutingProfileImportStateCreator(ctx context.Context, resource types.Object) ([]byte, error) {
	attrs := resource.Attributes()
	if attrs == nil {
		return nil, fmt.Errorf("Object has no attributes")
	}

	locationAttr, ok := attrs["location"]
	if !ok {
		return nil, fmt.Errorf("location attribute missing")
	}

	var location types.Object
	switch value := locationAttr.(type) {
	case types.Object:
		location = value
	default:
		return nil, fmt.Errorf("location attribute expected to be an object")
	}
	nameAttr, ok := attrs["name"]
	if !ok {
		return nil, fmt.Errorf("name attribute missing")
	}

	var name types.String
	switch value := nameAttr.(type) {
	case types.String:
		name = value
	default:
		return nil, fmt.Errorf("name attribute expected to be a string")
	}

	importStruct := BgpAddressFamilyRoutingProfileImportState{
		Location: location,
		Name:     name,
	}

	return json.Marshal(importStruct)
}

func (o *BgpAddressFamilyRoutingProfileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

	var obj BgpAddressFamilyRoutingProfileImportState
	data, err := base64.StdEncoding.DecodeString(req.ID)
	if err != nil {
		resp.Diagnostics.AddError("Failed to decode Import ID", err.Error())
		return
	}

	err = json.Unmarshal(data, &obj)
	if err != nil {
		var diagsErr *DiagnosticsError
		if errors.As(err, &diagsErr) {
			resp.Diagnostics.Append(diagsErr.Diagnostics()...)
		} else {
			resp.Diagnostics.AddError("Failed to unmarshal Import ID", err.Error())
		}
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("location"), obj.Location)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), obj.Name)...)
}

type BgpAddressFamilyRoutingProfileNgfwLocation struct {
	NgfwDevice types.String `tfsdk:"ngfw_device"`
}
type BgpAddressFamilyRoutingProfileTemplateLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type BgpAddressFamilyRoutingProfileTemplateStackLocation struct {
	PanoramaDevice types.String `tfsdk:"panorama_device"`
	Name           types.String `tfsdk:"name"`
	NgfwDevice     types.String `tfsdk:"ngfw_device"`
}
type BgpAddressFamilyRoutingProfileLocation struct {
	Ngfw          types.Object `tfsdk:"ngfw"`
	Template      types.Object `tfsdk:"template"`
	TemplateStack types.Object `tfsdk:"template_stack"`
}

func BgpAddressFamilyRoutingProfileLocationSchema() rsschema.Attribute {
	return rsschema.SingleNestedAttribute{
		Description: "The location of this object.",
		Required:    true,
		Attributes: map[string]rsschema.Attribute{
			"ngfw": rsschema.SingleNestedAttribute{
				Description: "Located in a specific NGFW device",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},

				Validators: []validator.Object{
					objectvalidator.ExactlyOneOf(path.Expressions{
						path.MatchRelative().AtParent().AtName("ngfw"),
						path.MatchRelative().AtParent().AtName("template"),
						path.MatchRelative().AtParent().AtName("template_stack"),
					}...),
				},
			},
			"template": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
			"template_stack": rsschema.SingleNestedAttribute{
				Description: "Located in a specific template stack",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					"panorama_device": rsschema.StringAttribute{
						Description: "Specific Panorama device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"name": rsschema.StringAttribute{
						Description: "Specific Panorama template stack",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString(""),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
					"ngfw_device": rsschema.StringAttribute{
						Description: "The NGFW device",
						Optional:    true,
						Computed:    true,
						Default:     stringdefault.StaticString("localhost.localdomain"),
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplace(),
						},
					},
				},
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplace(),
				},
			},
		},
	}
}

func (o BgpAddressFamilyRoutingProfileNgfwLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		NgfwDevice: o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *BgpAddressFamilyRoutingProfileNgfwLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		NgfwDevice *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o BgpAddressFamilyRoutingProfileTemplateLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *BgpAddressFamilyRoutingProfileTemplateLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o BgpAddressFamilyRoutingProfileTemplateStackLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	obj := shadow{
		PanoramaDevice: o.PanoramaDevice.ValueStringPointer(),
		Name:           o.Name.ValueStringPointer(),
		NgfwDevice:     o.NgfwDevice.ValueStringPointer(),
	}

	return json.Marshal(obj)
}

func (o *BgpAddressFamilyRoutingProfileTemplateStackLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		PanoramaDevice *string `json:"panorama_device,omitempty"`
		Name           *string `json:"name,omitempty"`
		NgfwDevice     *string `json:"ngfw_device,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	o.PanoramaDevice = types.StringPointerValue(shadow.PanoramaDevice)
	o.Name = types.StringPointerValue(shadow.Name)
	o.NgfwDevice = types.StringPointerValue(shadow.NgfwDevice)

	return nil
}
func (o BgpAddressFamilyRoutingProfileLocation) MarshalJSON() ([]byte, error) {
	type shadow struct {
		Ngfw          *BgpAddressFamilyRoutingProfileNgfwLocation          `json:"ngfw,omitempty"`
		Template      *BgpAddressFamilyRoutingProfileTemplateLocation      `json:"template,omitempty"`
		TemplateStack *BgpAddressFamilyRoutingProfileTemplateStackLocation `json:"template_stack,omitempty"`
	}
	var ngfw_object *BgpAddressFamilyRoutingProfileNgfwLocation
	{
		diags := o.Ngfw.As(context.TODO(), &ngfw_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal ngfw into JSON document", diags.Errors())
		}
	}
	var template_object *BgpAddressFamilyRoutingProfileTemplateLocation
	{
		diags := o.Template.As(context.TODO(), &template_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template into JSON document", diags.Errors())
		}
	}
	var templateStack_object *BgpAddressFamilyRoutingProfileTemplateStackLocation
	{
		diags := o.TemplateStack.As(context.TODO(), &templateStack_object, basetypes.ObjectAsOptions{})
		if diags.HasError() {
			return nil, NewDiagnosticsError("Failed to marshal template_stack into JSON document", diags.Errors())
		}
	}

	obj := shadow{
		Ngfw:          ngfw_object,
		Template:      template_object,
		TemplateStack: templateStack_object,
	}

	return json.Marshal(obj)
}

func (o *BgpAddressFamilyRoutingProfileLocation) UnmarshalJSON(data []byte) error {
	var shadow struct {
		Ngfw          *BgpAddressFamilyRoutingProfileNgfwLocation          `json:"ngfw,omitempty"`
		Template      *BgpAddressFamilyRoutingProfileTemplateLocation      `json:"template,omitempty"`
		TemplateStack *BgpAddressFamilyRoutingProfileTemplateStackLocation `json:"template_stack,omitempty"`
	}

	err := json.Unmarshal(data, &shadow)
	if err != nil {
		return err
	}
	var ngfw_object types.Object
	{
		var diags_tmp diag.Diagnostics
		ngfw_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Ngfw.AttributeTypes(), shadow.Ngfw)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into ngfw", diags_tmp.Errors())
		}
	}
	var template_object types.Object
	{
		var diags_tmp diag.Diagnostics
		template_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.Template.AttributeTypes(), shadow.Template)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template", diags_tmp.Errors())
		}
	}
	var templateStack_object types.Object
	{
		var diags_tmp diag.Diagnostics
		templateStack_object, diags_tmp = types.ObjectValueFrom(context.TODO(), shadow.TemplateStack.AttributeTypes(), shadow.TemplateStack)
		if diags_tmp.HasError() {
			return NewDiagnosticsError("Failed to unmarshal JSON document into template_stack", diags_tmp.Errors())
		}
	}
	o.Ngfw = ngfw_object
	o.Template = template_object
	o.TemplateStack = templateStack_object

	return nil
}

func (o *BgpAddressFamilyRoutingProfileNgfwLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"ngfw_device": types.StringType,
	}
}
func (o *BgpAddressFamilyRoutingProfileTemplateLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *BgpAddressFamilyRoutingProfileTemplateStackLocation) AttributeTypes() map[string]attr.Type {
	return map[string]attr.Type{
		"panorama_device": types.StringType,
		"name":            types.StringType,
		"ngfw_device":     types.StringType,
	}
}
func (o *BgpAddressFamilyRoutingProfileLocation) AttributeTypes() map[string]attr.Type {
	var ngfwObj BgpAddressFamilyRoutingProfileNgfwLocation
	var templateObj BgpAddressFamilyRoutingProfileTemplateLocation
	var templateStackObj BgpAddressFamilyRoutingProfileTemplateStackLocation
	return map[string]attr.Type{
		"ngfw": types.ObjectType{
			AttrTypes: ngfwObj.AttributeTypes(),
		},
		"template": types.ObjectType{
			AttrTypes: templateObj.AttributeTypes(),
		},
		"template_stack": types.ObjectType{
			AttrTypes: templateStackObj.AttributeTypes(),
		},
	}
}
