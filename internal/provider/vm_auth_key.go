package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"fmt"

	"github.com/PaloAltoNetworks/pango"

	"github.com/hashicorp/terraform-plugin-framework/attr"
	ephschema "github.com/hashicorp/terraform-plugin-framework/ephemeral/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

import (
	"encoding/xml"
	"regexp"

	"github.com/PaloAltoNetworks/pango/xmlapi"
	"github.com/hashicorp/terraform-plugin-framework/ephemeral"
)

// Generate Terraform Ephemeral object
var (
	_ ephemeral.EphemeralResource              = &VmAuthKeyResource{}
	_ ephemeral.EphemeralResourceWithConfigure = &VmAuthKeyResource{}
)

func NewVmAuthKeyResource() ephemeral.EphemeralResource {
	return &VmAuthKeyResource{}
}

type VmAuthKeyResource struct {
	client *pango.Client
}

type VmAuthKeyResourceModel struct {
	Lifetime       types.Int64  `tfsdk:"lifetime"`
	VmAuthKey      types.String `tfsdk:"vm_auth_key"`
	ExpirationDate types.String `tfsdk:"expiration_date"`
}

func (r *VmAuthKeyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
}

// <ResourceSchema>

func VmAuthKeyResourceSchema() ephschema.Schema {
	return ephschema.Schema{
		Attributes: map[string]ephschema.Attribute{

			"lifetime": ephschema.Int64Attribute{
				Description: "",
				Computed:    false,
				Required:    true,
				Optional:    false,
				Sensitive:   false,
			},

			"vm_auth_key": ephschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   true,
			},

			"expiration_date": ephschema.StringAttribute{
				Description: "",
				Computed:    true,
				Required:    false,
				Optional:    true,
				Sensitive:   false,
			},
		},
	}
}

func (o *VmAuthKeyResourceModel) getTypeFor(name string) attr.Type {
	schema := VmAuthKeyResourceSchema()
	if attr, ok := schema.Attributes[name]; !ok {
		panic(fmt.Sprintf("could not resolve schema for attribute %s", name))
	} else {
		switch attr := attr.(type) {
		case ephschema.ListNestedAttribute:
			return attr.NestedObject.Type()
		case ephschema.MapNestedAttribute:
			return attr.NestedObject.Type()
		default:
			return attr.GetType()
		}
	}

	panic("unreachable")
}

func (r *VmAuthKeyResource) Metadata(ctx context.Context, req ephemeral.MetadataRequest, resp *ephemeral.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_vm_auth_key"
}

func (r *VmAuthKeyResource) Schema(_ context.Context, _ ephemeral.SchemaRequest, resp *ephemeral.SchemaResponse) {
	resp.Schema = VmAuthKeyResourceSchema()
}

// </ResourceSchema>

func (r *VmAuthKeyResource) Configure(ctx context.Context, req ephemeral.ConfigureRequest, resp *ephemeral.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	providerData := req.ProviderData.(*ProviderData)
	r.client = providerData.Client
}

func (r *VmAuthKeyResource) Open(ctx context.Context, req ephemeral.OpenRequest, resp *ephemeral.OpenResponse) {

	var data VmAuthKeyResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	lifetime := data.Lifetime.ValueInt64()

	cmd := &xmlapi.Op{
		Command: vmAuthKeyRequest{Lifetime: lifetime},
	}

	var serverResponse vmAuthKeyResponse
	if _, _, err := r.client.Communicate(ctx, cmd, false, &serverResponse); err != nil {
		resp.Diagnostics.AddError("Failed to generate Authenticaion Key", "Server returned an error: "+err.Error())
		return
	}

	vmAuthKeyRegexp := `VM auth key (?P<vmauthkey>.+) generated. Expires at: (?P<expiration>.+)`
	expr := regexp.MustCompile(vmAuthKeyRegexp)
	match := expr.FindStringSubmatch(serverResponse.Result)
	if match == nil {
		resp.Diagnostics.AddError("Failed to parse server response", "Server response did not match regular expression")
		return
	}

	groups := make(map[string]string)
	for i, name := range expr.SubexpNames() {
		if i != 0 && name != "" {
			groups[name] = match[i]
		}
	}

	if vmAuthKey, found := groups["vmauthkey"]; found {
		data.VmAuthKey = types.StringValue(vmAuthKey)
	} else {
		resp.Diagnostics.AddError("Failed to parse server response", "Server response did not contain matching authentication key")
		return
	}

	if expiration, found := groups["expiration"]; found {
		data.ExpirationDate = types.StringValue(expiration)
	} else {
		resp.Diagnostics.AddWarning("Incomplete server response", "Server response didn't contain a valid expiration date")
	}

	resp.Diagnostics.Append(resp.Result.Set(ctx, &data)...)

}

func (r *VmAuthKeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {

}

type vmAuthKeyRequest struct {
	XMLName  xml.Name `xml:"request"`
	Lifetime int64    `xml:"bootstrap>vm-auth-key>generate>lifetime"`
}

type vmAuthKeyResponse struct {
	XMLName xml.Name `xml:"response"`
	Result  string   `xml:"result"`
}
